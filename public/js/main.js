require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"libs/jquery-2.1.1":[function(require,module,exports){
module.exports=require('1urUB6');
},{}],"1urUB6":[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.1.1
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-05-01T17:11Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper window is present,
		// execute the factory and get jQuery
		// For environments that do not inherently posses a window with a document
		// (such as Node.js), expose a jQuery-making factory as module.exports
		// This accentuates the need for the creation of a real window
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		return !jQuery.isArray( obj ) && obj - parseFloat( obj ) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android < 4.0, iOS < 6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v1.10.19
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-04-18
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf if we can't use a native one
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( documentIsHTML && !seed ) {

		// Shortcuts
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType === 9 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== strundefined && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare,
		doc = node ? node.ownerDocument || node : preferredDoc,
		parent = doc.defaultView;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;

	// Support tests
	documentIsHTML = !isXML( doc );

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", function() {
				setDocument();
			}, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", function() {
				setDocument();
			});
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Check if getElementsByClassName can be trusted
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
		div.innerHTML = "<div class='a'></div><div class='a i'></div>";

		// Support: Safari<4
		// Catch class over-caching
		div.firstChild.className = "i";
		// Support: Opera<10
		// Catch gEBCN failure to find non-leading classes
		return div.getElementsByClassName("i").length === 2;
	});

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select msallowclip=''><option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowclip^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android < 4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Math.random();
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android < 4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



/*
	Implementation Summary

	1. Enforce API surface and semantic compatibility with 1.9.x branch
	2. Improve the module's maintainability by reducing the storage
		paths to a single mechanism.
	3. Use the same single mechanism to support "private" and "user" data.
	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	5. Avoid exposing implementation details on user objects (eg. expando properties)
	6. Provide a clear path for implementation upgrade to WeakMap in 2014
*/
var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// #11217 - WebKit loses check when the name is after the checked attribute
	// Support: Windows Web Apps (WWA)
	// `name` and `type` need .setAttribute for WWA
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
	// old WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Make sure textarea (and checkbox) defaultValue is properly cloned
	// Support: IE9-IE11+
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome < 28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android < 4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Create "bubbling" focus and blur events
// Support: Firefox, Chrome, Safari
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE 9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE 9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Support: IE >= 9
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Support: IE >= 9
		// Fix Cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit
					// jQuery.merge because push.apply(_, arraylike) throws
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit
					// jQuery.merge because push.apply(_, arraylike) throws
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Fixes #12346
					// Support: Webkit, IE
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optmization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') in IE9, see #12537
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due to missing dependency),
				// remove it.
				// Since there are no other hooks for marginRight, remove the whole object.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.

			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {
				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {
				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set. See: #7116
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// Work around by temporarily setting element display to inline-block
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS 5.1, Android 4.x, Android 2.3
	// Check the default checkbox/radio value ("" on old WebKit; "on" elsewhere)
	support.checkOn = input.value !== "";

	// Must access the parent to make an option select properly
	// Support: IE9, IE10
	support.optSelected = opt.selected;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Check if an input maintains its value after becoming a radio
	// Support: IE9, IE10
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

// Support: IE9+
// Selectedness for an option in an optgroup can be inaccurate
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			// Support: Webkit
			// "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
if ( window.ActiveXObject ) {
	jQuery( window ).on( "unload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// If we don't have gBCR, just use 0,0 rather than error
		// BlackBerry 5, iOS 3 (original iPhone)
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// We assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// if curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

},{}],"U3u7kb":[function(require,module,exports){
/*!
* jQuery Mobile 1.4.3
* Git HEAD hash: b9c6473e3d90af26570e6f14e5a0307897ab385c <> Date: Tue Jul 1 2014 15:37:36 UTC
* http://jquerymobile.com
*
* Copyright 2010, 2014 jQuery Foundation, Inc. and othercontributors
* Released under the MIT license.
* http://jquery.org/license
*
*/


(function ( root, doc, factory ) {
	if ( typeof module === "object" && module && typeof module.exports === "object" ) {
		// PSALTED: added by Chris Baik 10/29/2013 to support commonjs
		$ = require('jquery')
		factory( $, root, doc );
		module.exports = $.mobile;
	} else if ( typeof define === "function" && define.amd ) {
		// AMD. Register as an anonymous module.
		define( [ "jquery" ], function ( $ ) {
			factory( $, root, doc );
			return $.mobile;
		});
	} else {
		// Browser globals
		factory( root.jQuery, root, doc );
	}
}( this, document, function ( jQuery, window, document, undefined ) {
(function( $ ) {
	$.mobile = {};
}( jQuery ));

(function( $, window, undefined ) {
	$.extend( $.mobile, {

		// Version of the jQuery Mobile Framework
		version: "1.4.3",

		// Deprecated and no longer used in 1.4 remove in 1.5
		// Define the url parameter used for referencing widget-generated sub-pages.
		// Translates to example.html&ui-page=subpageIdentifier
		// hash segment before &ui-page= is used to make Ajax request
		subPageUrlKey: "ui-page",

		hideUrlBar: true,

		// Keepnative Selector
		keepNative: ":jqmData(role='none'), :jqmData(role='nojs')",

		// Deprecated in 1.4 remove in 1.5
		// Class assigned to page currently in view, and during transitions
		activePageClass: "ui-page-active",

		// Deprecated in 1.4 remove in 1.5
		// Class used for "active" button state, from CSS framework
		activeBtnClass: "ui-btn-active",

		// Deprecated in 1.4 remove in 1.5
		// Class used for "focus" form element state, from CSS framework
		focusClass: "ui-focus",

		// Automatically handle clicks and form submissions through Ajax, when same-domain
		ajaxEnabled: true,

		// Automatically load and show pages based on location.hash
		hashListeningEnabled: true,

		// disable to prevent jquery from bothering with links
		linkBindingEnabled: true,

		// Set default page transition - 'none' for no transitions
		defaultPageTransition: "fade",

		// Set maximum window width for transitions to apply - 'false' for no limit
		maxTransitionWidth: false,

		// Minimum scroll distance that will be remembered when returning to a page
		// Deprecated remove in 1.5
		minScrollBack: 0,

		// Set default dialog transition - 'none' for no transitions
		defaultDialogTransition: "pop",

		// Error response message - appears when an Ajax page request fails
		pageLoadErrorMessage: "Error Loading Page",

		// For error messages, which theme does the box use?
		pageLoadErrorMessageTheme: "a",

		// replace calls to window.history.back with phonegaps navigation helper
		// where it is provided on the window object
		phonegapNavigationEnabled: false,

		//automatically initialize the DOM when it's ready
		autoInitializePage: true,

		pushStateEnabled: true,

		// allows users to opt in to ignoring content by marking a parent element as
		// data-ignored
		ignoreContentEnabled: false,

		buttonMarkup: {
			hoverDelay: 200
		},

		// disable the alteration of the dynamic base tag or links in the case
		// that a dynamic base tag isn't supported
		dynamicBaseEnabled: true,

		// default the property to remove dependency on assignment in init module
		pageContainer: $(),

		//enable cross-domain page support
		allowCrossDomainPages: false,

		dialogHashKey: "&ui-state=dialog"
	});
})( jQuery, this );

(function( $, window, undefined ) {
	var nsNormalizeDict = {},
		oldFind = $.find,
		rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
		jqmDataRE = /:jqmData\(([^)]*)\)/g;

	$.extend( $.mobile, {

		// Namespace used framework-wide for data-attrs. Default is no namespace

		ns: "",

		// Retrieve an attribute from an element and perform some massaging of the value

		getAttribute: function( element, key ) {
			var data;

			element = element.jquery ? element[0] : element;

			if ( element && element.getAttribute ) {
				data = element.getAttribute( "data-" + $.mobile.ns + key );
			}

			// Copied from core's src/data.js:dataAttr()
			// Convert from a string to a proper data type
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? JSON.parse( data ) :
					data;
			} catch( err ) {}

			return data;
		},

		// Expose our cache for testing purposes.
		nsNormalizeDict: nsNormalizeDict,

		// Take a data attribute property, prepend the namespace
		// and then camel case the attribute string. Add the result
		// to our nsNormalizeDict so we don't have to do this again.
		nsNormalize: function( prop ) {
			return nsNormalizeDict[ prop ] ||
				( nsNormalizeDict[ prop ] = $.camelCase( $.mobile.ns + prop ) );
		},

		// Find the closest javascript page element to gather settings data jsperf test
		// http://jsperf.com/single-complex-selector-vs-many-complex-selectors/edit
		// possibly naive, but it shows that the parsing overhead for *just* the page selector vs
		// the page and dialog selector is negligable. This could probably be speed up by
		// doing a similar parent node traversal to the one found in the inherited theme code above
		closestPageData: function( $target ) {
			return $target
				.closest( ":jqmData(role='page'), :jqmData(role='dialog')" )
				.data( "mobile-page" );
		}

	});

	// Mobile version of data and removeData and hasData methods
	// ensures all data is set and retrieved using jQuery Mobile's data namespace
	$.fn.jqmData = function( prop, value ) {
		var result;
		if ( typeof prop !== "undefined" ) {
			if ( prop ) {
				prop = $.mobile.nsNormalize( prop );
			}

			// undefined is permitted as an explicit input for the second param
			// in this case it returns the value and does not set it to undefined
			if ( arguments.length < 2 || value === undefined ) {
				result = this.data( prop );
			} else {
				result = this.data( prop, value );
			}
		}
		return result;
	};

	$.jqmData = function( elem, prop, value ) {
		var result;
		if ( typeof prop !== "undefined" ) {
			result = $.data( elem, prop ? $.mobile.nsNormalize( prop ) : prop, value );
		}
		return result;
	};

	$.fn.jqmRemoveData = function( prop ) {
		return this.removeData( $.mobile.nsNormalize( prop ) );
	};

	$.jqmRemoveData = function( elem, prop ) {
		return $.removeData( elem, $.mobile.nsNormalize( prop ) );
	};

	$.find = function( selector, context, ret, extra ) {
		if ( selector.indexOf( ":jqmData" ) > -1 ) {
			selector = selector.replace( jqmDataRE, "[data-" + ( $.mobile.ns || "" ) + "$1]" );
		}

		return oldFind.call( this, selector, context, ret, extra );
	};

	$.extend( $.find, oldFind );

})( jQuery, this );

/*!
 * jQuery UI Core c0ab71056b936627e8a7821f03c044aec6280a40
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "c0ab71056b936627e8a7821f03c044aec6280a40",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		}

		return ( /fixed/ ).test( this.css( "position") ) || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	}
});

// $.ui.plugin is deprecated. Use $.widget() extensions instead.
$.ui.plugin = {
	add: function( module, option, set ) {
		var i,
			proto = $.ui[ module ].prototype;
		for ( i in set ) {
			proto.plugins[ i ] = proto.plugins[ i ] || [];
			proto.plugins[ i ].push( [ option, set[ i ] ] );
		}
	},
	call: function( instance, name, args, allowDisconnected ) {
		var i,
			set = instance.plugins[ name ];

		if ( !set ) {
			return;
		}

		if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
			return;
		}

		for ( i = 0; i < set.length; i++ ) {
			if ( instance.options[ set[ i ][ 0 ] ] ) {
				set[ i ][ 1 ].apply( instance.element, args );
			}
		}
	}
};

})( jQuery );

(function( $, window, undefined ) {

	// Subtract the height of external toolbars from the page height, if the page does not have
	// internal toolbars of the same type
	var compensateToolbars = function( page, desiredHeight ) {
		var pageParent = page.parent(),
			toolbarsAffectingHeight = [],
			externalHeaders = pageParent.children( ":jqmData(role='header')" ),
			internalHeaders = page.children( ":jqmData(role='header')" ),
			externalFooters = pageParent.children( ":jqmData(role='footer')" ),
			internalFooters = page.children( ":jqmData(role='footer')" );

		// If we have no internal headers, but we do have external headers, then their height
		// reduces the page height
		if ( internalHeaders.length === 0 && externalHeaders.length > 0 ) {
			toolbarsAffectingHeight = toolbarsAffectingHeight.concat( externalHeaders.toArray() );
		}

		// If we have no internal footers, but we do have external footers, then their height
		// reduces the page height
		if ( internalFooters.length === 0 && externalFooters.length > 0 ) {
			toolbarsAffectingHeight = toolbarsAffectingHeight.concat( externalFooters.toArray() );
		}

		$.each( toolbarsAffectingHeight, function( index, value ) {
			desiredHeight -= $( value ).outerHeight();
		});

		// Height must be at least zero
		return Math.max( 0, desiredHeight );
	};

	$.extend( $.mobile, {
		// define the window and the document objects
		window: $( window ),
		document: $( document ),

		// TODO: Remove and use $.ui.keyCode directly
		keyCode: $.ui.keyCode,

		// Place to store various widget extensions
		behaviors: {},

		// Scroll page vertically: scroll to 0 to hide iOS address bar, or pass a Y value
		silentScroll: function( ypos ) {
			if ( $.type( ypos ) !== "number" ) {
				ypos = $.mobile.defaultHomeScroll;
			}

			// prevent scrollstart and scrollstop events
			$.event.special.scrollstart.enabled = false;

			setTimeout(function() {
				window.scrollTo( 0, ypos );
				$.mobile.document.trigger( "silentscroll", { x: 0, y: ypos });
			}, 20 );

			setTimeout(function() {
				$.event.special.scrollstart.enabled = true;
			}, 150 );
		},

		getClosestBaseUrl: function( ele )	{
			// Find the closest page and extract out its url.
			var url = $( ele ).closest( ".ui-page" ).jqmData( "url" ),
				base = $.mobile.path.documentBase.hrefNoHash;

			if ( !$.mobile.dynamicBaseEnabled || !url || !$.mobile.path.isPath( url ) ) {
				url = base;
			}

			return $.mobile.path.makeUrlAbsolute( url, base );
		},
		removeActiveLinkClass: function( forceRemoval ) {
			if ( !!$.mobile.activeClickedLink &&
				( !$.mobile.activeClickedLink.closest( "." + $.mobile.activePageClass ).length ||
					forceRemoval ) ) {

				$.mobile.activeClickedLink.removeClass( $.mobile.activeBtnClass );
			}
			$.mobile.activeClickedLink = null;
		},

		// DEPRECATED in 1.4
		// Find the closest parent with a theme class on it. Note that
		// we are not using $.fn.closest() on purpose here because this
		// method gets called quite a bit and we need it to be as fast
		// as possible.
		getInheritedTheme: function( el, defaultTheme ) {
			var e = el[ 0 ],
				ltr = "",
				re = /ui-(bar|body|overlay)-([a-z])\b/,
				c, m;
			while ( e ) {
				c = e.className || "";
				if ( c && ( m = re.exec( c ) ) && ( ltr = m[ 2 ] ) ) {
					// We found a parent with a theme class
					// on it so bail from this loop.
					break;
				}

				e = e.parentNode;
			}
			// Return the theme letter we found, if none, return the
			// specified default.
			return ltr || defaultTheme || "a";
		},

		enhanceable: function( elements ) {
			return this.haveParents( elements, "enhance" );
		},

		hijackable: function( elements ) {
			return this.haveParents( elements, "ajax" );
		},

		haveParents: function( elements, attr ) {
			if ( !$.mobile.ignoreContentEnabled ) {
				return elements;
			}

			var count = elements.length,
				$newSet = $(),
				e, $element, excluded,
				i, c;

			for ( i = 0; i < count; i++ ) {
				$element = elements.eq( i );
				excluded = false;
				e = elements[ i ];

				while ( e ) {
					c = e.getAttribute ? e.getAttribute( "data-" + $.mobile.ns + attr ) : "";

					if ( c === "false" ) {
						excluded = true;
						break;
					}

					e = e.parentNode;
				}

				if ( !excluded ) {
					$newSet = $newSet.add( $element );
				}
			}

			return $newSet;
		},

		getScreenHeight: function() {
			// Native innerHeight returns more accurate value for this across platforms,
			// jQuery version is here as a normalized fallback for platforms like Symbian
			return window.innerHeight || $.mobile.window.height();
		},

		//simply set the active page's minimum height to screen height, depending on orientation
		resetActivePageHeight: function( height ) {
			var page = $( "." + $.mobile.activePageClass ),
				pageHeight = page.height(),
				pageOuterHeight = page.outerHeight( true );

			height = compensateToolbars( page,
				( typeof height === "number" ) ? height : $.mobile.getScreenHeight() );

			// Remove any previous min-height setting
			page.css( "min-height", "" );

			// Set the minimum height only if the height as determined by CSS is insufficient
			if ( page.height() < height ) {
				page.css( "min-height", height - ( pageOuterHeight - pageHeight ) );
			}
		},

		loading: function() {
			// If this is the first call to this function, instantiate a loader widget
			var loader = this.loading._widget || $( $.mobile.loader.prototype.defaultHtml ).loader(),

				// Call the appropriate method on the loader
				returnValue = loader.loader.apply( loader, arguments );

			// Make sure the loader is retained for future calls to this function.
			this.loading._widget = loader;

			return returnValue;
		}
	});

	$.addDependents = function( elem, newDependents ) {
		var $elem = $( elem ),
			dependents = $elem.jqmData( "dependents" ) || $();

		$elem.jqmData( "dependents", $( dependents ).add( newDependents ) );
	};

	// plugins
	$.fn.extend({
		removeWithDependents: function() {
			$.removeWithDependents( this );
		},

		// Enhance child elements
		enhanceWithin: function() {
			var index,
				widgetElements = {},
				keepNative = $.mobile.page.prototype.keepNativeSelector(),
				that = this;

			// Add no js class to elements
			if ( $.mobile.nojs ) {
				$.mobile.nojs( this );
			}

			// Bind links for ajax nav
			if ( $.mobile.links ) {
				$.mobile.links( this );
			}

			// Degrade inputs for styleing
			if ( $.mobile.degradeInputsWithin ) {
				$.mobile.degradeInputsWithin( this );
			}

			// Run buttonmarkup
			if ( $.fn.buttonMarkup ) {
				this.find( $.fn.buttonMarkup.initSelector ).not( keepNative )
				.jqmEnhanceable().buttonMarkup();
			}

			// Add classes for fieldContain
			if ( $.fn.fieldcontain ) {
				this.find( ":jqmData(role='fieldcontain')" ).not( keepNative )
				.jqmEnhanceable().fieldcontain();
			}

			// Enhance widgets
			$.each( $.mobile.widgets, function( name, constructor ) {

				// If initSelector not false find elements
				if ( constructor.initSelector ) {

					// Filter elements that should not be enhanced based on parents
					var elements = $.mobile.enhanceable( that.find( constructor.initSelector ) );

					// If any matching elements remain filter ones with keepNativeSelector
					if ( elements.length > 0 ) {

						// $.mobile.page.prototype.keepNativeSelector is deprecated this is just for backcompat
						// Switch to $.mobile.keepNative in 1.5 which is just a value not a function
						elements = elements.not( keepNative );
					}

					// Enhance whatever is left
					if ( elements.length > 0 ) {
						widgetElements[ constructor.prototype.widgetName ] = elements;
					}
				}
			});

			for ( index in widgetElements ) {
				widgetElements[ index ][ index ]();
			}

			return this;
		},

		addDependents: function( newDependents ) {
			$.addDependents( this, newDependents );
		},

		// note that this helper doesn't attempt to handle the callback
		// or setting of an html element's text, its only purpose is
		// to return the html encoded version of the text in all cases. (thus the name)
		getEncodedText: function() {
			return $( "<a>" ).text( this.text() ).html();
		},

		// fluent helper function for the mobile namespaced equivalent
		jqmEnhanceable: function() {
			return $.mobile.enhanceable( this );
		},

		jqmHijackable: function() {
			return $.mobile.hijackable( this );
		}
	});

	$.removeWithDependents = function( nativeElement ) {
		var element = $( nativeElement );

		( element.jqmData( "dependents" ) || $() ).remove();
		element.remove();
	};
	$.addDependents = function( nativeElement, newDependents ) {
		var element = $( nativeElement ),
			dependents = element.jqmData( "dependents" ) || $();

		element.jqmData( "dependents", $( dependents ).add( newDependents ) );
	};

	$.find.matches = function( expr, set ) {
		return $.find( expr, null, null, set );
	};

	$.find.matchesSelector = function( node, expr ) {
		return $.find( expr, null, null, [ node ] ).length > 0;
	};

})( jQuery, this );


/*!
 * jQuery UI Widget c0ab71056b936627e8a7821f03c044aec6280a40
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( options === "instance" ) {
					returnValue = instance;
					return false;
				}
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( value === undefined ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( value === undefined ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled", !!value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOptions({ disabled: false });
	},
	disable: function() {
		return this._setOptions({ disabled: true });
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );

(function( $, undefined ) {

var rcapitals = /[A-Z]/g,
	replaceFunction = function( c ) {
		return "-" + c.toLowerCase();
	};

$.extend( $.Widget.prototype, {
	_getCreateOptions: function() {
		var option, value,
			elem = this.element[ 0 ],
			options = {};

		//
		if ( !$.mobile.getAttribute( elem, "defaults" ) ) {
			for ( option in this.options ) {
				value = $.mobile.getAttribute( elem, option.replace( rcapitals, replaceFunction ) );

				if ( value != null ) {
					options[ option ] = value;
				}
			}
		}

		return options;
	}
});

//TODO: Remove in 1.5 for backcompat only
$.mobile.widget = $.Widget;

})( jQuery );


(function( $ ) {
	// TODO move loader class down into the widget settings
	var loaderClass = "ui-loader", $html = $( "html" );

	$.widget( "mobile.loader", {
		// NOTE if the global config settings are defined they will override these
		//      options
		options: {
			// the theme for the loading message
			theme: "a",

			// whether the text in the loading message is shown
			textVisible: false,

			// custom html for the inner content of the loading message
			html: "",

			// the text to be displayed when the popup is shown
			text: "loading"
		},

		defaultHtml: "<div class='" + loaderClass + "'>" +
			"<span class='ui-icon-loading'></span>" +
			"<h1></h1>" +
			"</div>",

		// For non-fixed supportin browsers. Position at y center (if scrollTop supported), above the activeBtn (if defined), or just 100px from top
		fakeFixLoader: function() {
			var activeBtn = $( "." + $.mobile.activeBtnClass ).first();

			this.element
				.css({
					top: $.support.scrollTop && this.window.scrollTop() + this.window.height() / 2 ||
						activeBtn.length && activeBtn.offset().top || 100
				});
		},

		// check position of loader to see if it appears to be "fixed" to center
		// if not, use abs positioning
		checkLoaderPosition: function() {
			var offset = this.element.offset(),
				scrollTop = this.window.scrollTop(),
				screenHeight = $.mobile.getScreenHeight();

			if ( offset.top < scrollTop || ( offset.top - scrollTop ) > screenHeight ) {
				this.element.addClass( "ui-loader-fakefix" );
				this.fakeFixLoader();
				this.window
					.unbind( "scroll", this.checkLoaderPosition )
					.bind( "scroll", $.proxy( this.fakeFixLoader, this ) );
			}
		},

		resetHtml: function() {
			this.element.html( $( this.defaultHtml ).html() );
		},

		// Turn on/off page loading message. Theme doubles as an object argument
		// with the following shape: { theme: '', text: '', html: '', textVisible: '' }
		// NOTE that the $.mobile.loading* settings and params past the first are deprecated
		// TODO sweet jesus we need to break some of this out
		show: function( theme, msgText, textonly ) {
			var textVisible, message, loadSettings;

			this.resetHtml();

			// use the prototype options so that people can set them globally at
			// mobile init. Consistency, it's what's for dinner
			if ( $.type( theme ) === "object" ) {
				loadSettings = $.extend( {}, this.options, theme );

				theme = loadSettings.theme;
			} else {
				loadSettings = this.options;

				// here we prefer the theme value passed as a string argument, then
				// we prefer the global option because we can't use undefined default
				// prototype options, then the prototype option
				theme = theme || loadSettings.theme;
			}

			// set the message text, prefer the param, then the settings object
			// then loading message
			message = msgText || ( loadSettings.text === false ? "" : loadSettings.text );

			// prepare the dom
			$html.addClass( "ui-loading" );

			textVisible = loadSettings.textVisible;

			// add the proper css given the options (theme, text, etc)
			// Force text visibility if the second argument was supplied, or
			// if the text was explicitly set in the object args
			this.element.attr("class", loaderClass +
				" ui-corner-all ui-body-" + theme +
				" ui-loader-" + ( textVisible || msgText || theme.text ? "verbose" : "default" ) +
				( loadSettings.textonly || textonly ? " ui-loader-textonly" : "" ) );

			// TODO verify that jquery.fn.html is ok to use in both cases here
			//      this might be overly defensive in preventing unknowing xss
			// if the html attribute is defined on the loading settings, use that
			// otherwise use the fallbacks from above
			if ( loadSettings.html ) {
				this.element.html( loadSettings.html );
			} else {
				this.element.find( "h1" ).text( message );
			}

			// attach the loader to the DOM
			this.element.appendTo( $.mobile.pageContainer );

			// check that the loader is visible
			this.checkLoaderPosition();

			// on scroll check the loader position
			this.window.bind( "scroll", $.proxy( this.checkLoaderPosition, this ) );
		},

		hide: function() {
			$html.removeClass( "ui-loading" );

			if ( this.options.text ) {
				this.element.removeClass( "ui-loader-fakefix" );
			}

			$.mobile.window.unbind( "scroll", this.fakeFixLoader );
			$.mobile.window.unbind( "scroll", this.checkLoaderPosition );
		}
	});

})(jQuery, this);


/*!
 * jQuery hashchange event - v1.3 - 7/21/2010
 * http://benalman.com/projects/jquery-hashchange-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery hashchange event
//
// *Version: 1.3, Last updated: 7/21/2010*
// 
// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/
// GitHub       - http://github.com/cowboy/jquery-hashchange/
// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js
// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (0.8kb gzipped)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/
// document.domain - http://benalman.com/code/projects/jquery-hashchange/examples/document_domain/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.2.6, 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-4, Chrome 5-6, Safari 3.2-5,
//                   Opera 9.6-10.60, iPhone 3.1, Android 1.6-2.2, BlackBerry 4.6-5.
// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/
// 
// About: Known issues
// 
// While this jQuery hashchange event implementation is quite stable and
// robust, there are a few unfortunate browser bugs surrounding expected
// hashchange event-based behaviors, independent of any JavaScript
// window.onhashchange abstraction. See the following examples for more
// information:
// 
// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/
// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/
// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/
// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/
// 
// Also note that should a browser natively support the window.onhashchange 
// event, but not report that it does, the fallback polling loop will be used.
// 
// About: Release History
// 
// 1.3   - (7/21/2010) Reorganized IE6/7 Iframe code to make it more
//         "removable" for mobile-only development. Added IE6/7 document.title
//         support. Attempted to make Iframe as hidden as possible by using
//         techniques from http://www.paciellogroup.com/blog/?p=604. Added 
//         support for the "shortcut" format $(window).hashchange( fn ) and
//         $(window).hashchange() like jQuery provides for built-in events.
//         Renamed jQuery.hashchangeDelay to <jQuery.fn.hashchange.delay> and
//         lowered its default value to 50. Added <jQuery.fn.hashchange.domain>
//         and <jQuery.fn.hashchange.src> properties plus document-domain.html
//         file to address access denied issues when setting document.domain in
//         IE6/7.
// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin
//         from a page on another domain would cause an error in Safari 4. Also,
//         IE6/7 Iframe is now inserted after the body (this actually works),
//         which prevents the page from scrolling when the event is first bound.
//         Event can also now be bound before DOM ready, but it won't be usable
//         before then in IE6/7.
// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug
//         where browser version is incorrectly reported as 8.0, despite
//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.
// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special
//         window.onhashchange functionality into a separate plugin for users
//         who want just the basic event & back button support, without all the
//         extra awesomeness that BBQ provides. This plugin will be included as
//         part of jQuery BBQ, but also be available separately.

(function($,window,undefined){
  '$:nomunge'; // Used by YUI compressor.
  
  // Reused string.
  var str_hashchange = 'hashchange',
    
    // Method / object references.
    doc = document,
    fake_onhashchange,
    special = $.event.special,
    
    // Does the browser support window.onhashchange? Note that IE8 running in
    // IE7 compatibility mode reports true for 'onhashchange' in window, even
    // though the event isn't supported, so also test document.documentMode.
    doc_mode = doc.documentMode,
    supports_onhashchange = 'on' + str_hashchange in window && ( doc_mode === undefined || doc_mode > 7 );
  
  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    url = url || location.href;
    return '#' + url.replace( /^[^#]*#?(.*)$/, '$1' );
  };
  
  // Method: jQuery.fn.hashchange
  // 
  // Bind a handler to the window.onhashchange event or trigger all bound
  // window.onhashchange event handlers. This behavior is consistent with
  // jQuery's built-in event handlers.
  // 
  // Usage:
  // 
  // > jQuery(window).hashchange( [ handler ] );
  // 
  // Arguments:
  // 
  //  handler - (Function) Optional handler to be bound to the hashchange
  //    event. This is a "shortcut" for the more verbose form:
  //    jQuery(window).bind( 'hashchange', handler ). If handler is omitted,
  //    all bound window.onhashchange event handlers will be triggered. This
  //    is a shortcut for the more verbose
  //    jQuery(window).trigger( 'hashchange' ). These forms are described in
  //    the <hashchange event> section.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements.
  
  // Allow the "shortcut" format $(elem).hashchange( fn ) for binding and
  // $(elem).hashchange() for triggering, like jQuery does for built-in events.
  $.fn[ str_hashchange ] = function( fn ) {
    return fn ? this.bind( str_hashchange, fn ) : this.trigger( str_hashchange );
  };
  
  // Property: jQuery.fn.hashchange.delay
  // 
  // The numeric interval (in milliseconds) at which the <hashchange event>
  // polling loop executes. Defaults to 50.
  
  // Property: jQuery.fn.hashchange.domain
  // 
  // If you're setting document.domain in your JavaScript, and you want hash
  // history to work in IE6/7, not only must this property be set, but you must
  // also set document.domain BEFORE jQuery is loaded into the page. This
  // property is only applicable if you are supporting IE6/7 (or IE8 operating
  // in "IE7 compatibility" mode).
  // 
  // In addition, the <jQuery.fn.hashchange.src> property must be set to the
  // path of the included "document-domain.html" file, which can be renamed or
  // modified if necessary (note that the document.domain specified must be the
  // same in both your main JavaScript as well as in this file).
  // 
  // Usage:
  // 
  // jQuery.fn.hashchange.domain = document.domain;
  
  // Property: jQuery.fn.hashchange.src
  // 
  // If, for some reason, you need to specify an Iframe src file (for example,
  // when setting document.domain as in <jQuery.fn.hashchange.domain>), you can
  // do so using this property. Note that when using this property, history
  // won't be recorded in IE6/7 until the Iframe src file loads. This property
  // is only applicable if you are supporting IE6/7 (or IE8 operating in "IE7
  // compatibility" mode).
  // 
  // Usage:
  // 
  // jQuery.fn.hashchange.src = 'path/to/file.html';
  
  $.fn[ str_hashchange ].delay = 50;
  /*
  $.fn[ str_hashchange ].domain = null;
  $.fn[ str_hashchange ].src = null;
  */
  
  // Event: hashchange event
  // 
  // Fired when location.hash changes. In browsers that support it, the native
  // HTML5 window.onhashchange event is used, otherwise a polling loop is
  // initialized, running every <jQuery.fn.hashchange.delay> milliseconds to
  // see if the hash has changed. In IE6/7 (and IE8 operating in "IE7
  // compatibility" mode), a hidden Iframe is created to allow the back button
  // and hash-based history to work.
  // 
  // Usage as described in <jQuery.fn.hashchange>:
  // 
  // > // Bind an event handler.
  // > jQuery(window).hashchange( function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // > 
  // > // Manually trigger the event handler.
  // > jQuery(window).hashchange();
  // 
  // A more verbose usage that allows for event namespacing:
  // 
  // > // Bind an event handler.
  // > jQuery(window).bind( 'hashchange', function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // > 
  // > // Manually trigger the event handler.
  // > jQuery(window).trigger( 'hashchange' );
  // 
  // Additional Notes:
  // 
  // * The polling loop and Iframe are not created until at least one handler
  //   is actually bound to the 'hashchange' event.
  // * If you need the bound handler(s) to execute immediately, in cases where
  //   a location.hash exists on page load, via bookmark or page refresh for
  //   example, use jQuery(window).hashchange() or the more verbose 
  //   jQuery(window).trigger( 'hashchange' ).
  // * The event can be bound before DOM ready, but since it won't be usable
  //   before then in IE6/7 (due to the necessary Iframe), recommended usage is
  //   to bind it inside a DOM ready handler.
  
  // Override existing $.event.special.hashchange methods (allowing this plugin
  // to be defined after jQuery BBQ in BBQ's source code).
  special[ str_hashchange ] = $.extend( special[ str_hashchange ], {
    
    // Called only when the first 'hashchange' event is bound to window.
    setup: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to create our own. And we don't want to call this
      // until the user binds to the event, just in case they never do, since it
      // will create a polling loop and possibly even a hidden Iframe.
      $( fake_onhashchange.start );
    },
    
    // Called only when the last 'hashchange' event is unbound from window.
    teardown: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to stop ours (if possible).
      $( fake_onhashchange.stop );
    }
    
  });
  
  // fake_onhashchange does all the work of triggering the window.onhashchange
  // event for browsers that don't natively support it, including creating a
  // polling loop to watch for hash changes and in IE 6/7 creating a hidden
  // Iframe to enable back and forward.
  fake_onhashchange = (function(){
    var self = {},
      timeout_id,
      
      // Remember the initial hash so it doesn't get triggered immediately.
      last_hash = get_fragment(),
      
      fn_retval = function(val){ return val; },
      history_set = fn_retval,
      history_get = fn_retval;
    
    // Start the polling loop.
    self.start = function() {
      timeout_id || poll();
    };
    
    // Stop the polling loop.
    self.stop = function() {
      timeout_id && clearTimeout( timeout_id );
      timeout_id = undefined;
    };
    
    // This polling loop checks every $.fn.hashchange.delay milliseconds to see
    // if location.hash has changed, and triggers the 'hashchange' event on
    // window when necessary.
    function poll() {
      var hash = get_fragment(),
        history_hash = history_get( last_hash );
      
      if ( hash !== last_hash ) {
        history_set( last_hash = hash, history_hash );
        
        $(window).trigger( str_hashchange );
        
      } else if ( history_hash !== last_hash ) {
        location.href = location.href.replace( /#.*/, '' ) + history_hash;
      }
      
      timeout_id = setTimeout( poll, $.fn[ str_hashchange ].delay );
    };
    
    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    // vvvvvvvvvvvvvvvvvvv REMOVE IF NOT SUPPORTING IE6/7/8 vvvvvvvvvvvvvvvvvvv
    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    window.attachEvent && !window.addEventListener && !supports_onhashchange && (function(){
      // Not only do IE6/7 need the "magical" Iframe treatment, but so does IE8
      // when running in "IE7 compatibility" mode.
      
      var iframe,
        iframe_src;
      
      // When the event is bound and polling starts in IE 6/7, create a hidden
      // Iframe for history handling.
      self.start = function(){
        if ( !iframe ) {
          iframe_src = $.fn[ str_hashchange ].src;
          iframe_src = iframe_src && iframe_src + get_fragment();
          
          // Create hidden Iframe. Attempt to make Iframe as hidden as possible
          // by using techniques from http://www.paciellogroup.com/blog/?p=604.
          iframe = $('<iframe tabindex="-1" title="empty"/>').hide()
            
            // When Iframe has completely loaded, initialize the history and
            // start polling.
            .one( 'load', function(){
              iframe_src || history_set( get_fragment() );
              poll();
            })
            
            // Load Iframe src if specified, otherwise nothing.
            .attr( 'src', iframe_src || 'javascript:0' )
            
            // Append Iframe after the end of the body to prevent unnecessary
            // initial page scrolling (yes, this works).
            .insertAfter( 'body' )[0].contentWindow;
          
          // Whenever `document.title` changes, update the Iframe's title to
          // prettify the back/next history menu entries. Since IE sometimes
          // errors with "Unspecified error" the very first time this is set
          // (yes, very useful) wrap this with a try/catch block.
          doc.onpropertychange = function(){
            try {
              if ( event.propertyName === 'title' ) {
                iframe.document.title = doc.title;
              }
            } catch(e) {}
          };
          
        }
      };
      
      // Override the "stop" method since an IE6/7 Iframe was created. Even
      // if there are no longer any bound event handlers, the polling loop
      // is still necessary for back/next to work at all!
      self.stop = fn_retval;
      
      // Get history by looking at the hidden Iframe's location.hash.
      history_get = function() {
        return get_fragment( iframe.location.href );
      };
      
      // Set a new history item by opening and then closing the Iframe
      // document, *then* setting its location.hash. If document.domain has
      // been set, update that as well.
      history_set = function( hash, history_hash ) {
        var iframe_doc = iframe.document,
          domain = $.fn[ str_hashchange ].domain;
        
        if ( hash !== history_hash ) {
          // Update Iframe with any initial `document.title` that might be set.
          iframe_doc.title = doc.title;
          
          // Opening the Iframe's document after it has been closed is what
          // actually adds a history entry.
          iframe_doc.open();
          
          // Set document.domain for the Iframe document as well, if necessary.
          domain && iframe_doc.write( '\x3cscript>document.domain="' + domain + '"\x3c/script>' );
          
          iframe_doc.close();
          
          // Update the Iframe's hash, for great justice.
          iframe.location.hash = hash;
        }
      };
      
    })();
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^ REMOVE IF NOT SUPPORTING IE6/7/8 ^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
    return self;
  })();
  
})(jQuery,this);

(function( $, undefined ) {

	/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas. Dual MIT/BSD license */
	window.matchMedia = window.matchMedia || (function( doc, undefined ) {

		var bool,
			docElem = doc.documentElement,
			refNode = docElem.firstElementChild || docElem.firstChild,
			// fakeBody required for <FF4 when executed in <head>
			fakeBody = doc.createElement( "body" ),
			div = doc.createElement( "div" );

		div.id = "mq-test-1";
		div.style.cssText = "position:absolute;top:-100em";
		fakeBody.style.background = "none";
		fakeBody.appendChild(div);

		return function(q){

			div.innerHTML = "&shy;<style media=\"" + q + "\"> #mq-test-1 { width: 42px; }</style>";

			docElem.insertBefore( fakeBody, refNode );
			bool = div.offsetWidth === 42;
			docElem.removeChild( fakeBody );

			return {
				matches: bool,
				media: q
			};

		};

	}( document ));

	// $.mobile.media uses matchMedia to return a boolean.
	$.mobile.media = function( q ) {
		return window.matchMedia( q ).matches;
	};

})(jQuery);

	(function( $, undefined ) {
		var support = {
			touch: "ontouchend" in document
		};

		$.mobile.support = $.mobile.support || {};
		$.extend( $.support, support );
		$.extend( $.mobile.support, support );
	}( jQuery ));

	(function( $, undefined ) {
		$.extend( $.support, {
			orientation: "orientation" in window && "onorientationchange" in window
		});
	}( jQuery ));

(function( $, undefined ) {

// thx Modernizr
function propExists( prop ) {
	var uc_prop = prop.charAt( 0 ).toUpperCase() + prop.substr( 1 ),
		props = ( prop + " " + vendors.join( uc_prop + " " ) + uc_prop ).split( " " ),
		v;

	for ( v in props ) {
		if ( fbCSS[ props[ v ] ] !== undefined ) {
			return true;
		}
	}
}

var fakeBody = $( "<body>" ).prependTo( "html" ),
	fbCSS = fakeBody[ 0 ].style,
	vendors = [ "Webkit", "Moz", "O" ],
	webos = "palmGetResource" in window, //only used to rule out scrollTop
	operamini = window.operamini && ({}).toString.call( window.operamini ) === "[object OperaMini]",
	bb = window.blackberry && !propExists( "-webkit-transform" ), //only used to rule out box shadow, as it's filled opaque on BB 5 and lower
	nokiaLTE7_3;

// inline SVG support test
function inlineSVG() {
	// Thanks Modernizr & Erik Dahlstrom
	var w = window,
		svg = !!w.document.createElementNS && !!w.document.createElementNS( "http://www.w3.org/2000/svg", "svg" ).createSVGRect && !( w.opera && navigator.userAgent.indexOf( "Chrome" ) === -1 ),
		support = function( data ) {
			if ( !( data && svg ) ) {
				$( "html" ).addClass( "ui-nosvg" );
			}
		},
		img = new w.Image();

	img.onerror = function() {
		support( false );
	};
	img.onload = function() {
		support( img.width === 1 && img.height === 1 );
	};
	img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
}

function transform3dTest() {
	var mqProp = "transform-3d",
		// Because the `translate3d` test below throws false positives in Android:
		ret = $.mobile.media( "(-" + vendors.join( "-" + mqProp + "),(-" ) + "-" + mqProp + "),(" + mqProp + ")" ),
		el, transforms, t;

	if ( ret ) {
		return !!ret;
	}

	el = document.createElement( "div" );
	transforms = {
		// Were omitting Opera for the time being; MS uses unprefixed.
		"MozTransform": "-moz-transform",
		"transform": "transform"
	};

	fakeBody.append( el );

	for ( t in transforms ) {
		if ( el.style[ t ] !== undefined ) {
			el.style[ t ] = "translate3d( 100px, 1px, 1px )";
			ret = window.getComputedStyle( el ).getPropertyValue( transforms[ t ] );
		}
	}
	return ( !!ret && ret !== "none" );
}

// Test for dynamic-updating base tag support ( allows us to avoid href,src attr rewriting )
function baseTagTest() {
	var fauxBase = location.protocol + "//" + location.host + location.pathname + "ui-dir/",
		base = $( "head base" ),
		fauxEle = null,
		href = "",
		link, rebase;

	if ( !base.length ) {
		base = fauxEle = $( "<base>", { "href": fauxBase }).appendTo( "head" );
	} else {
		href = base.attr( "href" );
	}

	link = $( "<a href='testurl' />" ).prependTo( fakeBody );
	rebase = link[ 0 ].href;
	base[ 0 ].href = href || location.pathname;

	if ( fauxEle ) {
		fauxEle.remove();
	}
	return rebase.indexOf( fauxBase ) === 0;
}

// Thanks Modernizr
function cssPointerEventsTest() {
	var element = document.createElement( "x" ),
		documentElement = document.documentElement,
		getComputedStyle = window.getComputedStyle,
		supports;

	if ( !( "pointerEvents" in element.style ) ) {
		return false;
	}

	element.style.pointerEvents = "auto";
	element.style.pointerEvents = "x";
	documentElement.appendChild( element );
	supports = getComputedStyle &&
	getComputedStyle( element, "" ).pointerEvents === "auto";
	documentElement.removeChild( element );
	return !!supports;
}

function boundingRect() {
	var div = document.createElement( "div" );
	return typeof div.getBoundingClientRect !== "undefined";
}

// non-UA-based IE version check by James Padolsey, modified by jdalton - from http://gist.github.com/527683
// allows for inclusion of IE 6+, including Windows Mobile 7
$.extend( $.mobile, { browser: {} } );
$.mobile.browser.oldIE = (function() {
	var v = 3,
		div = document.createElement( "div" ),
		a = div.all || [];

	do {
		div.innerHTML = "<!--[if gt IE " + ( ++v ) + "]><br><![endif]-->";
	} while( a[0] );

	return v > 4 ? v : !v;
})();

function fixedPosition() {
	var w = window,
		ua = navigator.userAgent,
		platform = navigator.platform,
		// Rendering engine is Webkit, and capture major version
		wkmatch = ua.match( /AppleWebKit\/([0-9]+)/ ),
		wkversion = !!wkmatch && wkmatch[ 1 ],
		ffmatch = ua.match( /Fennec\/([0-9]+)/ ),
		ffversion = !!ffmatch && ffmatch[ 1 ],
		operammobilematch = ua.match( /Opera Mobi\/([0-9]+)/ ),
		omversion = !!operammobilematch && operammobilematch[ 1 ];

	if (
		// iOS 4.3 and older : Platform is iPhone/Pad/Touch and Webkit version is less than 534 (ios5)
		( ( platform.indexOf( "iPhone" ) > -1 || platform.indexOf( "iPad" ) > -1  || platform.indexOf( "iPod" ) > -1 ) && wkversion && wkversion < 534 ) ||
		// Opera Mini
		( w.operamini && ({}).toString.call( w.operamini ) === "[object OperaMini]" ) ||
		( operammobilematch && omversion < 7458 )	||
		//Android lte 2.1: Platform is Android and Webkit version is less than 533 (Android 2.2)
		( ua.indexOf( "Android" ) > -1 && wkversion && wkversion < 533 ) ||
		// Firefox Mobile before 6.0 -
		( ffversion && ffversion < 6 ) ||
		// WebOS less than 3
		( "palmGetResource" in window && wkversion && wkversion < 534 )	||
		// MeeGo
		( ua.indexOf( "MeeGo" ) > -1 && ua.indexOf( "NokiaBrowser/8.5.0" ) > -1 ) ) {
		return false;
	}

	return true;
}

$.extend( $.support, {
	// Note, Chrome for iOS has an extremely quirky implementation of popstate.
	// We've chosen to take the shortest path to a bug fix here for issue #5426
	// See the following link for information about the regex chosen
	// https://developers.google.com/chrome/mobile/docs/user-agent#chrome_for_ios_user-agent
	pushState: "pushState" in history &&
		"replaceState" in history &&
		// When running inside a FF iframe, calling replaceState causes an error
		!( window.navigator.userAgent.indexOf( "Firefox" ) >= 0 && window.top !== window ) &&
		( window.navigator.userAgent.search(/CriOS/) === -1 ),

	mediaquery: $.mobile.media( "only all" ),
	cssPseudoElement: !!propExists( "content" ),
	touchOverflow: !!propExists( "overflowScrolling" ),
	cssTransform3d: transform3dTest(),
	boxShadow: !!propExists( "boxShadow" ) && !bb,
	fixedPosition: fixedPosition(),
	scrollTop: ("pageXOffset" in window ||
		"scrollTop" in document.documentElement ||
		"scrollTop" in fakeBody[ 0 ]) && !webos && !operamini,

	dynamicBaseTag: baseTagTest(),
	cssPointerEvents: cssPointerEventsTest(),
	boundingRect: boundingRect(),
	inlineSVG: inlineSVG
});

fakeBody.remove();

// $.mobile.ajaxBlacklist is used to override ajaxEnabled on platforms that have known conflicts with hash history updates (BB5, Symbian)
// or that generally work better browsing in regular http for full page refreshes (Opera Mini)
// Note: This detection below is used as a last resort.
// We recommend only using these detection methods when all other more reliable/forward-looking approaches are not possible
nokiaLTE7_3 = (function() {

	var ua = window.navigator.userAgent;

	//The following is an attempt to match Nokia browsers that are running Symbian/s60, with webkit, version 7.3 or older
	return ua.indexOf( "Nokia" ) > -1 &&
			( ua.indexOf( "Symbian/3" ) > -1 || ua.indexOf( "Series60/5" ) > -1 ) &&
			ua.indexOf( "AppleWebKit" ) > -1 &&
			ua.match( /(BrowserNG|NokiaBrowser)\/7\.[0-3]/ );
})();

// Support conditions that must be met in order to proceed
// default enhanced qualifications are media query support OR IE 7+

$.mobile.gradeA = function() {
	return ( ( $.support.mediaquery && $.support.cssPseudoElement ) || $.mobile.browser.oldIE && $.mobile.browser.oldIE >= 8 ) && ( $.support.boundingRect || $.fn.jquery.match(/1\.[0-7+]\.[0-9+]?/) !== null );
};

$.mobile.ajaxBlacklist =
			// BlackBerry browsers, pre-webkit
			window.blackberry && !window.WebKitPoint ||
			// Opera Mini
			operamini ||
			// Symbian webkits pre 7.3
			nokiaLTE7_3;

// Lastly, this workaround is the only way we've found so far to get pre 7.3 Symbian webkit devices
// to render the stylesheets when they're referenced before this script, as we'd recommend doing.
// This simply reappends the CSS in place, which for some reason makes it apply
if ( nokiaLTE7_3 ) {
	$(function() {
		$( "head link[rel='stylesheet']" ).attr( "rel", "alternate stylesheet" ).attr( "rel", "stylesheet" );
	});
}

// For ruling out shadows via css
if ( !$.support.boxShadow ) {
	$( "html" ).addClass( "ui-noboxshadow" );
}

})( jQuery );


(function( $, undefined ) {
	var $win = $.mobile.window, self,
		dummyFnToInitNavigate = function() {
		};

	$.event.special.beforenavigate = {
		setup: function() {
			$win.on( "navigate", dummyFnToInitNavigate );
		},

		teardown: function() {
			$win.off( "navigate", dummyFnToInitNavigate );
		}
	};

	$.event.special.navigate = self = {
		bound: false,

		pushStateEnabled: true,

		originalEventName: undefined,

		// If pushstate support is present and push state support is defined to
		// be true on the mobile namespace.
		isPushStateEnabled: function() {
			return $.support.pushState &&
				$.mobile.pushStateEnabled === true &&
				this.isHashChangeEnabled();
		},

		// !! assumes mobile namespace is present
		isHashChangeEnabled: function() {
			return $.mobile.hashListeningEnabled === true;
		},

		// TODO a lot of duplication between popstate and hashchange
		popstate: function( event ) {
			var newEvent = new $.Event( "navigate" ),
				beforeNavigate = new $.Event( "beforenavigate" ),
				state = event.originalEvent.state || {};

			beforeNavigate.originalEvent = event;
			$win.trigger( beforeNavigate );

			if ( beforeNavigate.isDefaultPrevented() ) {
				return;
			}

			if ( event.historyState ) {
				$.extend(state, event.historyState);
			}

			// Make sure the original event is tracked for the end
			// user to inspect incase they want to do something special
			newEvent.originalEvent = event;

			// NOTE we let the current stack unwind because any assignment to
			//      location.hash will stop the world and run this event handler. By
			//      doing this we create a similar behavior to hashchange on hash
			//      assignment
			setTimeout(function() {
				$win.trigger( newEvent, {
					state: state
				});
			}, 0);
		},

		hashchange: function( event /*, data */ ) {
			var newEvent = new $.Event( "navigate" ),
				beforeNavigate = new $.Event( "beforenavigate" );

			beforeNavigate.originalEvent = event;
			$win.trigger( beforeNavigate );

			if ( beforeNavigate.isDefaultPrevented() ) {
				return;
			}

			// Make sure the original event is tracked for the end
			// user to inspect incase they want to do something special
			newEvent.originalEvent = event;

			// Trigger the hashchange with state provided by the user
			// that altered the hash
			$win.trigger( newEvent, {
				// Users that want to fully normalize the two events
				// will need to do history management down the stack and
				// add the state to the event before this binding is fired
				// TODO consider allowing for the explicit addition of callbacks
				//      to be fired before this value is set to avoid event timing issues
				state: event.hashchangeState || {}
			});
		},

		// TODO We really only want to set this up once
		//      but I'm not clear if there's a beter way to achieve
		//      this with the jQuery special event structure
		setup: function( /* data, namespaces */ ) {
			if ( self.bound ) {
				return;
			}

			self.bound = true;

			if ( self.isPushStateEnabled() ) {
				self.originalEventName = "popstate";
				$win.bind( "popstate.navigate", self.popstate );
			} else if ( self.isHashChangeEnabled() ) {
				self.originalEventName = "hashchange";
				$win.bind( "hashchange.navigate", self.hashchange );
			}
		}
	};
})( jQuery );



(function( $, undefined ) {
		var path, $base, dialogHashKey = "&ui-state=dialog";

		$.mobile.path = path = {
			uiStateKey: "&ui-state",

			// This scary looking regular expression parses an absolute URL or its relative
			// variants (protocol, site, document, query, and hash), into the various
			// components (protocol, host, path, query, fragment, etc that make up the
			// URL as well as some other commonly used sub-parts. When used with RegExp.exec()
			// or String.match, it parses the URL into a results array that looks like this:
			//
			//     [0]: http://jblas:password@mycompany.com:8080/mail/inbox?msg=1234&type=unread#msg-content
			//     [1]: http://jblas:password@mycompany.com:8080/mail/inbox?msg=1234&type=unread
			//     [2]: http://jblas:password@mycompany.com:8080/mail/inbox
			//     [3]: http://jblas:password@mycompany.com:8080
			//     [4]: http:
			//     [5]: //
			//     [6]: jblas:password@mycompany.com:8080
			//     [7]: jblas:password
			//     [8]: jblas
			//     [9]: password
			//    [10]: mycompany.com:8080
			//    [11]: mycompany.com
			//    [12]: 8080
			//    [13]: /mail/inbox
			//    [14]: /mail/
			//    [15]: inbox
			//    [16]: ?msg=1234&type=unread
			//    [17]: #msg-content
			//
			urlParseRE: /^\s*(((([^:\/#\?]+:)?(?:(\/\/)((?:(([^:@\/#\?]+)(?:\:([^:@\/#\?]+))?)@)?(([^:\/#\?\]\[]+|\[[^\/\]@#?]+\])(?:\:([0-9]+))?))?)?)?((\/?(?:[^\/\?#]+\/+)*)([^\?#]*)))?(\?[^#]+)?)(#.*)?/,

			// Abstraction to address xss (Issue #4787) by removing the authority in
			// browsers that auto-decode it. All references to location.href should be
			// replaced with a call to this method so that it can be dealt with properly here
			getLocation: function( url ) {
				var parsedUrl = this.parseUrl( url || location.href ),
					uri = url ? parsedUrl : location,

					// Make sure to parse the url or the location object for the hash because using
					// location.hash is autodecoded in firefox, the rest of the url should be from
					// the object (location unless we're testing) to avoid the inclusion of the
					// authority
					hash = parsedUrl.hash;

				// mimic the browser with an empty string when the hash is empty
				hash = hash === "#" ? "" : hash;

				return uri.protocol +
					parsedUrl.doubleSlash +
					uri.host +

					// The pathname must start with a slash if there's a protocol, because you
					// can't have a protocol followed by a relative path. Also, it's impossible to
					// calculate absolute URLs from relative ones if the absolute one doesn't have
					// a leading "/".
					( ( uri.protocol !== "" && uri.pathname.substring( 0, 1 ) !== "/" ) ?
						"/" : "" ) +
					uri.pathname +
					uri.search +
					hash;
			},

			//return the original document url
			getDocumentUrl: function( asParsedObject ) {
				return asParsedObject ? $.extend( {}, path.documentUrl ) : path.documentUrl.href;
			},

			parseLocation: function() {
				return this.parseUrl( this.getLocation() );
			},

			//Parse a URL into a structure that allows easy access to
			//all of the URL components by name.
			parseUrl: function( url ) {
				// If we're passed an object, we'll assume that it is
				// a parsed url object and just return it back to the caller.
				if ( $.type( url ) === "object" ) {
					return url;
				}

				var matches = path.urlParseRE.exec( url || "" ) || [];

					// Create an object that allows the caller to access the sub-matches
					// by name. Note that IE returns an empty string instead of undefined,
					// like all other browsers do, so we normalize everything so its consistent
					// no matter what browser we're running on.
					return {
						href:         matches[  0 ] || "",
						hrefNoHash:   matches[  1 ] || "",
						hrefNoSearch: matches[  2 ] || "",
						domain:       matches[  3 ] || "",
						protocol:     matches[  4 ] || "",
						doubleSlash:  matches[  5 ] || "",
						authority:    matches[  6 ] || "",
						username:     matches[  8 ] || "",
						password:     matches[  9 ] || "",
						host:         matches[ 10 ] || "",
						hostname:     matches[ 11 ] || "",
						port:         matches[ 12 ] || "",
						pathname:     matches[ 13 ] || "",
						directory:    matches[ 14 ] || "",
						filename:     matches[ 15 ] || "",
						search:       matches[ 16 ] || "",
						hash:         matches[ 17 ] || ""
					};
			},

			//Turn relPath into an asbolute path. absPath is
			//an optional absolute path which describes what
			//relPath is relative to.
			makePathAbsolute: function( relPath, absPath ) {
				var absStack,
					relStack,
					i, d;

				if ( relPath && relPath.charAt( 0 ) === "/" ) {
					return relPath;
				}

				relPath = relPath || "";
				absPath = absPath ? absPath.replace( /^\/|(\/[^\/]*|[^\/]+)$/g, "" ) : "";

				absStack = absPath ? absPath.split( "/" ) : [];
				relStack = relPath.split( "/" );

				for ( i = 0; i < relStack.length; i++ ) {
					d = relStack[ i ];
					switch ( d ) {
						case ".":
							break;
						case "..":
							if ( absStack.length ) {
								absStack.pop();
							}
							break;
						default:
							absStack.push( d );
							break;
					}
				}
				return "/" + absStack.join( "/" );
			},

			//Returns true if both urls have the same domain.
			isSameDomain: function( absUrl1, absUrl2 ) {
				return path.parseUrl( absUrl1 ).domain === path.parseUrl( absUrl2 ).domain;
			},

			//Returns true for any relative variant.
			isRelativeUrl: function( url ) {
				// All relative Url variants have one thing in common, no protocol.
				return path.parseUrl( url ).protocol === "";
			},

			//Returns true for an absolute url.
			isAbsoluteUrl: function( url ) {
				return path.parseUrl( url ).protocol !== "";
			},

			//Turn the specified realtive URL into an absolute one. This function
			//can handle all relative variants (protocol, site, document, query, fragment).
			makeUrlAbsolute: function( relUrl, absUrl ) {
				if ( !path.isRelativeUrl( relUrl ) ) {
					return relUrl;
				}

				if ( absUrl === undefined ) {
					absUrl = this.documentBase;
				}

				var relObj = path.parseUrl( relUrl ),
					absObj = path.parseUrl( absUrl ),
					protocol = relObj.protocol || absObj.protocol,
					doubleSlash = relObj.protocol ? relObj.doubleSlash : ( relObj.doubleSlash || absObj.doubleSlash ),
					authority = relObj.authority || absObj.authority,
					hasPath = relObj.pathname !== "",
					pathname = path.makePathAbsolute( relObj.pathname || absObj.filename, absObj.pathname ),
					search = relObj.search || ( !hasPath && absObj.search ) || "",
					hash = relObj.hash;

				return protocol + doubleSlash + authority + pathname + search + hash;
			},

			//Add search (aka query) params to the specified url.
			addSearchParams: function( url, params ) {
				var u = path.parseUrl( url ),
					p = ( typeof params === "object" ) ? $.param( params ) : params,
					s = u.search || "?";
				return u.hrefNoSearch + s + ( s.charAt( s.length - 1 ) !== "?" ? "&" : "" ) + p + ( u.hash || "" );
			},

			convertUrlToDataUrl: function( absUrl ) {
				var u = path.parseUrl( absUrl );
				if ( path.isEmbeddedPage( u ) ) {
					// For embedded pages, remove the dialog hash key as in getFilePath(),
					// and remove otherwise the Data Url won't match the id of the embedded Page.
					return u.hash
						.split( dialogHashKey )[0]
						.replace( /^#/, "" )
						.replace( /\?.*$/, "" );
				} else if ( path.isSameDomain( u, this.documentBase ) ) {
					return u.hrefNoHash.replace( this.documentBase.domain, "" ).split( dialogHashKey )[0];
				}

				return window.decodeURIComponent(absUrl);
			},

			//get path from current hash, or from a file path
			get: function( newPath ) {
				if ( newPath === undefined ) {
					newPath = path.parseLocation().hash;
				}
				return path.stripHash( newPath ).replace( /[^\/]*\.[^\/*]+$/, "" );
			},

			//set location hash to path
			set: function( path ) {
				location.hash = path;
			},

			//test if a given url (string) is a path
			//NOTE might be exceptionally naive
			isPath: function( url ) {
				return ( /\// ).test( url );
			},

			//return a url path with the window's location protocol/hostname/pathname removed
			clean: function( url ) {
				return url.replace( this.documentBase.domain, "" );
			},

			//just return the url without an initial #
			stripHash: function( url ) {
				return url.replace( /^#/, "" );
			},

			stripQueryParams: function( url ) {
				return url.replace( /\?.*$/, "" );
			},

			//remove the preceding hash, any query params, and dialog notations
			cleanHash: function( hash ) {
				return path.stripHash( hash.replace( /\?.*$/, "" ).replace( dialogHashKey, "" ) );
			},

			isHashValid: function( hash ) {
				return ( /^#[^#]+$/ ).test( hash );
			},

			//check whether a url is referencing the same domain, or an external domain or different protocol
			//could be mailto, etc
			isExternal: function( url ) {
				var u = path.parseUrl( url );
				return u.protocol && u.domain !== this.documentUrl.domain ? true : false;
			},

			hasProtocol: function( url ) {
				return ( /^(:?\w+:)/ ).test( url );
			},

			isEmbeddedPage: function( url ) {
				var u = path.parseUrl( url );

				//if the path is absolute, then we need to compare the url against
				//both the this.documentUrl and the documentBase. The main reason for this
				//is that links embedded within external documents will refer to the
				//application document, whereas links embedded within the application
				//document will be resolved against the document base.
				if ( u.protocol !== "" ) {
					return ( !this.isPath(u.hash) && u.hash && ( u.hrefNoHash === this.documentUrl.hrefNoHash || ( this.documentBaseDiffers && u.hrefNoHash === this.documentBase.hrefNoHash ) ) );
				}
				return ( /^#/ ).test( u.href );
			},

			squash: function( url, resolutionUrl ) {
				var href, cleanedUrl, search, stateIndex,
					isPath = this.isPath( url ),
					uri = this.parseUrl( url ),
					preservedHash = uri.hash,
					uiState = "";

				// produce a url against which we can resole the provided path
				resolutionUrl = resolutionUrl || (path.isPath(url) ? path.getLocation() : path.getDocumentUrl());

				// If the url is anything but a simple string, remove any preceding hash
				// eg #foo/bar -> foo/bar
				//    #foo -> #foo
				cleanedUrl = isPath ? path.stripHash( url ) : url;

				// If the url is a full url with a hash check if the parsed hash is a path
				// if it is, strip the #, and use it otherwise continue without change
				cleanedUrl = path.isPath( uri.hash ) ? path.stripHash( uri.hash ) : cleanedUrl;

				// Split the UI State keys off the href
				stateIndex = cleanedUrl.indexOf( this.uiStateKey );

				// store the ui state keys for use
				if ( stateIndex > -1 ) {
					uiState = cleanedUrl.slice( stateIndex );
					cleanedUrl = cleanedUrl.slice( 0, stateIndex );
				}

				// make the cleanedUrl absolute relative to the resolution url
				href = path.makeUrlAbsolute( cleanedUrl, resolutionUrl );

				// grab the search from the resolved url since parsing from
				// the passed url may not yield the correct result
				search = this.parseUrl( href ).search;

				// TODO all this crap is terrible, clean it up
				if ( isPath ) {
					// reject the hash if it's a path or it's just a dialog key
					if ( path.isPath( preservedHash ) || preservedHash.replace("#", "").indexOf( this.uiStateKey ) === 0) {
						preservedHash = "";
					}

					// Append the UI State keys where it exists and it's been removed
					// from the url
					if ( uiState && preservedHash.indexOf( this.uiStateKey ) === -1) {
						preservedHash += uiState;
					}

					// make sure that pound is on the front of the hash
					if ( preservedHash.indexOf( "#" ) === -1 && preservedHash !== "" ) {
						preservedHash = "#" + preservedHash;
					}

					// reconstruct each of the pieces with the new search string and hash
					href = path.parseUrl( href );
					href = href.protocol + href.doubleSlash + href.host + href.pathname + search +
						preservedHash;
				} else {
					href += href.indexOf( "#" ) > -1 ? uiState : "#" + uiState;
				}

				return href;
			},

			isPreservableHash: function( hash ) {
				return hash.replace( "#", "" ).indexOf( this.uiStateKey ) === 0;
			},

			// Escape weird characters in the hash if it is to be used as a selector
			hashToSelector: function( hash ) {
				var hasHash = ( hash.substring( 0, 1 ) === "#" );
				if ( hasHash ) {
					hash = hash.substring( 1 );
				}
				return ( hasHash ? "#" : "" ) + hash.replace( /([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g, "\\$1" );
			},

			// return the substring of a filepath before the sub-page key, for making
			// a server request
			getFilePath: function( path ) {
				var splitkey = "&" + $.mobile.subPageUrlKey;
				return path && path.split( splitkey )[0].split( dialogHashKey )[0];
			},

			// check if the specified url refers to the first page in the main
			// application document.
			isFirstPageUrl: function( url ) {
				// We only deal with absolute paths.
				var u = path.parseUrl( path.makeUrlAbsolute( url, this.documentBase ) ),

					// Does the url have the same path as the document?
					samePath = u.hrefNoHash === this.documentUrl.hrefNoHash ||
						( this.documentBaseDiffers &&
							u.hrefNoHash === this.documentBase.hrefNoHash ),

					// Get the first page element.
					fp = $.mobile.firstPage,

					// Get the id of the first page element if it has one.
					fpId = fp && fp[0] ? fp[0].id : undefined;

				// The url refers to the first page if the path matches the document and
				// it either has no hash value, or the hash is exactly equal to the id
				// of the first page element.
				return samePath &&
					( !u.hash ||
						u.hash === "#" ||
						( fpId && u.hash.replace( /^#/, "" ) === fpId ) );
			},

			// Some embedded browsers, like the web view in Phone Gap, allow
			// cross-domain XHR requests if the document doing the request was loaded
			// via the file:// protocol. This is usually to allow the application to
			// "phone home" and fetch app specific data. We normally let the browser
			// handle external/cross-domain urls, but if the allowCrossDomainPages
			// option is true, we will allow cross-domain http/https requests to go
			// through our page loading logic.
			isPermittedCrossDomainRequest: function( docUrl, reqUrl ) {
				return $.mobile.allowCrossDomainPages &&
					(docUrl.protocol === "file:" || docUrl.protocol === "content:") &&
					reqUrl.search( /^https?:/ ) !== -1;
			}
		};

		path.documentUrl = path.parseLocation();

		$base = $( "head" ).find( "base" );

		path.documentBase = $base.length ?
			path.parseUrl( path.makeUrlAbsolute( $base.attr( "href" ), path.documentUrl.href ) ) :
			path.documentUrl;

		path.documentBaseDiffers = (path.documentUrl.hrefNoHash !== path.documentBase.hrefNoHash);

		//return the original document base url
		path.getDocumentBase = function( asParsedObject ) {
			return asParsedObject ? $.extend( {}, path.documentBase ) : path.documentBase.href;
		};

		// DEPRECATED as of 1.4.0 - remove in 1.5.0
		$.extend( $.mobile, {

			//return the original document url
			getDocumentUrl: path.getDocumentUrl,

			//return the original document base url
			getDocumentBase: path.getDocumentBase
		});
})( jQuery );



(function( $, undefined ) {
	$.mobile.History = function( stack, index ) {
		this.stack = stack || [];
		this.activeIndex = index || 0;
	};

	$.extend($.mobile.History.prototype, {
		getActive: function() {
			return this.stack[ this.activeIndex ];
		},

		getLast: function() {
			return this.stack[ this.previousIndex ];
		},

		getNext: function() {
			return this.stack[ this.activeIndex + 1 ];
		},

		getPrev: function() {
			return this.stack[ this.activeIndex - 1 ];
		},

		// addNew is used whenever a new page is added
		add: function( url, data ) {
			data = data || {};

			//if there's forward history, wipe it
			if ( this.getNext() ) {
				this.clearForward();
			}

			// if the hash is included in the data make sure the shape
			// is consistent for comparison
			if ( data.hash && data.hash.indexOf( "#" ) === -1) {
				data.hash = "#" + data.hash;
			}

			data.url = url;
			this.stack.push( data );
			this.activeIndex = this.stack.length - 1;
		},

		//wipe urls ahead of active index
		clearForward: function() {
			this.stack = this.stack.slice( 0, this.activeIndex + 1 );
		},

		find: function( url, stack, earlyReturn ) {
			stack = stack || this.stack;

			var entry, i, length = stack.length, index;

			for ( i = 0; i < length; i++ ) {
				entry = stack[i];

				if ( decodeURIComponent(url) === decodeURIComponent(entry.url) ||
					decodeURIComponent(url) === decodeURIComponent(entry.hash) ) {
					index = i;

					if ( earlyReturn ) {
						return index;
					}
				}
			}

			return index;
		},

		closest: function( url ) {
			var closest, a = this.activeIndex;

			// First, take the slice of the history stack before the current index and search
			// for a url match. If one is found, we'll avoid avoid looking through forward history
			// NOTE the preference for backward history movement is driven by the fact that
			//      most mobile browsers only have a dedicated back button, and users rarely use
			//      the forward button in desktop browser anyhow
			closest = this.find( url, this.stack.slice(0, a) );

			// If nothing was found in backward history check forward. The `true`
			// value passed as the third parameter causes the find method to break
			// on the first match in the forward history slice. The starting index
			// of the slice must then be added to the result to get the element index
			// in the original history stack :( :(
			//
			// TODO this is hyper confusing and should be cleaned up (ugh so bad)
			if ( closest === undefined ) {
				closest = this.find( url, this.stack.slice(a), true );
				closest = closest === undefined ? closest : closest + a;
			}

			return closest;
		},

		direct: function( opts ) {
			var newActiveIndex = this.closest( opts.url ), a = this.activeIndex;

			// save new page index, null check to prevent falsey 0 result
			// record the previous index for reference
			if ( newActiveIndex !== undefined ) {
				this.activeIndex = newActiveIndex;
				this.previousIndex = a;
			}

			// invoke callbacks where appropriate
			//
			// TODO this is also convoluted and confusing
			if ( newActiveIndex < a ) {
				( opts.present || opts.back || $.noop )( this.getActive(), "back" );
			} else if ( newActiveIndex > a ) {
				( opts.present || opts.forward || $.noop )( this.getActive(), "forward" );
			} else if ( newActiveIndex === undefined && opts.missing ) {
				opts.missing( this.getActive() );
			}
		}
	});
})( jQuery );



(function( $, undefined ) {
	var path = $.mobile.path,
		initialHref = location.href;

	$.mobile.Navigator = function( history ) {
		this.history = history;
		this.ignoreInitialHashChange = true;

		$.mobile.window.bind({
			"popstate.history": $.proxy( this.popstate, this ),
			"hashchange.history": $.proxy( this.hashchange, this )
		});
	};

	$.extend($.mobile.Navigator.prototype, {
		squash: function( url, data ) {
			var state, href, hash = path.isPath(url) ? path.stripHash(url) : url;

			href = path.squash( url );

			// make sure to provide this information when it isn't explicitly set in the
			// data object that was passed to the squash method
			state = $.extend({
				hash: hash,
				url: href
			}, data);

			// replace the current url with the new href and store the state
			// Note that in some cases we might be replacing an url with the
			// same url. We do this anyways because we need to make sure that
			// all of our history entries have a state object associated with
			// them. This allows us to work around the case where $.mobile.back()
			// is called to transition from an external page to an embedded page.
			// In that particular case, a hashchange event is *NOT* generated by the browser.
			// Ensuring each history entry has a state object means that onPopState()
			// will always trigger our hashchange callback even when a hashchange event
			// is not fired.
			window.history.replaceState( state, state.title || document.title, href );

			return state;
		},

		hash: function( url, href ) {
			var parsed, loc, hash, resolved;

			// Grab the hash for recording. If the passed url is a path
			// we used the parsed version of the squashed url to reconstruct,
			// otherwise we assume it's a hash and store it directly
			parsed = path.parseUrl( url );
			loc = path.parseLocation();

			if ( loc.pathname + loc.search === parsed.pathname + parsed.search ) {
				// If the pathname and search of the passed url is identical to the current loc
				// then we must use the hash. Otherwise there will be no event
				// eg, url = "/foo/bar?baz#bang", location.href = "http://example.com/foo/bar?baz"
				hash = parsed.hash ? parsed.hash : parsed.pathname + parsed.search;
			} else if ( path.isPath(url) ) {
				resolved = path.parseUrl( href );
				// If the passed url is a path, make it domain relative and remove any trailing hash
				hash = resolved.pathname + resolved.search + (path.isPreservableHash( resolved.hash )? resolved.hash.replace( "#", "" ) : "");
			} else {
				hash = url;
			}

			return hash;
		},

		// TODO reconsider name
		go: function( url, data, noEvents ) {
			var state, href, hash, popstateEvent,
				isPopStateEvent = $.event.special.navigate.isPushStateEnabled();

			// Get the url as it would look squashed on to the current resolution url
			href = path.squash( url );

			// sort out what the hash sould be from the url
			hash = this.hash( url, href );

			// Here we prevent the next hash change or popstate event from doing any
			// history management. In the case of hashchange we don't swallow it
			// if there will be no hashchange fired (since that won't reset the value)
			// and will swallow the following hashchange
			if ( noEvents && hash !== path.stripHash(path.parseLocation().hash) ) {
				this.preventNextHashChange = noEvents;
			}

			// IMPORTANT in the case where popstate is supported the event will be triggered
			//      directly, stopping further execution - ie, interupting the flow of this
			//      method call to fire bindings at this expression. Below the navigate method
			//      there is a binding to catch this event and stop its propagation.
			//
			//      We then trigger a new popstate event on the window with a null state
			//      so that the navigate events can conclude their work properly
			//
			// if the url is a path we want to preserve the query params that are available on
			// the current url.
			this.preventHashAssignPopState = true;
			window.location.hash = hash;

			// If popstate is enabled and the browser triggers `popstate` events when the hash
			// is set (this often happens immediately in browsers like Chrome), then the
			// this flag will be set to false already. If it's a browser that does not trigger
			// a `popstate` on hash assignement or `replaceState` then we need avoid the branch
			// that swallows the event created by the popstate generated by the hash assignment
			// At the time of this writing this happens with Opera 12 and some version of IE
			this.preventHashAssignPopState = false;

			state = $.extend({
				url: href,
				hash: hash,
				title: document.title
			}, data);

			if ( isPopStateEvent ) {
				popstateEvent = new $.Event( "popstate" );
				popstateEvent.originalEvent = {
					type: "popstate",
					state: null
				};

				this.squash( url, state );

				// Trigger a new faux popstate event to replace the one that we
				// caught that was triggered by the hash setting above.
				if ( !noEvents ) {
					this.ignorePopState = true;
					$.mobile.window.trigger( popstateEvent );
				}
			}

			// record the history entry so that the information can be included
			// in hashchange event driven navigate events in a similar fashion to
			// the state that's provided by popstate
			this.history.add( state.url, state );
		},

		// This binding is intended to catch the popstate events that are fired
		// when execution of the `$.navigate` method stops at window.location.hash = url;
		// and completely prevent them from propagating. The popstate event will then be
		// retriggered after execution resumes
		//
		// TODO grab the original event here and use it for the synthetic event in the
		//      second half of the navigate execution that will follow this binding
		popstate: function( event ) {
			var hash, state;

			// Partly to support our test suite which manually alters the support
			// value to test hashchange. Partly to prevent all around weirdness
			if ( !$.event.special.navigate.isPushStateEnabled() ) {
				return;
			}

			// If this is the popstate triggered by the actual alteration of the hash
			// prevent it completely. History is tracked manually
			if ( this.preventHashAssignPopState ) {
				this.preventHashAssignPopState = false;
				event.stopImmediatePropagation();
				return;
			}

			// if this is the popstate triggered after the `replaceState` call in the go
			// method, then simply ignore it. The history entry has already been captured
			if ( this.ignorePopState ) {
				this.ignorePopState = false;
				return;
			}

			// If there is no state, and the history stack length is one were
			// probably getting the page load popstate fired by browsers like chrome
			// avoid it and set the one time flag to false.
			// TODO: Do we really need all these conditions? Comparing location hrefs
			// should be sufficient.
			if ( !event.originalEvent.state &&
				this.history.stack.length === 1 &&
				this.ignoreInitialHashChange ) {
				this.ignoreInitialHashChange = false;

				if ( location.href === initialHref ) {
					event.preventDefault();
					return;
				}
			}

			// account for direct manipulation of the hash. That is, we will receive a popstate
			// when the hash is changed by assignment, and it won't have a state associated. We
			// then need to squash the hash. See below for handling of hash assignment that
			// matches an existing history entry
			// TODO it might be better to only add to the history stack
			//      when the hash is adjacent to the active history entry
			hash = path.parseLocation().hash;
			if ( !event.originalEvent.state && hash ) {
				// squash the hash that's been assigned on the URL with replaceState
				// also grab the resulting state object for storage
				state = this.squash( hash );

				// record the new hash as an additional history entry
				// to match the browser's treatment of hash assignment
				this.history.add( state.url, state );

				// pass the newly created state information
				// along with the event
				event.historyState = state;

				// do not alter history, we've added a new history entry
				// so we know where we are
				return;
			}

			// If all else fails this is a popstate that comes from the back or forward buttons
			// make sure to set the state of our history stack properly, and record the directionality
			this.history.direct({
				url: (event.originalEvent.state || {}).url || hash,

				// When the url is either forward or backward in history include the entry
				// as data on the event object for merging as data in the navigate event
				present: function( historyEntry, direction ) {
					// make sure to create a new object to pass down as the navigate event data
					event.historyState = $.extend({}, historyEntry);
					event.historyState.direction = direction;
				}
			});
		},

		// NOTE must bind before `navigate` special event hashchange binding otherwise the
		//      navigation data won't be attached to the hashchange event in time for those
		//      bindings to attach it to the `navigate` special event
		// TODO add a check here that `hashchange.navigate` is bound already otherwise it's
		//      broken (exception?)
		hashchange: function( event ) {
			var history, hash;

			// If hashchange listening is explicitly disabled or pushstate is supported
			// avoid making use of the hashchange handler.
			if (!$.event.special.navigate.isHashChangeEnabled() ||
				$.event.special.navigate.isPushStateEnabled() ) {
				return;
			}

			// On occasion explicitly want to prevent the next hash from propogating because we only
			// with to alter the url to represent the new state do so here
			if ( this.preventNextHashChange ) {
				this.preventNextHashChange = false;
				event.stopImmediatePropagation();
				return;
			}

			history = this.history;
			hash = path.parseLocation().hash;

			// If this is a hashchange caused by the back or forward button
			// make sure to set the state of our history stack properly
			this.history.direct({
				url: hash,

				// When the url is either forward or backward in history include the entry
				// as data on the event object for merging as data in the navigate event
				present: function( historyEntry, direction ) {
					// make sure to create a new object to pass down as the navigate event data
					event.hashchangeState = $.extend({}, historyEntry);
					event.hashchangeState.direction = direction;
				},

				// When we don't find a hash in our history clearly we're aiming to go there
				// record the entry as new for future traversal
				//
				// NOTE it's not entirely clear that this is the right thing to do given that we
				//      can't know the users intention. It might be better to explicitly _not_
				//      support location.hash assignment in preference to $.navigate calls
				// TODO first arg to add should be the href, but it causes issues in identifying
				//      embeded pages
				missing: function() {
					history.add( hash, {
						hash: hash,
						title: document.title
					});
				}
			});
		}
	});
})( jQuery );



(function( $, undefined ) {
	// TODO consider queueing navigation activity until previous activities have completed
	//      so that end users don't have to think about it. Punting for now
	// TODO !! move the event bindings into callbacks on the navigate event
	$.mobile.navigate = function( url, data, noEvents ) {
		$.mobile.navigate.navigator.go( url, data, noEvents );
	};

	// expose the history on the navigate method in anticipation of full integration with
	// existing navigation functionalty that is tightly coupled to the history information
	$.mobile.navigate.history = new $.mobile.History();

	// instantiate an instance of the navigator for use within the $.navigate method
	$.mobile.navigate.navigator = new $.mobile.Navigator( $.mobile.navigate.history );

	var loc = $.mobile.path.parseLocation();
	$.mobile.navigate.history.add( loc.href, {hash: loc.hash} );
})( jQuery );


(function( $, undefined ) {
	var props = {
			"animation": {},
			"transition": {}
		},
		testElement = document.createElement( "a" ),
		vendorPrefixes = [ "", "webkit-", "moz-", "o-" ];

	$.each( [ "animation", "transition" ], function( i, test ) {

		// Get correct name for test
		var testName = ( i === 0 ) ? test + "-" + "name" : test;

		$.each( vendorPrefixes, function( j, prefix ) {
			if ( testElement.style[ $.camelCase( prefix + testName ) ] !== undefined ) {
				 props[ test ][ "prefix" ] = prefix;
				return false;
			}
		});

		// Set event and duration names for later use
		props[ test ][ "duration" ] =
			$.camelCase( props[ test ][ "prefix" ] + test + "-" + "duration" );
		props[ test ][ "event" ] =
			$.camelCase( props[ test ][ "prefix" ] + test + "-" + "end" );

		// All lower case if not a vendor prop
		if ( props[ test ][ "prefix" ] === "" ) {
			props[ test ][ "event" ] = props[ test ][ "event" ].toLowerCase();
		}
	});

	// If a valid prefix was found then the it is supported by the browser
	$.support.cssTransitions = ( props[ "transition" ][ "prefix" ] !== undefined );
	$.support.cssAnimations = ( props[ "animation" ][ "prefix" ] !== undefined );

	// Remove the testElement
	$( testElement ).remove();

	// Animation complete callback
	$.fn.animationComplete = function( callback, type, fallbackTime ) {
		var timer, duration,
			that = this,
			eventBinding = function() {

				// Clear the timer so we don't call callback twice
				clearTimeout( timer );
				callback.apply( this, arguments );
			},
			animationType = ( !type || type === "animation" ) ? "animation" : "transition";

		// Make sure selected type is supported by browser
		if ( ( $.support.cssTransitions && animationType === "transition" ) ||
			( $.support.cssAnimations && animationType === "animation" ) ) {

			// If a fallback time was not passed set one
			if ( fallbackTime === undefined ) {

				// Make sure the was not bound to document before checking .css
				if ( $( this ).context !== document ) {

					// Parse the durration since its in second multiple by 1000 for milliseconds
					// Multiply by 3 to make sure we give the animation plenty of time.
					duration = parseFloat(
						$( this ).css( props[ animationType ].duration )
					) * 3000;
				}

				// If we could not read a duration use the default
				if ( duration === 0 || duration === undefined || isNaN( duration ) ) {
					duration = $.fn.animationComplete.defaultDuration;
				}
			}

			// Sets up the fallback if event never comes
			timer = setTimeout( function() {
				$( that ).off( props[ animationType ].event, eventBinding );
				callback.apply( that );
			}, duration );

			// Bind the event
			return $( this ).one( props[ animationType ].event, eventBinding );
		} else {

			// CSS animation / transitions not supported
			// Defer execution for consistency between webkit/non webkit
			setTimeout( $.proxy( callback, this ), 0 );
			return $( this );
		}
	};

	// Allow default callback to be configured on mobileInit
	$.fn.animationComplete.defaultDuration = 1000;
})( jQuery );

// This plugin is an experiment for abstracting away the touch and mouse
// events so that developers don't have to worry about which method of input
// the device their document is loaded on supports.
//
// The idea here is to allow the developer to register listeners for the
// basic mouse events, such as mousedown, mousemove, mouseup, and click,
// and the plugin will take care of registering the correct listeners
// behind the scenes to invoke the listener at the fastest possible time
// for that device, while still retaining the order of event firing in
// the traditional mouse environment, should multiple handlers be registered
// on the same element for different events.
//
// The current version exposes the following virtual events to jQuery bind methods:
// "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel"

(function( $, window, document, undefined ) {

var dataPropertyName = "virtualMouseBindings",
	touchTargetPropertyName = "virtualTouchID",
	virtualEventNames = "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel".split( " " ),
	touchEventProps = "clientX clientY pageX pageY screenX screenY".split( " " ),
	mouseHookProps = $.event.mouseHooks ? $.event.mouseHooks.props : [],
	mouseEventProps = $.event.props.concat( mouseHookProps ),
	activeDocHandlers = {},
	resetTimerID = 0,
	startX = 0,
	startY = 0,
	didScroll = false,
	clickBlockList = [],
	blockMouseTriggers = false,
	blockTouchTriggers = false,
	eventCaptureSupported = "addEventListener" in document,
	$document = $( document ),
	nextTouchID = 1,
	lastTouchID = 0, threshold,
	i;

$.vmouse = {
	moveDistanceThreshold: 10,
	clickDistanceThreshold: 10,
	resetTimerDuration: 1500
};

function getNativeEvent( event ) {

	while ( event && typeof event.originalEvent !== "undefined" ) {
		event = event.originalEvent;
	}
	return event;
}

function createVirtualEvent( event, eventType ) {

	var t = event.type,
		oe, props, ne, prop, ct, touch, i, j, len;

	event = $.Event( event );
	event.type = eventType;

	oe = event.originalEvent;
	props = $.event.props;

	// addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280
	// https://github.com/jquery/jquery-mobile/issues/3280
	if ( t.search( /^(mouse|click)/ ) > -1 ) {
		props = mouseEventProps;
	}

	// copy original event properties over to the new event
	// this would happen if we could call $.event.fix instead of $.Event
	// but we don't have a way to force an event to be fixed multiple times
	if ( oe ) {
		for ( i = props.length, prop; i; ) {
			prop = props[ --i ];
			event[ prop ] = oe[ prop ];
		}
	}

	// make sure that if the mouse and click virtual events are generated
	// without a .which one is defined
	if ( t.search(/mouse(down|up)|click/) > -1 && !event.which ) {
		event.which = 1;
	}

	if ( t.search(/^touch/) !== -1 ) {
		ne = getNativeEvent( oe );
		t = ne.touches;
		ct = ne.changedTouches;
		touch = ( t && t.length ) ? t[0] : ( ( ct && ct.length ) ? ct[ 0 ] : undefined );

		if ( touch ) {
			for ( j = 0, len = touchEventProps.length; j < len; j++) {
				prop = touchEventProps[ j ];
				event[ prop ] = touch[ prop ];
			}
		}
	}

	return event;
}

function getVirtualBindingFlags( element ) {

	var flags = {},
		b, k;

	while ( element ) {

		b = $.data( element, dataPropertyName );

		for (  k in b ) {
			if ( b[ k ] ) {
				flags[ k ] = flags.hasVirtualBinding = true;
			}
		}
		element = element.parentNode;
	}
	return flags;
}

function getClosestElementWithVirtualBinding( element, eventType ) {
	var b;
	while ( element ) {

		b = $.data( element, dataPropertyName );

		if ( b && ( !eventType || b[ eventType ] ) ) {
			return element;
		}
		element = element.parentNode;
	}
	return null;
}

function enableTouchBindings() {
	blockTouchTriggers = false;
}

function disableTouchBindings() {
	blockTouchTriggers = true;
}

function enableMouseBindings() {
	lastTouchID = 0;
	clickBlockList.length = 0;
	blockMouseTriggers = false;

	// When mouse bindings are enabled, our
	// touch bindings are disabled.
	disableTouchBindings();
}

function disableMouseBindings() {
	// When mouse bindings are disabled, our
	// touch bindings are enabled.
	enableTouchBindings();
}

function startResetTimer() {
	clearResetTimer();
	resetTimerID = setTimeout( function() {
		resetTimerID = 0;
		enableMouseBindings();
	}, $.vmouse.resetTimerDuration );
}

function clearResetTimer() {
	if ( resetTimerID ) {
		clearTimeout( resetTimerID );
		resetTimerID = 0;
	}
}

function triggerVirtualEvent( eventType, event, flags ) {
	var ve;

	if ( ( flags && flags[ eventType ] ) ||
				( !flags && getClosestElementWithVirtualBinding( event.target, eventType ) ) ) {

		ve = createVirtualEvent( event, eventType );

		$( event.target).trigger( ve );
	}

	return ve;
}

function mouseEventCallback( event ) {
	var touchID = $.data( event.target, touchTargetPropertyName ),
		ve;

	if ( !blockMouseTriggers && ( !lastTouchID || lastTouchID !== touchID ) ) {
		ve = triggerVirtualEvent( "v" + event.type, event );
		if ( ve ) {
			if ( ve.isDefaultPrevented() ) {
				event.preventDefault();
			}
			if ( ve.isPropagationStopped() ) {
				event.stopPropagation();
			}
			if ( ve.isImmediatePropagationStopped() ) {
				event.stopImmediatePropagation();
			}
		}
	}
}

function handleTouchStart( event ) {

	var touches = getNativeEvent( event ).touches,
		target, flags, t;

	if ( touches && touches.length === 1 ) {

		target = event.target;
		flags = getVirtualBindingFlags( target );

		if ( flags.hasVirtualBinding ) {

			lastTouchID = nextTouchID++;
			$.data( target, touchTargetPropertyName, lastTouchID );

			clearResetTimer();

			disableMouseBindings();
			didScroll = false;

			t = getNativeEvent( event ).touches[ 0 ];
			startX = t.pageX;
			startY = t.pageY;

			triggerVirtualEvent( "vmouseover", event, flags );
			triggerVirtualEvent( "vmousedown", event, flags );
		}
	}
}

function handleScroll( event ) {
	if ( blockTouchTriggers ) {
		return;
	}

	if ( !didScroll ) {
		triggerVirtualEvent( "vmousecancel", event, getVirtualBindingFlags( event.target ) );
	}

	didScroll = true;
	startResetTimer();
}

function handleTouchMove( event ) {
	if ( blockTouchTriggers ) {
		return;
	}

	var t = getNativeEvent( event ).touches[ 0 ],
		didCancel = didScroll,
		moveThreshold = $.vmouse.moveDistanceThreshold,
		flags = getVirtualBindingFlags( event.target );

		didScroll = didScroll ||
			( Math.abs( t.pageX - startX ) > moveThreshold ||
				Math.abs( t.pageY - startY ) > moveThreshold );

	if ( didScroll && !didCancel ) {
		triggerVirtualEvent( "vmousecancel", event, flags );
	}

	triggerVirtualEvent( "vmousemove", event, flags );
	startResetTimer();
}

function handleTouchEnd( event ) {
	if ( blockTouchTriggers ) {
		return;
	}

	disableTouchBindings();

	var flags = getVirtualBindingFlags( event.target ),
		ve, t;
	triggerVirtualEvent( "vmouseup", event, flags );

	if ( !didScroll ) {
		ve = triggerVirtualEvent( "vclick", event, flags );
		if ( ve && ve.isDefaultPrevented() ) {
			// The target of the mouse events that follow the touchend
			// event don't necessarily match the target used during the
			// touch. This means we need to rely on coordinates for blocking
			// any click that is generated.
			t = getNativeEvent( event ).changedTouches[ 0 ];
			clickBlockList.push({
				touchID: lastTouchID,
				x: t.clientX,
				y: t.clientY
			});

			// Prevent any mouse events that follow from triggering
			// virtual event notifications.
			blockMouseTriggers = true;
		}
	}
	triggerVirtualEvent( "vmouseout", event, flags);
	didScroll = false;

	startResetTimer();
}

function hasVirtualBindings( ele ) {
	var bindings = $.data( ele, dataPropertyName ),
		k;

	if ( bindings ) {
		for ( k in bindings ) {
			if ( bindings[ k ] ) {
				return true;
			}
		}
	}
	return false;
}

function dummyMouseHandler() {}

function getSpecialEventObject( eventType ) {
	var realType = eventType.substr( 1 );

	return {
		setup: function(/* data, namespace */) {
			// If this is the first virtual mouse binding for this element,
			// add a bindings object to its data.

			if ( !hasVirtualBindings( this ) ) {
				$.data( this, dataPropertyName, {} );
			}

			// If setup is called, we know it is the first binding for this
			// eventType, so initialize the count for the eventType to zero.
			var bindings = $.data( this, dataPropertyName );
			bindings[ eventType ] = true;

			// If this is the first virtual mouse event for this type,
			// register a global handler on the document.

			activeDocHandlers[ eventType ] = ( activeDocHandlers[ eventType ] || 0 ) + 1;

			if ( activeDocHandlers[ eventType ] === 1 ) {
				$document.bind( realType, mouseEventCallback );
			}

			// Some browsers, like Opera Mini, won't dispatch mouse/click events
			// for elements unless they actually have handlers registered on them.
			// To get around this, we register dummy handlers on the elements.

			$( this ).bind( realType, dummyMouseHandler );

			// For now, if event capture is not supported, we rely on mouse handlers.
			if ( eventCaptureSupported ) {
				// If this is the first virtual mouse binding for the document,
				// register our touchstart handler on the document.

				activeDocHandlers[ "touchstart" ] = ( activeDocHandlers[ "touchstart" ] || 0) + 1;

				if ( activeDocHandlers[ "touchstart" ] === 1 ) {
					$document.bind( "touchstart", handleTouchStart )
						.bind( "touchend", handleTouchEnd )

						// On touch platforms, touching the screen and then dragging your finger
						// causes the window content to scroll after some distance threshold is
						// exceeded. On these platforms, a scroll prevents a click event from being
						// dispatched, and on some platforms, even the touchend is suppressed. To
						// mimic the suppression of the click event, we need to watch for a scroll
						// event. Unfortunately, some platforms like iOS don't dispatch scroll
						// events until *AFTER* the user lifts their finger (touchend). This means
						// we need to watch both scroll and touchmove events to figure out whether
						// or not a scroll happenens before the touchend event is fired.

						.bind( "touchmove", handleTouchMove )
						.bind( "scroll", handleScroll );
				}
			}
		},

		teardown: function(/* data, namespace */) {
			// If this is the last virtual binding for this eventType,
			// remove its global handler from the document.

			--activeDocHandlers[ eventType ];

			if ( !activeDocHandlers[ eventType ] ) {
				$document.unbind( realType, mouseEventCallback );
			}

			if ( eventCaptureSupported ) {
				// If this is the last virtual mouse binding in existence,
				// remove our document touchstart listener.

				--activeDocHandlers[ "touchstart" ];

				if ( !activeDocHandlers[ "touchstart" ] ) {
					$document.unbind( "touchstart", handleTouchStart )
						.unbind( "touchmove", handleTouchMove )
						.unbind( "touchend", handleTouchEnd )
						.unbind( "scroll", handleScroll );
				}
			}

			var $this = $( this ),
				bindings = $.data( this, dataPropertyName );

			// teardown may be called when an element was
			// removed from the DOM. If this is the case,
			// jQuery core may have already stripped the element
			// of any data bindings so we need to check it before
			// using it.
			if ( bindings ) {
				bindings[ eventType ] = false;
			}

			// Unregister the dummy event handler.

			$this.unbind( realType, dummyMouseHandler );

			// If this is the last virtual mouse binding on the
			// element, remove the binding data from the element.

			if ( !hasVirtualBindings( this ) ) {
				$this.removeData( dataPropertyName );
			}
		}
	};
}

// Expose our custom events to the jQuery bind/unbind mechanism.

for ( i = 0; i < virtualEventNames.length; i++ ) {
	$.event.special[ virtualEventNames[ i ] ] = getSpecialEventObject( virtualEventNames[ i ] );
}

// Add a capture click handler to block clicks.
// Note that we require event capture support for this so if the device
// doesn't support it, we punt for now and rely solely on mouse events.
if ( eventCaptureSupported ) {
	document.addEventListener( "click", function( e ) {
		var cnt = clickBlockList.length,
			target = e.target,
			x, y, ele, i, o, touchID;

		if ( cnt ) {
			x = e.clientX;
			y = e.clientY;
			threshold = $.vmouse.clickDistanceThreshold;

			// The idea here is to run through the clickBlockList to see if
			// the current click event is in the proximity of one of our
			// vclick events that had preventDefault() called on it. If we find
			// one, then we block the click.
			//
			// Why do we have to rely on proximity?
			//
			// Because the target of the touch event that triggered the vclick
			// can be different from the target of the click event synthesized
			// by the browser. The target of a mouse/click event that is synthesized
			// from a touch event seems to be implementation specific. For example,
			// some browsers will fire mouse/click events for a link that is near
			// a touch event, even though the target of the touchstart/touchend event
			// says the user touched outside the link. Also, it seems that with most
			// browsers, the target of the mouse/click event is not calculated until the
			// time it is dispatched, so if you replace an element that you touched
			// with another element, the target of the mouse/click will be the new
			// element underneath that point.
			//
			// Aside from proximity, we also check to see if the target and any
			// of its ancestors were the ones that blocked a click. This is necessary
			// because of the strange mouse/click target calculation done in the
			// Android 2.1 browser, where if you click on an element, and there is a
			// mouse/click handler on one of its ancestors, the target will be the
			// innermost child of the touched element, even if that child is no where
			// near the point of touch.

			ele = target;

			while ( ele ) {
				for ( i = 0; i < cnt; i++ ) {
					o = clickBlockList[ i ];
					touchID = 0;

					if ( ( ele === target && Math.abs( o.x - x ) < threshold && Math.abs( o.y - y ) < threshold ) ||
								$.data( ele, touchTargetPropertyName ) === o.touchID ) {
						// XXX: We may want to consider removing matches from the block list
						//      instead of waiting for the reset timer to fire.
						e.preventDefault();
						e.stopPropagation();
						return;
					}
				}
				ele = ele.parentNode;
			}
		}
	}, true);
}
})( jQuery, window, document );


(function( $, window, undefined ) {
	var $document = $( document ),
		supportTouch = $.mobile.support.touch,
		scrollEvent = "touchmove scroll",
		touchStartEvent = supportTouch ? "touchstart" : "mousedown",
		touchStopEvent = supportTouch ? "touchend" : "mouseup",
		touchMoveEvent = supportTouch ? "touchmove" : "mousemove";

	// setup new event shortcuts
	$.each( ( "touchstart touchmove touchend " +
		"tap taphold " +
		"swipe swipeleft swiperight " +
		"scrollstart scrollstop" ).split( " " ), function( i, name ) {

		$.fn[ name ] = function( fn ) {
			return fn ? this.bind( name, fn ) : this.trigger( name );
		};

		// jQuery < 1.8
		if ( $.attrFn ) {
			$.attrFn[ name ] = true;
		}
	});

	function triggerCustomEvent( obj, eventType, event, bubble ) {
		var originalType = event.type;
		event.type = eventType;
		if ( bubble ) {
			$.event.trigger( event, undefined, obj );
		} else {
			$.event.dispatch.call( obj, event );
		}
		event.type = originalType;
	}

	// also handles scrollstop
	$.event.special.scrollstart = {

		enabled: true,
		setup: function() {

			var thisObject = this,
				$this = $( thisObject ),
				scrolling,
				timer;

			function trigger( event, state ) {
				scrolling = state;
				triggerCustomEvent( thisObject, scrolling ? "scrollstart" : "scrollstop", event );
			}

			// iPhone triggers scroll after a small delay; use touchmove instead
			$this.bind( scrollEvent, function( event ) {

				if ( !$.event.special.scrollstart.enabled ) {
					return;
				}

				if ( !scrolling ) {
					trigger( event, true );
				}

				clearTimeout( timer );
				timer = setTimeout( function() {
					trigger( event, false );
				}, 50 );
			});
		},
		teardown: function() {
			$( this ).unbind( scrollEvent );
		}
	};

	// also handles taphold
	$.event.special.tap = {
		tapholdThreshold: 750,
		emitTapOnTaphold: true,
		setup: function() {
			var thisObject = this,
				$this = $( thisObject ),
				isTaphold = false;

			$this.bind( "vmousedown", function( event ) {
				isTaphold = false;
				if ( event.which && event.which !== 1 ) {
					return false;
				}

				var origTarget = event.target,
					timer;

				function clearTapTimer() {
					clearTimeout( timer );
				}

				function clearTapHandlers() {
					clearTapTimer();

					$this.unbind( "vclick", clickHandler )
						.unbind( "vmouseup", clearTapTimer );
					$document.unbind( "vmousecancel", clearTapHandlers );
				}

				function clickHandler( event ) {
					clearTapHandlers();

					// ONLY trigger a 'tap' event if the start target is
					// the same as the stop target.
					if ( !isTaphold && origTarget === event.target ) {
						triggerCustomEvent( thisObject, "tap", event );
					} else if ( isTaphold ) {
						event.preventDefault();
					}
				}

				$this.bind( "vmouseup", clearTapTimer )
					.bind( "vclick", clickHandler );
				$document.bind( "vmousecancel", clearTapHandlers );

				timer = setTimeout( function() {
					if ( !$.event.special.tap.emitTapOnTaphold ) {
						isTaphold = true;
					}
					triggerCustomEvent( thisObject, "taphold", $.Event( "taphold", { target: origTarget } ) );
				}, $.event.special.tap.tapholdThreshold );
			});
		},
		teardown: function() {
			$( this ).unbind( "vmousedown" ).unbind( "vclick" ).unbind( "vmouseup" );
			$document.unbind( "vmousecancel" );
		}
	};

	// Also handles swipeleft, swiperight
	$.event.special.swipe = {

		// More than this horizontal displacement, and we will suppress scrolling.
		scrollSupressionThreshold: 30,

		// More time than this, and it isn't a swipe.
		durationThreshold: 1000,

		// Swipe horizontal displacement must be more than this.
		horizontalDistanceThreshold: 30,

		// Swipe vertical displacement must be less than this.
		verticalDistanceThreshold: 30,

		getLocation: function ( event ) {
			var winPageX = window.pageXOffset,
				winPageY = window.pageYOffset,
				x = event.clientX,
				y = event.clientY;

			if ( event.pageY === 0 && Math.floor( y ) > Math.floor( event.pageY ) ||
				event.pageX === 0 && Math.floor( x ) > Math.floor( event.pageX ) ) {

				// iOS4 clientX/clientY have the value that should have been
				// in pageX/pageY. While pageX/page/ have the value 0
				x = x - winPageX;
				y = y - winPageY;
			} else if ( y < ( event.pageY - winPageY) || x < ( event.pageX - winPageX ) ) {

				// Some Android browsers have totally bogus values for clientX/Y
				// when scrolling/zooming a page. Detectable since clientX/clientY
				// should never be smaller than pageX/pageY minus page scroll
				x = event.pageX - winPageX;
				y = event.pageY - winPageY;
			}

			return {
				x: x,
				y: y
			};
		},

		start: function( event ) {
			var data = event.originalEvent.touches ?
					event.originalEvent.touches[ 0 ] : event,
				location = $.event.special.swipe.getLocation( data );
			return {
						time: ( new Date() ).getTime(),
						coords: [ location.x, location.y ],
						origin: $( event.target )
					};
		},

		stop: function( event ) {
			var data = event.originalEvent.touches ?
					event.originalEvent.touches[ 0 ] : event,
				location = $.event.special.swipe.getLocation( data );
			return {
						time: ( new Date() ).getTime(),
						coords: [ location.x, location.y ]
					};
		},

		handleSwipe: function( start, stop, thisObject, origTarget ) {
			if ( stop.time - start.time < $.event.special.swipe.durationThreshold &&
				Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&
				Math.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {
				var direction = start.coords[0] > stop.coords[ 0 ] ? "swipeleft" : "swiperight";

				triggerCustomEvent( thisObject, "swipe", $.Event( "swipe", { target: origTarget, swipestart: start, swipestop: stop }), true );
				triggerCustomEvent( thisObject, direction,$.Event( direction, { target: origTarget, swipestart: start, swipestop: stop } ), true );
				return true;
			}
			return false;

		},

		// This serves as a flag to ensure that at most one swipe event event is
		// in work at any given time
		eventInProgress: false,

		setup: function() {
			var events,
				thisObject = this,
				$this = $( thisObject ),
				context = {};

			// Retrieve the events data for this element and add the swipe context
			events = $.data( this, "mobile-events" );
			if ( !events ) {
				events = { length: 0 };
				$.data( this, "mobile-events", events );
			}
			events.length++;
			events.swipe = context;

			context.start = function( event ) {

				// Bail if we're already working on a swipe event
				if ( $.event.special.swipe.eventInProgress ) {
					return;
				}
				$.event.special.swipe.eventInProgress = true;

				var stop,
					start = $.event.special.swipe.start( event ),
					origTarget = event.target,
					emitted = false;

				context.move = function( event ) {
					if ( !start ) {
						return;
					}

					stop = $.event.special.swipe.stop( event );
					if ( !emitted ) {
						emitted = $.event.special.swipe.handleSwipe( start, stop, thisObject, origTarget );
						if ( emitted ) {

							// Reset the context to make way for the next swipe event
							$.event.special.swipe.eventInProgress = false;
						}
					}
					// prevent scrolling
					if ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {
						event.preventDefault();
					}
				};

				context.stop = function() {
						emitted = true;

						// Reset the context to make way for the next swipe event
						$.event.special.swipe.eventInProgress = false;
						$document.off( touchMoveEvent, context.move );
						context.move = null;
				};

				$document.on( touchMoveEvent, context.move )
					.one( touchStopEvent, context.stop );
			};
			$this.on( touchStartEvent, context.start );
		},

		teardown: function() {
			var events, context;

			events = $.data( this, "mobile-events" );
			if ( events ) {
				context = events.swipe;
				delete events.swipe;
				events.length--;
				if ( events.length === 0 ) {
					$.removeData( this, "mobile-events" );
				}
			}

			if ( context ) {
				if ( context.start ) {
					$( this ).off( touchStartEvent, context.start );
				}
				if ( context.move ) {
					$document.off( touchMoveEvent, context.move );
				}
				if ( context.stop ) {
					$document.off( touchStopEvent, context.stop );
				}
			}
		}
	};
	$.each({
		scrollstop: "scrollstart",
		taphold: "tap",
		swipeleft: "swipe.left",
		swiperight: "swipe.right"
	}, function( event, sourceEvent ) {

		$.event.special[ event ] = {
			setup: function() {
				$( this ).bind( sourceEvent, $.noop );
			},
			teardown: function() {
				$( this ).unbind( sourceEvent );
			}
		};
	});

})( jQuery, this );


	// throttled resize event
	(function( $ ) {
		$.event.special.throttledresize = {
			setup: function() {
				$( this ).bind( "resize", handler );
			},
			teardown: function() {
				$( this ).unbind( "resize", handler );
			}
		};

		var throttle = 250,
			handler = function() {
				curr = ( new Date() ).getTime();
				diff = curr - lastCall;

				if ( diff >= throttle ) {

					lastCall = curr;
					$( this ).trigger( "throttledresize" );

				} else {

					if ( heldCall ) {
						clearTimeout( heldCall );
					}

					// Promise a held call will still execute
					heldCall = setTimeout( handler, throttle - diff );
				}
			},
			lastCall = 0,
			heldCall,
			curr,
			diff;
	})( jQuery );


(function( $, window ) {
	var win = $( window ),
		event_name = "orientationchange",
		get_orientation,
		last_orientation,
		initial_orientation_is_landscape,
		initial_orientation_is_default,
		portrait_map = { "0": true, "180": true },
		ww, wh, landscape_threshold;

	// It seems that some device/browser vendors use window.orientation values 0 and 180 to
	// denote the "default" orientation. For iOS devices, and most other smart-phones tested,
	// the default orientation is always "portrait", but in some Android and RIM based tablets,
	// the default orientation is "landscape". The following code attempts to use the window
	// dimensions to figure out what the current orientation is, and then makes adjustments
	// to the to the portrait_map if necessary, so that we can properly decode the
	// window.orientation value whenever get_orientation() is called.
	//
	// Note that we used to use a media query to figure out what the orientation the browser
	// thinks it is in:
	//
	//     initial_orientation_is_landscape = $.mobile.media("all and (orientation: landscape)");
	//
	// but there was an iPhone/iPod Touch bug beginning with iOS 4.2, up through iOS 5.1,
	// where the browser *ALWAYS* applied the landscape media query. This bug does not
	// happen on iPad.

	if ( $.support.orientation ) {

		// Check the window width and height to figure out what the current orientation
		// of the device is at this moment. Note that we've initialized the portrait map
		// values to 0 and 180, *AND* we purposely check for landscape so that if we guess
		// wrong, , we default to the assumption that portrait is the default orientation.
		// We use a threshold check below because on some platforms like iOS, the iPhone
		// form-factor can report a larger width than height if the user turns on the
		// developer console. The actual threshold value is somewhat arbitrary, we just
		// need to make sure it is large enough to exclude the developer console case.

		ww = window.innerWidth || win.width();
		wh = window.innerHeight || win.height();
		landscape_threshold = 50;

		initial_orientation_is_landscape = ww > wh && ( ww - wh ) > landscape_threshold;

		// Now check to see if the current window.orientation is 0 or 180.
		initial_orientation_is_default = portrait_map[ window.orientation ];

		// If the initial orientation is landscape, but window.orientation reports 0 or 180, *OR*
		// if the initial orientation is portrait, but window.orientation reports 90 or -90, we
		// need to flip our portrait_map values because landscape is the default orientation for
		// this device/browser.
		if ( ( initial_orientation_is_landscape && initial_orientation_is_default ) || ( !initial_orientation_is_landscape && !initial_orientation_is_default ) ) {
			portrait_map = { "-90": true, "90": true };
		}
	}

	$.event.special.orientationchange = $.extend( {}, $.event.special.orientationchange, {
		setup: function() {
			// If the event is supported natively, return false so that jQuery
			// will bind to the event using DOM methods.
			if ( $.support.orientation && !$.event.special.orientationchange.disabled ) {
				return false;
			}

			// Get the current orientation to avoid initial double-triggering.
			last_orientation = get_orientation();

			// Because the orientationchange event doesn't exist, simulate the
			// event by testing window dimensions on resize.
			win.bind( "throttledresize", handler );
		},
		teardown: function() {
			// If the event is not supported natively, return false so that
			// jQuery will unbind the event using DOM methods.
			if ( $.support.orientation && !$.event.special.orientationchange.disabled ) {
				return false;
			}

			// Because the orientationchange event doesn't exist, unbind the
			// resize event handler.
			win.unbind( "throttledresize", handler );
		},
		add: function( handleObj ) {
			// Save a reference to the bound event handler.
			var old_handler = handleObj.handler;

			handleObj.handler = function( event ) {
				// Modify event object, adding the .orientation property.
				event.orientation = get_orientation();

				// Call the originally-bound event handler and return its result.
				return old_handler.apply( this, arguments );
			};
		}
	});

	// If the event is not supported natively, this handler will be bound to
	// the window resize event to simulate the orientationchange event.
	function handler() {
		// Get the current orientation.
		var orientation = get_orientation();

		if ( orientation !== last_orientation ) {
			// The orientation has changed, so trigger the orientationchange event.
			last_orientation = orientation;
			win.trigger( event_name );
		}
	}

	// Get the current page orientation. This method is exposed publicly, should it
	// be needed, as jQuery.event.special.orientationchange.orientation()
	$.event.special.orientationchange.orientation = get_orientation = function() {
		var isPortrait = true, elem = document.documentElement;

		// prefer window orientation to the calculation based on screensize as
		// the actual screen resize takes place before or after the orientation change event
		// has been fired depending on implementation (eg android 2.3 is before, iphone after).
		// More testing is required to determine if a more reliable method of determining the new screensize
		// is possible when orientationchange is fired. (eg, use media queries + element + opacity)
		if ( $.support.orientation ) {
			// if the window orientation registers as 0 or 180 degrees report
			// portrait, otherwise landscape
			isPortrait = portrait_map[ window.orientation ];
		} else {
			isPortrait = elem && elem.clientWidth / elem.clientHeight < 1.1;
		}

		return isPortrait ? "portrait" : "landscape";
	};

	$.fn[ event_name ] = function( fn ) {
		return fn ? this.bind( event_name, fn ) : this.trigger( event_name );
	};

	// jQuery < 1.8
	if ( $.attrFn ) {
		$.attrFn[ event_name ] = true;
	}

}( jQuery, this ));




(function( $, undefined ) {

	// existing base tag?
	var baseElement = $( "head" ).children( "base" ),

	// base element management, defined depending on dynamic base tag support
	// TODO move to external widget
	base = {

		// define base element, for use in routing asset urls that are referenced
		// in Ajax-requested markup
		element: ( baseElement.length ? baseElement :
			$( "<base>", { href: $.mobile.path.documentBase.hrefNoHash } ).prependTo( $( "head" ) ) ),

		linkSelector: "[src], link[href], a[rel='external'], :jqmData(ajax='false'), a[target]",

		// set the generated BASE element's href to a new page's base path
		set: function( href ) {

			// we should do nothing if the user wants to manage their url base
			// manually
			if ( !$.mobile.dynamicBaseEnabled ) {
				return;
			}

			// we should use the base tag if we can manipulate it dynamically
			if ( $.support.dynamicBaseTag ) {
				base.element.attr( "href",
					$.mobile.path.makeUrlAbsolute( href, $.mobile.path.documentBase ) );
			}
		},

		rewrite: function( href, page ) {
			var newPath = $.mobile.path.get( href );

			page.find( base.linkSelector ).each(function( i, link ) {
				var thisAttr = $( link ).is( "[href]" ) ? "href" :
					$( link ).is( "[src]" ) ? "src" : "action",
				theLocation = $.mobile.path.parseLocation(),
				thisUrl = $( link ).attr( thisAttr );

				// XXX_jblas: We need to fix this so that it removes the document
				//            base URL, and then prepends with the new page URL.
				// if full path exists and is same, chop it - helps IE out
				thisUrl = thisUrl.replace( theLocation.protocol + theLocation.doubleSlash +
					theLocation.host + theLocation.pathname, "" );

				if ( !/^(\w+:|#|\/)/.test( thisUrl ) ) {
					$( link ).attr( thisAttr, newPath + thisUrl );
				}
			});
		},

		// set the generated BASE element's href to a new page's base path
		reset: function(/* href */) {
			base.element.attr( "href", $.mobile.path.documentBase.hrefNoSearch );
		}
	};

	$.mobile.base = base;

})( jQuery );


(function( $, undefined ) {
$.mobile.widgets = {};

var originalWidget = $.widget,

	// Record the original, non-mobileinit-modified version of $.mobile.keepNative
	// so we can later determine whether someone has modified $.mobile.keepNative
	keepNativeFactoryDefault = $.mobile.keepNative;

$.widget = (function( orig ) {
	return function() {
		var constructor = orig.apply( this, arguments ),
			name = constructor.prototype.widgetName;

		constructor.initSelector = ( ( constructor.prototype.initSelector !== undefined ) ?
			constructor.prototype.initSelector : ":jqmData(role='" + name + "')" );

		$.mobile.widgets[ name ] = constructor;

		return constructor;
	};
})( $.widget );

// Make sure $.widget still has bridge and extend methods
$.extend( $.widget, originalWidget );

// For backcompat remove in 1.5
$.mobile.document.on( "create", function( event ) {
	$( event.target ).enhanceWithin();
});

$.widget( "mobile.page", {
	options: {
		theme: "a",
		domCache: false,

		// Deprecated in 1.4 remove in 1.5
		keepNativeDefault: $.mobile.keepNative,

		// Deprecated in 1.4 remove in 1.5
		contentTheme: null,
		enhanced: false
	},

	// DEPRECATED for > 1.4
	// TODO remove at 1.5
	_createWidget: function() {
		$.Widget.prototype._createWidget.apply( this, arguments );
		this._trigger( "init" );
	},

	_create: function() {
		// If false is returned by the callbacks do not create the page
		if ( this._trigger( "beforecreate" ) === false ) {
			return false;
		}

		if ( !this.options.enhanced ) {
			this._enhance();
		}

		this._on( this.element, {
			pagebeforehide: "removeContainerBackground",
			pagebeforeshow: "_handlePageBeforeShow"
		});

		this.element.enhanceWithin();
		// Dialog widget is deprecated in 1.4 remove this in 1.5
		if ( $.mobile.getAttribute( this.element[0], "role" ) === "dialog" && $.mobile.dialog ) {
			this.element.dialog();
		}
	},

	_enhance: function () {
		var attrPrefix = "data-" + $.mobile.ns,
			self = this;

		if ( this.options.role ) {
			this.element.attr( "data-" + $.mobile.ns + "role", this.options.role );
		}

		this.element
			.attr( "tabindex", "0" )
			.addClass( "ui-page ui-page-theme-" + this.options.theme );

		// Manipulation of content os Deprecated as of 1.4 remove in 1.5
		this.element.find( "[" + attrPrefix + "role='content']" ).each( function() {
			var $this = $( this ),
				theme = this.getAttribute( attrPrefix + "theme" ) || undefined;
				self.options.contentTheme = theme || self.options.contentTheme || ( self.options.dialog && self.options.theme ) || ( self.element.jqmData("role") === "dialog" &&  self.options.theme );
				$this.addClass( "ui-content" );
				if ( self.options.contentTheme ) {
					$this.addClass( "ui-body-" + ( self.options.contentTheme ) );
				}
				// Add ARIA role
				$this.attr( "role", "main" ).addClass( "ui-content" );
		});
	},

	bindRemove: function( callback ) {
		var page = this.element;

		// when dom caching is not enabled or the page is embedded bind to remove the page on hide
		if ( !page.data( "mobile-page" ).options.domCache &&
			page.is( ":jqmData(external-page='true')" ) ) {

			// TODO use _on - that is, sort out why it doesn't work in this case
			page.bind( "pagehide.remove", callback || function( e, data ) {

				//check if this is a same page transition and if so don't remove the page
				if( !data.samePage ){
					var $this = $( this ),
						prEvent = new $.Event( "pageremove" );

					$this.trigger( prEvent );

					if ( !prEvent.isDefaultPrevented() ) {
						$this.removeWithDependents();
					}
				}
			});
		}
	},

	_setOptions: function( o ) {
		if ( o.theme !== undefined ) {
			this.element.removeClass( "ui-page-theme-" + this.options.theme ).addClass( "ui-page-theme-" + o.theme );
		}

		if ( o.contentTheme !== undefined ) {
			this.element.find( "[data-" + $.mobile.ns + "='content']" ).removeClass( "ui-body-" + this.options.contentTheme )
				.addClass( "ui-body-" + o.contentTheme );
		}
	},

	_handlePageBeforeShow: function(/* e */) {
		this.setContainerBackground();
	},
	// Deprecated in 1.4 remove in 1.5
	removeContainerBackground: function() {
		this.element.closest( ":mobile-pagecontainer" ).pagecontainer({ "theme": "none" });
	},
	// Deprecated in 1.4 remove in 1.5
	// set the page container background to the page theme
	setContainerBackground: function( theme ) {
		this.element.parent().pagecontainer( { "theme": theme || this.options.theme } );
	},
	// Deprecated in 1.4 remove in 1.5
	keepNativeSelector: function() {
		var options = this.options,
			keepNative = $.trim( options.keepNative || "" ),
			globalValue = $.trim( $.mobile.keepNative ),
			optionValue = $.trim( options.keepNativeDefault ),

			// Check if $.mobile.keepNative has changed from the factory default
			newDefault = ( keepNativeFactoryDefault === globalValue ?
				"" : globalValue ),

			// If $.mobile.keepNative has not changed, use options.keepNativeDefault
			oldDefault = ( newDefault === "" ? optionValue : "" );

		// Concatenate keepNative selectors from all sources where the value has
		// changed or, if nothing has changed, return the default
		return ( ( keepNative ? [ keepNative ] : [] )
			.concat( newDefault ? [ newDefault ] : [] )
			.concat( oldDefault ? [ oldDefault ] : [] )
			.join( ", " ) );
	}
});
})( jQuery );

(function( $, undefined ) {

	$.widget( "mobile.pagecontainer", {
		options: {
			theme: "a"
		},

		initSelector: false,

		_create: function() {
			this._trigger( "beforecreate" );
			this.setLastScrollEnabled = true;

			this._on( this.window, {
				// disable an scroll setting when a hashchange has been fired,
				// this only works because the recording of the scroll position
				// is delayed for 100ms after the browser might have changed the
				// position because of the hashchange
				navigate: "_disableRecordScroll",

				// bind to scrollstop for the first page, "pagechange" won't be
				// fired in that case
				scrollstop: "_delayedRecordScroll"
			});

			// TODO consider moving the navigation handler OUT of widget into
			//      some other object as glue between the navigate event and the
			//      content widget load and change methods
			this._on( this.window, { navigate: "_filterNavigateEvents" });

			// TODO move from page* events to content* events
			this._on({ pagechange: "_afterContentChange" });

			// handle initial hashchange from chrome :(
			this.window.one( "navigate", $.proxy(function() {
				this.setLastScrollEnabled = true;
			}, this));
		},

		_setOptions: function( options ) {
			if ( options.theme !== undefined && options.theme !== "none" ) {
				this.element.removeClass( "ui-overlay-" + this.options.theme )
					.addClass( "ui-overlay-" + options.theme );
			} else if ( options.theme !== undefined ) {
				this.element.removeClass( "ui-overlay-" + this.options.theme );
			}

			this._super( options );
		},

		_disableRecordScroll: function() {
			this.setLastScrollEnabled = false;
		},

		_enableRecordScroll: function() {
			this.setLastScrollEnabled = true;
		},

		// TODO consider the name here, since it's purpose specific
		_afterContentChange: function() {
			// once the page has changed, re-enable the scroll recording
			this.setLastScrollEnabled = true;

			// remove any binding that previously existed on the get scroll
			// which may or may not be different than the scroll element
			// determined for this page previously
			this._off( this.window, "scrollstop" );

			// determine and bind to the current scoll element which may be the
			// window or in the case of touch overflow the element touch overflow
			this._on( this.window, { scrollstop: "_delayedRecordScroll" });
		},

		_recordScroll: function() {
			// this barrier prevents setting the scroll value based on
			// the browser scrolling the window based on a hashchange
			if ( !this.setLastScrollEnabled ) {
				return;
			}

			var active = this._getActiveHistory(),
				currentScroll, minScroll, defaultScroll;

			if ( active ) {
				currentScroll = this._getScroll();
				minScroll = this._getMinScroll();
				defaultScroll = this._getDefaultScroll();

				// Set active page's lastScroll prop. If the location we're
				// scrolling to is less than minScrollBack, let it go.
				active.lastScroll = currentScroll < minScroll ? defaultScroll : currentScroll;
			}
		},

		_delayedRecordScroll: function() {
			setTimeout( $.proxy(this, "_recordScroll"), 100 );
		},

		_getScroll: function() {
			return this.window.scrollTop();
		},

		_getMinScroll: function() {
			return $.mobile.minScrollBack;
		},

		_getDefaultScroll: function() {
			return $.mobile.defaultHomeScroll;
		},

		_filterNavigateEvents: function( e, data ) {
			var url;

			if ( e.originalEvent && e.originalEvent.isDefaultPrevented() ) {
				return;
			}

			url = e.originalEvent.type.indexOf( "hashchange" ) > -1 ? data.state.hash : data.state.url;

			if ( !url ) {
				url = this._getHash();
			}

			if ( !url || url === "#" || url.indexOf( "#" + $.mobile.path.uiStateKey ) === 0 ) {
				url = location.href;
			}

			this._handleNavigate( url, data.state );
		},

		_getHash: function() {
			return $.mobile.path.parseLocation().hash;
		},

		// TODO active page should be managed by the container (ie, it should be a property)
		getActivePage: function() {
			return this.activePage;
		},

		// TODO the first page should be a property set during _create using the logic
		//      that currently resides in init
		_getInitialContent: function() {
			return $.mobile.firstPage;
		},

		// TODO each content container should have a history object
		_getHistory: function() {
			return $.mobile.navigate.history;
		},

		// TODO use _getHistory
		_getActiveHistory: function() {
			return $.mobile.navigate.history.getActive();
		},

		// TODO the document base should be determined at creation
		_getDocumentBase: function() {
			return $.mobile.path.documentBase;
		},

		back: function() {
			this.go( -1 );
		},

		forward: function() {
			this.go( 1 );
		},

		go: function( steps ) {

			//if hashlistening is enabled use native history method
			if ( $.mobile.hashListeningEnabled ) {
				window.history.go( steps );
			} else {

				//we are not listening to the hash so handle history internally
				var activeIndex = $.mobile.navigate.history.activeIndex,
					index = activeIndex + parseInt( steps, 10 ),
					url = $.mobile.navigate.history.stack[ index ].url,
					direction = ( steps >= 1 )? "forward" : "back";

				//update the history object
				$.mobile.navigate.history.activeIndex = index;
				$.mobile.navigate.history.previousIndex = activeIndex;

				//change to the new page
				this.change( url, { direction: direction, changeHash: false, fromHashChange: true } );
			}
		},

		// TODO rename _handleDestination
		_handleDestination: function( to ) {
			var history;

			// clean the hash for comparison if it's a url
			if ( $.type(to) === "string" ) {
				to = $.mobile.path.stripHash( to );
			}

			if ( to ) {
				history = this._getHistory();

				// At this point, 'to' can be one of 3 things, a cached page
				// element from a history stack entry, an id, or site-relative /
				// absolute URL. If 'to' is an id, we need to resolve it against
				// the documentBase, not the location.href, since the hashchange
				// could've been the result of a forward/backward navigation
				// that crosses from an external page/dialog to an internal
				// page/dialog.
				//
				// TODO move check to history object or path object?
				to = !$.mobile.path.isPath( to ) ? ( $.mobile.path.makeUrlAbsolute( "#" + to, this._getDocumentBase() ) ) : to;

				// If we're about to go to an initial URL that contains a
				// reference to a non-existent internal page, go to the first
				// page instead. We know that the initial hash refers to a
				// non-existent page, because the initial hash did not end
				// up in the initial history entry
				// TODO move check to history object?
				if ( to === $.mobile.path.makeUrlAbsolute( "#" + history.initialDst, this._getDocumentBase() ) &&
					history.stack.length &&
					history.stack[0].url !== history.initialDst.replace( $.mobile.dialogHashKey, "" ) ) {
					to = this._getInitialContent();
				}
			}
			return to || this._getInitialContent();
		},

		_handleDialog: function( changePageOptions, data ) {
			var to, active, activeContent = this.getActivePage();

			// If current active page is not a dialog skip the dialog and continue
			// in the same direction
			if ( activeContent && !activeContent.hasClass( "ui-dialog" ) ) {
				// determine if we're heading forward or backward and continue
				// accordingly past the current dialog
				if ( data.direction === "back" ) {
					this.back();
				} else {
					this.forward();
				}

				// prevent changePage call
				return false;
			} else {
				// if the current active page is a dialog and we're navigating
				// to a dialog use the dialog objected saved in the stack
				to = data.pageUrl;
				active = this._getActiveHistory();

				// make sure to set the role, transition and reversal
				// as most of this is lost by the domCache cleaning
				$.extend( changePageOptions, {
					role: active.role,
					transition: active.transition,
					reverse: data.direction === "back"
				});
			}

			return to;
		},

		_handleNavigate: function( url, data ) {
			//find first page via hash
			// TODO stripping the hash twice with handleUrl
			var to = $.mobile.path.stripHash( url ), history = this._getHistory(),

				// transition is false if it's the first page, undefined
				// otherwise (and may be overridden by default)
				transition = history.stack.length === 0 ? "none" : undefined,

				// default options for the changPage calls made after examining
				// the current state of the page and the hash, NOTE that the
				// transition is derived from the previous history entry
				changePageOptions = {
					changeHash: false,
					fromHashChange: true,
					reverse: data.direction === "back"
				};

			$.extend( changePageOptions, data, {
				transition: ( history.getLast() || {} ).transition || transition
			});

			// TODO move to _handleDestination ?
			// If this isn't the first page, if the current url is a dialog hash
			// key, and the initial destination isn't equal to the current target
			// page, use the special dialog handling
			if ( history.activeIndex > 0 &&
				to.indexOf( $.mobile.dialogHashKey ) > -1 &&
				history.initialDst !== to ) {

				to = this._handleDialog( changePageOptions, data );

				if ( to === false ) {
					return;
				}
			}

			this._changeContent( this._handleDestination( to ), changePageOptions );
		},

		_changeContent: function( to, opts ) {
			$.mobile.changePage( to, opts );
		},

		_getBase: function() {
			return $.mobile.base;
		},

		_getNs: function() {
			return $.mobile.ns;
		},

		_enhance: function( content, role ) {
			// TODO consider supporting a custom callback, and passing in
			// the settings which includes the role
			return content.page({ role: role });
		},

		_include: function( page, settings ) {
			// append to page and enhance
			page.appendTo( this.element );

			// use the page widget to enhance
			this._enhance( page, settings.role );

			// remove page on hide
			page.page( "bindRemove" );
		},

		_find: function( absUrl ) {
			// TODO consider supporting a custom callback
			var fileUrl = this._createFileUrl( absUrl ),
				dataUrl = this._createDataUrl( absUrl ),
				page, initialContent = this._getInitialContent();

			// Check to see if the page already exists in the DOM.
			// NOTE do _not_ use the :jqmData pseudo selector because parenthesis
			//      are a valid url char and it breaks on the first occurence
			page = this.element
				.children( "[data-" + this._getNs() +"url='" + dataUrl + "']" );

			// If we failed to find the page, check to see if the url is a
			// reference to an embedded page. If so, it may have been dynamically
			// injected by a developer, in which case it would be lacking a
			// data-url attribute and in need of enhancement.
			if ( page.length === 0 && dataUrl && !$.mobile.path.isPath( dataUrl ) ) {
				page = this.element.children( $.mobile.path.hashToSelector("#" + dataUrl) )
					.attr( "data-" + this._getNs() + "url", dataUrl )
					.jqmData( "url", dataUrl );
			}

			// If we failed to find a page in the DOM, check the URL to see if it
			// refers to the first page in the application. Also check to make sure
			// our cached-first-page is actually in the DOM. Some user deployed
			// apps are pruning the first page from the DOM for various reasons.
			// We check for this case here because we don't want a first-page with
			// an id falling through to the non-existent embedded page error case.
			if ( page.length === 0 &&
				$.mobile.path.isFirstPageUrl( fileUrl ) &&
				initialContent &&
				initialContent.parent().length ) {
				page = $( initialContent );
			}

			return page;
		},

		_getLoader: function() {
			return $.mobile.loading();
		},

		_showLoading: function( delay, theme, msg, textonly ) {
			// This configurable timeout allows cached pages a brief
			// delay to load without showing a message
			if ( this._loadMsg ) {
				return;
			}

			this._loadMsg = setTimeout($.proxy(function() {
				this._getLoader().loader( "show", theme, msg, textonly );
				this._loadMsg = 0;
			}, this), delay );
		},

		_hideLoading: function() {
			// Stop message show timer
			clearTimeout( this._loadMsg );
			this._loadMsg = 0;

			// Hide loading message
			this._getLoader().loader( "hide" );
		},

		_showError: function() {
			// make sure to remove the current loading message
			this._hideLoading();

			// show the error message
			this._showLoading( 0, $.mobile.pageLoadErrorMessageTheme, $.mobile.pageLoadErrorMessage, true );

			// hide the error message after a delay
			// TODO configuration
			setTimeout( $.proxy(this, "_hideLoading"), 1500 );
		},

		_parse: function( html, fileUrl ) {
			// TODO consider allowing customization of this method. It's very JQM specific
			var page, all = $( "<div></div>" );

			//workaround to allow scripts to execute when included in page divs
			all.get( 0 ).innerHTML = html;

			page = all.find( ":jqmData(role='page'), :jqmData(role='dialog')" ).first();

			//if page elem couldn't be found, create one and insert the body element's contents
			if ( !page.length ) {
				page = $( "<div data-" + this._getNs() + "role='page'>" +
					( html.split( /<\/?body[^>]*>/gmi )[1] || "" ) +
					"</div>" );
			}

			// TODO tagging a page with external to make sure that embedded pages aren't
			// removed by the various page handling code is bad. Having page handling code
			// in many places is bad. Solutions post 1.0
			page.attr( "data-" + this._getNs() + "url", $.mobile.path.convertUrlToDataUrl(fileUrl) )
				.attr( "data-" + this._getNs() + "external-page", true );

			return page;
		},

		_setLoadedTitle: function( page, html ) {
			//page title regexp
			var newPageTitle = html.match( /<title[^>]*>([^<]*)/ ) && RegExp.$1;

			if ( newPageTitle && !page.jqmData("title") ) {
				newPageTitle = $( "<div>" + newPageTitle + "</div>" ).text();
				page.jqmData( "title", newPageTitle );
			}
		},

		_isRewritableBaseTag: function() {
			return $.mobile.dynamicBaseEnabled && !$.support.dynamicBaseTag;
		},

		_createDataUrl: function( absoluteUrl ) {
			return $.mobile.path.convertUrlToDataUrl( absoluteUrl );
		},

		_createFileUrl: function( absoluteUrl ) {
			return $.mobile.path.getFilePath( absoluteUrl );
		},

		_triggerWithDeprecated: function( name, data, page ) {
			var deprecatedEvent = $.Event( "page" + name ),
				newEvent = $.Event( this.widgetName + name );

			// DEPRECATED
			// trigger the old deprecated event on the page if it's provided
			( page || this.element ).trigger( deprecatedEvent, data );

			// use the widget trigger method for the new content* event
			this._trigger( name, newEvent, data );

			return {
				deprecatedEvent: deprecatedEvent,
				event: newEvent
			};
		},

		// TODO it would be nice to split this up more but everything appears to be "one off"
		//      or require ordering such that other bits are sprinkled in between parts that
		//      could be abstracted out as a group
		_loadSuccess: function( absUrl, triggerData, settings, deferred ) {
			var fileUrl = this._createFileUrl( absUrl ),
				dataUrl = this._createDataUrl( absUrl );

			return $.proxy(function( html, textStatus, xhr ) {
				//pre-parse html to check for a data-url,
				//use it as the new fileUrl, base path, etc
				var content,

					// TODO handle dialogs again
					pageElemRegex = new RegExp( "(<[^>]+\\bdata-" + this._getNs() + "role=[\"']?page[\"']?[^>]*>)" ),

					dataUrlRegex = new RegExp( "\\bdata-" + this._getNs() + "url=[\"']?([^\"'>]*)[\"']?" );

				// data-url must be provided for the base tag so resource requests
				// can be directed to the correct url. loading into a temprorary
				// element makes these requests immediately
				if ( pageElemRegex.test( html ) &&
					RegExp.$1 &&
					dataUrlRegex.test( RegExp.$1 ) &&
					RegExp.$1 ) {
					fileUrl = $.mobile.path.getFilePath( $("<div>" + RegExp.$1 + "</div>").text() );
				}

				//dont update the base tag if we are prefetching
				if ( settings.prefetch === undefined ) {
					this._getBase().set( fileUrl );
				}

				content = this._parse( html, fileUrl );

				this._setLoadedTitle( content, html );

				// Add the content reference and xhr to our triggerData.
				triggerData.xhr = xhr;
				triggerData.textStatus = textStatus;

				// DEPRECATED
				triggerData.page = content;

				triggerData.content = content;

				triggerData.toPage = content;

				// If the default behavior is prevented, stop here!
				// Note that it is the responsibility of the listener/handler
				// that called preventDefault(), to resolve/reject the
				// deferred object within the triggerData.
				if ( this._triggerWithDeprecated( "load" ).event.isDefaultPrevented() ) {
					return;
				}

				// rewrite src and href attrs to use a base url if the base tag won't work
				if ( this._isRewritableBaseTag() && content ) {
					this._getBase().rewrite( fileUrl, content );
				}

				this._include( content, settings );

				// Enhancing the content may result in new dialogs/sub content being inserted
				// into the DOM. If the original absUrl refers to a sub-content, that is the
				// real content we are interested in.
				if ( absUrl.indexOf( "&" + $.mobile.subPageUrlKey ) > -1 ) {
					content = this.element.children( "[data-" + this._getNs() +"url='" + dataUrl + "']" );
				}

				// Remove loading message.
				if ( settings.showLoadMsg ) {
					this._hideLoading();
				}

				deferred.resolve( absUrl, settings, content );
			}, this);
		},

		_loadDefaults: {
			type: "get",
			data: undefined,

			// DEPRECATED
			reloadPage: false,

			reload: false,

			// By default we rely on the role defined by the @data-role attribute.
			role: undefined,

			showLoadMsg: false,

			// This delay allows loads that pull from browser cache to
			// occur without showing the loading message.
			loadMsgDelay: 50
		},

		load: function( url, options ) {
			// This function uses deferred notifications to let callers
			// know when the content is done loading, or if an error has occurred.
			var deferred = ( options && options.deferred ) || $.Deferred(),

				// The default load options with overrides specified by the caller.
				settings = $.extend( {}, this._loadDefaults, options ),

				// The DOM element for the content after it has been loaded.
				content = null,

				// The absolute version of the URL passed into the function. This
				// version of the URL may contain dialog/subcontent params in it.
				absUrl = $.mobile.path.makeUrlAbsolute( url, this._findBaseWithDefault() ),
				fileUrl, dataUrl, pblEvent, triggerData;

			// DEPRECATED reloadPage
			settings.reload = settings.reloadPage;

			// If the caller provided data, and we're using "get" request,
			// append the data to the URL.
			if ( settings.data && settings.type === "get" ) {
				absUrl = $.mobile.path.addSearchParams( absUrl, settings.data );
				settings.data = undefined;
			}

			// If the caller is using a "post" request, reload must be true
			if ( settings.data && settings.type === "post" ) {
				settings.reload = true;
			}

			// The absolute version of the URL minus any dialog/subcontent params.
			// In otherwords the real URL of the content to be loaded.
			fileUrl = this._createFileUrl( absUrl );

			// The version of the Url actually stored in the data-url attribute of
			// the content. For embedded content, it is just the id of the page. For
			// content within the same domain as the document base, it is the site
			// relative path. For cross-domain content (Phone Gap only) the entire
			// absolute Url is used to load the content.
			dataUrl = this._createDataUrl( absUrl );

			content = this._find( absUrl );

			// If it isn't a reference to the first content and refers to missing
			// embedded content reject the deferred and return
			if ( content.length === 0 &&
				$.mobile.path.isEmbeddedPage(fileUrl) &&
				!$.mobile.path.isFirstPageUrl(fileUrl) ) {
				deferred.reject( absUrl, settings );
				return deferred.promise();
			}

			// Reset base to the default document base
			// TODO figure out why we doe this
			this._getBase().reset();

			// If the content we are interested in is already in the DOM,
			// and the caller did not indicate that we should force a
			// reload of the file, we are done. Resolve the deferrred so that
			// users can bind to .done on the promise
			if ( content.length && !settings.reload ) {
				this._enhance( content, settings.role );
				deferred.resolve( absUrl, settings, content );

				//if we are reloading the content make sure we update
				// the base if its not a prefetch
				if ( !settings.prefetch ) {
					this._getBase().set(url);
				}

				return deferred.promise();
			}

			triggerData = {
				url: url,
				absUrl: absUrl,
				toPage: url,
				prevPage: options ? options.fromPage : undefined,
				dataUrl: dataUrl,
				deferred: deferred,
				options: settings
			};

			// Let listeners know we're about to load content.
			pblEvent = this._triggerWithDeprecated( "beforeload", triggerData );

			// If the default behavior is prevented, stop here!
			if ( pblEvent.deprecatedEvent.isDefaultPrevented() ||
				pblEvent.event.isDefaultPrevented() ) {
				return deferred.promise();
			}

			if ( settings.showLoadMsg ) {
				this._showLoading( settings.loadMsgDelay );
			}

			// Reset base to the default document base.
			// only reset if we are not prefetching
			if ( settings.prefetch === undefined ) {
				this._getBase().reset();
			}

			if ( !( $.mobile.allowCrossDomainPages ||
				$.mobile.path.isSameDomain($.mobile.path.documentUrl, absUrl ) ) ) {
				deferred.reject( absUrl, settings );
				return deferred.promise();
			}

			// Load the new content.
			$.ajax({
				url: fileUrl,
				type: settings.type,
				data: settings.data,
				contentType: settings.contentType,
				dataType: "html",
				success: this._loadSuccess( absUrl, triggerData, settings, deferred ),
				error: this._loadError( absUrl, triggerData, settings, deferred )
			});

			return deferred.promise();
		},

		_loadError: function( absUrl, triggerData, settings, deferred ) {
			return $.proxy(function( xhr, textStatus, errorThrown ) {
				//set base back to current path
				this._getBase().set( $.mobile.path.get() );

				// Add error info to our triggerData.
				triggerData.xhr = xhr;
				triggerData.textStatus = textStatus;
				triggerData.errorThrown = errorThrown;

				// Let listeners know the page load failed.
				var plfEvent = this._triggerWithDeprecated( "loadfailed", triggerData );

				// If the default behavior is prevented, stop here!
				// Note that it is the responsibility of the listener/handler
				// that called preventDefault(), to resolve/reject the
				// deferred object within the triggerData.
				if ( plfEvent.deprecatedEvent.isDefaultPrevented() ||
					plfEvent.event.isDefaultPrevented() ) {
					return;
				}

				// Remove loading message.
				if ( settings.showLoadMsg ) {
					this._showError();
				}

				deferred.reject( absUrl, settings );
			}, this);
		},

		_getTransitionHandler: function( transition ) {
			transition = $.mobile._maybeDegradeTransition( transition );

			//find the transition handler for the specified transition. If there
			//isn't one in our transitionHandlers dictionary, use the default one.
			//call the handler immediately to kick-off the transition.
			return $.mobile.transitionHandlers[ transition ] || $.mobile.defaultTransitionHandler;
		},

		// TODO move into transition handlers?
		_triggerCssTransitionEvents: function( to, from, prefix ) {
			var samePage = false;

			prefix = prefix || "";

			// TODO decide if these events should in fact be triggered on the container
			if ( from ) {

				//Check if this is a same page transition and tell the handler in page
				if( to[0] === from[0] ){
					samePage = true;
				}

				//trigger before show/hide events
				// TODO deprecate nextPage in favor of next
				this._triggerWithDeprecated( prefix + "hide", {

					// Deprecated in 1.4 remove in 1.5
					nextPage: to,
					toPage: to,
					prevPage: from,
					samePage: samePage
				}, from );
			}

			// TODO deprecate prevPage in favor of previous
			this._triggerWithDeprecated( prefix + "show", {
				prevPage: from || $( "" ),
				toPage: to
			}, to );
		},

		// TODO make private once change has been defined in the widget
		_cssTransition: function( to, from, options ) {
			var transition = options.transition,
				reverse = options.reverse,
				deferred = options.deferred,
				TransitionHandler,
				promise;

			this._triggerCssTransitionEvents( to, from, "before" );

			// TODO put this in a binding to events *outside* the widget
			this._hideLoading();

			TransitionHandler = this._getTransitionHandler( transition );

			promise = ( new TransitionHandler( transition, reverse, to, from ) ).transition();

			promise.done( $.proxy( function() {
				this._triggerCssTransitionEvents( to, from );
			}, this ));

			// TODO temporary accomodation of argument deferred
			promise.done(function() {
				deferred.resolve.apply( deferred, arguments );
			});
		},

		_releaseTransitionLock: function() {
			//release transition lock so navigation is free again
			isPageTransitioning = false;
			if ( pageTransitionQueue.length > 0 ) {
				$.mobile.changePage.apply( null, pageTransitionQueue.pop() );
			}
		},

		_removeActiveLinkClass: function( force ) {
			//clear out the active button state
			$.mobile.removeActiveLinkClass( force );
		},

		_loadUrl: function( to, triggerData, settings ) {
			// preserve the original target as the dataUrl value will be
			// simplified eg, removing ui-state, and removing query params
			// from the hash this is so that users who want to use query
			// params have access to them in the event bindings for the page
			// life cycle See issue #5085
			settings.target = to;
			settings.deferred = $.Deferred();

			this.load( to, settings );

			settings.deferred.done($.proxy(function( url, options, content ) {
				isPageTransitioning = false;

				// store the original absolute url so that it can be provided
				// to events in the triggerData of the subsequent changePage call
				options.absUrl = triggerData.absUrl;

				this.transition( content, triggerData, options );
			}, this));

			settings.deferred.fail($.proxy(function(/* url, options */) {
				this._removeActiveLinkClass( true );
				this._releaseTransitionLock();
				this._triggerWithDeprecated( "changefailed", triggerData );
			}, this));
		},

		_triggerPageBeforeChange: function( to, triggerData, settings ) {
			var returnEvents;

			triggerData.prevPage = this.activePage;
			$.extend( triggerData, {
				toPage: to,
				options: settings
			});

			// NOTE: preserve the original target as the dataUrl value will be
			// simplified eg, removing ui-state, and removing query params from
			// the hash this is so that users who want to use query params have
			// access to them in the event bindings for the page life cycle
			// See issue #5085
			if ( $.type(to) === "string" ) {
				// if the toPage is a string simply convert it
				triggerData.absUrl = $.mobile.path.makeUrlAbsolute( to, this._findBaseWithDefault() );
			} else {
				// if the toPage is a jQuery object grab the absolute url stored
				// in the loadPage callback where it exists
				triggerData.absUrl = settings.absUrl;
			}

			// Let listeners know we're about to change the current page.
			returnEvents = this._triggerWithDeprecated( "beforechange", triggerData );

			// If the default behavior is prevented, stop here!
			if ( returnEvents.event.isDefaultPrevented() ||
				returnEvents.deprecatedEvent.isDefaultPrevented() ) {
				return false;
			}

			return true;
		},

		change: function( to, options ) {
			// If we are in the midst of a transition, queue the current request.
			// We'll call changePage() once we're done with the current transition
			// to service the request.
			if ( isPageTransitioning ) {
				pageTransitionQueue.unshift( arguments );
				return;
			}

			var settings = $.extend( {}, $.mobile.changePage.defaults, options ),
				triggerData = {};

			// Make sure we have a fromPage.
			settings.fromPage = settings.fromPage || this.activePage;

			// if the page beforechange default is prevented return early
			if ( !this._triggerPageBeforeChange(to, triggerData, settings) ) {
				return;
			}

			// We allow "pagebeforechange" observers to modify the to in
			// the trigger data to allow for redirects. Make sure our to is
			// updated. We also need to re-evaluate whether it is a string,
			// because an object can also be replaced by a string
			to = triggerData.toPage;

			// If the caller passed us a url, call loadPage()
			// to make sure it is loaded into the DOM. We'll listen
			// to the promise object it returns so we know when
			// it is done loading or if an error ocurred.
			if ( $.type(to) === "string" ) {
				// Set the isPageTransitioning flag to prevent any requests from
				// entering this method while we are in the midst of loading a page
				// or transitioning.
				isPageTransitioning = true;

				this._loadUrl( to, triggerData, settings );
			} else {
				this.transition( to, triggerData, settings );
			}
		},

		transition: function( toPage, triggerData, settings ) {
			var fromPage, url, pageUrl, fileUrl,
				active, activeIsInitialPage,
				historyDir, pageTitle, isDialog,
				alreadyThere, newPageTitle,
				params,	cssTransitionDeferred,
				beforeTransition;

			// If we are in the midst of a transition, queue the current request.
			// We'll call changePage() once we're done with the current transition
			// to service the request.
			if ( isPageTransitioning ) {
				// make sure to only queue the to and settings values so the arguments
				// work with a call to the change method
				pageTransitionQueue.unshift( [toPage, settings] );
				return;
			}

			// DEPRECATED - this call only, in favor of the before transition
			// if the page beforechange default is prevented return early
			if ( !this._triggerPageBeforeChange(toPage, triggerData, settings) ) {
				return;
			}

			triggerData.prevPage = settings.fromPage;
			// if the (content|page)beforetransition default is prevented return early
			// Note, we have to check for both the deprecated and new events
			beforeTransition = this._triggerWithDeprecated( "beforetransition", triggerData );
			if (beforeTransition.deprecatedEvent.isDefaultPrevented() ||
				beforeTransition.event.isDefaultPrevented() ) {
				return;
			}

			// Set the isPageTransitioning flag to prevent any requests from
			// entering this method while we are in the midst of loading a page
			// or transitioning.
			isPageTransitioning = true;

			// If we are going to the first-page of the application, we need to make
			// sure settings.dataUrl is set to the application document url. This allows
			// us to avoid generating a document url with an id hash in the case where the
			// first-page of the document has an id attribute specified.
			if ( toPage[ 0 ] === $.mobile.firstPage[ 0 ] && !settings.dataUrl ) {
				settings.dataUrl = $.mobile.path.documentUrl.hrefNoHash;
			}

			// The caller passed us a real page DOM element. Update our
			// internal state and then trigger a transition to the page.
			fromPage = settings.fromPage;
			url = ( settings.dataUrl && $.mobile.path.convertUrlToDataUrl(settings.dataUrl) ) ||
				toPage.jqmData( "url" );

			// The pageUrl var is usually the same as url, except when url is obscured
			// as a dialog url. pageUrl always contains the file path
			pageUrl = url;
			fileUrl = $.mobile.path.getFilePath( url );
			active = $.mobile.navigate.history.getActive();
			activeIsInitialPage = $.mobile.navigate.history.activeIndex === 0;
			historyDir = 0;
			pageTitle = document.title;
			isDialog = ( settings.role === "dialog" ||
				toPage.jqmData( "role" ) === "dialog" ) &&
				toPage.jqmData( "dialog" ) !== true;

			// By default, we prevent changePage requests when the fromPage and toPage
			// are the same element, but folks that generate content
			// manually/dynamically and reuse pages want to be able to transition to
			// the same page. To allow this, they will need to change the default
			// value of allowSamePageTransition to true, *OR*, pass it in as an
			// option when they manually call changePage(). It should be noted that
			// our default transition animations assume that the formPage and toPage
			// are different elements, so they may behave unexpectedly. It is up to
			// the developer that turns on the allowSamePageTransitiona option to
			// either turn off transition animations, or make sure that an appropriate
			// animation transition is used.
			if ( fromPage && fromPage[0] === toPage[0] &&
				!settings.allowSamePageTransition ) {

				isPageTransitioning = false;
				this._triggerWithDeprecated( "transition", triggerData );
				this._triggerWithDeprecated( "change", triggerData );

				// Even if there is no page change to be done, we should keep the
				// urlHistory in sync with the hash changes
				if ( settings.fromHashChange ) {
					$.mobile.navigate.history.direct({ url: url });
				}

				return;
			}

			// We need to make sure the page we are given has already been enhanced.
			toPage.page({ role: settings.role });

			// If the changePage request was sent from a hashChange event, check to
			// see if the page is already within the urlHistory stack. If so, we'll
			// assume the user hit the forward/back button and will try to match the
			// transition accordingly.
			if ( settings.fromHashChange ) {
				historyDir = settings.direction === "back" ? -1 : 1;
			}

			// Kill the keyboard.
			// XXX_jblas: We need to stop crawling the entire document to kill focus.
			//            Instead, we should be tracking focus with a delegate()
			//            handler so we already have the element in hand at this
			//            point.
			// Wrap this in a try/catch block since IE9 throw "Unspecified error" if
			// document.activeElement is undefined when we are in an IFrame.
			try {
				if ( document.activeElement &&
					document.activeElement.nodeName.toLowerCase() !== "body" ) {

					$( document.activeElement ).blur();
				} else {
					$( "input:focus, textarea:focus, select:focus" ).blur();
				}
			} catch( e ) {}

			// Record whether we are at a place in history where a dialog used to be -
			// if so, do not add a new history entry and do not change the hash either
			alreadyThere = false;

			// If we're displaying the page as a dialog, we don't want the url
			// for the dialog content to be used in the hash. Instead, we want
			// to append the dialogHashKey to the url of the current page.
			if ( isDialog && active ) {
				// on the initial page load active.url is undefined and in that case
				// should be an empty string. Moving the undefined -> empty string back
				// into urlHistory.addNew seemed imprudent given undefined better
				// represents the url state

				// If we are at a place in history that once belonged to a dialog, reuse
				// this state without adding to urlHistory and without modifying the
				// hash. However, if a dialog is already displayed at this point, and
				// we're about to display another dialog, then we must add another hash
				// and history entry on top so that one may navigate back to the
				// original dialog
				if ( active.url &&
					active.url.indexOf( $.mobile.dialogHashKey ) > -1 &&
					this.activePage &&
					!this.activePage.hasClass( "ui-dialog" ) &&
					$.mobile.navigate.history.activeIndex > 0 ) {

					settings.changeHash = false;
					alreadyThere = true;
				}

				// Normally, we tack on a dialog hash key, but if this is the location
				// of a stale dialog, we reuse the URL from the entry
				url = ( active.url || "" );

				// account for absolute urls instead of just relative urls use as hashes
				if ( !alreadyThere && url.indexOf("#") > -1 ) {
					url += $.mobile.dialogHashKey;
				} else {
					url += "#" + $.mobile.dialogHashKey;
				}

				// tack on another dialogHashKey if this is the same as the initial hash
				// this makes sure that a history entry is created for this dialog
				if ( $.mobile.navigate.history.activeIndex === 0 && url === $.mobile.navigate.history.initialDst ) {
					url += $.mobile.dialogHashKey;
				}
			}

			// if title element wasn't found, try the page div data attr too
			// If this is a deep-link or a reload ( active === undefined ) then just
			// use pageTitle
			newPageTitle = ( !active ) ? pageTitle : toPage.jqmData( "title" ) ||
				toPage.children( ":jqmData(role='header')" ).find( ".ui-title" ).text();
			if ( !!newPageTitle && pageTitle === document.title ) {
				pageTitle = newPageTitle;
			}
			if ( !toPage.jqmData( "title" ) ) {
				toPage.jqmData( "title", pageTitle );
			}

			// Make sure we have a transition defined.
			settings.transition = settings.transition ||
				( ( historyDir && !activeIsInitialPage ) ? active.transition : undefined ) ||
				( isDialog ? $.mobile.defaultDialogTransition : $.mobile.defaultPageTransition );

			//add page to history stack if it's not back or forward
			if ( !historyDir && alreadyThere ) {
				$.mobile.navigate.history.getActive().pageUrl = pageUrl;
			}

			// Set the location hash.
			if ( url && !settings.fromHashChange ) {

				// rebuilding the hash here since we loose it earlier on
				// TODO preserve the originally passed in path
				if ( !$.mobile.path.isPath( url ) && url.indexOf( "#" ) < 0 ) {
					url = "#" + url;
				}

				// TODO the property names here are just silly
				params = {
					transition: settings.transition,
					title: pageTitle,
					pageUrl: pageUrl,
					role: settings.role
				};

				if ( settings.changeHash !== false && $.mobile.hashListeningEnabled ) {
					$.mobile.navigate( url, params, true);
				} else if ( toPage[ 0 ] !== $.mobile.firstPage[ 0 ] ) {
					$.mobile.navigate.history.add( url, params );
				}
			}

			//set page title
			document.title = pageTitle;

			//set "toPage" as activePage deprecated in 1.4 remove in 1.5
			$.mobile.activePage = toPage;

			//new way to handle activePage
			this.activePage = toPage;

			// If we're navigating back in the URL history, set reverse accordingly.
			settings.reverse = settings.reverse || historyDir < 0;

			cssTransitionDeferred = $.Deferred();

			this._cssTransition(toPage, fromPage, {
				transition: settings.transition,
				reverse: settings.reverse,
				deferred: cssTransitionDeferred
			});

			cssTransitionDeferred.done($.proxy(function( name, reverse, $to, $from, alreadyFocused ) {
				$.mobile.removeActiveLinkClass();

				//if there's a duplicateCachedPage, remove it from the DOM now that it's hidden
				if ( settings.duplicateCachedPage ) {
					settings.duplicateCachedPage.remove();
				}

				// despite visibility: hidden addresses issue #2965
				// https://github.com/jquery/jquery-mobile/issues/2965
				if ( !alreadyFocused ) {
					$.mobile.focusPage( toPage );
				}

				this._releaseTransitionLock();
				this._triggerWithDeprecated( "transition", triggerData );
				this._triggerWithDeprecated( "change", triggerData );
			}, this));
		},

		// determine the current base url
		_findBaseWithDefault: function() {
			var closestBase = ( this.activePage &&
			$.mobile.getClosestBaseUrl( this.activePage ) );
		return closestBase || $.mobile.path.documentBase.hrefNoHash;
		}
	});

	// The following handlers should be bound after mobileinit has been triggered
	// the following deferred is resolved in the init file
	$.mobile.navreadyDeferred = $.Deferred();

	//these variables make all page containers use the same queue and only navigate one at a time
	// queue to hold simultanious page transitions
	var pageTransitionQueue = [],

		// indicates whether or not page is in process of transitioning
		isPageTransitioning = false;

})( jQuery );

(function( $, undefined ) {

		// resolved on domready
	var domreadyDeferred = $.Deferred(),

		// resolved and nulled on window.load()
		loadDeferred = $.Deferred(),

		// function that resolves the above deferred
		pageIsFullyLoaded = function() {

			// Resolve and null the deferred
			loadDeferred.resolve();
			loadDeferred = null;
		},

		documentUrl = $.mobile.path.documentUrl,

		// used to track last vclicked element to make sure its value is added to form data
		$lastVClicked = null;

	/* Event Bindings - hashchange, submit, and click */
	function findClosestLink( ele )	{
		while ( ele ) {
			// Look for the closest element with a nodeName of "a".
			// Note that we are checking if we have a valid nodeName
			// before attempting to access it. This is because the
			// node we get called with could have originated from within
			// an embedded SVG document where some symbol instance elements
			// don't have nodeName defined on them, or strings are of type
			// SVGAnimatedString.
			if ( ( typeof ele.nodeName === "string" ) && ele.nodeName.toLowerCase() === "a" ) {
				break;
			}
			ele = ele.parentNode;
		}
		return ele;
	}

	$.mobile.loadPage = function( url, opts ) {
		var container;

		opts = opts || {};
		container = ( opts.pageContainer || $.mobile.pageContainer );

		// create the deferred that will be supplied to loadPage callers
		// and resolved by the content widget's load method
		opts.deferred = $.Deferred();

		// Preferring to allow exceptions for uninitialized opts.pageContainer
		// widgets so we know if we need to force init here for users
		container.pagecontainer( "load", url, opts );

		// provide the deferred
		return opts.deferred.promise();
	};

	//define vars for interal use

	/* internal utility functions */

	// NOTE Issue #4950 Android phonegap doesn't navigate back properly
	//      when a full page refresh has taken place. It appears that hashchange
	//      and replacestate history alterations work fine but we need to support
	//      both forms of history traversal in our code that uses backward history
	//      movement
	$.mobile.back = function() {
		var nav = window.navigator;

		// if the setting is on and the navigator object is
		// available use the phonegap navigation capability
		if ( this.phonegapNavigationEnabled &&
			nav &&
			nav.app &&
			nav.app.backHistory ) {
			nav.app.backHistory();
		} else {
			$.mobile.pageContainer.pagecontainer( "back" );
		}
	};

	// Direct focus to the page title, or otherwise first focusable element
	$.mobile.focusPage = function ( page ) {
		var autofocus = page.find( "[autofocus]" ),
			pageTitle = page.find( ".ui-title:eq(0)" );

		if ( autofocus.length ) {
			autofocus.focus();
			return;
		}

		if ( pageTitle.length ) {
			pageTitle.focus();
		} else{
			page.focus();
		}
	};

	// No-op implementation of transition degradation
	$.mobile._maybeDegradeTransition = $.mobile._maybeDegradeTransition || function( transition ) {
		return transition;
	};

	// Exposed $.mobile methods

	$.mobile.changePage = function( to, options ) {
		$.mobile.pageContainer.pagecontainer( "change", to, options );
	};

	$.mobile.changePage.defaults = {
		transition: undefined,
		reverse: false,
		changeHash: true,
		fromHashChange: false,
		role: undefined, // By default we rely on the role defined by the @data-role attribute.
		duplicateCachedPage: undefined,
		pageContainer: undefined,
		showLoadMsg: true, //loading message shows by default when pages are being fetched during changePage
		dataUrl: undefined,
		fromPage: undefined,
		allowSamePageTransition: false
	};

	$.mobile._registerInternalEvents = function() {
		var getAjaxFormData = function( $form, calculateOnly ) {
			var url, ret = true, formData, vclickedName, method;
			if ( !$.mobile.ajaxEnabled ||
					// test that the form is, itself, ajax false
					$form.is( ":jqmData(ajax='false')" ) ||
					// test that $.mobile.ignoreContentEnabled is set and
					// the form or one of it's parents is ajax=false
					!$form.jqmHijackable().length ||
					$form.attr( "target" ) ) {
				return false;
			}

			url = ( $lastVClicked && $lastVClicked.attr( "formaction" ) ) ||
				$form.attr( "action" );
			method = ( $form.attr( "method" ) || "get" ).toLowerCase();

			// If no action is specified, browsers default to using the
			// URL of the document containing the form. Since we dynamically
			// pull in pages from external documents, the form should submit
			// to the URL for the source document of the page containing
			// the form.
			if ( !url ) {
				// Get the @data-url for the page containing the form.
				url = $.mobile.getClosestBaseUrl( $form );

				// NOTE: If the method is "get", we need to strip off the query string
				// because it will get replaced with the new form data. See issue #5710.
				if ( method === "get" ) {
					url = $.mobile.path.parseUrl( url ).hrefNoSearch;
				}

				if ( url === $.mobile.path.documentBase.hrefNoHash ) {
					// The url we got back matches the document base,
					// which means the page must be an internal/embedded page,
					// so default to using the actual document url as a browser
					// would.
					url = documentUrl.hrefNoSearch;
				}
			}

			url = $.mobile.path.makeUrlAbsolute(  url, $.mobile.getClosestBaseUrl( $form ) );

			if ( ( $.mobile.path.isExternal( url ) && !$.mobile.path.isPermittedCrossDomainRequest( documentUrl, url ) ) ) {
				return false;
			}

			if ( !calculateOnly ) {
				formData = $form.serializeArray();

				if ( $lastVClicked && $lastVClicked[ 0 ].form === $form[ 0 ] ) {
					vclickedName = $lastVClicked.attr( "name" );
					if ( vclickedName ) {
						// Make sure the last clicked element is included in the form
						$.each( formData, function( key, value ) {
							if ( value.name === vclickedName ) {
								// Unset vclickedName - we've found it in the serialized data already
								vclickedName = "";
								return false;
							}
						});
						if ( vclickedName ) {
							formData.push( { name: vclickedName, value: $lastVClicked.attr( "value" ) } );
						}
					}
				}

				ret = {
					url: url,
					options: {
						type:		method,
						data:		$.param( formData ),
						transition:	$form.jqmData( "transition" ),
						reverse:	$form.jqmData( "direction" ) === "reverse",
						reloadPage:	true
					}
				};
			}

			return ret;
		};

		//bind to form submit events, handle with Ajax
		$.mobile.document.delegate( "form", "submit", function( event ) {
			var formData;

			if ( !event.isDefaultPrevented() ) {
				formData = getAjaxFormData( $( this ) );
				if ( formData ) {
					$.mobile.changePage( formData.url, formData.options );
					event.preventDefault();
				}
			}
		});

		//add active state on vclick
		$.mobile.document.bind( "vclick", function( event ) {
			var $btn, btnEls, target = event.target, needClosest = false;
			// if this isn't a left click we don't care. Its important to note
			// that when the virtual event is generated it will create the which attr
			if ( event.which > 1 || !$.mobile.linkBindingEnabled ) {
				return;
			}

			// Record that this element was clicked, in case we need it for correct
			// form submission during the "submit" handler above
			$lastVClicked = $( target );

			// Try to find a target element to which the active class will be applied
			if ( $.data( target, "mobile-button" ) ) {
				// If the form will not be submitted via AJAX, do not add active class
				if ( !getAjaxFormData( $( target ).closest( "form" ), true ) ) {
					return;
				}
				// We will apply the active state to this button widget - the parent
				// of the input that was clicked will have the associated data
				if ( target.parentNode ) {
					target = target.parentNode;
				}
			} else {
				target = findClosestLink( target );
				if ( !( target && $.mobile.path.parseUrl( target.getAttribute( "href" ) || "#" ).hash !== "#" ) ) {
					return;
				}

				// TODO teach $.mobile.hijackable to operate on raw dom elements so the
				// link wrapping can be avoided
				if ( !$( target ).jqmHijackable().length ) {
					return;
				}
			}

			// Avoid calling .closest by using the data set during .buttonMarkup()
			// List items have the button data in the parent of the element clicked
			if ( !!~target.className.indexOf( "ui-link-inherit" ) ) {
				if ( target.parentNode ) {
					btnEls = $.data( target.parentNode, "buttonElements" );
				}
			// Otherwise, look for the data on the target itself
			} else {
				btnEls = $.data( target, "buttonElements" );
			}
			// If found, grab the button's outer element
			if ( btnEls ) {
				target = btnEls.outer;
			} else {
				needClosest = true;
			}

			$btn = $( target );
			// If the outer element wasn't found by the our heuristics, use .closest()
			if ( needClosest ) {
				$btn = $btn.closest( ".ui-btn" );
			}

			if ( $btn.length > 0 &&
				!( $btn.hasClass( "ui-state-disabled" ||

					// DEPRECATED as of 1.4.0 - remove after 1.4.0 release
					// only ui-state-disabled should be present thereafter
					$btn.hasClass( "ui-disabled" ) ) ) ) {
				$.mobile.removeActiveLinkClass( true );
				$.mobile.activeClickedLink = $btn;
				$.mobile.activeClickedLink.addClass( $.mobile.activeBtnClass );
			}
		});

		// click routing - direct to HTTP or Ajax, accordingly
		$.mobile.document.bind( "click", function( event ) {
			if ( !$.mobile.linkBindingEnabled || event.isDefaultPrevented() ) {
				return;
			}

			var link = findClosestLink( event.target ),
				$link = $( link ),

				//remove active link class if external (then it won't be there if you come back)
				httpCleanup = function() {
					window.setTimeout(function() { $.mobile.removeActiveLinkClass( true ); }, 200 );
				},
				baseUrl, href,
				useDefaultUrlHandling, isExternal,
				transition, reverse, role;

			// If a button was clicked, clean up the active class added by vclick above
			if ( $.mobile.activeClickedLink &&
				$.mobile.activeClickedLink[ 0 ] === event.target.parentNode ) {
				httpCleanup();
			}

			// If there is no link associated with the click or its not a left
			// click we want to ignore the click
			// TODO teach $.mobile.hijackable to operate on raw dom elements so the link wrapping
			// can be avoided
			if ( !link || event.which > 1 || !$link.jqmHijackable().length ) {
				return;
			}

			//if there's a data-rel=back attr, go back in history
			if ( $link.is( ":jqmData(rel='back')" ) ) {
				$.mobile.back();
				return false;
			}

			baseUrl = $.mobile.getClosestBaseUrl( $link );

			//get href, if defined, otherwise default to empty hash
			href = $.mobile.path.makeUrlAbsolute( $link.attr( "href" ) || "#", baseUrl );

			//if ajax is disabled, exit early
			if ( !$.mobile.ajaxEnabled && !$.mobile.path.isEmbeddedPage( href ) ) {
				httpCleanup();
				//use default click handling
				return;
			}

			// XXX_jblas: Ideally links to application pages should be specified as
			//            an url to the application document with a hash that is either
			//            the site relative path or id to the page. But some of the
			//            internal code that dynamically generates sub-pages for nested
			//            lists and select dialogs, just write a hash in the link they
			//            create. This means the actual URL path is based on whatever
			//            the current value of the base tag is at the time this code
			//            is called. For now we are just assuming that any url with a
			//            hash in it is an application page reference.
			if ( href.search( "#" ) !== -1 ) {
				href = href.replace( /[^#]*#/, "" );
				if ( !href ) {
					//link was an empty hash meant purely
					//for interaction, so we ignore it.
					event.preventDefault();
					return;
				} else if ( $.mobile.path.isPath( href ) ) {
					//we have apath so make it the href we want to load.
					href = $.mobile.path.makeUrlAbsolute( href, baseUrl );
				} else {
					//we have a simple id so use the documentUrl as its base.
					href = $.mobile.path.makeUrlAbsolute( "#" + href, documentUrl.hrefNoHash );
				}
			}

			// Should we handle this link, or let the browser deal with it?
			useDefaultUrlHandling = $link.is( "[rel='external']" ) || $link.is( ":jqmData(ajax='false')" ) || $link.is( "[target]" );

			// Some embedded browsers, like the web view in Phone Gap, allow cross-domain XHR
			// requests if the document doing the request was loaded via the file:// protocol.
			// This is usually to allow the application to "phone home" and fetch app specific
			// data. We normally let the browser handle external/cross-domain urls, but if the
			// allowCrossDomainPages option is true, we will allow cross-domain http/https
			// requests to go through our page loading logic.

			//check for protocol or rel and its not an embedded page
			//TODO overlap in logic from isExternal, rel=external check should be
			//     moved into more comprehensive isExternalLink
			isExternal = useDefaultUrlHandling || ( $.mobile.path.isExternal( href ) && !$.mobile.path.isPermittedCrossDomainRequest( documentUrl, href ) );

			if ( isExternal ) {
				httpCleanup();
				//use default click handling
				return;
			}

			//use ajax
			transition = $link.jqmData( "transition" );
			reverse = $link.jqmData( "direction" ) === "reverse" ||
						// deprecated - remove by 1.0
						$link.jqmData( "back" );

			//this may need to be more specific as we use data-rel more
			role = $link.attr( "data-" + $.mobile.ns + "rel" ) || undefined;

			$.mobile.changePage( href, { transition: transition, reverse: reverse, role: role, link: $link } );
			event.preventDefault();
		});

		//prefetch pages when anchors with data-prefetch are encountered
		$.mobile.document.delegate( ".ui-page", "pageshow.prefetch", function() {
			var urls = [];
			$( this ).find( "a:jqmData(prefetch)" ).each(function() {
				var $link = $( this ),
					url = $link.attr( "href" );

				if ( url && $.inArray( url, urls ) === -1 ) {
					urls.push( url );

					$.mobile.loadPage( url, { role: $link.attr( "data-" + $.mobile.ns + "rel" ),prefetch: true } );
				}
			});
		});

		// TODO ensure that the navigate binding in the content widget happens at the right time
		$.mobile.pageContainer.pagecontainer();

		//set page min-heights to be device specific
		$.mobile.document.bind( "pageshow", function() {

			// We need to wait for window.load to make sure that styles have already been rendered,
			// otherwise heights of external toolbars will have the wrong value
			if ( loadDeferred ) {
				loadDeferred.done( $.mobile.resetActivePageHeight );
			} else {
				$.mobile.resetActivePageHeight();
			}
		});
		$.mobile.window.bind( "throttledresize", $.mobile.resetActivePageHeight );

	};//navreadyDeferred done callback

	$( function() { domreadyDeferred.resolve(); } );

	// Account for the possibility that the load event has already fired
	if ( document.readyState === "complete" ) {
		pageIsFullyLoaded();
	} else {
		$.mobile.window.load( pageIsFullyLoaded );
	}

	$.when( domreadyDeferred, $.mobile.navreadyDeferred ).done( function() { $.mobile._registerInternalEvents(); } );
})( jQuery );


(function( $, window, undefined ) {

	// TODO remove direct references to $.mobile and properties, we should
	//      favor injection with params to the constructor
	$.mobile.Transition = function() {
		this.init.apply( this, arguments );
	};

	$.extend($.mobile.Transition.prototype, {
		toPreClass: " ui-page-pre-in",

		init: function( name, reverse, $to, $from ) {
			$.extend(this, {
				name: name,
				reverse: reverse,
				$to: $to,
				$from: $from,
				deferred: new $.Deferred()
			});
		},

		cleanFrom: function() {
			this.$from
				.removeClass( $.mobile.activePageClass + " out in reverse " + this.name )
				.height( "" );
		},

		// NOTE overridden by child object prototypes, noop'd here as defaults
		beforeDoneIn: function() {},
		beforeDoneOut: function() {},
		beforeStartOut: function() {},

		doneIn: function() {
			this.beforeDoneIn();

			this.$to.removeClass( "out in reverse " + this.name ).height( "" );

			this.toggleViewportClass();

			// In some browsers (iOS5), 3D transitions block the ability to scroll to the desired location during transition
			// This ensures we jump to that spot after the fact, if we aren't there already.
			if ( $.mobile.window.scrollTop() !== this.toScroll ) {
				this.scrollPage();
			}
			if ( !this.sequential ) {
				this.$to.addClass( $.mobile.activePageClass );
			}
			this.deferred.resolve( this.name, this.reverse, this.$to, this.$from, true );
		},

		doneOut: function( screenHeight, reverseClass, none, preventFocus ) {
			this.beforeDoneOut();
			this.startIn( screenHeight, reverseClass, none, preventFocus );
		},

		hideIn: function( callback ) {
			// Prevent flickering in phonegap container: see comments at #4024 regarding iOS
			this.$to.css( "z-index", -10 );
			callback.call( this );
			this.$to.css( "z-index", "" );
		},

		scrollPage: function() {
			// By using scrollTo instead of silentScroll, we can keep things better in order
			// Just to be precautios, disable scrollstart listening like silentScroll would
			$.event.special.scrollstart.enabled = false;
			//if we are hiding the url bar or the page was previously scrolled scroll to hide or return to position
			if ( $.mobile.hideUrlBar || this.toScroll !== $.mobile.defaultHomeScroll ) {
				window.scrollTo( 0, this.toScroll );
			}

			// reenable scrollstart listening like silentScroll would
			setTimeout( function() {
				$.event.special.scrollstart.enabled = true;
			}, 150 );
		},

		startIn: function( screenHeight, reverseClass, none, preventFocus ) {
			this.hideIn(function() {
				this.$to.addClass( $.mobile.activePageClass + this.toPreClass );

				// Send focus to page as it is now display: block
				if ( !preventFocus ) {
					$.mobile.focusPage( this.$to );
				}

				// Set to page height
				this.$to.height( screenHeight + this.toScroll );

                if ( !none ) {
                    this.scrollPage();
                }
			});

			this.$to
				.removeClass( this.toPreClass )
				.addClass( this.name + " in " + reverseClass );

			if ( !none ) {
				this.$to.animationComplete( $.proxy(function() {
					this.doneIn();
				}, this ));
			} else {
				this.doneIn();
			}

		},

		startOut: function( screenHeight, reverseClass, none ) {
			this.beforeStartOut( screenHeight, reverseClass, none );

			// Set the from page's height and start it transitioning out
			// Note: setting an explicit height helps eliminate tiling in the transitions
			this.$from
				.height( screenHeight + $.mobile.window.scrollTop() )
				.addClass( this.name + " out" + reverseClass );
		},

		toggleViewportClass: function() {
			$.mobile.pageContainer.toggleClass( "ui-mobile-viewport-transitioning viewport-" + this.name );
		},

		transition: function() {
			// NOTE many of these could be calculated/recorded in the constructor, it's my
			//      opinion that binding them as late as possible has value with regards to
			//      better transitions with fewer bugs. Ie, it's not guaranteed that the
			//      object will be created and transition will be run immediately after as
			//      it is today. So we wait until transition is invoked to gather the following
			var none,
				reverseClass = this.reverse ? " reverse" : "",
				screenHeight = $.mobile.getScreenHeight(),
				maxTransitionOverride = $.mobile.maxTransitionWidth !== false &&
					$.mobile.window.width() > $.mobile.maxTransitionWidth;

			this.toScroll = $.mobile.navigate.history.getActive().lastScroll || $.mobile.defaultHomeScroll;

			none = !$.support.cssTransitions || !$.support.cssAnimations ||
				maxTransitionOverride || !this.name || this.name === "none" ||
				Math.max( $.mobile.window.scrollTop(), this.toScroll ) >
					$.mobile.getMaxScrollForTransition();

			this.toggleViewportClass();

			if ( this.$from && !none ) {
				this.startOut( screenHeight, reverseClass, none );
			} else {
				this.doneOut( screenHeight, reverseClass, none, true );
			}

			return this.deferred.promise();
		}
	});
})( jQuery, this );


(function( $ ) {

	$.mobile.SerialTransition = function() {
		this.init.apply(this, arguments);
	};

	$.extend($.mobile.SerialTransition.prototype, $.mobile.Transition.prototype, {
		sequential: true,

		beforeDoneOut: function() {
			if ( this.$from ) {
				this.cleanFrom();
			}
		},

		beforeStartOut: function( screenHeight, reverseClass, none ) {
			this.$from.animationComplete($.proxy(function() {
				this.doneOut( screenHeight, reverseClass, none );
			}, this ));
		}
	});

})( jQuery );


(function( $ ) {

	$.mobile.ConcurrentTransition = function() {
		this.init.apply(this, arguments);
	};

	$.extend($.mobile.ConcurrentTransition.prototype, $.mobile.Transition.prototype, {
		sequential: false,

		beforeDoneIn: function() {
			if ( this.$from ) {
				this.cleanFrom();
			}
		},

		beforeStartOut: function( screenHeight, reverseClass, none ) {
			this.doneOut( screenHeight, reverseClass, none );
		}
	});

})( jQuery );


(function( $ ) {

	// generate the handlers from the above
	var defaultGetMaxScrollForTransition = function() {
		return $.mobile.getScreenHeight() * 3;
	};

	//transition handler dictionary for 3rd party transitions
	$.mobile.transitionHandlers = {
		"sequential": $.mobile.SerialTransition,
		"simultaneous": $.mobile.ConcurrentTransition
	};

	// Make our transition handler the public default.
	$.mobile.defaultTransitionHandler = $.mobile.transitionHandlers.sequential;

	$.mobile.transitionFallbacks = {};

	// If transition is defined, check if css 3D transforms are supported, and if not, if a fallback is specified
	$.mobile._maybeDegradeTransition = function( transition ) {
		if ( transition && !$.support.cssTransform3d && $.mobile.transitionFallbacks[ transition ] ) {
			transition = $.mobile.transitionFallbacks[ transition ];
		}

		return transition;
	};

	// Set the getMaxScrollForTransition to default if no implementation was set by user
	$.mobile.getMaxScrollForTransition = $.mobile.getMaxScrollForTransition || defaultGetMaxScrollForTransition;

})( jQuery );

/*
* fallback transition for flip in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.flip = "fade";

})( jQuery, this );

/*
* fallback transition for flow in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.flow = "fade";

})( jQuery, this );

/*
* fallback transition for pop in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.pop = "fade";

})( jQuery, this );

/*
* fallback transition for slide in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

// Use the simultaneous transitions handler for slide transitions
$.mobile.transitionHandlers.slide = $.mobile.transitionHandlers.simultaneous;

// Set the slide transitions's fallback to "fade"
$.mobile.transitionFallbacks.slide = "fade";

})( jQuery, this );

/*
* fallback transition for slidedown in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.slidedown = "fade";

})( jQuery, this );

/*
* fallback transition for slidefade in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

// Set the slide transitions's fallback to "fade"
$.mobile.transitionFallbacks.slidefade = "fade";

})( jQuery, this );

/*
* fallback transition for slideup in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.slideup = "fade";

})( jQuery, this );

/*
* fallback transition for turn in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.turn = "fade";

})( jQuery, this );


(function( $, undefined ) {

$.mobile.degradeInputs = {
	color: false,
	date: false,
	datetime: false,
	"datetime-local": false,
	email: false,
	month: false,
	number: false,
	range: "number",
	search: "text",
	tel: false,
	time: false,
	url: false,
	week: false
};
// Backcompat remove in 1.5
$.mobile.page.prototype.options.degradeInputs = $.mobile.degradeInputs;

// Auto self-init widgets
$.mobile.degradeInputsWithin = function( target ) {

	target = $( target );

	// Degrade inputs to avoid poorly implemented native functionality
	target.find( "input" ).not( $.mobile.page.prototype.keepNativeSelector() ).each(function() {
		var element = $( this ),
			type = this.getAttribute( "type" ),
			optType = $.mobile.degradeInputs[ type ] || "text",
			html, hasType, findstr, repstr;

		if ( $.mobile.degradeInputs[ type ] ) {
			html = $( "<div>" ).html( element.clone() ).html();
			// In IE browsers, the type sometimes doesn't exist in the cloned markup, so we replace the closing tag instead
			hasType = html.indexOf( " type=" ) > -1;
			findstr = hasType ? /\s+type=["']?\w+['"]?/ : /\/?>/;
			repstr = " type=\"" + optType + "\" data-" + $.mobile.ns + "type=\"" + type + "\"" + ( hasType ? "" : ">" );

			element.replaceWith( html.replace( findstr, repstr ) );
		}
	});

};

})( jQuery );

(function( $, window, undefined ) {

$.widget( "mobile.page", $.mobile.page, {
	options: {

		// Accepts left, right and none
		closeBtn: "left",
		closeBtnText: "Close",
		overlayTheme: "a",
		corners: true,
		dialog: false
	},

	_create: function() {
		this._super();
		if ( this.options.dialog ) {

			$.extend( this, {
				_inner: this.element.children(),
				_headerCloseButton: null
			});

			if ( !this.options.enhanced ) {
				this._setCloseBtn( this.options.closeBtn );
			}
		}
	},

	_enhance: function() {
		this._super();

		// Class the markup for dialog styling and wrap interior
		if ( this.options.dialog ) {
			this.element.addClass( "ui-dialog" )
				.wrapInner( $( "<div/>", {

					// ARIA role
					"role" : "dialog",
					"class" : "ui-dialog-contain ui-overlay-shadow" +
						( this.options.corners ? " ui-corner-all" : "" )
				}));
		}
	},

	_setOptions: function( options ) {
		var closeButtonLocation, closeButtonText,
			currentOpts = this.options;

		if ( options.corners !== undefined ) {
			this._inner.toggleClass( "ui-corner-all", !!options.corners );
		}

		if ( options.overlayTheme !== undefined ) {
			if ( $.mobile.activePage[ 0 ] === this.element[ 0 ] ) {
				currentOpts.overlayTheme = options.overlayTheme;
				this._handlePageBeforeShow();
			}
		}

		if ( options.closeBtnText !== undefined ) {
			closeButtonLocation = currentOpts.closeBtn;
			closeButtonText = options.closeBtnText;
		}

		if ( options.closeBtn !== undefined ) {
			closeButtonLocation = options.closeBtn;
		}

		if ( closeButtonLocation ) {
			this._setCloseBtn( closeButtonLocation, closeButtonText );
		}

		this._super( options );
	},

	_handlePageBeforeShow: function () {
		if ( this.options.overlayTheme && this.options.dialog ) {
			this.removeContainerBackground();
			this.setContainerBackground( this.options.overlayTheme );
		} else {
			this._super();
		}
	},

	_setCloseBtn: function( location, text ) {
		var dst,
			btn = this._headerCloseButton;

		// Sanitize value
		location = "left" === location ? "left" : "right" === location ? "right" : "none";

		if ( "none" === location ) {
			if ( btn ) {
				btn.remove();
				btn = null;
			}
		} else if ( btn ) {
			btn.removeClass( "ui-btn-left ui-btn-right" ).addClass( "ui-btn-" + location );
			if ( text ) {
				btn.text( text );
			}
		} else {
			dst = this._inner.find( ":jqmData(role='header')" ).first();
			btn = $( "<a></a>", {
					"href": "#",
					"class": "ui-btn ui-corner-all ui-icon-delete ui-btn-icon-notext ui-btn-" + location
				})
				.attr( "data-" + $.mobile.ns + "rel", "back" )
				.text( text || this.options.closeBtnText || "" )
				.prependTo( dst );
		}

		this._headerCloseButton = btn;
	}
});

})( jQuery, this );

(function( $, window, undefined ) {

$.widget( "mobile.dialog", {
	options: {

		// Accepts left, right and none
		closeBtn: "left",
		closeBtnText: "Close",
		overlayTheme: "a",
		corners: true
	},

	// Override the theme set by the page plugin on pageshow
	_handlePageBeforeShow: function() {
		this._isCloseable = true;
		if ( this.options.overlayTheme ) {
			this.element
				.page( "removeContainerBackground" )
				.page( "setContainerBackground", this.options.overlayTheme );
		}
	},

	_handlePageBeforeHide: function() {
		this._isCloseable = false;
	},

	// click and submit events:
	// - clicks and submits should use the closing transition that the dialog
	//   opened with unless a data-transition is specified on the link/form
	// - if the click was on the close button, or the link has a data-rel="back"
	//   it'll go back in history naturally
	_handleVClickSubmit: function( event ) {
		var attrs,
			$target = $( event.target ).closest( event.type === "vclick" ? "a" : "form" );

		if ( $target.length && !$target.jqmData( "transition" ) ) {
			attrs = {};
			attrs[ "data-" + $.mobile.ns + "transition" ] =
				( $.mobile.navigate.history.getActive() || {} )[ "transition" ] ||
				$.mobile.defaultDialogTransition;
			attrs[ "data-" + $.mobile.ns + "direction" ] = "reverse";
			$target.attr( attrs );
		}
	},

	_create: function() {
		var elem = this.element,
			opts = this.options;

		// Class the markup for dialog styling and wrap interior
		elem.addClass( "ui-dialog" )
			.wrapInner( $( "<div/>", {

				// ARIA role
				"role" : "dialog",
				"class" : "ui-dialog-contain ui-overlay-shadow" +
					( !!opts.corners ? " ui-corner-all" : "" )
			}));

		$.extend( this, {
			_isCloseable: false,
			_inner: elem.children(),
			_headerCloseButton: null
		});

		this._on( elem, {
			vclick: "_handleVClickSubmit",
			submit: "_handleVClickSubmit",
			pagebeforeshow: "_handlePageBeforeShow",
			pagebeforehide: "_handlePageBeforeHide"
		});

		this._setCloseBtn( opts.closeBtn );
	},

	_setOptions: function( options ) {
		var closeButtonLocation, closeButtonText,
			currentOpts = this.options;

		if ( options.corners !== undefined ) {
			this._inner.toggleClass( "ui-corner-all", !!options.corners );
		}

		if ( options.overlayTheme !== undefined ) {
			if ( $.mobile.activePage[ 0 ] === this.element[ 0 ] ) {
				currentOpts.overlayTheme = options.overlayTheme;
				this._handlePageBeforeShow();
			}
		}

		if ( options.closeBtnText !== undefined ) {
			closeButtonLocation = currentOpts.closeBtn;
			closeButtonText = options.closeBtnText;
		}

		if ( options.closeBtn !== undefined ) {
			closeButtonLocation = options.closeBtn;
		}

		if ( closeButtonLocation ) {
			this._setCloseBtn( closeButtonLocation, closeButtonText );
		}

		this._super( options );
	},

	_setCloseBtn: function( location, text ) {
		var dst,
			btn = this._headerCloseButton;

		// Sanitize value
		location = "left" === location ? "left" : "right" === location ? "right" : "none";

		if ( "none" === location ) {
			if ( btn ) {
				btn.remove();
				btn = null;
			}
		} else if ( btn ) {
			btn.removeClass( "ui-btn-left ui-btn-right" ).addClass( "ui-btn-" + location );
			if ( text ) {
				btn.text( text );
			}
		} else {
			dst = this._inner.find( ":jqmData(role='header')" ).first();
			btn = $( "<a></a>", {
					"role": "button",
					"href": "#",
					"class": "ui-btn ui-corner-all ui-icon-delete ui-btn-icon-notext ui-btn-" + location
				})
				.text( text || this.options.closeBtnText || "" )
				.prependTo( dst );
			this._on( btn, { click: "close" } );
		}

		this._headerCloseButton = btn;
	},

	// Close method goes back in history
	close: function() {
		var hist = $.mobile.navigate.history;

		if ( this._isCloseable ) {
			this._isCloseable = false;
			// If the hash listening is enabled and there is at least one preceding history
			// entry it's ok to go back. Initial pages with the dialog hash state are an example
			// where the stack check is necessary
			if ( $.mobile.hashListeningEnabled && hist.activeIndex > 0 ) {
				$.mobile.back();
			} else {
				$.mobile.pageContainer.pagecontainer( "back" );
			}
		}
	}
});

})( jQuery, this );

(function( $, undefined ) {

var rInitialLetter = /([A-Z])/g,

	// Construct iconpos class from iconpos value
	iconposClass = function( iconpos ) {
		return ( "ui-btn-icon-" + ( iconpos === null ? "left" : iconpos ) );
	};

$.widget( "mobile.collapsible", {
	options: {
		enhanced: false,
		expandCueText: null,
		collapseCueText: null,
		collapsed: true,
		heading: "h1,h2,h3,h4,h5,h6,legend",
		collapsedIcon: null,
		expandedIcon: null,
		iconpos: null,
		theme: null,
		contentTheme: null,
		inset: null,
		corners: null,
		mini: null
	},

	_create: function() {
		var elem = this.element,
			ui = {
				accordion: elem
					.closest( ":jqmData(role='collapsible-set')," +
						":jqmData(role='collapsibleset')" +
						( $.mobile.collapsibleset ? ", :mobile-collapsibleset" :
							"" ) )
					.addClass( "ui-collapsible-set" )
			};

		this._ui = ui;
		this._renderedOptions = this._getOptions( this.options );

		if ( this.options.enhanced ) {
			ui.heading = $( ".ui-collapsible-heading", this.element[ 0 ] );
			ui.content = ui.heading.next();
			ui.anchor = $( "a", ui.heading[ 0 ] ).first();
			ui.status = ui.anchor.children( ".ui-collapsible-heading-status" );
		} else {
			this._enhance( elem, ui );
		}

		this._on( ui.heading, {
			"tap": function() {
				ui.heading.find( "a" ).first().addClass( $.mobile.activeBtnClass );
			},

			"click": function( event ) {
				this._handleExpandCollapse( !ui.heading.hasClass( "ui-collapsible-heading-collapsed" ) );
				event.preventDefault();
				event.stopPropagation();
			}
		});
	},

	// Adjust the keys inside options for inherited values
	_getOptions: function( options ) {
		var key,
			accordion = this._ui.accordion,
			accordionWidget = this._ui.accordionWidget;

		// Copy options
		options = $.extend( {}, options );

		if ( accordion.length && !accordionWidget ) {
			this._ui.accordionWidget =
			accordionWidget = accordion.data( "mobile-collapsibleset" );
		}

		for ( key in options ) {

			// Retrieve the option value first from the options object passed in and, if
			// null, from the parent accordion or, if that's null too, or if there's no
			// parent accordion, then from the defaults.
			options[ key ] =
				( options[ key ] != null ) ? options[ key ] :
				( accordionWidget ) ? accordionWidget.options[ key ] :
				accordion.length ? $.mobile.getAttribute( accordion[ 0 ],
					key.replace( rInitialLetter, "-$1" ).toLowerCase() ):
				null;

			if ( null == options[ key ] ) {
				options[ key ] = $.mobile.collapsible.defaults[ key ];
			}
		}

		return options;
	},

	_themeClassFromOption: function( prefix, value ) {
		return ( value ? ( value === "none" ? "" : prefix + value ) : "" );
	},

	_enhance: function( elem, ui ) {
		var iconclass,
			opts = this._renderedOptions,
			contentThemeClass = this._themeClassFromOption( "ui-body-", opts.contentTheme );

		elem.addClass( "ui-collapsible " +
			( opts.inset ? "ui-collapsible-inset " : "" ) +
			( opts.inset && opts.corners ? "ui-corner-all " : "" ) +
			( contentThemeClass ? "ui-collapsible-themed-content " : "" ) );
		ui.originalHeading = elem.children( this.options.heading ).first(),
		ui.content = elem
			.wrapInner( "<div " +
				"class='ui-collapsible-content " +
				contentThemeClass + "'></div>" )
			.children( ".ui-collapsible-content" ),
		ui.heading = ui.originalHeading;

		// Replace collapsibleHeading if it's a legend
		if ( ui.heading.is( "legend" ) ) {
			ui.heading = $( "<div role='heading'>"+ ui.heading.html() +"</div>" );
			ui.placeholder = $( "<div><!-- placeholder for legend --></div>" ).insertBefore( ui.originalHeading );
			ui.originalHeading.remove();
		}

		iconclass = ( opts.collapsed ? ( opts.collapsedIcon ? "ui-icon-" + opts.collapsedIcon : "" ):
			( opts.expandedIcon ? "ui-icon-" + opts.expandedIcon : "" ) );

		ui.status = $( "<span class='ui-collapsible-heading-status'></span>" );
		ui.anchor = ui.heading
			.detach()
			//modify markup & attributes
			.addClass( "ui-collapsible-heading" )
			.append( ui.status )
			.wrapInner( "<a href='#' class='ui-collapsible-heading-toggle'></a>" )
			.find( "a" )
				.first()
				.addClass( "ui-btn " +
					( iconclass ? iconclass + " " : "" ) +
					( iconclass ? iconposClass( opts.iconpos ) +
						" " : "" ) +
					this._themeClassFromOption( "ui-btn-", opts.theme ) + " " +
					( opts.mini ? "ui-mini " : "" ) );

		//drop heading in before content
		ui.heading.insertBefore( ui.content );

		this._handleExpandCollapse( this.options.collapsed );

		return ui;
	},

	refresh: function() {
		this._applyOptions( this.options );
		this._renderedOptions = this._getOptions( this.options );
	},

	_applyOptions: function( options ) {
		var isCollapsed, newTheme, oldTheme, hasCorners, hasIcon,
			elem = this.element,
			currentOpts = this._renderedOptions,
			ui = this._ui,
			anchor = ui.anchor,
			status = ui.status,
			opts = this._getOptions( options );

		// First and foremost we need to make sure the collapsible is in the proper
		// state, in case somebody decided to change the collapsed option at the
		// same time as another option
		if ( options.collapsed !== undefined ) {
			this._handleExpandCollapse( options.collapsed );
		}

		isCollapsed = elem.hasClass( "ui-collapsible-collapsed" );

		// We only need to apply the cue text for the current state right away.
		// The cue text for the alternate state will be stored in the options
		// and applied the next time the collapsible's state is toggled
		if ( isCollapsed ) {
			if ( opts.expandCueText !== undefined ) {
				status.text( opts.expandCueText );
			}
		} else {
			if ( opts.collapseCueText !== undefined ) {
				status.text( opts.collapseCueText );
			}
		}

		// Update icon

		// Is it supposed to have an icon?
		hasIcon =

			// If the collapsedIcon is being set, consult that
			( opts.collapsedIcon !== undefined ? opts.collapsedIcon !== false :

				// Otherwise consult the existing option value
				currentOpts.collapsedIcon !== false );


		// If any icon-related options have changed, make sure the new icon
		// state is reflected by first removing all icon-related classes
		// reflecting the current state and then adding all icon-related
		// classes for the new state
		if ( !( opts.iconpos === undefined &&
			opts.collapsedIcon === undefined &&
			opts.expandedIcon === undefined ) ) {

			// Remove all current icon-related classes
			anchor.removeClass( [ iconposClass( currentOpts.iconpos ) ]
				.concat( ( currentOpts.expandedIcon ?
					[ "ui-icon-" + currentOpts.expandedIcon ] : [] ) )
				.concat( ( currentOpts.collapsedIcon ?
					[ "ui-icon-" + currentOpts.collapsedIcon ] : [] ) )
				.join( " " ) );

			// Add new classes if an icon is supposed to be present
			if ( hasIcon ) {
				anchor.addClass(
					[ iconposClass( opts.iconpos !== undefined ?
						opts.iconpos : currentOpts.iconpos ) ]
						.concat( isCollapsed ?
							[ "ui-icon-" + ( opts.collapsedIcon !== undefined ?
								opts.collapsedIcon :
								currentOpts.collapsedIcon ) ] :
							[ "ui-icon-" + ( opts.expandedIcon !== undefined ?
								opts.expandedIcon :
								currentOpts.expandedIcon ) ] )
						.join( " " ) );
			}
		}

		if ( opts.theme !== undefined ) {
			oldTheme = this._themeClassFromOption( "ui-btn-", currentOpts.theme );
			newTheme = this._themeClassFromOption( "ui-btn-", opts.theme );
			anchor.removeClass( oldTheme ).addClass( newTheme );
		}

		if ( opts.contentTheme !== undefined ) {
			oldTheme = this._themeClassFromOption( "ui-body-",
				currentOpts.contentTheme );
			newTheme = this._themeClassFromOption( "ui-body-",
				opts.contentTheme );
			ui.content.removeClass( oldTheme ).addClass( newTheme );
		}

		if ( opts.inset !== undefined ) {
			elem.toggleClass( "ui-collapsible-inset", opts.inset );
			hasCorners = !!( opts.inset && ( opts.corners || currentOpts.corners ) );
		}

		if ( opts.corners !== undefined ) {
			hasCorners = !!( opts.corners && ( opts.inset || currentOpts.inset ) );
		}

		if ( hasCorners !== undefined ) {
			elem.toggleClass( "ui-corner-all", hasCorners );
		}

		if ( opts.mini !== undefined ) {
			anchor.toggleClass( "ui-mini", opts.mini );
		}
	},

	_setOptions: function( options ) {
		this._applyOptions( options );
		this._super( options );
		this._renderedOptions = this._getOptions( this.options );
	},

	_handleExpandCollapse: function( isCollapse ) {
		var opts = this._renderedOptions,
			ui = this._ui;

		ui.status.text( isCollapse ? opts.expandCueText : opts.collapseCueText );
		ui.heading
			.toggleClass( "ui-collapsible-heading-collapsed", isCollapse )
			.find( "a" ).first()
			.toggleClass( "ui-icon-" + opts.expandedIcon, !isCollapse )

			// logic or cause same icon for expanded/collapsed state would remove the ui-icon-class
			.toggleClass( "ui-icon-" + opts.collapsedIcon, ( isCollapse || opts.expandedIcon === opts.collapsedIcon ) )
			.removeClass( $.mobile.activeBtnClass );

		this.element.toggleClass( "ui-collapsible-collapsed", isCollapse );
		ui.content
			.toggleClass( "ui-collapsible-content-collapsed", isCollapse )
			.attr( "aria-hidden", isCollapse )
			.trigger( "updatelayout" );
		this.options.collapsed = isCollapse;
		this._trigger( isCollapse ? "collapse" : "expand" );
	},

	expand: function() {
		this._handleExpandCollapse( false );
	},

	collapse: function() {
		this._handleExpandCollapse( true );
	},

	_destroy: function() {
		var ui = this._ui,
			opts = this.options;

		if ( opts.enhanced ) {
			return;
		}

		if ( ui.placeholder ) {
			ui.originalHeading.insertBefore( ui.placeholder );
			ui.placeholder.remove();
			ui.heading.remove();
		} else {
			ui.status.remove();
			ui.heading
				.removeClass( "ui-collapsible-heading ui-collapsible-heading-collapsed" )
				.children()
					.contents()
						.unwrap();
		}

		ui.anchor.contents().unwrap();
		ui.content.contents().unwrap();
		this.element
			.removeClass( "ui-collapsible ui-collapsible-collapsed " +
				"ui-collapsible-themed-content ui-collapsible-inset ui-corner-all" );
	}
});

// Defaults to be used by all instances of collapsible if per-instance values
// are unset or if nothing is specified by way of inheritance from an accordion.
// Note that this hash does not contain options "collapsed" or "heading",
// because those are not inheritable.
$.mobile.collapsible.defaults = {
	expandCueText: " click to expand contents",
	collapseCueText: " click to collapse contents",
	collapsedIcon: "plus",
	contentTheme: "inherit",
	expandedIcon: "minus",
	iconpos: "left",
	inset: true,
	corners: true,
	theme: "inherit",
	mini: false
};

})( jQuery );

(function( $, undefined ) {

var uiScreenHiddenRegex = /\bui-screen-hidden\b/;
function noHiddenClass( elements ) {
	var index,
		length = elements.length,
		result = [];

	for ( index = 0; index < length; index++ ) {
		if ( !elements[ index ].className.match( uiScreenHiddenRegex ) ) {
			result.push( elements[ index ] );
		}
	}

	return $( result );
}

$.mobile.behaviors.addFirstLastClasses = {
	_getVisibles: function( $els, create ) {
		var visibles;

		if ( create ) {
			visibles = noHiddenClass( $els );
		} else {
			visibles = $els.filter( ":visible" );
			if ( visibles.length === 0 ) {
				visibles = noHiddenClass( $els );
			}
		}

		return visibles;
	},

	_addFirstLastClasses: function( $els, $visibles, create ) {
		$els.removeClass( "ui-first-child ui-last-child" );
		$visibles.eq( 0 ).addClass( "ui-first-child" ).end().last().addClass( "ui-last-child" );
		if ( !create ) {
			this.element.trigger( "updatelayout" );
		}
	},

	_removeFirstLastClasses: function( $els ) {
		$els.removeClass( "ui-first-child ui-last-child" );
	}
};

})( jQuery );

(function( $, undefined ) {

var childCollapsiblesSelector = ":mobile-collapsible, " + $.mobile.collapsible.initSelector;

$.widget( "mobile.collapsibleset", $.extend( {

	// The initSelector is deprecated as of 1.4.0. In 1.5.0 we will use
	// :jqmData(role='collapsibleset') which will allow us to get rid of the line
	// below altogether, because the autoinit will generate such an initSelector
	initSelector: ":jqmData(role='collapsible-set'),:jqmData(role='collapsibleset')",

	options: $.extend( {
		enhanced: false
	}, $.mobile.collapsible.defaults ),

	_handleCollapsibleExpand: function( event ) {
		var closestCollapsible = $( event.target ).closest( ".ui-collapsible" );

		if ( closestCollapsible.parent().is( ":mobile-collapsibleset, :jqmData(role='collapsible-set')" ) ) {
			closestCollapsible
				.siblings( ".ui-collapsible:not(.ui-collapsible-collapsed)" )
				.collapsible( "collapse" );
		}
	},

	_create: function() {
		var elem = this.element,
			opts = this.options;

		$.extend( this, {
			_classes: ""
		});

		if ( !opts.enhanced ) {
			elem.addClass( "ui-collapsible-set " +
				this._themeClassFromOption( "ui-group-theme-", opts.theme ) + " " +
				( opts.corners && opts.inset ? "ui-corner-all " : "" ) );
			this.element.find( $.mobile.collapsible.initSelector ).collapsible();
		}

		this._on( elem, { collapsibleexpand: "_handleCollapsibleExpand" } );
	},

	_themeClassFromOption: function( prefix, value ) {
		return ( value ? ( value === "none" ? "" : prefix + value ) : "" );
	},

	_init: function() {
		this._refresh( true );

		// Because the corners are handled by the collapsible itself and the default state is collapsed
		// That was causing https://github.com/jquery/jquery-mobile/issues/4116
		this.element
			.children( childCollapsiblesSelector )
			.filter( ":jqmData(collapsed='false')" )
			.collapsible( "expand" );
	},

	_setOptions: function( options ) {
		var ret, hasCorners,
			elem = this.element,
			themeClass = this._themeClassFromOption( "ui-group-theme-", options.theme );

		if ( themeClass ) {
			elem
				.removeClass( this._themeClassFromOption( "ui-group-theme-", this.options.theme ) )
				.addClass( themeClass );
		}

		if ( options.inset !== undefined ) {
			hasCorners = !!( options.inset && ( options.corners || this.options.corners ) );
		}

		if ( options.corners !== undefined ) {
			hasCorners = !!( options.corners && ( options.inset || this.options.inset ) );
		}

		if ( hasCorners !== undefined ) {
			elem.toggleClass( "ui-corner-all", hasCorners );
		}

		ret = this._super( options );
		this.element.children( ":mobile-collapsible" ).collapsible( "refresh" );
		return ret;
	},

	_destroy: function() {
		var el = this.element;

		this._removeFirstLastClasses( el.children( childCollapsiblesSelector ) );
		el
			.removeClass( "ui-collapsible-set ui-corner-all " +
				this._themeClassFromOption( "ui-group-theme-", this.options.theme ) )
			.children( ":mobile-collapsible" )
			.collapsible( "destroy" );
	},

	_refresh: function( create ) {
		var collapsiblesInSet = this.element.children( childCollapsiblesSelector );

		this.element.find( $.mobile.collapsible.initSelector ).not( ".ui-collapsible" ).collapsible();

		this._addFirstLastClasses( collapsiblesInSet, this._getVisibles( collapsiblesInSet, create ), create );
	},

	refresh: function() {
		this._refresh( false );
	}
}, $.mobile.behaviors.addFirstLastClasses ) );

})( jQuery );

(function( $, undefined ) {

// Deprecated in 1.4
$.fn.fieldcontain = function(/* options */) {
	return this.addClass( "ui-field-contain" );
};

})( jQuery );

(function( $, undefined ) {

$.fn.grid = function( options ) {
	return this.each(function() {

		var $this = $( this ),
			o = $.extend({
				grid: null
			}, options ),
			$kids = $this.children(),
			gridCols = { solo:1, a:2, b:3, c:4, d:5 },
			grid = o.grid,
			iterator,
			letter;

			if ( !grid ) {
				if ( $kids.length <= 5 ) {
					for ( letter in gridCols ) {
						if ( gridCols[ letter ] === $kids.length ) {
							grid = letter;
						}
					}
				} else {
					grid = "a";
					$this.addClass( "ui-grid-duo" );
				}
			}
			iterator = gridCols[grid];

		$this.addClass( "ui-grid-" + grid );

		$kids.filter( ":nth-child(" + iterator + "n+1)" ).addClass( "ui-block-a" );

		if ( iterator > 1 ) {
			$kids.filter( ":nth-child(" + iterator + "n+2)" ).addClass( "ui-block-b" );
		}
		if ( iterator > 2 ) {
			$kids.filter( ":nth-child(" + iterator + "n+3)" ).addClass( "ui-block-c" );
		}
		if ( iterator > 3 ) {
			$kids.filter( ":nth-child(" + iterator + "n+4)" ).addClass( "ui-block-d" );
		}
		if ( iterator > 4 ) {
			$kids.filter( ":nth-child(" + iterator + "n+5)" ).addClass( "ui-block-e" );
		}
	});
};
})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.navbar", {
	options: {
		iconpos: "top",
		grid: null
	},

	_create: function() {

		var $navbar = this.element,
			$navbtns = $navbar.find( "a" ),
			iconpos = $navbtns.filter( ":jqmData(icon)" ).length ? this.options.iconpos : undefined;

		$navbar.addClass( "ui-navbar" )
			.attr( "role", "navigation" )
			.find( "ul" )
			.jqmEnhanceable()
			.grid({ grid: this.options.grid });

		$navbtns
			.each( function() {
				var icon = $.mobile.getAttribute( this, "icon" ),
					theme = $.mobile.getAttribute( this, "theme" ),
					classes = "ui-btn";

				if ( theme ) {
					classes += " ui-btn-" + theme;
				}
				if ( icon ) {
					classes += " ui-icon-" + icon + " ui-btn-icon-" + iconpos;
				}
				$( this ).addClass( classes );
			});

		$navbar.delegate( "a", "vclick", function( /* event */ ) {
			var activeBtn = $( this );

			if ( !( activeBtn.hasClass( "ui-state-disabled" ) ||

				// DEPRECATED as of 1.4.0 - remove after 1.4.0 release
				// only ui-state-disabled should be present thereafter
				activeBtn.hasClass( "ui-disabled" ) ||
				activeBtn.hasClass( $.mobile.activeBtnClass ) ) ) {

				$navbtns.removeClass( $.mobile.activeBtnClass );
				activeBtn.addClass( $.mobile.activeBtnClass );

				// The code below is a workaround to fix #1181
				$( document ).one( "pagehide", function() {
					activeBtn.removeClass( $.mobile.activeBtnClass );
				});
			}
		});

		// Buttons in the navbar with ui-state-persist class should regain their active state before page show
		$navbar.closest( ".ui-page" ).bind( "pagebeforeshow", function() {
			$navbtns.filter( ".ui-state-persist" ).addClass( $.mobile.activeBtnClass );
		});
	}
});

})( jQuery );

(function( $, undefined ) {

var getAttr = $.mobile.getAttribute;

$.widget( "mobile.listview", $.extend( {

	options: {
		theme: null,
		countTheme: null, /* Deprecated in 1.4 */
		dividerTheme: null,
		icon: "carat-r",
		splitIcon: "carat-r",
		splitTheme: null,
		corners: true,
		shadow: true,
		inset: false
	},

	_create: function() {
		var t = this,
			listviewClasses = "";

		listviewClasses += t.options.inset ? " ui-listview-inset" : "";

		if ( !!t.options.inset ) {
			listviewClasses += t.options.corners ? " ui-corner-all" : "";
			listviewClasses += t.options.shadow ? " ui-shadow" : "";
		}

		// create listview markup
		t.element.addClass( " ui-listview" + listviewClasses );

		t.refresh( true );
	},

	// TODO: Remove in 1.5
	_findFirstElementByTagName: function( ele, nextProp, lcName, ucName ) {
		var dict = {};
		dict[ lcName ] = dict[ ucName ] = true;
		while ( ele ) {
			if ( dict[ ele.nodeName ] ) {
				return ele;
			}
			ele = ele[ nextProp ];
		}
		return null;
	},
	// TODO: Remove in 1.5
	_addThumbClasses: function( containers ) {
		var i, img, len = containers.length;
		for ( i = 0; i < len; i++ ) {
			img = $( this._findFirstElementByTagName( containers[ i ].firstChild, "nextSibling", "img", "IMG" ) );
			if ( img.length ) {
				$( this._findFirstElementByTagName( img[ 0 ].parentNode, "parentNode", "li", "LI" ) ).addClass( img.hasClass( "ui-li-icon" ) ? "ui-li-has-icon" : "ui-li-has-thumb" );
			}
		}
	},

	_getChildrenByTagName: function( ele, lcName, ucName ) {
		var results = [],
			dict = {};
		dict[ lcName ] = dict[ ucName ] = true;
		ele = ele.firstChild;
		while ( ele ) {
			if ( dict[ ele.nodeName ] ) {
				results.push( ele );
			}
			ele = ele.nextSibling;
		}
		return $( results );
	},

	_beforeListviewRefresh: $.noop,
	_afterListviewRefresh: $.noop,

	refresh: function( create ) {
		var buttonClass, pos, numli, item, itemClass, itemTheme, itemIcon, icon, a,
			isDivider, startCount, newStartCount, value, last, splittheme, splitThemeClass, spliticon,
			altButtonClass, dividerTheme, li,
			o = this.options,
			$list = this.element,
			ol = !!$.nodeName( $list[ 0 ], "ol" ),
			start = $list.attr( "start" ),
			itemClassDict = {},
			countBubbles = $list.find( ".ui-li-count" ),
			countTheme = getAttr( $list[ 0 ], "counttheme" ) || this.options.countTheme,
			countThemeClass = countTheme ? "ui-body-" + countTheme : "ui-body-inherit";

		if ( o.theme ) {
			$list.addClass( "ui-group-theme-" + o.theme );
		}

		// Check if a start attribute has been set while taking a value of 0 into account
		if ( ol && ( start || start === 0 ) ) {
			startCount = parseInt( start, 10 ) - 1;
			$list.css( "counter-reset", "listnumbering " + startCount );
		}

		this._beforeListviewRefresh();

		li = this._getChildrenByTagName( $list[ 0 ], "li", "LI" );

		for ( pos = 0, numli = li.length; pos < numli; pos++ ) {
			item = li.eq( pos );
			itemClass = "";

			if ( create || item[ 0 ].className.search( /\bui-li-static\b|\bui-li-divider\b/ ) < 0 ) {
				a = this._getChildrenByTagName( item[ 0 ], "a", "A" );
				isDivider = ( getAttr( item[ 0 ], "role" ) === "list-divider" );
				value = item.attr( "value" );
				itemTheme = getAttr( item[ 0 ], "theme" );

				if ( a.length && a[ 0 ].className.search( /\bui-btn\b/ ) < 0 && !isDivider ) {
					itemIcon = getAttr( item[ 0 ], "icon" );
					icon = ( itemIcon === false ) ? false : ( itemIcon || o.icon );

					// TODO: Remove in 1.5 together with links.js (links.js / .ui-link deprecated in 1.4)
					a.removeClass( "ui-link" );

					buttonClass = "ui-btn";

					if ( itemTheme ) {
						buttonClass += " ui-btn-" + itemTheme;
					}

					if ( a.length > 1 ) {
						itemClass = "ui-li-has-alt";

						last = a.last();
						splittheme = getAttr( last[ 0 ], "theme" ) || o.splitTheme || getAttr( item[ 0 ], "theme", true );
						splitThemeClass = splittheme ? " ui-btn-" + splittheme : "";
						spliticon = getAttr( last[ 0 ], "icon" ) || getAttr( item[ 0 ], "icon" ) || o.splitIcon;
						altButtonClass = "ui-btn ui-btn-icon-notext ui-icon-" + spliticon + splitThemeClass;

						last
							.attr( "title", $.trim( last.getEncodedText() ) )
							.addClass( altButtonClass )
							.empty();

						// Reduce to the first anchor, because only the first gets the buttonClass
						a = a.first();
					} else if ( icon ) {
						buttonClass += " ui-btn-icon-right ui-icon-" + icon;
					}

					// Apply buttonClass to the (first) anchor
					a.addClass( buttonClass );
				} else if ( isDivider ) {
					dividerTheme = ( getAttr( item[ 0 ], "theme" ) || o.dividerTheme || o.theme );

					itemClass = "ui-li-divider ui-bar-" + ( dividerTheme ? dividerTheme : "inherit" );

					item.attr( "role", "heading" );
				} else if ( a.length <= 0 ) {
					itemClass = "ui-li-static ui-body-" + ( itemTheme ? itemTheme : "inherit" );
				}
				if ( ol && value ) {
					newStartCount = parseInt( value , 10 ) - 1;

					item.css( "counter-reset", "listnumbering " + newStartCount );
				}
			}

			// Instead of setting item class directly on the list item
			// at this point in time, push the item into a dictionary
			// that tells us what class to set on it so we can do this after this
			// processing loop is finished.

			if ( !itemClassDict[ itemClass ] ) {
				itemClassDict[ itemClass ] = [];
			}

			itemClassDict[ itemClass ].push( item[ 0 ] );
		}

		// Set the appropriate listview item classes on each list item.
		// The main reason we didn't do this
		// in the for-loop above is because we can eliminate per-item function overhead
		// by calling addClass() and children() once or twice afterwards. This
		// can give us a significant boost on platforms like WP7.5.

		for ( itemClass in itemClassDict ) {
			$( itemClassDict[ itemClass ] ).addClass( itemClass );
		}

		countBubbles.each( function() {
			$( this ).closest( "li" ).addClass( "ui-li-has-count" );
		});
		if ( countThemeClass ) {
			countBubbles.not( "[class*='ui-body-']" ).addClass( countThemeClass );
		}

		// Deprecated in 1.4. From 1.5 you have to add class ui-li-has-thumb or ui-li-has-icon to the LI.
		this._addThumbClasses( li );
		this._addThumbClasses( li.find( ".ui-btn" ) );

		this._afterListviewRefresh();

		this._addFirstLastClasses( li, this._getVisibles( li, create ), create );
	}
}, $.mobile.behaviors.addFirstLastClasses ) );

})( jQuery );

(function( $, undefined ) {

function defaultAutodividersSelector( elt ) {
	// look for the text in the given element
	var text = $.trim( elt.text() ) || null;

	if ( !text ) {
		return null;
	}

	// create the text for the divider (first uppercased letter)
	text = text.slice( 0, 1 ).toUpperCase();

	return text;
}

$.widget( "mobile.listview", $.mobile.listview, {
	options: {
		autodividers: false,
		autodividersSelector: defaultAutodividersSelector
	},

	_beforeListviewRefresh: function() {
		if ( this.options.autodividers ) {
			this._replaceDividers();
			this._superApply( arguments );
		}
	},

	_replaceDividers: function() {
		var i, lis, li, dividerText,
			lastDividerText = null,
			list = this.element,
			divider;

		list.children( "li:jqmData(role='list-divider')" ).remove();

		lis = list.children( "li" );

		for ( i = 0; i < lis.length ; i++ ) {
			li = lis[ i ];
			dividerText = this.options.autodividersSelector( $( li ) );

			if ( dividerText && lastDividerText !== dividerText ) {
				divider = document.createElement( "li" );
				divider.appendChild( document.createTextNode( dividerText ) );
				divider.setAttribute( "data-" + $.mobile.ns + "role", "list-divider" );
				li.parentNode.insertBefore( divider, li );
			}

			lastDividerText = dividerText;
		}
	}
});

})( jQuery );

(function( $, undefined ) {

var rdivider = /(^|\s)ui-li-divider($|\s)/,
	rhidden = /(^|\s)ui-screen-hidden($|\s)/;

$.widget( "mobile.listview", $.mobile.listview, {
	options: {
		hideDividers: false
	},

	_afterListviewRefresh: function() {
		var items, idx, item, hideDivider = true;

		this._superApply( arguments );

		if ( this.options.hideDividers ) {
			items = this._getChildrenByTagName( this.element[ 0 ], "li", "LI" );
			for ( idx = items.length - 1 ; idx > -1 ; idx-- ) {
				item = items[ idx ];
				if ( item.className.match( rdivider ) ) {
					if ( hideDivider ) {
						item.className = item.className + " ui-screen-hidden";
					}
					hideDivider = true;
				} else {
					if ( !item.className.match( rhidden ) ) {
						hideDivider = false;
					}
				}
			}
		}
	}
});

})( jQuery );

(function( $, undefined ) {

$.mobile.nojs = function( target ) {
	$( ":jqmData(role='nojs')", target ).addClass( "ui-nojs" );
};

})( jQuery );

(function( $, undefined ) {

$.mobile.behaviors.formReset = {
	_handleFormReset: function() {
		this._on( this.element.closest( "form" ), {
			reset: function() {
				this._delay( "_reset" );
			}
		});
	}
};

})( jQuery );

/*
* "checkboxradio" plugin
*/

(function( $, undefined ) {

var escapeId = $.mobile.path.hashToSelector;

$.widget( "mobile.checkboxradio", $.extend( {

	initSelector: "input:not( :jqmData(role='flipswitch' ) )[type='checkbox'],input[type='radio']:not( :jqmData(role='flipswitch' ))",

	options: {
		theme: "inherit",
		mini: false,
		wrapperClass: null,
		enhanced: false,
		iconpos: "left"

	},
	_create: function() {
		var input = this.element,
			o = this.options,
			inheritAttr = function( input, dataAttr ) {
				return input.jqmData( dataAttr ) ||
					input.closest( "form, fieldset" ).jqmData( dataAttr );
			},
			label = this.options.enhanced ?
				{
					element: this.element.siblings( "label" ),
					isParent: false
				} :
				this._findLabel(),
			inputtype = input[0].type,
			checkedClass = "ui-" + inputtype + "-on",
			uncheckedClass = "ui-" + inputtype + "-off";

		if ( inputtype !== "checkbox" && inputtype !== "radio" ) {
			return;
		}

		if ( this.element[0].disabled ) {
			this.options.disabled = true;
		}

		o.iconpos = inheritAttr( input, "iconpos" ) ||
			label.element.attr( "data-" + $.mobile.ns + "iconpos" ) || o.iconpos,

		// Establish options
		o.mini = inheritAttr( input, "mini" ) || o.mini;

		// Expose for other methods
		$.extend( this, {
			input: input,
			label: label.element,
			labelIsParent: label.isParent,
			inputtype: inputtype,
			checkedClass: checkedClass,
			uncheckedClass: uncheckedClass
		});

		if ( !this.options.enhanced ) {
			this._enhance();
		}

		this._on( label.element, {
			vmouseover: "_handleLabelVMouseOver",
			vclick: "_handleLabelVClick"
		});

		this._on( input, {
			vmousedown: "_cacheVals",
			vclick: "_handleInputVClick",
			focus: "_handleInputFocus",
			blur: "_handleInputBlur"
		});

		this._handleFormReset();
		this.refresh();
	},

	_findLabel: function() {
		var parentLabel, label, isParent,
			input = this.element,
			labelsList = input[ 0 ].labels;

		if( labelsList && labelsList.length > 0 ) {
			label = $( labelsList[ 0 ] );
			isParent = $.contains( label[ 0 ], input[ 0 ] );
		} else {
			parentLabel = input.closest( "label" );
			isParent = ( parentLabel.length > 0 );

			// NOTE: Windows Phone could not find the label through a selector
			// filter works though.
			label = isParent ? parentLabel :
				$( this.document[ 0 ].getElementsByTagName( "label" ) )
					.filter( "[for='" + escapeId( input[ 0 ].id ) + "']" )
					.first();
		}

		return {
			element: label,
			isParent: isParent
		};
	},

	_enhance: function() {
		this.label.addClass( "ui-btn ui-corner-all");

		if ( this.labelIsParent ) {
			this.input.add( this.label ).wrapAll( this._wrapper() );
		} else {
			//this.element.replaceWith( this.input.add( this.label ).wrapAll( this._wrapper() ) );
			this.element.wrap( this._wrapper() );
			this.element.parent().prepend( this.label );
		}

		// Wrap the input + label in a div

		this._setOptions({
			"theme": this.options.theme,
			"iconpos": this.options.iconpos,
			"mini": this.options.mini
		});

	},

	_wrapper: function() {
		return $( "<div class='"  +
			( this.options.wrapperClass ? this.options.wrapperClass : "" ) +
			" ui-" + this.inputtype +
			( this.options.disabled ? " ui-state-disabled" : "" ) + "' ></div>" );
	},

	_handleInputFocus: function() {
		this.label.addClass( $.mobile.focusClass );
	},

	_handleInputBlur: function() {
		this.label.removeClass( $.mobile.focusClass );
	},

	_handleInputVClick: function() {
		// Adds checked attribute to checked input when keyboard is used
		this.element.prop( "checked", this.element.is( ":checked" ) );
		this._getInputSet().not( this.element ).prop( "checked", false );
		this._updateAll( true );
	},

	_handleLabelVMouseOver: function( event ) {
		if ( this.label.parent().hasClass( "ui-state-disabled" ) ) {
			event.stopPropagation();
		}
	},

	_handleLabelVClick: function( event ) {
		var input = this.element;

		if ( input.is( ":disabled" ) ) {
			event.preventDefault();
			return;
		}

		this._cacheVals();

		input.prop( "checked", this.inputtype === "radio" && true || !input.prop( "checked" ) );

		// trigger click handler's bound directly to the input as a substitute for
		// how label clicks behave normally in the browsers
		// TODO: it would be nice to let the browser's handle the clicks and pass them
		//       through to the associate input. we can swallow that click at the parent
		//       wrapper element level
		input.triggerHandler( "click" );

		// Input set for common radio buttons will contain all the radio
		// buttons, but will not for checkboxes. clearing the checked status
		// of other radios ensures the active button state is applied properly
		this._getInputSet().not( input ).prop( "checked", false );

		this._updateAll();
		return false;
	},

	_cacheVals: function() {
		this._getInputSet().each( function() {
			$( this ).attr("data-" + $.mobile.ns + "cacheVal", this.checked );
		});
	},

	// Returns those radio buttons that are supposed to be in the same group as
	// this radio button. In the case of a checkbox or a radio lacking a name
	// attribute, it returns this.element.
	_getInputSet: function() {
		var selector, formId,
			radio = this.element[ 0 ],
			name = radio.name,
			form = radio.form,
			doc = this.element.parents().last().get( 0 ),

			// A radio is always a member of its own group
			radios = this.element;

		// Only start running selectors if this is an attached radio button with a name
		if ( name && this.inputtype === "radio" && doc ) {
			selector = "input[type='radio'][name='" + escapeId( name ) + "']";

			// If we're inside a form
			if ( form ) {
				formId = form.getAttribute( "id" );

				// If the form has an ID, collect radios scattered throught the document which
				// nevertheless are part of the form by way of the value of their form attribute
				if ( formId ) {
					radios = $( selector + "[form='" + escapeId( formId ) + "']", doc );
				}

				// Also add to those the radios in the form itself
				radios = $( form ).find( selector ).filter( function() {

					// Some radios inside the form may belong to some other form by virtue of
					// having a form attribute defined on them, so we must filter them out here
					return ( this.form === form );
				}).add( radios );

			// If we're outside a form
			} else {

				// Collect all those radios which are also outside of a form and match our name
				radios = $( selector, doc ).filter( function() {
					return !this.form;
				});
			}
		}
		return radios;
	},

	_updateAll: function( changeTriggered ) {
		var self = this;

		this._getInputSet().each( function() {
			var $this = $( this );

			if ( ( this.checked || self.inputtype === "checkbox" ) && !changeTriggered ) {
				$this.trigger( "change" );
			}
		})
		.checkboxradio( "refresh" );
	},

	_reset: function() {
		this.refresh();
	},

	// Is the widget supposed to display an icon?
	_hasIcon: function() {
		var controlgroup, controlgroupWidget,
			controlgroupConstructor = $.mobile.controlgroup;

		// If the controlgroup widget is defined ...
		if ( controlgroupConstructor ) {
			controlgroup = this.element.closest(
				":mobile-controlgroup," +
				controlgroupConstructor.prototype.initSelector );

			// ... and the checkbox is in a controlgroup ...
			if ( controlgroup.length > 0 ) {

				// ... look for a controlgroup widget instance, and ...
				controlgroupWidget = $.data( controlgroup[ 0 ], "mobile-controlgroup" );

				// ... if found, decide based on the option value, ...
				return ( ( controlgroupWidget ? controlgroupWidget.options.type :

					// ... otherwise decide based on the "type" data attribute.
					controlgroup.attr( "data-" + $.mobile.ns + "type" ) ) !== "horizontal" );
			}
		}

		// Normally, the widget displays an icon.
		return true;
	},

	refresh: function() {
		var hasIcon = this._hasIcon(),
			isChecked = this.element[ 0 ].checked,
			active = $.mobile.activeBtnClass,
			iconposClass = "ui-btn-icon-" + this.options.iconpos,
			addClasses = [],
			removeClasses = [];

		if ( hasIcon ) {
			removeClasses.push( active );
			addClasses.push( iconposClass );
		} else {
			removeClasses.push( iconposClass );
			( isChecked ? addClasses : removeClasses ).push( active );
		}

		if ( isChecked ) {
			addClasses.push( this.checkedClass );
			removeClasses.push( this.uncheckedClass );
		} else {
			addClasses.push( this.uncheckedClass );
			removeClasses.push( this.checkedClass );
		}

		this.label
			.addClass( addClasses.join( " " ) )
			.removeClass( removeClasses.join( " " ) );
	},

	widget: function() {
		return this.label.parent();
	},

	_setOptions: function( options ) {
		var label = this.label,
			currentOptions = this.options,
			outer = this.widget(),
			hasIcon = this._hasIcon();

		if ( options.disabled !== undefined ) {
			this.input.prop( "disabled", !!options.disabled );
			outer.toggleClass( "ui-state-disabled", !!options.disabled );
		}
		if ( options.mini !== undefined ) {
			outer.toggleClass( "ui-mini", !!options.mini );
		}
		if ( options.theme !== undefined ) {
			label
				.removeClass( "ui-btn-" + currentOptions.theme )
				.addClass( "ui-btn-" + options.theme );
		}
		if ( options.wrapperClass !== undefined ) {
			outer
				.removeClass( currentOptions.wrapperClass )
				.addClass( options.wrapperClass );
		}
		if ( options.iconpos !== undefined && hasIcon ) {
			label.removeClass( "ui-btn-icon-" + currentOptions.iconpos ).addClass( "ui-btn-icon-" + options.iconpos );
		} else if ( !hasIcon ) {
			label.removeClass( "ui-btn-icon-" + currentOptions.iconpos );
		}
		this._super( options );
	}

}, $.mobile.behaviors.formReset ) );

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.button", {

	initSelector: "input[type='button'], input[type='submit'], input[type='reset']",

	options: {
		theme: null,
		icon: null,
		iconpos: "left",
		iconshadow: false, /* TODO: Deprecated in 1.4, remove in 1.5. */
		corners: true,
		shadow: true,
		inline: null,
		mini: null,
		wrapperClass: null,
		enhanced: false
	},

	_create: function() {

		if ( this.element.is( ":disabled" ) ) {
			this.options.disabled = true;
		}

		if ( !this.options.enhanced ) {
			this._enhance();
		}

		$.extend( this, {
			wrapper: this.element.parent()
		});

		this._on( {
			focus: function() {
				this.widget().addClass( $.mobile.focusClass );
			},

			blur: function() {
				this.widget().removeClass( $.mobile.focusClass );
			}
		});

		this.refresh( true );
	},

	_enhance: function() {
		this.element.wrap( this._button() );
	},

	_button: function() {
		var options = this.options,
			iconClasses = this._getIconClasses( this.options );

		return $("<div class='ui-btn ui-input-btn" +
			( options.wrapperClass ? " " + options.wrapperClass : "" ) +
			( options.theme ? " ui-btn-" + options.theme : "" ) +
			( options.corners ? " ui-corner-all" : "" ) +
			( options.shadow ? " ui-shadow" : "" ) +
			( options.inline ? " ui-btn-inline" : "" ) +
			( options.mini ? " ui-mini" : "" ) +
			( options.disabled ? " ui-state-disabled" : "" ) +
			( iconClasses ? ( " " + iconClasses ) : "" ) +
			"' >" + this.element.val() + "</div>" );
	},

	widget: function() {
		return this.wrapper;
	},

	_destroy: function() {
			this.element.insertBefore( this.button );
			this.button.remove();
	},

	_getIconClasses: function( options ) {
		return ( options.icon ? ( "ui-icon-" + options.icon +
			( options.iconshadow ? " ui-shadow-icon" : "" ) + /* TODO: Deprecated in 1.4, remove in 1.5. */
			" ui-btn-icon-" + options.iconpos ) : "" );
	},

	_setOptions: function( options ) {
		var outer = this.widget();

		if ( options.theme !== undefined ) {
			outer
				.removeClass( this.options.theme )
				.addClass( "ui-btn-" + options.theme );
		}
		if ( options.corners !== undefined ) {
			outer.toggleClass( "ui-corner-all", options.corners );
		}
		if ( options.shadow !== undefined ) {
			outer.toggleClass( "ui-shadow", options.shadow );
		}
		if ( options.inline !== undefined ) {
			outer.toggleClass( "ui-btn-inline", options.inline );
		}
		if ( options.mini !== undefined ) {
			outer.toggleClass( "ui-mini", options.mini );
		}
		if ( options.disabled !== undefined ) {
			this.element.prop( "disabled", options.disabled );
			outer.toggleClass( "ui-state-disabled", options.disabled );
		}

		if ( options.icon !== undefined ||
				options.iconshadow !== undefined || /* TODO: Deprecated in 1.4, remove in 1.5. */
				options.iconpos !== undefined ) {
			outer
				.removeClass( this._getIconClasses( this.options ) )
				.addClass( this._getIconClasses(
					$.extend( {}, this.options, options ) ) );
		}

		this._super( options );
	},

	refresh: function( create ) {
		var originalElement,
			isDisabled = this.element.prop( "disabled" );

		if ( this.options.icon && this.options.iconpos === "notext" && this.element.attr( "title" ) ) {
			this.element.attr( "title", this.element.val() );
		}
		if ( !create ) {
			originalElement = this.element.detach();
			$( this.wrapper ).text( this.element.val() ).append( originalElement );
		}
		if ( this.options.disabled !== isDisabled ) {
			this._setOptions({ disabled: isDisabled });
		}
	}
});

})( jQuery );

(function( $ ) {
	var	meta = $( "meta[name=viewport]" ),
		initialContent = meta.attr( "content" ),
		disabledZoom = initialContent + ",maximum-scale=1, user-scalable=no",
		enabledZoom = initialContent + ",maximum-scale=10, user-scalable=yes",
		disabledInitially = /(user-scalable[\s]*=[\s]*no)|(maximum-scale[\s]*=[\s]*1)[$,\s]/.test( initialContent );

	$.mobile.zoom = $.extend( {}, {
		enabled: !disabledInitially,
		locked: false,
		disable: function( lock ) {
			if ( !disabledInitially && !$.mobile.zoom.locked ) {
				meta.attr( "content", disabledZoom );
				$.mobile.zoom.enabled = false;
				$.mobile.zoom.locked = lock || false;
			}
		},
		enable: function( unlock ) {
			if ( !disabledInitially && ( !$.mobile.zoom.locked || unlock === true ) ) {
				meta.attr( "content", enabledZoom );
				$.mobile.zoom.enabled = true;
				$.mobile.zoom.locked = false;
			}
		},
		restore: function() {
			if ( !disabledInitially ) {
				meta.attr( "content", initialContent );
				$.mobile.zoom.enabled = true;
			}
		}
	});

}( jQuery ));

(function( $, undefined ) {

$.widget( "mobile.textinput", {
	initSelector: "input[type='text']," +
		"input[type='search']," +
		":jqmData(type='search')," +
		"input[type='number']," +
		":jqmData(type='number')," +
		"input[type='password']," +
		"input[type='email']," +
		"input[type='url']," +
		"input[type='tel']," +
		"textarea," +
		"input[type='time']," +
		"input[type='date']," +
		"input[type='month']," +
		"input[type='week']," +
		"input[type='datetime']," +
		"input[type='datetime-local']," +
		"input[type='color']," +
		"input:not([type])," +
		"input[type='file']",

	options: {
		theme: null,
		corners: true,
		mini: false,
		// This option defaults to true on iOS devices.
		preventFocusZoom: /iPhone|iPad|iPod/.test( navigator.platform ) && navigator.userAgent.indexOf( "AppleWebKit" ) > -1,
		wrapperClass: "",
		enhanced: false
	},

	_create: function() {

		var options = this.options,
			isSearch = this.element.is( "[type='search'], :jqmData(type='search')" ),
			isTextarea = this.element[ 0 ].tagName === "TEXTAREA",
			isRange = this.element.is( "[data-" + ( $.mobile.ns || "" ) + "type='range']" ),
			inputNeedsWrap = ( (this.element.is( "input" ) ||
				this.element.is( "[data-" + ( $.mobile.ns || "" ) + "type='search']" ) ) &&
					!isRange );

		if ( this.element.prop( "disabled" ) ) {
			options.disabled = true;
		}

		$.extend( this, {
			classes: this._classesFromOptions(),
			isSearch: isSearch,
			isTextarea: isTextarea,
			isRange: isRange,
			inputNeedsWrap: inputNeedsWrap
		});

		this._autoCorrect();

		if ( !options.enhanced ) {
			this._enhance();
		}

		this._on( {
			"focus": "_handleFocus",
			"blur": "_handleBlur"
		});

	},

	refresh: function() {
		this.setOptions({
			"disabled" : this.element.is( ":disabled" )
		});
	},

	_enhance: function() {
		var elementClasses = [];

		if ( this.isTextarea ) {
			elementClasses.push( "ui-input-text" );
		}

		if ( this.isTextarea || this.isRange ) {
			elementClasses.push( "ui-shadow-inset" );
		}

		//"search" and "text" input widgets
		if ( this.inputNeedsWrap ) {
			this.element.wrap( this._wrap() );
		} else {
			elementClasses = elementClasses.concat( this.classes );
		}

		this.element.addClass( elementClasses.join( " " ) );
	},

	widget: function() {
		return ( this.inputNeedsWrap ) ? this.element.parent() : this.element;
	},

	_classesFromOptions: function() {
		var options = this.options,
			classes = [];

		classes.push( "ui-body-" + ( ( options.theme === null ) ? "inherit" : options.theme ) );
		if ( options.corners ) {
			classes.push( "ui-corner-all" );
		}
		if ( options.mini ) {
			classes.push( "ui-mini" );
		}
		if ( options.disabled ) {
			classes.push( "ui-state-disabled" );
		}
		if ( options.wrapperClass ) {
			classes.push( options.wrapperClass );
		}

		return classes;
	},

	_wrap: function() {
		return $( "<div class='" +
			( this.isSearch ? "ui-input-search " : "ui-input-text " ) +
			this.classes.join( " " ) + " " +
			"ui-shadow-inset'></div>" );
	},

	_autoCorrect: function() {
		// XXX: Temporary workaround for issue 785 (Apple bug 8910589).
		//      Turn off autocorrect and autocomplete on non-iOS 5 devices
		//      since the popup they use can't be dismissed by the user. Note
		//      that we test for the presence of the feature by looking for
		//      the autocorrect property on the input element. We currently
		//      have no test for iOS 5 or newer so we're temporarily using
		//      the touchOverflow support flag for jQM 1.0. Yes, I feel dirty.
		//      - jblas
		if ( typeof this.element[0].autocorrect !== "undefined" &&
			!$.support.touchOverflow ) {

			// Set the attribute instead of the property just in case there
			// is code that attempts to make modifications via HTML.
			this.element[0].setAttribute( "autocorrect", "off" );
			this.element[0].setAttribute( "autocomplete", "off" );
		}
	},

	_handleBlur: function() {
		this.widget().removeClass( $.mobile.focusClass );
		if ( this.options.preventFocusZoom ) {
			$.mobile.zoom.enable( true );
		}
	},

	_handleFocus: function() {
		// In many situations, iOS will zoom into the input upon tap, this
		// prevents that from happening
		if ( this.options.preventFocusZoom ) {
			$.mobile.zoom.disable( true );
		}
		this.widget().addClass( $.mobile.focusClass );
	},

	_setOptions: function ( options ) {
		var outer = this.widget();

		this._super( options );

		if ( !( options.disabled === undefined &&
			options.mini === undefined &&
			options.corners === undefined &&
			options.theme === undefined &&
			options.wrapperClass === undefined ) ) {

			outer.removeClass( this.classes.join( " " ) );
			this.classes = this._classesFromOptions();
			outer.addClass( this.classes.join( " " ) );
		}

		if ( options.disabled !== undefined ) {
			this.element.prop( "disabled", !!options.disabled );
		}
	},

	_destroy: function() {
		if ( this.options.enhanced ) {
			return;
		}
		if ( this.inputNeedsWrap ) {
			this.element.unwrap();
		}
		this.element.removeClass( "ui-input-text " + this.classes.join( " " ) );
	}
});

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.slider", $.extend( {
	initSelector: "input[type='range'], :jqmData(type='range'), :jqmData(role='slider')",

	widgetEventPrefix: "slide",

	options: {
		theme: null,
		trackTheme: null,
		corners: true,
		mini: false,
		highlight: false
	},

	_create: function() {

		// TODO: Each of these should have comments explain what they're for
		var self = this,
			control = this.element,
			trackTheme = this.options.trackTheme || $.mobile.getAttribute( control[ 0 ], "theme" ),
			trackThemeClass = trackTheme ? " ui-bar-" + trackTheme : " ui-bar-inherit",
			cornerClass = ( this.options.corners || control.jqmData( "corners" ) ) ? " ui-corner-all" : "",
			miniClass = ( this.options.mini || control.jqmData( "mini" ) ) ? " ui-mini" : "",
			cType = control[ 0 ].nodeName.toLowerCase(),
			isToggleSwitch = ( cType === "select" ),
			isRangeslider = control.parent().is( ":jqmData(role='rangeslider')" ),
			selectClass = ( isToggleSwitch ) ? "ui-slider-switch" : "",
			controlID = control.attr( "id" ),
			$label = $( "[for='" + controlID + "']" ),
			labelID = $label.attr( "id" ) || controlID + "-label",
			min = !isToggleSwitch ? parseFloat( control.attr( "min" ) ) : 0,
			max =  !isToggleSwitch ? parseFloat( control.attr( "max" ) ) : control.find( "option" ).length-1,
			step = window.parseFloat( control.attr( "step" ) || 1 ),
			domHandle = document.createElement( "a" ),
			handle = $( domHandle ),
			domSlider = document.createElement( "div" ),
			slider = $( domSlider ),
			valuebg = this.options.highlight && !isToggleSwitch ? (function() {
				var bg = document.createElement( "div" );
				bg.className = "ui-slider-bg " + $.mobile.activeBtnClass;
				return $( bg ).prependTo( slider );
			})() : false,
			options,
			wrapper,
			j, length,
			i, optionsCount, origTabIndex,
			side, activeClass, sliderImg;

		$label.attr( "id", labelID );
		this.isToggleSwitch = isToggleSwitch;

		domHandle.setAttribute( "href", "#" );
		domSlider.setAttribute( "role", "application" );
		domSlider.className = [ this.isToggleSwitch ? "ui-slider ui-slider-track ui-shadow-inset " : "ui-slider-track ui-shadow-inset ", selectClass, trackThemeClass, cornerClass, miniClass ].join( "" );
		domHandle.className = "ui-slider-handle";
		domSlider.appendChild( domHandle );

		handle.attr({
			"role": "slider",
			"aria-valuemin": min,
			"aria-valuemax": max,
			"aria-valuenow": this._value(),
			"aria-valuetext": this._value(),
			"title": this._value(),
			"aria-labelledby": labelID
		});

		$.extend( this, {
			slider: slider,
			handle: handle,
			control: control,
			type: cType,
			step: step,
			max: max,
			min: min,
			valuebg: valuebg,
			isRangeslider: isRangeslider,
			dragging: false,
			beforeStart: null,
			userModified: false,
			mouseMoved: false
		});

		if ( isToggleSwitch ) {
			// TODO: restore original tabindex (if any) in a destroy method
			origTabIndex = control.attr( "tabindex" );
			if ( origTabIndex ) {
				handle.attr( "tabindex", origTabIndex );
			}
			control.attr( "tabindex", "-1" ).focus(function() {
				$( this ).blur();
				handle.focus();
			});

			wrapper = document.createElement( "div" );
			wrapper.className = "ui-slider-inneroffset";

			for ( j = 0, length = domSlider.childNodes.length; j < length; j++ ) {
				wrapper.appendChild( domSlider.childNodes[j] );
			}

			domSlider.appendChild( wrapper );

			// slider.wrapInner( "<div class='ui-slider-inneroffset'></div>" );

			// make the handle move with a smooth transition
			handle.addClass( "ui-slider-handle-snapping" );

			options = control.find( "option" );

			for ( i = 0, optionsCount = options.length; i < optionsCount; i++ ) {
				side = !i ? "b" : "a";
				activeClass = !i ? "" : " " + $.mobile.activeBtnClass;
				sliderImg = document.createElement( "span" );

				sliderImg.className = [ "ui-slider-label ui-slider-label-", side, activeClass ].join( "" );
				sliderImg.setAttribute( "role", "img" );
				sliderImg.appendChild( document.createTextNode( options[i].innerHTML ) );
				$( sliderImg ).prependTo( slider );
			}

			self._labels = $( ".ui-slider-label", slider );

		}

		// monitor the input for updated values
		control.addClass( isToggleSwitch ? "ui-slider-switch" : "ui-slider-input" );

		this._on( control, {
			"change": "_controlChange",
			"keyup": "_controlKeyup",
			"blur": "_controlBlur",
			"vmouseup": "_controlVMouseUp"
		});

		slider.bind( "vmousedown", $.proxy( this._sliderVMouseDown, this ) )
			.bind( "vclick", false );

		// We have to instantiate a new function object for the unbind to work properly
		// since the method itself is defined in the prototype (causing it to unbind everything)
		this._on( document, { "vmousemove": "_preventDocumentDrag" });
		this._on( slider.add( document ), { "vmouseup": "_sliderVMouseUp" });

		slider.insertAfter( control );

		// wrap in a div for styling purposes
		if ( !isToggleSwitch && !isRangeslider ) {
			wrapper = this.options.mini ? "<div class='ui-slider ui-mini'>" : "<div class='ui-slider'>";

			control.add( slider ).wrapAll( wrapper );
		}

		// bind the handle event callbacks and set the context to the widget instance
		this._on( this.handle, {
			"vmousedown": "_handleVMouseDown",
			"keydown": "_handleKeydown",
			"keyup": "_handleKeyup"
		});

		this.handle.bind( "vclick", false );

		this._handleFormReset();

		this.refresh( undefined, undefined, true );
	},

	_setOptions: function( options ) {
		if ( options.theme !== undefined ) {
			this._setTheme( options.theme );
		}

		if ( options.trackTheme !== undefined ) {
			this._setTrackTheme( options.trackTheme );
		}

		if ( options.corners !== undefined ) {
			this._setCorners( options.corners );
		}

		if ( options.mini !== undefined ) {
			this._setMini( options.mini );
		}

		if ( options.highlight !== undefined ) {
			this._setHighlight( options.highlight );
		}

		if ( options.disabled !== undefined ) {
			this._setDisabled( options.disabled );
		}
		this._super( options );
	},

	_controlChange: function( event ) {
		// if the user dragged the handle, the "change" event was triggered from inside refresh(); don't call refresh() again
		if ( this._trigger( "controlchange", event ) === false ) {
			return false;
		}
		if ( !this.mouseMoved ) {
			this.refresh( this._value(), true );
		}
	},

	_controlKeyup: function(/* event */) { // necessary?
		this.refresh( this._value(), true, true );
	},

	_controlBlur: function(/* event */) {
		this.refresh( this._value(), true );
	},

	// it appears the clicking the up and down buttons in chrome on
	// range/number inputs doesn't trigger a change until the field is
	// blurred. Here we check thif the value has changed and refresh
	_controlVMouseUp: function(/* event */) {
		this._checkedRefresh();
	},

	// NOTE force focus on handle
	_handleVMouseDown: function(/* event */) {
		this.handle.focus();
	},

	_handleKeydown: function( event ) {
		var index = this._value();
		if ( this.options.disabled ) {
			return;
		}

		// In all cases prevent the default and mark the handle as active
		switch ( event.keyCode ) {
			case $.mobile.keyCode.HOME:
			case $.mobile.keyCode.END:
			case $.mobile.keyCode.PAGE_UP:
			case $.mobile.keyCode.PAGE_DOWN:
			case $.mobile.keyCode.UP:
			case $.mobile.keyCode.RIGHT:
			case $.mobile.keyCode.DOWN:
			case $.mobile.keyCode.LEFT:
				event.preventDefault();

				if ( !this._keySliding ) {
					this._keySliding = true;
					this.handle.addClass( "ui-state-active" ); /* TODO: We don't use this class for styling. Do we need to add it? */
				}

				break;
		}

		// move the slider according to the keypress
		switch ( event.keyCode ) {
			case $.mobile.keyCode.HOME:
				this.refresh( this.min );
				break;
			case $.mobile.keyCode.END:
				this.refresh( this.max );
				break;
			case $.mobile.keyCode.PAGE_UP:
			case $.mobile.keyCode.UP:
			case $.mobile.keyCode.RIGHT:
				this.refresh( index + this.step );
				break;
			case $.mobile.keyCode.PAGE_DOWN:
			case $.mobile.keyCode.DOWN:
			case $.mobile.keyCode.LEFT:
				this.refresh( index - this.step );
				break;
		}
	}, // remove active mark

	_handleKeyup: function(/* event */) {
		if ( this._keySliding ) {
			this._keySliding = false;
			this.handle.removeClass( "ui-state-active" ); /* See comment above. */
		}
	},

	_sliderVMouseDown: function( event ) {
		// NOTE: we don't do this in refresh because we still want to
		//       support programmatic alteration of disabled inputs
		if ( this.options.disabled || !( event.which === 1 || event.which === 0 || event.which === undefined ) ) {
			return false;
		}
		if ( this._trigger( "beforestart", event ) === false ) {
			return false;
		}
		this.dragging = true;
		this.userModified = false;
		this.mouseMoved = false;

		if ( this.isToggleSwitch ) {
			this.beforeStart = this.element[0].selectedIndex;
		}

		this.refresh( event );
		this._trigger( "start" );
		return false;
	},

	_sliderVMouseUp: function() {
		if ( this.dragging ) {
			this.dragging = false;

			if ( this.isToggleSwitch ) {
				// make the handle move with a smooth transition
				this.handle.addClass( "ui-slider-handle-snapping" );

				if ( this.mouseMoved ) {
					// this is a drag, change the value only if user dragged enough
					if ( this.userModified ) {
						this.refresh( this.beforeStart === 0 ? 1 : 0 );
					} else {
						this.refresh( this.beforeStart );
					}
				} else {
					// this is just a click, change the value
					this.refresh( this.beforeStart === 0 ? 1 : 0 );
				}
			}

			this.mouseMoved = false;
			this._trigger( "stop" );
			return false;
		}
	},

	_preventDocumentDrag: function( event ) {
			// NOTE: we don't do this in refresh because we still want to
			//       support programmatic alteration of disabled inputs
			if ( this._trigger( "drag", event ) === false) {
				return false;
			}
			if ( this.dragging && !this.options.disabled ) {

				// this.mouseMoved must be updated before refresh() because it will be used in the control "change" event
				this.mouseMoved = true;

				if ( this.isToggleSwitch ) {
					// make the handle move in sync with the mouse
					this.handle.removeClass( "ui-slider-handle-snapping" );
				}

				this.refresh( event );

				// only after refresh() you can calculate this.userModified
				this.userModified = this.beforeStart !== this.element[0].selectedIndex;
				return false;
			}
		},

	_checkedRefresh: function() {
		if ( this.value !== this._value() ) {
			this.refresh( this._value() );
		}
	},

	_value: function() {
		return  this.isToggleSwitch ? this.element[0].selectedIndex : parseFloat( this.element.val() ) ;
	},

	_reset: function() {
		this.refresh( undefined, false, true );
	},

	refresh: function( val, isfromControl, preventInputUpdate ) {
		// NOTE: we don't return here because we want to support programmatic
		//       alteration of the input value, which should still update the slider

		var self = this,
			parentTheme = $.mobile.getAttribute( this.element[ 0 ], "theme" ),
			theme = this.options.theme || parentTheme,
			themeClass =  theme ? " ui-btn-" + theme : "",
			trackTheme = this.options.trackTheme || parentTheme,
			trackThemeClass = trackTheme ? " ui-bar-" + trackTheme : " ui-bar-inherit",
			cornerClass = this.options.corners ? " ui-corner-all" : "",
			miniClass = this.options.mini ? " ui-mini" : "",
			left, width, data, tol,
			pxStep, percent,
			control, isInput, optionElements, min, max, step,
			newval, valModStep, alignValue, percentPerStep,
			handlePercent, aPercent, bPercent,
			valueChanged;

		self.slider[0].className = [ this.isToggleSwitch ? "ui-slider ui-slider-switch ui-slider-track ui-shadow-inset" : "ui-slider-track ui-shadow-inset", trackThemeClass, cornerClass, miniClass ].join( "" );
		if ( this.options.disabled || this.element.prop( "disabled" ) ) {
			this.disable();
		}

		// set the stored value for comparison later
		this.value = this._value();
		if ( this.options.highlight && !this.isToggleSwitch && this.slider.find( ".ui-slider-bg" ).length === 0 ) {
			this.valuebg = (function() {
				var bg = document.createElement( "div" );
				bg.className = "ui-slider-bg " + $.mobile.activeBtnClass;
				return $( bg ).prependTo( self.slider );
			})();
		}
		this.handle.addClass( "ui-btn" + themeClass + " ui-shadow" );

		control = this.element;
		isInput = !this.isToggleSwitch;
		optionElements = isInput ? [] : control.find( "option" );
		min =  isInput ? parseFloat( control.attr( "min" ) ) : 0;
		max = isInput ? parseFloat( control.attr( "max" ) ) : optionElements.length - 1;
		step = ( isInput && parseFloat( control.attr( "step" ) ) > 0 ) ? parseFloat( control.attr( "step" ) ) : 1;

		if ( typeof val === "object" ) {
			data = val;
			// a slight tolerance helped get to the ends of the slider
			tol = 8;

			left = this.slider.offset().left;
			width = this.slider.width();
			pxStep = width/((max-min)/step);
			if ( !this.dragging ||
					data.pageX < left - tol ||
					data.pageX > left + width + tol ) {
				return;
			}
			if ( pxStep > 1 ) {
				percent = ( ( data.pageX - left ) / width ) * 100;
			} else {
				percent = Math.round( ( ( data.pageX - left ) / width ) * 100 );
			}
		} else {
			if ( val == null ) {
				val = isInput ? parseFloat( control.val() || 0 ) : control[0].selectedIndex;
			}
			percent = ( parseFloat( val ) - min ) / ( max - min ) * 100;
		}

		if ( isNaN( percent ) ) {
			return;
		}

		newval = ( percent / 100 ) * ( max - min ) + min;

		//from jQuery UI slider, the following source will round to the nearest step
		valModStep = ( newval - min ) % step;
		alignValue = newval - valModStep;

		if ( Math.abs( valModStep ) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		percentPerStep = 100/((max-min)/step);
		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see jQueryUI: #4124)
		newval = parseFloat( alignValue.toFixed(5) );

		if ( typeof pxStep === "undefined" ) {
			pxStep = width / ( (max-min) / step );
		}
		if ( pxStep > 1 && isInput ) {
			percent = ( newval - min ) * percentPerStep * ( 1 / step );
		}
		if ( percent < 0 ) {
			percent = 0;
		}

		if ( percent > 100 ) {
			percent = 100;
		}

		if ( newval < min ) {
			newval = min;
		}

		if ( newval > max ) {
			newval = max;
		}

		this.handle.css( "left", percent + "%" );

		this.handle[0].setAttribute( "aria-valuenow", isInput ? newval : optionElements.eq( newval ).attr( "value" ) );

		this.handle[0].setAttribute( "aria-valuetext", isInput ? newval : optionElements.eq( newval ).getEncodedText() );

		this.handle[0].setAttribute( "title", isInput ? newval : optionElements.eq( newval ).getEncodedText() );

		if ( this.valuebg ) {
			this.valuebg.css( "width", percent + "%" );
		}

		// drag the label widths
		if ( this._labels ) {
			handlePercent = this.handle.width() / this.slider.width() * 100;
			aPercent = percent && handlePercent + ( 100 - handlePercent ) * percent / 100;
			bPercent = percent === 100 ? 0 : Math.min( handlePercent + 100 - aPercent, 100 );

			this._labels.each(function() {
				var ab = $( this ).hasClass( "ui-slider-label-a" );
				$( this ).width( ( ab ? aPercent : bPercent  ) + "%" );
			});
		}

		if ( !preventInputUpdate ) {
			valueChanged = false;

			// update control"s value
			if ( isInput ) {
				valueChanged = control.val() !== newval;
				control.val( newval );
			} else {
				valueChanged = control[ 0 ].selectedIndex !== newval;
				control[ 0 ].selectedIndex = newval;
			}
			if ( this._trigger( "beforechange", val ) === false) {
					return false;
			}
			if ( !isfromControl && valueChanged ) {
				control.trigger( "change" );
			}
		}
	},

	_setHighlight: function( value ) {
		value = !!value;
		if ( value ) {
			this.options.highlight = !!value;
			this.refresh();
		} else if ( this.valuebg ) {
			this.valuebg.remove();
			this.valuebg = false;
		}
	},

	_setTheme: function( value ) {
		this.handle
			.removeClass( "ui-btn-" + this.options.theme )
			.addClass( "ui-btn-" + value );

		var currentTheme = this.options.theme ? this.options.theme : "inherit",
			newTheme = value ? value : "inherit";

		this.control
			.removeClass( "ui-body-" + currentTheme )
			.addClass( "ui-body-" + newTheme );
	},

	_setTrackTheme: function( value ) {
		var currentTrackTheme = this.options.trackTheme ? this.options.trackTheme : "inherit",
			newTrackTheme = value ? value : "inherit";

		this.slider
			.removeClass( "ui-body-" + currentTrackTheme )
			.addClass( "ui-body-" + newTrackTheme );
	},

	_setMini: function( value ) {
		value = !!value;
		if ( !this.isToggleSwitch && !this.isRangeslider ) {
			this.slider.parent().toggleClass( "ui-mini", value );
			this.element.toggleClass( "ui-mini", value );
		}
		this.slider.toggleClass( "ui-mini", value );
	},

	_setCorners: function( value ) {
		this.slider.toggleClass( "ui-corner-all", value );

		if ( !this.isToggleSwitch ) {
			this.control.toggleClass( "ui-corner-all", value );
		}
	},

	_setDisabled: function( value ) {
		value = !!value;
		this.element.prop( "disabled", value );
		this.slider
			.toggleClass( "ui-state-disabled", value )
			.attr( "aria-disabled", value );
	}

}, $.mobile.behaviors.formReset ) );

})( jQuery );

(function( $, undefined ) {

var popup;

function getPopup() {
	if ( !popup ) {
		popup = $( "<div></div>", {
			"class": "ui-slider-popup ui-shadow ui-corner-all"
		});
	}
	return popup.clone();
}

$.widget( "mobile.slider", $.mobile.slider, {
	options: {
		popupEnabled: false,
		showValue: false
	},

	_create: function() {
		this._super();

		$.extend( this, {
			_currentValue: null,
			_popup: null,
			_popupVisible: false
		});

		this._setOption( "popupEnabled", this.options.popupEnabled );

		this._on( this.handle, { "vmousedown" : "_showPopup" } );
		this._on( this.slider.add( this.document ), { "vmouseup" : "_hidePopup" } );
		this._refresh();
	},

	// position the popup centered 5px above the handle
	_positionPopup: function() {
		var dstOffset = this.handle.offset();

		this._popup.offset( {
			left: dstOffset.left + ( this.handle.width() - this._popup.width() ) / 2,
			top: dstOffset.top - this._popup.outerHeight() - 5
		});
	},

	_setOption: function( key, value ) {
		this._super( key, value );

		if ( key === "showValue" ) {
			this.handle.html( value && !this.options.mini ? this._value() : "" );
		} else if ( key === "popupEnabled" ) {
			if ( value && !this._popup ) {
				this._popup = getPopup()
					.addClass( "ui-body-" + ( this.options.theme || "a" ) )
					.hide()
					.insertBefore( this.element );
			}
		}
	},

	// show value on the handle and in popup
	refresh: function() {
		this._super.apply( this, arguments );
		this._refresh();
	},

	_refresh: function() {
		var o = this.options, newValue;

		if ( o.popupEnabled ) {
			// remove the title attribute from the handle (which is
			// responsible for the annoying tooltip); NB we have
			// to do it here as the jqm slider sets it every time
			// the slider's value changes :(
			this.handle.removeAttr( "title" );
		}

		newValue = this._value();
		if ( newValue === this._currentValue ) {
			return;
		}
		this._currentValue = newValue;

		if ( o.popupEnabled && this._popup ) {
			this._positionPopup();
			this._popup.html( newValue );
		}

		if ( o.showValue && !this.options.mini ) {
			this.handle.html( newValue );
		}
	},

	_showPopup: function() {
		if ( this.options.popupEnabled && !this._popupVisible ) {
			this.handle.html( "" );
			this._popup.show();
			this._positionPopup();
			this._popupVisible = true;
		}
	},

	_hidePopup: function() {
		var o = this.options;

		if ( o.popupEnabled && this._popupVisible ) {
			if ( o.showValue && !o.mini ) {
				this.handle.html( this._value() );
			}
			this._popup.hide();
			this._popupVisible = false;
		}
	}
});

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.flipswitch", $.extend({

	options: {
		onText: "On",
		offText: "Off",
		theme: null,
		enhanced: false,
		wrapperClass: null,
		corners: true,
		mini: false
	},

	_create: function() {
			if ( !this.options.enhanced ) {
				this._enhance();
			} else {
				$.extend( this, {
					flipswitch: this.element.parent(),
					on: this.element.find( ".ui-flipswitch-on" ).eq( 0 ),
					off: this.element.find( ".ui-flipswitch-off" ).eq(0),
					type: this.element.get( 0 ).tagName
				});
			}

			this._handleFormReset();

			// Transfer tabindex to "on" element and make input unfocusable
			this._originalTabIndex = this.element.attr( "tabindex" );
			if ( this._originalTabIndex != null ) {
				this.on.attr( "tabindex", this._originalTabIndex );
			}
			this.element.attr( "tabindex", "-1" );
			this._on({
				"focus" : "_handleInputFocus"
			});

			if ( this.element.is( ":disabled" ) ) {
				this._setOptions({
					"disabled": true
				});
			}

			this._on( this.flipswitch, {
				"click": "_toggle",
				"swipeleft": "_left",
				"swiperight": "_right"
			});

			this._on( this.on, {
				"keydown": "_keydown"
			});

			this._on( {
				"change": "refresh"
			});
	},

	_handleInputFocus: function() {
		this.on.focus();
	},

	widget: function() {
		return this.flipswitch;
	},

	_left: function() {
		this.flipswitch.removeClass( "ui-flipswitch-active" );
		if ( this.type === "SELECT" ) {
			this.element.get( 0 ).selectedIndex = 0;
		} else {
			this.element.prop( "checked", false );
		}
		this.element.trigger( "change" );
	},

	_right: function() {
		this.flipswitch.addClass( "ui-flipswitch-active" );
		if ( this.type === "SELECT" ) {
			this.element.get( 0 ).selectedIndex = 1;
		} else {
			this.element.prop( "checked", true );
		}
		this.element.trigger( "change" );
	},

	_enhance: function() {
		var flipswitch = $( "<div>" ),
			options = this.options,
			element = this.element,
			theme = options.theme ? options.theme : "inherit",

			// The "on" button is an anchor so it's focusable
			on = $( "<a></a>", {
				"href": "#"
			}),
			off = $( "<span></span>" ),
			type = element.get( 0 ).tagName,
			onText = ( type === "INPUT" ) ?
				options.onText : element.find( "option" ).eq( 1 ).text(),
			offText = ( type === "INPUT" ) ?
				options.offText : element.find( "option" ).eq( 0 ).text();

			on
				.addClass( "ui-flipswitch-on ui-btn ui-shadow ui-btn-inherit" )
				.text( onText );
			off
				.addClass( "ui-flipswitch-off" )
				.text( offText );

			flipswitch
				.addClass( "ui-flipswitch ui-shadow-inset " +
					"ui-bar-" + theme + " " +
					( options.wrapperClass ? options.wrapperClass : "" ) + " " +
					( ( element.is( ":checked" ) ||
						element
							.find( "option" )
							.eq( 1 )
							.is( ":selected" ) ) ? "ui-flipswitch-active" : "" ) +
					( element.is(":disabled") ? " ui-state-disabled": "") +
					( options.corners ? " ui-corner-all": "" ) +
					( options.mini ? " ui-mini": "" ) )
				.append( on, off );

			element
				.addClass( "ui-flipswitch-input" )
				.after( flipswitch )
				.appendTo( flipswitch );

		$.extend( this, {
			flipswitch: flipswitch,
			on: on,
			off: off,
			type: type
		});
	},

	_reset: function() {
		this.refresh();
	},

	refresh: function() {
		var direction,
			existingDirection = this.flipswitch.hasClass( "ui-flipswitch-active" ) ? "_right" : "_left";

		if ( this.type === "SELECT" ) {
			direction = ( this.element.get( 0 ).selectedIndex > 0 ) ? "_right": "_left";
		} else {
			direction = this.element.prop( "checked" ) ? "_right": "_left";
		}

		if ( direction !== existingDirection ) {
			this[ direction ]();
		}
	},

	_toggle: function() {
		var direction = this.flipswitch.hasClass( "ui-flipswitch-active" ) ? "_left" : "_right";

		this[ direction ]();
	},

	_keydown: function( e ) {
		if ( e.which === $.mobile.keyCode.LEFT ) {
			this._left();
		} else if ( e.which === $.mobile.keyCode.RIGHT ) {
			this._right();
		} else if ( e.which === $.mobile.keyCode.SPACE ) {
			this._toggle();
			e.preventDefault();
		}
	},

	_setOptions: function( options ) {
		if ( options.theme !== undefined ) {
			var currentTheme = options.theme ? options.theme : "inherit",
				newTheme = options.theme ? options.theme : "inherit";

			this.widget()
				.removeClass( "ui-bar-" + currentTheme )
				.addClass( "ui-bar-" + newTheme );
		}
		if ( options.onText !== undefined ) {
			this.on.text( options.onText );
		}
		if ( options.offText !== undefined ) {
			this.off.text( options.offText );
		}
		if ( options.disabled !== undefined ) {
			this.widget().toggleClass( "ui-state-disabled", options.disabled );
		}
		if ( options.mini !== undefined ) {
			this.widget().toggleClass( "ui-mini", options.mini );
		}
		if ( options.corners !== undefined ) {
			this.widget().toggleClass( "ui-corner-all", options.corners );
		}

		this._super( options );
	},

	_destroy: function() {
		if ( this.options.enhanced ) {
			return;
		}
		if ( this._originalTabIndex != null ) {
			this.element.attr( "tabindex", this._originalTabIndex );
		} else {
			this.element.removeAttr( "tabindex" );
		}
		this.on.remove();
		this.off.remove();
		this.element.unwrap();
		this.flipswitch.remove();
		this.removeClass( "ui-flipswitch-input" );
	}

}, $.mobile.behaviors.formReset ) );

})( jQuery );

(function( $, undefined ) {
	$.widget( "mobile.rangeslider", $.extend( {

		options: {
			theme: null,
			trackTheme: null,
			corners: true,
			mini: false,
			highlight: true
		},

		_create: function() {
			var $el = this.element,
			elClass = this.options.mini ? "ui-rangeslider ui-mini" : "ui-rangeslider",
			_inputFirst = $el.find( "input" ).first(),
			_inputLast = $el.find( "input" ).last(),
			_label = $el.find( "label" ).first(),
			_sliderWidgetFirst = $.data( _inputFirst.get( 0 ), "mobile-slider" ) ||
				$.data( _inputFirst.slider().get( 0 ), "mobile-slider" ),
			_sliderWidgetLast = $.data( _inputLast.get(0), "mobile-slider" ) ||
				$.data( _inputLast.slider().get( 0 ), "mobile-slider" ),
			_sliderFirst = _sliderWidgetFirst.slider,
			_sliderLast = _sliderWidgetLast.slider,
			firstHandle = _sliderWidgetFirst.handle,
			_sliders = $( "<div class='ui-rangeslider-sliders' />" ).appendTo( $el );

			_inputFirst.addClass( "ui-rangeslider-first" );
			_inputLast.addClass( "ui-rangeslider-last" );
			$el.addClass( elClass );

			_sliderFirst.appendTo( _sliders );
			_sliderLast.appendTo( _sliders );
			_label.insertBefore( $el );
			firstHandle.prependTo( _sliderLast );

			$.extend( this, {
				_inputFirst: _inputFirst,
				_inputLast: _inputLast,
				_sliderFirst: _sliderFirst,
				_sliderLast: _sliderLast,
				_label: _label,
				_targetVal: null,
				_sliderTarget: false,
				_sliders: _sliders,
				_proxy: false
			});

			this.refresh();
			this._on( this.element.find( "input.ui-slider-input" ), {
				"slidebeforestart": "_slidebeforestart",
				"slidestop": "_slidestop",
				"slidedrag": "_slidedrag",
				"slidebeforechange": "_change",
				"blur": "_change",
				"keyup": "_change"
			});
			this._on({
				"mousedown":"_change"
			});
			this._on( this.element.closest( "form" ), {
				"reset":"_handleReset"
			});
			this._on( firstHandle, {
				"vmousedown": "_dragFirstHandle"
			});
		},
		_handleReset: function() {
			var self = this;
			//we must wait for the stack to unwind before updateing other wise sliders will not have updated yet
			setTimeout( function() {
				self._updateHighlight();
			},0);
		},

		_dragFirstHandle: function( event ) {
			//if the first handle is dragged send the event to the first slider
			$.data( this._inputFirst.get(0), "mobile-slider" ).dragging = true;
			$.data( this._inputFirst.get(0), "mobile-slider" ).refresh( event );
			return false;
		},

		_slidedrag: function( event ) {
			var first = $( event.target ).is( this._inputFirst ),
				otherSlider = ( first ) ? this._inputLast : this._inputFirst;

			this._sliderTarget = false;
			//if the drag was initiated on an extreme and the other handle is focused send the events to
			//the closest handle
			if ( ( this._proxy === "first" && first ) || ( this._proxy === "last" && !first ) ) {
				$.data( otherSlider.get(0), "mobile-slider" ).dragging = true;
				$.data( otherSlider.get(0), "mobile-slider" ).refresh( event );
				return false;
			}
		},

		_slidestop: function( event ) {
			var first = $( event.target ).is( this._inputFirst );

			this._proxy = false;
			//this stops dragging of the handle and brings the active track to the front
			//this makes clicks on the track go the the last handle used
			this.element.find( "input" ).trigger( "vmouseup" );
			this._sliderFirst.css( "z-index", first ? 1 : "" );
		},

		_slidebeforestart: function( event ) {
			this._sliderTarget = false;
			//if the track is the target remember this and the original value
			if ( $( event.originalEvent.target ).hasClass( "ui-slider-track" ) ) {
				this._sliderTarget = true;
				this._targetVal = $( event.target ).val();
			}
		},

		_setOptions: function( options ) {
			if ( options.theme !== undefined ) {
				this._setTheme( options.theme );
			}

			if ( options.trackTheme !== undefined ) {
				this._setTrackTheme( options.trackTheme );
			}

			if ( options.mini !== undefined ) {
				this._setMini( options.mini );
			}

			if ( options.highlight !== undefined ) {
				this._setHighlight( options.highlight );
			}
			this._super( options );
			this.refresh();
		},

		refresh: function() {
			var $el = this.element,
				o = this.options;

			if ( this._inputFirst.is( ":disabled" ) || this._inputLast.is( ":disabled" ) ) {
				this.options.disabled = true;
			}

			$el.find( "input" ).slider({
				theme: o.theme,
				trackTheme: o.trackTheme,
				disabled: o.disabled,
				corners: o.corners,
				mini: o.mini,
				highlight: o.highlight
			}).slider( "refresh" );
			this._updateHighlight();
		},

		_change: function( event ) {
			if ( event.type === "keyup" ) {
				this._updateHighlight();
				return false;
			}

			var self = this,
				min = parseFloat( this._inputFirst.val(), 10 ),
				max = parseFloat( this._inputLast.val(), 10 ),
				first = $( event.target ).hasClass( "ui-rangeslider-first" ),
				thisSlider = first ? this._inputFirst : this._inputLast,
				otherSlider = first ? this._inputLast : this._inputFirst;

			if ( ( this._inputFirst.val() > this._inputLast.val() && event.type === "mousedown" && !$(event.target).hasClass("ui-slider-handle")) ) {
				thisSlider.blur();
			} else if ( event.type === "mousedown" ) {
				return;
			}
			if ( min > max && !this._sliderTarget ) {
				//this prevents min from being greater then max
				thisSlider.val( first ? max: min ).slider( "refresh" );
				this._trigger( "normalize" );
			} else if ( min > max ) {
				//this makes it so clicks on the target on either extreme go to the closest handle
				thisSlider.val( this._targetVal ).slider( "refresh" );

				//You must wait for the stack to unwind so first slider is updated before updating second
				setTimeout( function() {
					otherSlider.val( first ? min: max ).slider( "refresh" );
					$.data( otherSlider.get(0), "mobile-slider" ).handle.focus();
					self._sliderFirst.css( "z-index", first ? "" : 1 );
					self._trigger( "normalize" );
				}, 0 );
				this._proxy = ( first ) ? "first" : "last";
			}
			//fixes issue where when both _sliders are at min they cannot be adjusted
			if ( min === max ) {
				$.data( thisSlider.get(0), "mobile-slider" ).handle.css( "z-index", 1 );
				$.data( otherSlider.get(0), "mobile-slider" ).handle.css( "z-index", 0 );
			} else {
				$.data( otherSlider.get(0), "mobile-slider" ).handle.css( "z-index", "" );
				$.data( thisSlider.get(0), "mobile-slider" ).handle.css( "z-index", "" );
			}

			this._updateHighlight();

			if ( min >= max ) {
				return false;
			}
		},

		_updateHighlight: function() {
			var min = parseInt( $.data( this._inputFirst.get(0), "mobile-slider" ).handle.get(0).style.left, 10 ),
				max = parseInt( $.data( this._inputLast.get(0), "mobile-slider" ).handle.get(0).style.left, 10 ),
				width = (max - min);

			this.element.find( ".ui-slider-bg" ).css({
				"margin-left": min + "%",
				"width": width + "%"
			});
		},

		_setTheme: function( value ) {
			this._inputFirst.slider( "option", "theme", value );
			this._inputLast.slider( "option", "theme", value );
		},

		_setTrackTheme: function( value ) {
			this._inputFirst.slider( "option", "trackTheme", value );
			this._inputLast.slider( "option", "trackTheme", value );
		},

		_setMini: function( value ) {
			this._inputFirst.slider( "option", "mini", value );
			this._inputLast.slider( "option", "mini", value );
			this.element.toggleClass( "ui-mini", !!value );
		},

		_setHighlight: function( value ) {
			this._inputFirst.slider( "option", "highlight", value );
			this._inputLast.slider( "option", "highlight", value );
		},

		_destroy: function() {
			this._label.prependTo( this.element );
			this.element.removeClass( "ui-rangeslider ui-mini" );
			this._inputFirst.after( this._sliderFirst );
			this._inputLast.after( this._sliderLast );
			this._sliders.remove();
			this.element.find( "input" ).removeClass( "ui-rangeslider-first ui-rangeslider-last" ).slider( "destroy" );
		}

	}, $.mobile.behaviors.formReset ) );

})( jQuery );

(function( $, undefined ) {

	$.widget( "mobile.textinput", $.mobile.textinput, {
		options: {
			clearBtn: false,
			clearBtnText: "Clear text"
		},

		_create: function() {
			this._super();

			if ( !!this.options.clearBtn || this.isSearch ) {
				this._addClearBtn();
			}
		},

		clearButton: function() {

			return $( "<a href='#' class='ui-input-clear ui-btn ui-icon-delete ui-btn-icon-notext ui-corner-all" +
    "' title='" + this.options.clearBtnText + "'>" + this.options.clearBtnText + "</a>" );

		},

		_clearBtnClick: function( event ) {
			this.element.val( "" )
					.focus()
					.trigger( "change" );

			this._clearBtn.addClass( "ui-input-clear-hidden" );
			event.preventDefault();
		},

		_addClearBtn: function() {

			if ( !this.options.enhanced ) {
				this._enhanceClear();
			}

			$.extend( this, {
				_clearBtn: this.widget().find("a.ui-input-clear")
			});

			this._bindClearEvents();

			this._toggleClear();

		},

		_enhanceClear: function() {

			this.clearButton().appendTo( this.widget() );
			this.widget().addClass( "ui-input-has-clear" );

		},

		_bindClearEvents: function() {

			this._on( this._clearBtn, {
				"click": "_clearBtnClick"
			});

			this._on({
				"keyup": "_toggleClear",
				"change": "_toggleClear",
				"input": "_toggleClear",
				"focus": "_toggleClear",
				"blur": "_toggleClear",
				"cut": "_toggleClear",
				"paste": "_toggleClear"

			});

		},

		_unbindClear: function() {
			this._off( this._clearBtn, "click");
			this._off( this.element, "keyup change input focus blur cut paste" );
		},

		_setOptions: function( options ) {
			this._super( options );

			if ( options.clearBtn !== undefined &&
				!this.element.is( "textarea, :jqmData(type='range')" ) ) {
				if ( options.clearBtn ) {
					this._addClearBtn();
				} else {
					this._destroyClear();
				}
			}

			if ( options.clearBtnText !== undefined && this._clearBtn !== undefined ) {
				this._clearBtn.text( options.clearBtnText )
					.attr("title", options.clearBtnText);
			}
		},

		_toggleClear: function() {
			this._delay( "_toggleClearClass", 0 );
		},

		_toggleClearClass: function() {
			this._clearBtn.toggleClass( "ui-input-clear-hidden", !this.element.val() );
		},

		_destroyClear: function() {
			this.widget().removeClass( "ui-input-has-clear" );
			this._unbindClear();
			this._clearBtn.remove();
		},

		_destroy: function() {
			this._super();
			this._destroyClear();
		}

	});

})( jQuery );

(function( $, undefined ) {

	$.widget( "mobile.textinput", $.mobile.textinput, {
		options: {
			autogrow:true,
			keyupTimeoutBuffer: 100
		},

		_create: function() {
			this._super();

			if ( this.options.autogrow && this.isTextarea ) {
				this._autogrow();
			}
		},

		_autogrow: function() {
			this.element.addClass( "ui-textinput-autogrow" );

			this._on({
				"keyup": "_timeout",
				"change": "_timeout",
				"input": "_timeout",
				"paste": "_timeout"
			});

			// Attach to the various you-have-become-visible notifications that the
			// various framework elements emit.
			// TODO: Remove all but the updatelayout handler once #6426 is fixed.
			this._on( true, this.document, {

				// TODO: Move to non-deprecated event
				"pageshow": "_handleShow",
				"popupbeforeposition": "_handleShow",
				"updatelayout": "_handleShow",
				"panelopen": "_handleShow"
			});
		},

		// Synchronously fix the widget height if this widget's parents are such
		// that they show/hide content at runtime. We still need to check whether
		// the widget is actually visible in case it is contained inside multiple
		// such containers. For example: panel contains collapsible contains
		// autogrow textinput. The panel may emit "panelopen" indicating that its
		// content has become visible, but the collapsible is still collapsed, so
		// the autogrow textarea is still not visible.
		_handleShow: function( event ) {
			if ( $.contains( event.target, this.element[ 0 ] ) &&
				this.element.is( ":visible" ) ) {

				if ( event.type !== "popupbeforeposition" ) {
					this.element
						.addClass( "ui-textinput-autogrow-resize" )
						.animationComplete(
							$.proxy( function() {
								this.element.removeClass( "ui-textinput-autogrow-resize" );
							}, this ),
						"transition" );
				}
				this._timeout();
			}
		},

		_unbindAutogrow: function() {
			this.element.removeClass( "ui-textinput-autogrow" );
			this._off( this.element, "keyup change input paste" );
			this._off( this.document,
				"pageshow popupbeforeposition updatelayout panelopen" );
		},

		keyupTimeout: null,

		_prepareHeightUpdate: function( delay ) {
			if ( this.keyupTimeout ) {
				clearTimeout( this.keyupTimeout );
			}
			if ( delay === undefined ) {
				this._updateHeight();
			} else {
				this.keyupTimeout = this._delay( "_updateHeight", delay );
			}
		},

		_timeout: function() {
			this._prepareHeightUpdate( this.options.keyupTimeoutBuffer );
		},

		_updateHeight: function() {
			var paddingTop, paddingBottom, paddingHeight, scrollHeight, clientHeight,
				borderTop, borderBottom, borderHeight, height,
				scrollTop = this.window.scrollTop();
			this.keyupTimeout = 0;

			// IE8 textareas have the onpage property - others do not
			if ( !( "onpage" in this.element[ 0 ] ) ) {
				this.element.css({
					"height": 0,
					"min-height": 0,
					"max-height": 0
				});
			}

			scrollHeight = this.element[ 0 ].scrollHeight;
			clientHeight = this.element[ 0 ].clientHeight;
			borderTop = parseFloat( this.element.css( "border-top-width" ) );
			borderBottom = parseFloat( this.element.css( "border-bottom-width" ) );
			borderHeight = borderTop + borderBottom;
			height = scrollHeight + borderHeight + 15;

			// Issue 6179: Padding is not included in scrollHeight and
			// clientHeight by Firefox if no scrollbar is visible. Because
			// textareas use the border-box box-sizing model, padding should be
			// included in the new (assigned) height. Because the height is set
			// to 0, clientHeight == 0 in Firefox. Therefore, we can use this to
			// check if padding must be added.
			if ( clientHeight === 0 ) {
				paddingTop = parseFloat( this.element.css( "padding-top" ) );
				paddingBottom = parseFloat( this.element.css( "padding-bottom" ) );
				paddingHeight = paddingTop + paddingBottom;

				height += paddingHeight;
			}

			this.element.css({
				"height": height,
				"min-height": "",
				"max-height": ""
			});

			this.window.scrollTop( scrollTop );
		},

		refresh: function() {
			if ( this.options.autogrow && this.isTextarea ) {
				this._updateHeight();
			}
		},

		_setOptions: function( options ) {

			this._super( options );

			if ( options.autogrow !== undefined && this.isTextarea ) {
				if ( options.autogrow ) {
					this._autogrow();
				} else {
					this._unbindAutogrow();
				}
			}
		}

	});
})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.selectmenu", $.extend( {
	initSelector: "select:not( :jqmData(role='slider')):not( :jqmData(role='flipswitch') )",

	options: {
		theme: null,
		icon: "carat-d",
		iconpos: "right",
		inline: false,
		corners: true,
		shadow: true,
		iconshadow: false, /* TODO: Deprecated in 1.4, remove in 1.5. */
		overlayTheme: null,
		dividerTheme: null,
		hidePlaceholderMenuItems: true,
		closeText: "Close",
		nativeMenu: true,
		// This option defaults to true on iOS devices.
		preventFocusZoom: /iPhone|iPad|iPod/.test( navigator.platform ) && navigator.userAgent.indexOf( "AppleWebKit" ) > -1,
		mini: false
	},

	_button: function() {
		return $( "<div/>" );
	},

	_setDisabled: function( value ) {
		this.element.attr( "disabled", value );
		this.button.attr( "aria-disabled", value );
		return this._setOption( "disabled", value );
	},

	_focusButton : function() {
		var self = this;

		setTimeout( function() {
			self.button.focus();
		}, 40);
	},

	_selectOptions: function() {
		return this.select.find( "option" );
	},

	// setup items that are generally necessary for select menu extension
	_preExtension: function() {
		var inline = this.options.inline || this.element.jqmData( "inline" ),
			mini = this.options.mini || this.element.jqmData( "mini" ),
			classes = "";
		// TODO: Post 1.1--once we have time to test thoroughly--any classes manually applied to the original element should be carried over to the enhanced element, with an `-enhanced` suffix. See https://github.com/jquery/jquery-mobile/issues/3577
		/* if ( $el[0].className.length ) {
			classes = $el[0].className;
		} */
		if ( !!~this.element[0].className.indexOf( "ui-btn-left" ) ) {
			classes = " ui-btn-left";
		}

		if (  !!~this.element[0].className.indexOf( "ui-btn-right" ) ) {
			classes = " ui-btn-right";
		}

		if ( inline ) {
			classes += " ui-btn-inline";
		}
		if ( mini ) {
			classes += " ui-mini";
		}

		this.select = this.element.removeClass( "ui-btn-left ui-btn-right" ).wrap( "<div class='ui-select" + classes + "'>" );
		this.selectId  = this.select.attr( "id" ) || ( "select-" + this.uuid );
		this.buttonId = this.selectId + "-button";
		this.label = $( "label[for='"+ this.selectId +"']" );
		this.isMultiple = this.select[ 0 ].multiple;
	},

	_destroy: function() {
		var wrapper = this.element.parents( ".ui-select" );
		if ( wrapper.length > 0 ) {
			if ( wrapper.is( ".ui-btn-left, .ui-btn-right" ) ) {
				this.element.addClass( wrapper.hasClass( "ui-btn-left" ) ? "ui-btn-left" : "ui-btn-right" );
			}
			this.element.insertAfter( wrapper );
			wrapper.remove();
		}
	},

	_create: function() {
		this._preExtension();

		this.button = this._button();

		var self = this,

			options = this.options,

			iconpos = options.icon ? ( options.iconpos || this.select.jqmData( "iconpos" ) ) : false,

			button = this.button
				.insertBefore( this.select )
				.attr( "id", this.buttonId )
				.addClass( "ui-btn" +
					( options.icon ? ( " ui-icon-" + options.icon + " ui-btn-icon-" + iconpos +
					( options.iconshadow ? " ui-shadow-icon" : "" ) ) :	"" ) + /* TODO: Remove in 1.5. */
					( options.theme ? " ui-btn-" + options.theme : "" ) +
					( options.corners ? " ui-corner-all" : "" ) +
					( options.shadow ? " ui-shadow" : "" ) );

		this.setButtonText();

		// Opera does not properly support opacity on select elements
		// In Mini, it hides the element, but not its text
		// On the desktop,it seems to do the opposite
		// for these reasons, using the nativeMenu option results in a full native select in Opera
		if ( options.nativeMenu && window.opera && window.opera.version ) {
			button.addClass( "ui-select-nativeonly" );
		}

		// Add counter for multi selects
		if ( this.isMultiple ) {
			this.buttonCount = $( "<span>" )
				.addClass( "ui-li-count ui-body-inherit" )
				.hide()
				.appendTo( button.addClass( "ui-li-has-count" ) );
		}

		// Disable if specified
		if ( options.disabled || this.element.attr( "disabled" )) {
			this.disable();
		}

		// Events on native select
		this.select.change(function() {
			self.refresh();

			if ( !!options.nativeMenu ) {
				this.blur();
			}
		});

		this._handleFormReset();

		this._on( this.button, {
			keydown: "_handleKeydown"
		});

		this.build();
	},

	build: function() {
		var self = this;

		this.select
			.appendTo( self.button )
			.bind( "vmousedown", function() {
				// Add active class to button
				self.button.addClass( $.mobile.activeBtnClass );
			})
			.bind( "focus", function() {
				self.button.addClass( $.mobile.focusClass );
			})
			.bind( "blur", function() {
				self.button.removeClass( $.mobile.focusClass );
			})
			.bind( "focus vmouseover", function() {
				self.button.trigger( "vmouseover" );
			})
			.bind( "vmousemove", function() {
				// Remove active class on scroll/touchmove
				self.button.removeClass( $.mobile.activeBtnClass );
			})
			.bind( "change blur vmouseout", function() {
				self.button.trigger( "vmouseout" )
					.removeClass( $.mobile.activeBtnClass );
			});

		// In many situations, iOS will zoom into the select upon tap, this prevents that from happening
		self.button.bind( "vmousedown", function() {
			if ( self.options.preventFocusZoom ) {
					$.mobile.zoom.disable( true );
			}
		});
		self.label.bind( "click focus", function() {
			if ( self.options.preventFocusZoom ) {
					$.mobile.zoom.disable( true );
			}
		});
		self.select.bind( "focus", function() {
			if ( self.options.preventFocusZoom ) {
					$.mobile.zoom.disable( true );
			}
		});
		self.button.bind( "mouseup", function() {
			if ( self.options.preventFocusZoom ) {
				setTimeout(function() {
					$.mobile.zoom.enable( true );
				}, 0 );
			}
		});
		self.select.bind( "blur", function() {
			if ( self.options.preventFocusZoom ) {
				$.mobile.zoom.enable( true );
			}
		});

	},

	selected: function() {
		return this._selectOptions().filter( ":selected" );
	},

	selectedIndices: function() {
		var self = this;

		return this.selected().map(function() {
			return self._selectOptions().index( this );
		}).get();
	},

	setButtonText: function() {
		var self = this,
			selected = this.selected(),
			text = this.placeholder,
			span = $( document.createElement( "span" ) );

		this.button.children( "span" ).not( ".ui-li-count" ).remove().end().end().prepend( (function() {
			if ( selected.length ) {
				text = selected.map(function() {
					return $( this ).text();
				}).get().join( ", " );
			} else {
				text = self.placeholder;
			}

			if ( text ) {
				span.text( text );
			} else {

				// Set the contents to &nbsp; which we write as &#160; to be XHTML compliant - see gh-6699
				span.html( "&#160;" );
			}

			// TODO possibly aggregate multiple select option classes
			return span
				.addClass( self.select.attr( "class" ) )
				.addClass( selected.attr( "class" ) )
				.removeClass( "ui-screen-hidden" );
		})());
	},

	setButtonCount: function() {
		var selected = this.selected();

		// multiple count inside button
		if ( this.isMultiple ) {
			this.buttonCount[ selected.length > 1 ? "show" : "hide" ]().text( selected.length );
		}
	},

	_handleKeydown: function( /* event */ ) {
		this._delay( "_refreshButton" );
	},

	_reset: function() {
		this.refresh();
	},

	_refreshButton: function() {
		this.setButtonText();
		this.setButtonCount();
	},

	refresh: function() {
		this._refreshButton();
	},

	// open and close preserved in native selects
	// to simplify users code when looping over selects
	open: $.noop,
	close: $.noop,

	disable: function() {
		this._setDisabled( true );
		this.button.addClass( "ui-state-disabled" );
	},

	enable: function() {
		this._setDisabled( false );
		this.button.removeClass( "ui-state-disabled" );
	}
}, $.mobile.behaviors.formReset ) );

})( jQuery );

(function( $, undefined ) {

$.mobile.links = function( target ) {

	//links within content areas, tests included with page
	$( target )
		.find( "a" )
		.jqmEnhanceable()
		.filter( ":jqmData(rel='popup')[href][href!='']" )
		.each( function() {
			// Accessibility info for popups
			var element = this,
				idref = element.getAttribute( "href" ).substring( 1 );

			if ( idref ) {
				element.setAttribute( "aria-haspopup", true );
				element.setAttribute( "aria-owns", idref );
				element.setAttribute( "aria-expanded", false );
			}
		})
		.end()
		.not( ".ui-btn, :jqmData(role='none'), :jqmData(role='nojs')" )
		.addClass( "ui-link" );

};

})( jQuery );


(function( $, undefined ) {

function fitSegmentInsideSegment( windowSize, segmentSize, offset, desired ) {
	var returnValue = desired;

	if ( windowSize < segmentSize ) {
		// Center segment if it's bigger than the window
		returnValue = offset + ( windowSize - segmentSize ) / 2;
	} else {
		// Otherwise center it at the desired coordinate while keeping it completely inside the window
		returnValue = Math.min( Math.max( offset, desired - segmentSize / 2 ), offset + windowSize - segmentSize );
	}

	return returnValue;
}

function getWindowCoordinates( theWindow ) {
	return {
		x: theWindow.scrollLeft(),
		y: theWindow.scrollTop(),
		cx: ( theWindow[ 0 ].innerWidth || theWindow.width() ),
		cy: ( theWindow[ 0 ].innerHeight || theWindow.height() )
	};
}

$.widget( "mobile.popup", {
	options: {
		wrapperClass: null,
		theme: null,
		overlayTheme: null,
		shadow: true,
		corners: true,
		transition: "none",
		positionTo: "origin",
		tolerance: null,
		closeLinkSelector: "a:jqmData(rel='back')",
		closeLinkEvents: "click.popup",
		navigateEvents: "navigate.popup",
		closeEvents: "navigate.popup pagebeforechange.popup",
		dismissible: true,
		enhanced: false,

		// NOTE Windows Phone 7 has a scroll position caching issue that
		//      requires us to disable popup history management by default
		//      https://github.com/jquery/jquery-mobile/issues/4784
		//
		// NOTE this option is modified in _create!
		history: !$.mobile.browser.oldIE
	},

	// When the user depresses the mouse/finger on an element inside the popup while the popup is
	// open, we ignore resize events for a short while. This prevents #6961.
	_handleDocumentVmousedown: function( theEvent ) {
		if ( this._isOpen && $.contains( this._ui.container[ 0 ], theEvent.target ) ) {
			this._ignoreResizeEvents();
		}
	},

	_create: function() {
		var theElement = this.element,
			myId = theElement.attr( "id" ),
			currentOptions = this.options;

		// We need to adjust the history option to be false if there's no AJAX nav.
		// We can't do it in the option declarations because those are run before
		// it is determined whether there shall be AJAX nav.
		currentOptions.history = currentOptions.history && $.mobile.ajaxEnabled && $.mobile.hashListeningEnabled;

		this._on( this.document, {
			"vmousedown": "_handleDocumentVmousedown"
		});

		// Define instance variables
		$.extend( this, {
			_scrollTop: 0,
			_page: theElement.closest( ".ui-page" ),
			_ui: null,
			_fallbackTransition: "",
			_currentTransition: false,
			_prerequisites: null,
			_isOpen: false,
			_tolerance: null,
			_resizeData: null,
			_ignoreResizeTo: 0,
			_orientationchangeInProgress: false
		});

		if ( this._page.length === 0 ) {
			this._page = $( "body" );
		}

		if ( currentOptions.enhanced ) {
			this._ui = {
				container: theElement.parent(),
				screen: theElement.parent().prev(),
				placeholder: $( this.document[ 0 ].getElementById( myId + "-placeholder" ) )
			};
		} else {
			this._ui = this._enhance( theElement, myId );
			this._applyTransition( currentOptions.transition );
		}
		this
			._setTolerance( currentOptions.tolerance )
			._ui.focusElement = this._ui.container;

		// Event handlers
		this._on( this._ui.screen, { "vclick": "_eatEventAndClose" } );
		this._on( this.window, {
			orientationchange: $.proxy( this, "_handleWindowOrientationchange" ),
			resize: $.proxy( this, "_handleWindowResize" ),
			keyup: $.proxy( this, "_handleWindowKeyUp" )
		});
		this._on( this.document, { "focusin": "_handleDocumentFocusIn" } );
	},

	_enhance: function( theElement, myId ) {
		var currentOptions = this.options,
			wrapperClass = currentOptions.wrapperClass,
			ui = {
				screen: $( "<div class='ui-screen-hidden ui-popup-screen " +
				this._themeClassFromOption( "ui-overlay-", currentOptions.overlayTheme ) + "'></div>" ),
				placeholder: $( "<div style='display: none;'><!-- placeholder --></div>" ),
				container: $( "<div class='ui-popup-container ui-popup-hidden ui-popup-truncate" +
					( wrapperClass ? ( " " + wrapperClass ) : "" ) + "'></div>" )
			},
			fragment = this.document[ 0 ].createDocumentFragment();

		fragment.appendChild( ui.screen[ 0 ] );
		fragment.appendChild( ui.container[ 0 ] );

		if ( myId ) {
			ui.screen.attr( "id", myId + "-screen" );
			ui.container.attr( "id", myId + "-popup" );
			ui.placeholder
				.attr( "id", myId + "-placeholder" )
				.html( "<!-- placeholder for " + myId + " -->" );
		}

		// Apply the proto
		this._page[ 0 ].appendChild( fragment );
		// Leave a placeholder where the element used to be
		ui.placeholder.insertAfter( theElement );
		theElement
			.detach()
			.addClass( "ui-popup " +
				this._themeClassFromOption( "ui-body-", currentOptions.theme ) + " " +
				( currentOptions.shadow ? "ui-overlay-shadow " : "" ) +
				( currentOptions.corners ? "ui-corner-all " : "" ) )
			.appendTo( ui.container );

		return ui;
	},

	_eatEventAndClose: function( theEvent ) {
		theEvent.preventDefault();
		theEvent.stopImmediatePropagation();
		if ( this.options.dismissible ) {
			this.close();
		}
		return false;
	},

	// Make sure the screen covers the entire document - CSS is sometimes not
	// enough to accomplish this.
	_resizeScreen: function() {
		var screen = this._ui.screen,
			popupHeight = this._ui.container.outerHeight( true ),
			screenHeight = screen.removeAttr( "style" ).height(),

			// Subtracting 1 here is necessary for an obscure Andrdoid 4.0 bug where
			// the browser hangs if the screen covers the entire document :/
			documentHeight = this.document.height() - 1;

		if ( screenHeight < documentHeight ) {
			screen.height( documentHeight );
		} else if ( popupHeight > screenHeight ) {
			screen.height( popupHeight );
		}
	},

	_handleWindowKeyUp: function( theEvent ) {
		if ( this._isOpen && theEvent.keyCode === $.mobile.keyCode.ESCAPE ) {
			return this._eatEventAndClose( theEvent );
		}
	},

	_expectResizeEvent: function() {
		var windowCoordinates = getWindowCoordinates( this.window );

		if ( this._resizeData ) {
			if ( windowCoordinates.x === this._resizeData.windowCoordinates.x &&
				windowCoordinates.y === this._resizeData.windowCoordinates.y &&
				windowCoordinates.cx === this._resizeData.windowCoordinates.cx &&
				windowCoordinates.cy === this._resizeData.windowCoordinates.cy ) {
				// timeout not refreshed
				return false;
			} else {
				// clear existing timeout - it will be refreshed below
				clearTimeout( this._resizeData.timeoutId );
			}
		}

		this._resizeData = {
			timeoutId: this._delay( "_resizeTimeout", 200 ),
			windowCoordinates: windowCoordinates
		};

		return true;
	},

	_resizeTimeout: function() {
		if ( this._isOpen ) {
			if ( !this._expectResizeEvent() ) {
				if ( this._ui.container.hasClass( "ui-popup-hidden" ) ) {
					// effectively rapid-open the popup while leaving the screen intact
					this._ui.container.removeClass( "ui-popup-hidden ui-popup-truncate" );
					this.reposition( { positionTo: "window" } );
					this._ignoreResizeEvents();
				}

				this._resizeScreen();
				this._resizeData = null;
				this._orientationchangeInProgress = false;
			}
		} else {
			this._resizeData = null;
			this._orientationchangeInProgress = false;
		}
	},

	_stopIgnoringResizeEvents: function() {
		this._ignoreResizeTo = 0;
	},

	_ignoreResizeEvents: function() {
		if ( this._ignoreResizeTo ) {
			clearTimeout( this._ignoreResizeTo );
		}
		this._ignoreResizeTo = this._delay( "_stopIgnoringResizeEvents", 1000 );
	},

	_handleWindowResize: function(/* theEvent */) {
		if ( this._isOpen && this._ignoreResizeTo === 0 ) {
			if ( ( this._expectResizeEvent() || this._orientationchangeInProgress ) &&
				!this._ui.container.hasClass( "ui-popup-hidden" ) ) {
				// effectively rapid-close the popup while leaving the screen intact
				this._ui.container
					.addClass( "ui-popup-hidden ui-popup-truncate" )
					.removeAttr( "style" );
			}
		}
	},

	_handleWindowOrientationchange: function(/* theEvent */) {
		if ( !this._orientationchangeInProgress && this._isOpen && this._ignoreResizeTo === 0 ) {
			this._expectResizeEvent();
			this._orientationchangeInProgress = true;
		}
	},

	// When the popup is open, attempting to focus on an element that is not a
	// child of the popup will redirect focus to the popup
	_handleDocumentFocusIn: function( theEvent ) {
		var target,
			targetElement = theEvent.target,
			ui = this._ui;

		if ( !this._isOpen ) {
			return;
		}

		if ( targetElement !== ui.container[ 0 ] ) {
			target = $( targetElement );
			if ( 0 === target.parents().filter( ui.container[ 0 ] ).length ) {
				$( this.document[ 0 ].activeElement ).one( "focus", function(/* theEvent */) {
					target.blur();
				});
				ui.focusElement.focus();
				theEvent.preventDefault();
				theEvent.stopImmediatePropagation();
				return false;
			} else if ( ui.focusElement[ 0 ] === ui.container[ 0 ] ) {
				ui.focusElement = target;
			}
		}

		this._ignoreResizeEvents();
	},

	_themeClassFromOption: function( prefix, value ) {
		return ( value ? ( value === "none" ? "" : ( prefix + value ) ) : ( prefix + "inherit" ) );
	},

	_applyTransition: function( value ) {
		if ( value ) {
			this._ui.container.removeClass( this._fallbackTransition );
			if ( value !== "none" ) {
				this._fallbackTransition = $.mobile._maybeDegradeTransition( value );
				if ( this._fallbackTransition === "none" ) {
					this._fallbackTransition = "";
				}
				this._ui.container.addClass( this._fallbackTransition );
			}
		}

		return this;
	},

	_setOptions: function( newOptions ) {
		var currentOptions = this.options,
			theElement = this.element,
			screen = this._ui.screen;

		if ( newOptions.wrapperClass !== undefined ) {
			this._ui.container
				.removeClass( currentOptions.wrapperClass )
				.addClass( newOptions.wrapperClass );
		}

		if ( newOptions.theme !== undefined ) {
			theElement
				.removeClass( this._themeClassFromOption( "ui-body-", currentOptions.theme ) )
				.addClass( this._themeClassFromOption( "ui-body-", newOptions.theme ) );
		}

		if ( newOptions.overlayTheme !== undefined ) {
			screen
				.removeClass( this._themeClassFromOption( "ui-overlay-", currentOptions.overlayTheme ) )
				.addClass( this._themeClassFromOption( "ui-overlay-", newOptions.overlayTheme ) );

			if ( this._isOpen ) {
				screen.addClass( "in" );
			}
		}

		if ( newOptions.shadow !== undefined ) {
			theElement.toggleClass( "ui-overlay-shadow", newOptions.shadow );
		}

		if ( newOptions.corners !== undefined ) {
			theElement.toggleClass( "ui-corner-all", newOptions.corners );
		}

		if ( newOptions.transition !== undefined ) {
			if ( !this._currentTransition ) {
				this._applyTransition( newOptions.transition );
			}
		}

		if ( newOptions.tolerance !== undefined ) {
			this._setTolerance( newOptions.tolerance );
		}

		if ( newOptions.disabled !== undefined ) {
			if ( newOptions.disabled ) {
				this.close();
			}
		}

		return this._super( newOptions );
	},

	_setTolerance: function( value ) {
		var tol = { t: 30, r: 15, b: 30, l: 15 },
			ar;

		if ( value !== undefined ) {
			ar = String( value ).split( "," );

			$.each( ar, function( idx, val ) { ar[ idx ] = parseInt( val, 10 ); } );

			switch( ar.length ) {
				// All values are to be the same
				case 1:
					if ( !isNaN( ar[ 0 ] ) ) {
						tol.t = tol.r = tol.b = tol.l = ar[ 0 ];
					}
					break;

				// The first value denotes top/bottom tolerance, and the second value denotes left/right tolerance
				case 2:
					if ( !isNaN( ar[ 0 ] ) ) {
						tol.t = tol.b = ar[ 0 ];
					}
					if ( !isNaN( ar[ 1 ] ) ) {
						tol.l = tol.r = ar[ 1 ];
					}
					break;

				// The array contains values in the order top, right, bottom, left
				case 4:
					if ( !isNaN( ar[ 0 ] ) ) {
						tol.t = ar[ 0 ];
					}
					if ( !isNaN( ar[ 1 ] ) ) {
						tol.r = ar[ 1 ];
					}
					if ( !isNaN( ar[ 2 ] ) ) {
						tol.b = ar[ 2 ];
					}
					if ( !isNaN( ar[ 3 ] ) ) {
						tol.l = ar[ 3 ];
					}
					break;

				default:
					break;
			}
		}

		this._tolerance = tol;
		return this;
	},

	_clampPopupWidth: function( infoOnly ) {
		var menuSize,
			windowCoordinates = getWindowCoordinates( this.window ),
			// rectangle within which the popup must fit
			rectangle = {
				x: this._tolerance.l,
				y: windowCoordinates.y + this._tolerance.t,
				cx: windowCoordinates.cx - this._tolerance.l - this._tolerance.r,
				cy: windowCoordinates.cy - this._tolerance.t - this._tolerance.b
			};

		if ( !infoOnly ) {
			// Clamp the width of the menu before grabbing its size
			this._ui.container.css( "max-width", rectangle.cx );
		}

		menuSize = {
			cx: this._ui.container.outerWidth( true ),
			cy: this._ui.container.outerHeight( true )
		};

		return { rc: rectangle, menuSize: menuSize };
	},

	_calculateFinalLocation: function( desired, clampInfo ) {
		var returnValue,
			rectangle = clampInfo.rc,
			menuSize = clampInfo.menuSize;

		// Center the menu over the desired coordinates, while not going outside
		// the window tolerances. This will center wrt. the window if the popup is
		// too large.
		returnValue = {
			left: fitSegmentInsideSegment( rectangle.cx, menuSize.cx, rectangle.x, desired.x ),
			top: fitSegmentInsideSegment( rectangle.cy, menuSize.cy, rectangle.y, desired.y )
		};

		// Make sure the top of the menu is visible
		returnValue.top = Math.max( 0, returnValue.top );

		// If the height of the menu is smaller than the height of the document
		// align the bottom with the bottom of the document

		returnValue.top -= Math.min( returnValue.top,
			Math.max( 0, returnValue.top + menuSize.cy - this.document.height() ) );

		return returnValue;
	},

	// Try and center the overlay over the given coordinates
	_placementCoords: function( desired ) {
		return this._calculateFinalLocation( desired, this._clampPopupWidth() );
	},

	_createPrerequisites: function( screenPrerequisite, containerPrerequisite, whenDone ) {
		var prerequisites,
			self = this;

		// It is important to maintain both the local variable prerequisites and
		// self._prerequisites. The local variable remains in the closure of the
		// functions which call the callbacks passed in. The comparison between the
		// local variable and self._prerequisites is necessary, because once a
		// function has been passed to .animationComplete() it will be called next
		// time an animation completes, even if that's not the animation whose end
		// the function was supposed to catch (for example, if an abort happens
		// during the opening animation, the .animationComplete handler is not
		// called for that animation anymore, but the handler remains attached, so
		// it is called the next time the popup is opened - making it stale.
		// Comparing the local variable prerequisites to the widget-level variable
		// self._prerequisites ensures that callbacks triggered by a stale
		// .animationComplete will be ignored.

		prerequisites = {
			screen: $.Deferred(),
			container: $.Deferred()
		};

		prerequisites.screen.then( function() {
			if ( prerequisites === self._prerequisites ) {
				screenPrerequisite();
			}
		});

		prerequisites.container.then( function() {
			if ( prerequisites === self._prerequisites ) {
				containerPrerequisite();
			}
		});

		$.when( prerequisites.screen, prerequisites.container ).done( function() {
			if ( prerequisites === self._prerequisites ) {
				self._prerequisites = null;
				whenDone();
			}
		});

		self._prerequisites = prerequisites;
	},

	_animate: function( args ) {
		// NOTE before removing the default animation of the screen
		//      this had an animate callback that would resolve the deferred
		//      now the deferred is resolved immediately
		// TODO remove the dependency on the screen deferred
		this._ui.screen
			.removeClass( args.classToRemove )
			.addClass( args.screenClassToAdd );

		args.prerequisites.screen.resolve();

		if ( args.transition && args.transition !== "none" ) {
			if ( args.applyTransition ) {
				this._applyTransition( args.transition );
			}
			if ( this._fallbackTransition ) {
				this._ui.container
					.addClass( args.containerClassToAdd )
					.removeClass( args.classToRemove )
					.animationComplete( $.proxy( args.prerequisites.container, "resolve" ) );
				return;
			}
		}
		this._ui.container.removeClass( args.classToRemove );
		args.prerequisites.container.resolve();
	},

	// The desired coordinates passed in will be returned untouched if no reference element can be identified via
	// desiredPosition.positionTo. Nevertheless, this function ensures that its return value always contains valid
	// x and y coordinates by specifying the center middle of the window if the coordinates are absent.
	// options: { x: coordinate, y: coordinate, positionTo: string: "origin", "window", or jQuery selector
	_desiredCoords: function( openOptions ) {
		var offset,
			dst = null,
			windowCoordinates = getWindowCoordinates( this.window ),
			x = openOptions.x,
			y = openOptions.y,
			pTo = openOptions.positionTo;

		// Establish which element will serve as the reference
		if ( pTo && pTo !== "origin" ) {
			if ( pTo === "window" ) {
				x = windowCoordinates.cx / 2 + windowCoordinates.x;
				y = windowCoordinates.cy / 2 + windowCoordinates.y;
			} else {
				try {
					dst = $( pTo );
				} catch( err ) {
					dst = null;
				}
				if ( dst ) {
					dst.filter( ":visible" );
					if ( dst.length === 0 ) {
						dst = null;
					}
				}
			}
		}

		// If an element was found, center over it
		if ( dst ) {
			offset = dst.offset();
			x = offset.left + dst.outerWidth() / 2;
			y = offset.top + dst.outerHeight() / 2;
		}

		// Make sure x and y are valid numbers - center over the window
		if ( $.type( x ) !== "number" || isNaN( x ) ) {
			x = windowCoordinates.cx / 2 + windowCoordinates.x;
		}
		if ( $.type( y ) !== "number" || isNaN( y ) ) {
			y = windowCoordinates.cy / 2 + windowCoordinates.y;
		}

		return { x: x, y: y };
	},

	_reposition: function( openOptions ) {
		// We only care about position-related parameters for repositioning
		openOptions = {
			x: openOptions.x,
			y: openOptions.y,
			positionTo: openOptions.positionTo
		};
		this._trigger( "beforeposition", undefined, openOptions );
		this._ui.container.offset( this._placementCoords( this._desiredCoords( openOptions ) ) );
	},

	reposition: function( openOptions ) {
		if ( this._isOpen ) {
			this._reposition( openOptions );
		}
	},

	_openPrerequisitesComplete: function() {
		var id = this.element.attr( "id" );

		this._ui.container.addClass( "ui-popup-active" );
		this._isOpen = true;
		this._resizeScreen();
		this._ui.container.attr( "tabindex", "0" ).focus();
		this._ignoreResizeEvents();
		if ( id ) {
			this.document.find( "[aria-haspopup='true'][aria-owns='" +  id + "']" ).attr( "aria-expanded", true );
		}
		this._trigger( "afteropen" );
	},

	_open: function( options ) {
		var openOptions = $.extend( {}, this.options, options ),
			// TODO move blacklist to private method
			androidBlacklist = ( function() {
				var ua = navigator.userAgent,
					// Rendering engine is Webkit, and capture major version
					wkmatch = ua.match( /AppleWebKit\/([0-9\.]+)/ ),
					wkversion = !!wkmatch && wkmatch[ 1 ],
					androidmatch = ua.match( /Android (\d+(?:\.\d+))/ ),
					andversion = !!androidmatch && androidmatch[ 1 ],
					chromematch = ua.indexOf( "Chrome" ) > -1;

				// Platform is Android, WebKit version is greater than 534.13 ( Android 3.2.1 ) and not Chrome.
				if ( androidmatch !== null && andversion === "4.0" && wkversion && wkversion > 534.13 && !chromematch ) {
					return true;
				}
				return false;
			}());

		// Count down to triggering "popupafteropen" - we have two prerequisites:
		// 1. The popup window animation completes (container())
		// 2. The screen opacity animation completes (screen())
		this._createPrerequisites(
			$.noop,
			$.noop,
			$.proxy( this, "_openPrerequisitesComplete" ) );

		this._currentTransition = openOptions.transition;
		this._applyTransition( openOptions.transition );

		this._ui.screen.removeClass( "ui-screen-hidden" );
		this._ui.container.removeClass( "ui-popup-truncate" );

		// Give applications a chance to modify the contents of the container before it appears
		this._reposition( openOptions );

		this._ui.container.removeClass( "ui-popup-hidden" );

		if ( this.options.overlayTheme && androidBlacklist ) {
			/* TODO: The native browser on Android 4.0.X ("Ice Cream Sandwich") suffers from an issue where the popup overlay appears to be z-indexed above the popup itself when certain other styles exist on the same page -- namely, any element set to `position: fixed` and certain types of input. These issues are reminiscent of previously uncovered bugs in older versions of Android's native browser: https://github.com/scottjehl/Device-Bugs/issues/3
			This fix closes the following bugs ( I use "closes" with reluctance, and stress that this issue should be revisited as soon as possible ):
			https://github.com/jquery/jquery-mobile/issues/4816
			https://github.com/jquery/jquery-mobile/issues/4844
			https://github.com/jquery/jquery-mobile/issues/4874
			*/

			// TODO sort out why this._page isn't working
			this.element.closest( ".ui-page" ).addClass( "ui-popup-open" );
		}
		this._animate({
			additionalCondition: true,
			transition: openOptions.transition,
			classToRemove: "",
			screenClassToAdd: "in",
			containerClassToAdd: "in",
			applyTransition: false,
			prerequisites: this._prerequisites
		});
	},

	_closePrerequisiteScreen: function() {
		this._ui.screen
			.removeClass( "out" )
			.addClass( "ui-screen-hidden" );
	},

	_closePrerequisiteContainer: function() {
		this._ui.container
			.removeClass( "reverse out" )
			.addClass( "ui-popup-hidden ui-popup-truncate" )
			.removeAttr( "style" );
	},

	_closePrerequisitesDone: function() {
		var container = this._ui.container,
			id = this.element.attr( "id" );

		container.removeAttr( "tabindex" );

		// remove the global mutex for popups
		$.mobile.popup.active = undefined;

		// Blur elements inside the container, including the container
		$( ":focus", container[ 0 ] ).add( container[ 0 ] ).blur();

		if ( id ) {
			this.document.find( "[aria-haspopup='true'][aria-owns='" +  id + "']" ).attr( "aria-expanded", false );
		}

		// alert users that the popup is closed
		this._trigger( "afterclose" );
	},

	_close: function( immediate ) {
		this._ui.container.removeClass( "ui-popup-active" );
		this._page.removeClass( "ui-popup-open" );

		this._isOpen = false;

		// Count down to triggering "popupafterclose" - we have two prerequisites:
		// 1. The popup window reverse animation completes (container())
		// 2. The screen opacity animation completes (screen())
		this._createPrerequisites(
			$.proxy( this, "_closePrerequisiteScreen" ),
			$.proxy( this, "_closePrerequisiteContainer" ),
			$.proxy( this, "_closePrerequisitesDone" ) );

		this._animate( {
			additionalCondition: this._ui.screen.hasClass( "in" ),
			transition: ( immediate ? "none" : ( this._currentTransition ) ),
			classToRemove: "in",
			screenClassToAdd: "out",
			containerClassToAdd: "reverse out",
			applyTransition: true,
			prerequisites: this._prerequisites
		});
	},

	_unenhance: function() {
		if ( this.options.enhanced ) {
			return;
		}

		// Put the element back to where the placeholder was and remove the "ui-popup" class
		this._setOptions( { theme: $.mobile.popup.prototype.options.theme } );
		this.element
			// Cannot directly insertAfter() - we need to detach() first, because
			// insertAfter() will do nothing if the payload div was not attached
			// to the DOM at the time the widget was created, and so the payload
			// will remain inside the container even after we call insertAfter().
			// If that happens and we remove the container a few lines below, we
			// will cause an infinite recursion - #5244
			.detach()
			.insertAfter( this._ui.placeholder )
			.removeClass( "ui-popup ui-overlay-shadow ui-corner-all ui-body-inherit" );
		this._ui.screen.remove();
		this._ui.container.remove();
		this._ui.placeholder.remove();
	},

	_destroy: function() {
		if ( $.mobile.popup.active === this ) {
			this.element.one( "popupafterclose", $.proxy( this, "_unenhance" ) );
			this.close();
		} else {
			this._unenhance();
		}

		return this;
	},

	_closePopup: function( theEvent, data ) {
		var parsedDst, toUrl,
			currentOptions = this.options,
			immediate = false;

		if ( ( theEvent && theEvent.isDefaultPrevented() ) || $.mobile.popup.active !== this ) {
			return;
		}

		// restore location on screen
		window.scrollTo( 0, this._scrollTop );

		if ( theEvent && theEvent.type === "pagebeforechange" && data ) {
			// Determine whether we need to rapid-close the popup, or whether we can
			// take the time to run the closing transition
			if ( typeof data.toPage === "string" ) {
				parsedDst = data.toPage;
			} else {
				parsedDst = data.toPage.jqmData( "url" );
			}
			parsedDst = $.mobile.path.parseUrl( parsedDst );
			toUrl = parsedDst.pathname + parsedDst.search + parsedDst.hash;

			if ( this._myUrl !== $.mobile.path.makeUrlAbsolute( toUrl ) ) {
				// Going to a different page - close immediately
				immediate = true;
			} else {
				theEvent.preventDefault();
			}
		}

		// remove nav bindings
		this.window.off( currentOptions.closeEvents );
		// unbind click handlers added when history is disabled
		this.element.undelegate( currentOptions.closeLinkSelector, currentOptions.closeLinkEvents );

		this._close( immediate );
	},

	// any navigation event after a popup is opened should close the popup
	// NOTE the pagebeforechange is bound to catch navigation events that don't
	//      alter the url (eg, dialogs from popups)
	_bindContainerClose: function() {
		this.window
			.on( this.options.closeEvents, $.proxy( this, "_closePopup" ) );
	},

	widget: function() {
		return this._ui.container;
	},

	// TODO no clear deliniation of what should be here and
	// what should be in _open. Seems to be "visual" vs "history" for now
	open: function( options ) {
		var url, hashkey, activePage, currentIsDialog, hasHash, urlHistory,
			self = this,
			currentOptions = this.options;

		// make sure open is idempotent
		if ( $.mobile.popup.active || currentOptions.disabled ) {
			return this;
		}

		// set the global popup mutex
		$.mobile.popup.active = this;
		this._scrollTop = this.window.scrollTop();

		// if history alteration is disabled close on navigate events
		// and leave the url as is
		if ( !( currentOptions.history ) ) {
			self._open( options );
			self._bindContainerClose();

			// When histoy is disabled we have to grab the data-rel
			// back link clicks so we can close the popup instead of
			// relying on history to do it for us
			self.element
				.delegate( currentOptions.closeLinkSelector, currentOptions.closeLinkEvents, function( theEvent ) {
					self.close();
					theEvent.preventDefault();
				});

			return this;
		}

		// cache some values for min/readability
		urlHistory = $.mobile.navigate.history;
		hashkey = $.mobile.dialogHashKey;
		activePage = $.mobile.activePage;
		currentIsDialog = ( activePage ? activePage.hasClass( "ui-dialog" ) : false );
		this._myUrl = url = urlHistory.getActive().url;
		hasHash = ( url.indexOf( hashkey ) > -1 ) && !currentIsDialog && ( urlHistory.activeIndex > 0 );

		if ( hasHash ) {
			self._open( options );
			self._bindContainerClose();
			return this;
		}

		// if the current url has no dialog hash key proceed as normal
		// otherwise, if the page is a dialog simply tack on the hash key
		if ( url.indexOf( hashkey ) === -1 && !currentIsDialog ) {
			url = url + (url.indexOf( "#" ) > -1 ? hashkey : "#" + hashkey);
		} else {
			url = $.mobile.path.parseLocation().hash + hashkey;
		}

		// Tack on an extra hashkey if this is the first page and we've just reconstructed the initial hash
		if ( urlHistory.activeIndex === 0 && url === urlHistory.initialDst ) {
			url += hashkey;
		}

		// swallow the the initial navigation event, and bind for the next
		this.window.one( "beforenavigate", function( theEvent ) {
			theEvent.preventDefault();
			self._open( options );
			self._bindContainerClose();
		});

		this.urlAltered = true;
		$.mobile.navigate( url, { role: "dialog" } );

		return this;
	},

	close: function() {
		// make sure close is idempotent
		if ( $.mobile.popup.active !== this ) {
			return this;
		}

		this._scrollTop = this.window.scrollTop();

		if ( this.options.history && this.urlAltered ) {
			$.mobile.back();
			this.urlAltered = false;
		} else {
			// simulate the nav bindings having fired
			this._closePopup();
		}

		return this;
	}
});

// TODO this can be moved inside the widget
$.mobile.popup.handleLink = function( $link ) {
	var offset,
		path = $.mobile.path,

		// NOTE make sure to get only the hash from the href because ie7 (wp7)
		//      returns the absolute href in this case ruining the element selection
		popup = $( path.hashToSelector( path.parseUrl( $link.attr( "href" ) ).hash ) ).first();

	if ( popup.length > 0 && popup.data( "mobile-popup" ) ) {
		offset = $link.offset();
		popup.popup( "open", {
			x: offset.left + $link.outerWidth() / 2,
			y: offset.top + $link.outerHeight() / 2,
			transition: $link.jqmData( "transition" ),
			positionTo: $link.jqmData( "position-to" )
		});
	}

	//remove after delay
	setTimeout( function() {
		$link.removeClass( $.mobile.activeBtnClass );
	}, 300 );
};

// TODO move inside _create
$.mobile.document.on( "pagebeforechange", function( theEvent, data ) {
	if ( data.options.role === "popup" ) {
		$.mobile.popup.handleLink( data.options.link );
		theEvent.preventDefault();
	}
});

})( jQuery );

/*
* custom "selectmenu" plugin
*/

(function( $, undefined ) {

var unfocusableItemSelector = ".ui-disabled,.ui-state-disabled,.ui-li-divider,.ui-screen-hidden,:jqmData(role='placeholder')",
	goToAdjacentItem = function( item, target, direction ) {
		var adjacent = item[ direction + "All" ]()
			.not( unfocusableItemSelector )
			.first();

		// if there's a previous option, focus it
		if ( adjacent.length ) {
			target
				.blur()
				.attr( "tabindex", "-1" );

			adjacent.find( "a" ).first().focus();
		}
	};

$.widget( "mobile.selectmenu", $.mobile.selectmenu, {
	_create: function() {
		var o = this.options;

		// Custom selects cannot exist inside popups, so revert the "nativeMenu"
		// option to true if a parent is a popup
		o.nativeMenu = o.nativeMenu || ( this.element.parents( ":jqmData(role='popup'),:mobile-popup" ).length > 0 );

		return this._super();
	},

	_handleSelectFocus: function() {
		this.element.blur();
		this.button.focus();
	},

	_handleKeydown: function( event ) {
		this._super( event );
		this._handleButtonVclickKeydown( event );
	},

	_handleButtonVclickKeydown: function( event ) {
		if ( this.options.disabled || this.isOpen || this.options.nativeMenu ) {
			return;
		}

		if (event.type === "vclick" ||
				event.keyCode && (event.keyCode === $.mobile.keyCode.ENTER || event.keyCode === $.mobile.keyCode.SPACE)) {

			this._decideFormat();
			if ( this.menuType === "overlay" ) {
				this.button.attr( "href", "#" + this.popupId ).attr( "data-" + ( $.mobile.ns || "" ) + "rel", "popup" );
			} else {
				this.button.attr( "href", "#" + this.dialogId ).attr( "data-" + ( $.mobile.ns || "" ) + "rel", "dialog" );
			}
			this.isOpen = true;
			// Do not prevent default, so the navigation may have a chance to actually open the chosen format
		}
	},

	_handleListFocus: function( e ) {
		var params = ( e.type === "focusin" ) ?
			{ tabindex: "0", event: "vmouseover" }:
			{ tabindex: "-1", event: "vmouseout" };

		$( e.target )
			.attr( "tabindex", params.tabindex )
			.trigger( params.event );
	},

	_handleListKeydown: function( event ) {
		var target = $( event.target ),
			li = target.closest( "li" );

		// switch logic based on which key was pressed
		switch ( event.keyCode ) {
			// up or left arrow keys
		case 38:
			goToAdjacentItem( li, target, "prev" );
			return false;
			// down or right arrow keys
		case 40:
			goToAdjacentItem( li, target, "next" );
			return false;
			// If enter or space is pressed, trigger click
		case 13:
		case 32:
			target.trigger( "click" );
			return false;
		}
	},

	_handleMenuPageHide: function() {

		// After the dialog's done, we may want to trigger change if the value has actually changed
		this._delayedTrigger();

		// TODO centralize page removal binding / handling in the page plugin.
		// Suggestion from @jblas to do refcounting
		//
		// TODO extremely confusing dependency on the open method where the pagehide.remove
		// bindings are stripped to prevent the parent page from disappearing. The way
		// we're keeping pages in the DOM right now sucks
		//
		// rebind the page remove that was unbound in the open function
		// to allow for the parent page removal from actions other than the use
		// of a dialog sized custom select
		//
		// doing this here provides for the back button on the custom select dialog
		this.thisPage.page( "bindRemove" );
	},

	_handleHeaderCloseClick: function() {
		if ( this.menuType === "overlay" ) {
			this.close();
			return false;
		}
	},

	_handleListItemClick: function( event ) {
		var listItem = $( event.target ).closest( "li" ),

			// Index of option tag to be selected
			oldIndex = this.select[ 0 ].selectedIndex,
			newIndex = $.mobile.getAttribute( listItem, "option-index" ),
			option = this._selectOptions().eq( newIndex )[ 0 ];

		// Toggle selected status on the tag for multi selects
		option.selected = this.isMultiple ? !option.selected : true;

		// Toggle checkbox class for multiple selects
		if ( this.isMultiple ) {
			listItem.find( "a" )
				.toggleClass( "ui-checkbox-on", option.selected )
				.toggleClass( "ui-checkbox-off", !option.selected );
		}

		// If it's not a multiple select, trigger change after it has finished closing
		if ( !this.isMultiple && oldIndex !== newIndex ) {
			this._triggerChange = true;
		}

		// Trigger change if it's a multiple select
		// Hide custom select for single selects only - otherwise focus clicked item
		// We need to grab the clicked item the hard way, because the list may have been rebuilt
		if ( this.isMultiple ) {
			this.select.trigger( "change" );
			this.list.find( "li:not(.ui-li-divider)" ).eq( newIndex )
				.find( "a" ).first().focus();
		}
		else {
			this.close();
		}

		event.preventDefault();
	},

	build: function() {
		var selectId, popupId, dialogId, label, thisPage, isMultiple, menuId,
			themeAttr, overlayTheme, overlayThemeAttr, dividerThemeAttr,
			menuPage, listbox, list, header, headerTitle, menuPageContent,
			menuPageClose, headerClose,
			o = this.options;

		if ( o.nativeMenu ) {
			return this._super();
		}

		selectId = this.selectId;
		popupId = selectId + "-listbox";
		dialogId = selectId + "-dialog";
		label = this.label;
		thisPage = this.element.closest( ".ui-page" );
		isMultiple = this.element[ 0 ].multiple;
		menuId = selectId + "-menu";
		themeAttr = o.theme ? ( " data-" + $.mobile.ns + "theme='" + o.theme + "'" ) : "";
		overlayTheme = o.overlayTheme || o.theme || null;
		overlayThemeAttr = overlayTheme ? ( " data-" + $.mobile.ns +
			"overlay-theme='" + overlayTheme + "'" ) : "";
		dividerThemeAttr = ( o.dividerTheme && isMultiple ) ? ( " data-" + $.mobile.ns + "divider-theme='" + o.dividerTheme + "'" ) : "";
		menuPage = $( "<div data-" + $.mobile.ns + "role='dialog' class='ui-selectmenu' id='" + dialogId + "'" + themeAttr + overlayThemeAttr + ">" +
			"<div data-" + $.mobile.ns + "role='header'>" +
			"<div class='ui-title'></div>"+
			"</div>"+
			"<div data-" + $.mobile.ns + "role='content'></div>"+
			"</div>" );
		listbox = $( "<div" + themeAttr + overlayThemeAttr + " id='" + popupId +
				"' class='ui-selectmenu'></div>" )
			.insertAfter( this.select )
			.popup();
		list = $( "<ul class='ui-selectmenu-list' id='" + menuId + "' role='listbox' aria-labelledby='" + this.buttonId + "'" + themeAttr + dividerThemeAttr + "></ul>" ).appendTo( listbox );
		header = $( "<div class='ui-header ui-bar-" + ( o.theme ? o.theme : "inherit" ) + "'></div>" ).prependTo( listbox );
		headerTitle = $( "<h1 class='ui-title'></h1>" ).appendTo( header );

		if ( this.isMultiple ) {
			headerClose = $( "<a>", {
				"role": "button",
				"text": o.closeText,
				"href": "#",
				"class": "ui-btn ui-corner-all ui-btn-left ui-btn-icon-notext ui-icon-delete"
			}).appendTo( header );
		}

		$.extend( this, {
			selectId: selectId,
			menuId: menuId,
			popupId: popupId,
			dialogId: dialogId,
			thisPage: thisPage,
			menuPage: menuPage,
			label: label,
			isMultiple: isMultiple,
			theme: o.theme,
			listbox: listbox,
			list: list,
			header: header,
			headerTitle: headerTitle,
			headerClose: headerClose,
			menuPageContent: menuPageContent,
			menuPageClose: menuPageClose,
			placeholder: ""
		});

		// Create list from select, update state
		this.refresh();

		if ( this._origTabIndex === undefined ) {
			// Map undefined to false, because this._origTabIndex === undefined
			// indicates that we have not yet checked whether the select has
			// originally had a tabindex attribute, whereas false indicates that
			// we have checked the select for such an attribute, and have found
			// none present.
			this._origTabIndex = ( this.select[ 0 ].getAttribute( "tabindex" ) === null ) ? false : this.select.attr( "tabindex" );
		}
		this.select.attr( "tabindex", "-1" );
		this._on( this.select, { focus : "_handleSelectFocus" } );

		// Button events
		this._on( this.button, {
			vclick: "_handleButtonVclickKeydown"
		});

		// Events for list items
		this.list.attr( "role", "listbox" );
		this._on( this.list, {
			"focusin": "_handleListFocus",
			"focusout": "_handleListFocus",
			"keydown": "_handleListKeydown",
			"click li:not(.ui-disabled,.ui-state-disabled,.ui-li-divider)": "_handleListItemClick"
		});

		// button refocus ensures proper height calculation
		// by removing the inline style and ensuring page inclusion
		this._on( this.menuPage, { pagehide: "_handleMenuPageHide" } );

		// Events on the popup
		this._on( this.listbox, { popupafterclose: "_popupClosed" } );

		// Close button on small overlays
		if ( this.isMultiple ) {
			this._on( this.headerClose, { click: "_handleHeaderCloseClick" } );
		}

		return this;
	},

	_popupClosed: function() {
		this.close();
		this._delayedTrigger();
	},

	_delayedTrigger: function() {
		if ( this._triggerChange ) {
			this.element.trigger( "change" );
		}
		this._triggerChange = false;
	},

	_isRebuildRequired: function() {
		var list = this.list.find( "li" ),
			options = this._selectOptions().not( ".ui-screen-hidden" );

		// TODO exceedingly naive method to determine difference
		// ignores value changes etc in favor of a forcedRebuild
		// from the user in the refresh method
		return options.text() !== list.text();
	},

	selected: function() {
		return this._selectOptions().filter( ":selected:not( :jqmData(placeholder='true') )" );
	},

	refresh: function( force ) {
		var self, indices;

		if ( this.options.nativeMenu ) {
			return this._super( force );
		}

		self = this;
		if ( force || this._isRebuildRequired() ) {
			self._buildList();
		}

		indices = this.selectedIndices();

		self.setButtonText();
		self.setButtonCount();

		self.list.find( "li:not(.ui-li-divider)" )
			.find( "a" ).removeClass( $.mobile.activeBtnClass ).end()
			.attr( "aria-selected", false )
			.each(function( i ) {

				if ( $.inArray( i, indices ) > -1 ) {
					var item = $( this );

					// Aria selected attr
					item.attr( "aria-selected", true );

					// Multiple selects: add the "on" checkbox state to the icon
					if ( self.isMultiple ) {
						item.find( "a" ).removeClass( "ui-checkbox-off" ).addClass( "ui-checkbox-on" );
					} else {
						if ( item.hasClass( "ui-screen-hidden" ) ) {
							item.next().find( "a" ).addClass( $.mobile.activeBtnClass );
						} else {
							item.find( "a" ).addClass( $.mobile.activeBtnClass );
						}
					}
				}
			});
	},

	close: function() {
		if ( this.options.disabled || !this.isOpen ) {
			return;
		}

		var self = this;

		if ( self.menuType === "page" ) {
			self.menuPage.dialog( "close" );
			self.list.appendTo( self.listbox );
		} else {
			self.listbox.popup( "close" );
		}

		self._focusButton();
		// allow the dialog to be closed again
		self.isOpen = false;
	},

	open: function() {
		this.button.click();
	},

	_focusMenuItem: function() {
		var selector = this.list.find( "a." + $.mobile.activeBtnClass );
		if ( selector.length === 0 ) {
			selector = this.list.find( "li:not(" + unfocusableItemSelector + ") a.ui-btn" );
		}
		selector.first().focus();
	},

	_decideFormat: function() {
		var self = this,
			$window = this.window,
			selfListParent = self.list.parent(),
			menuHeight = selfListParent.outerHeight(),
			scrollTop = $window.scrollTop(),
			btnOffset = self.button.offset().top,
			screenHeight = $window.height();

		if ( menuHeight > screenHeight - 80 || !$.support.scrollTop ) {

			self.menuPage.appendTo( $.mobile.pageContainer ).page();
			self.menuPageContent = self.menuPage.find( ".ui-content" );
			self.menuPageClose = self.menuPage.find( ".ui-header a" );

			// prevent the parent page from being removed from the DOM,
			// otherwise the results of selecting a list item in the dialog
			// fall into a black hole
			self.thisPage.unbind( "pagehide.remove" );

			//for WebOS/Opera Mini (set lastscroll using button offset)
			if ( scrollTop === 0 && btnOffset > screenHeight ) {
				self.thisPage.one( "pagehide", function() {
					$( this ).jqmData( "lastScroll", btnOffset );
				});
			}

			self.menuPage.one( {
				pageshow: $.proxy( this, "_focusMenuItem" ),
				pagehide: $.proxy( this, "close" )
			});

			self.menuType = "page";
			self.menuPageContent.append( self.list );
			self.menuPage
				.find( "div .ui-title" )
					.text( self.label.getEncodedText() || self.placeholder );
		} else {
			self.menuType = "overlay";

			self.listbox.one( { popupafteropen: $.proxy( this, "_focusMenuItem" ) } );
		}
	},

	_buildList: function() {
		var self = this,
			o = this.options,
			placeholder = this.placeholder,
			needPlaceholder = true,
			dataIcon = "false",
			$options, numOptions, select,
			dataPrefix = "data-" + $.mobile.ns,
			dataIndexAttr = dataPrefix + "option-index",
			dataIconAttr = dataPrefix + "icon",
			dataRoleAttr = dataPrefix + "role",
			dataPlaceholderAttr = dataPrefix + "placeholder",
			fragment = document.createDocumentFragment(),
			isPlaceholderItem = false,
			optGroup,
			i,
			option, $option, parent, text, anchor, classes,
			optLabel, divider, item;

		self.list.empty().filter( ".ui-listview" ).listview( "destroy" );
		$options = this._selectOptions();
		numOptions = $options.length;
		select = this.select[ 0 ];

		for ( i = 0; i < numOptions;i++, isPlaceholderItem = false) {
			option = $options[i];
			$option = $( option );

			// Do not create options based on ui-screen-hidden select options
			if ( $option.hasClass( "ui-screen-hidden" ) ) {
				continue;
			}

			parent = option.parentNode;
			text = $option.getEncodedText();
			anchor  = document.createElement( "a" );
			classes = [];

			anchor.setAttribute( "href", "#" );
			anchor.appendChild( document.createTextNode( text ) );

			// Are we inside an optgroup?
			if ( parent !== select && parent.nodeName.toLowerCase() === "optgroup" ) {
				optLabel = parent.getAttribute( "label" );
				if ( optLabel !== optGroup ) {
					divider = document.createElement( "li" );
					divider.setAttribute( dataRoleAttr, "list-divider" );
					divider.setAttribute( "role", "option" );
					divider.setAttribute( "tabindex", "-1" );
					divider.appendChild( document.createTextNode( optLabel ) );
					fragment.appendChild( divider );
					optGroup = optLabel;
				}
			}

			if ( needPlaceholder && ( !option.getAttribute( "value" ) || text.length === 0 || $option.jqmData( "placeholder" ) ) ) {
				needPlaceholder = false;
				isPlaceholderItem = true;

				// If we have identified a placeholder, record the fact that it was
				// us who have added the placeholder to the option and mark it
				// retroactively in the select as well
				if ( null === option.getAttribute( dataPlaceholderAttr ) ) {
					this._removePlaceholderAttr = true;
				}
				option.setAttribute( dataPlaceholderAttr, true );
				if ( o.hidePlaceholderMenuItems ) {
					classes.push( "ui-screen-hidden" );
				}
				if ( placeholder !== text ) {
					placeholder = self.placeholder = text;
				}
			}

			item = document.createElement( "li" );
			if ( option.disabled ) {
				classes.push( "ui-state-disabled" );
				item.setAttribute( "aria-disabled", true );
			}
			item.setAttribute( dataIndexAttr, i );
			item.setAttribute( dataIconAttr, dataIcon );
			if ( isPlaceholderItem ) {
				item.setAttribute( dataPlaceholderAttr, true );
			}
			item.className = classes.join( " " );
			item.setAttribute( "role", "option" );
			anchor.setAttribute( "tabindex", "-1" );
			if ( this.isMultiple ) {
				$( anchor ).addClass( "ui-btn ui-checkbox-off ui-btn-icon-right" );
			}

			item.appendChild( anchor );
			fragment.appendChild( item );
		}

		self.list[0].appendChild( fragment );

		// Hide header if it's not a multiselect and there's no placeholder
		if ( !this.isMultiple && !placeholder.length ) {
			this.header.addClass( "ui-screen-hidden" );
		} else {
			this.headerTitle.text( this.placeholder );
		}

		// Now populated, create listview
		self.list.listview();
	},

	_button: function() {
		return this.options.nativeMenu ?
			this._super() :
			$( "<a>", {
				"href": "#",
				"role": "button",
				// TODO value is undefined at creation
				"id": this.buttonId,
				"aria-haspopup": "true",

				// TODO value is undefined at creation
				"aria-owns": this.menuId
			});
	},

	_destroy: function() {

		if ( !this.options.nativeMenu ) {
			this.close();

			// Restore the tabindex attribute to its original value
			if ( this._origTabIndex !== undefined ) {
				if ( this._origTabIndex !== false ) {
					this.select.attr( "tabindex", this._origTabIndex );
				} else {
					this.select.removeAttr( "tabindex" );
				}
			}

			// Remove the placeholder attribute if we were the ones to add it
			if ( this._removePlaceholderAttr ) {
				this._selectOptions().removeAttr( "data-" + $.mobile.ns + "placeholder" );
			}

			// Remove the popup
			this.listbox.remove();

			// Remove the dialog
			this.menuPage.remove();
		}

		// Chain up
		this._super();
	}
});

})( jQuery );


// buttonMarkup is deprecated as of 1.4.0 and will be removed in 1.5.0.

(function( $, undefined ) {

// General policy: Do not access data-* attributes except during enhancement.
// In all other cases we determine the state of the button exclusively from its
// className. That's why optionsToClasses expects a full complement of options,
// and the jQuery plugin completes the set of options from the default values.

// Map classes to buttonMarkup boolean options - used in classNameToOptions()
var reverseBoolOptionMap = {
		"ui-shadow" : "shadow",
		"ui-corner-all" : "corners",
		"ui-btn-inline" : "inline",
		"ui-shadow-icon" : "iconshadow", /* TODO: Remove in 1.5 */
		"ui-mini" : "mini"
	},
	getAttrFixed = function() {
		var ret = $.mobile.getAttribute.apply( this, arguments );

		return ( ret == null ? undefined : ret );
	},
	capitalLettersRE = /[A-Z]/g;

// optionsToClasses:
// @options: A complete set of options to convert to class names.
// @existingClasses: extra classes to add to the result
//
// Converts @options to buttonMarkup classes and returns the result as an array
// that can be converted to an element's className with .join( " " ). All
// possible options must be set inside @options. Use $.fn.buttonMarkup.defaults
// to get a complete set and use $.extend to override your choice of options
// from that set.
function optionsToClasses( options, existingClasses ) {
	var classes = existingClasses ? existingClasses : [];

	// Add classes to the array - first ui-btn
	classes.push( "ui-btn" );

	// If there is a theme
	if ( options.theme ) {
		classes.push( "ui-btn-" + options.theme );
	}

	// If there's an icon, add the icon-related classes
	if ( options.icon ) {
		classes = classes.concat([
			"ui-icon-" + options.icon,
			"ui-btn-icon-" + options.iconpos
		]);
		if ( options.iconshadow ) {
			classes.push( "ui-shadow-icon" ); /* TODO: Remove in 1.5 */
		}
	}

	// Add the appropriate class for each boolean option
	if ( options.inline ) {
		classes.push( "ui-btn-inline" );
	}
	if ( options.shadow ) {
		classes.push( "ui-shadow" );
	}
	if ( options.corners ) {
		classes.push( "ui-corner-all" );
	}
	if ( options.mini ) {
		classes.push( "ui-mini" );
	}

	// Create a string from the array and return it
	return classes;
}

// classNameToOptions:
// @classes: A string containing a .className-style space-separated class list
//
// Loops over @classes and calculates an options object based on the
// buttonMarkup-related classes it finds. It records unrecognized classes in an
// array.
//
// Returns: An object containing the following items:
//
// "options": buttonMarkup options found to be present because of the
// presence/absence of corresponding classes
//
// "unknownClasses": a string containing all the non-buttonMarkup-related
// classes found in @classes
//
// "alreadyEnhanced": A boolean indicating whether the ui-btn class was among
// those found to be present
function classNameToOptions( classes ) {
	var idx, map, unknownClass,
		alreadyEnhanced = false,
		noIcon = true,
		o = {
			icon: "",
			inline: false,
			shadow: false,
			corners: false,
			iconshadow: false,
			mini: false
		},
		unknownClasses = [];

	classes = classes.split( " " );

	// Loop over the classes
	for ( idx = 0 ; idx < classes.length ; idx++ ) {

		// Assume it's an unrecognized class
		unknownClass = true;

		// Recognize boolean options from the presence of classes
		map = reverseBoolOptionMap[ classes[ idx ] ];
		if ( map !== undefined ) {
			unknownClass = false;
			o[ map ] = true;

		// Recognize the presence of an icon and establish the icon position
		} else if ( classes[ idx ].indexOf( "ui-btn-icon-" ) === 0 ) {
			unknownClass = false;
			noIcon = false;
			o.iconpos = classes[ idx ].substring( 12 );

		// Establish which icon is present
		} else if ( classes[ idx ].indexOf( "ui-icon-" ) === 0 ) {
			unknownClass = false;
			o.icon = classes[ idx ].substring( 8 );

		// Establish the theme - this recognizes one-letter theme swatch names
		} else if ( classes[ idx ].indexOf( "ui-btn-" ) === 0 && classes[ idx ].length === 8 ) {
			unknownClass = false;
			o.theme = classes[ idx ].substring( 7 );

		// Recognize that this element has already been buttonMarkup-enhanced
		} else if ( classes[ idx ] === "ui-btn" ) {
			unknownClass = false;
			alreadyEnhanced = true;
		}

		// If this class has not been recognized, add it to the list
		if ( unknownClass ) {
			unknownClasses.push( classes[ idx ] );
		}
	}

	// If a "ui-btn-icon-*" icon position class is absent there cannot be an icon
	if ( noIcon ) {
		o.icon = "";
	}

	return {
		options: o,
		unknownClasses: unknownClasses,
		alreadyEnhanced: alreadyEnhanced
	};
}

function camelCase2Hyphenated( c ) {
	return "-" + c.toLowerCase();
}

// $.fn.buttonMarkup:
// DOM: gets/sets .className
//
// @options: options to apply to the elements in the jQuery object
// @overwriteClasses: boolean indicating whether to honour existing classes
//
// Calculates the classes to apply to the elements in the jQuery object based on
// the options passed in. If @overwriteClasses is true, it sets the className
// property of each element in the jQuery object to the buttonMarkup classes
// it calculates based on the options passed in.
//
// If you wish to preserve any classes that are already present on the elements
// inside the jQuery object, including buttonMarkup-related classes that were
// added by a previous call to $.fn.buttonMarkup() or during page enhancement
// then you should omit @overwriteClasses or set it to false.
$.fn.buttonMarkup = function( options, overwriteClasses ) {
	var idx, data, el, retrievedOptions, optionKey,
		defaults = $.fn.buttonMarkup.defaults;

	for ( idx = 0 ; idx < this.length ; idx++ ) {
		el = this[ idx ];
		data = overwriteClasses ?

			// Assume this element is not enhanced and ignore its classes
			{ alreadyEnhanced: false, unknownClasses: [] } :

			// Otherwise analyze existing classes to establish existing options and
			// classes
			classNameToOptions( el.className );

		retrievedOptions = $.extend( {},

			// If the element already has the class ui-btn, then we assume that
			// it has passed through buttonMarkup before - otherwise, the options
			// returned by classNameToOptions do not correctly reflect the state of
			// the element
			( data.alreadyEnhanced ? data.options : {} ),

			// Finally, apply the options passed in
			options );

		// If this is the first call on this element, retrieve remaining options
		// from the data-attributes
		if ( !data.alreadyEnhanced ) {
			for ( optionKey in defaults ) {
				if ( retrievedOptions[ optionKey ] === undefined ) {
					retrievedOptions[ optionKey ] = getAttrFixed( el,
						optionKey.replace( capitalLettersRE, camelCase2Hyphenated )
					);
				}
			}
		}

		el.className = optionsToClasses(

			// Merge all the options and apply them as classes
			$.extend( {},

				// The defaults form the basis
				defaults,

				// Add the computed options
				retrievedOptions
			),

			// ... and re-apply any unrecognized classes that were found
			data.unknownClasses ).join( " " );
		if ( el.tagName.toLowerCase() !== "button" ) {
			el.setAttribute( "role", "button" );
		}
	}

	return this;
};

// buttonMarkup defaults. This must be a complete set, i.e., a value must be
// given here for all recognized options
$.fn.buttonMarkup.defaults = {
	icon: "",
	iconpos: "left",
	theme: null,
	inline: false,
	shadow: true,
	corners: true,
	iconshadow: false, /* TODO: Remove in 1.5. Option deprecated in 1.4. */
	mini: false
};

$.extend( $.fn.buttonMarkup, {
	initSelector: "a:jqmData(role='button'), .ui-bar > a, .ui-bar > :jqmData(role='controlgroup') > a, button"
});

})( jQuery );


(function( $, undefined ) {

$.widget( "mobile.controlgroup", $.extend( {
	options: {
		enhanced: false,
		theme: null,
		shadow: false,
		corners: true,
		excludeInvisible: true,
		type: "vertical",
		mini: false
	},

	_create: function() {
		var elem = this.element,
			opts = this.options;

		// Run buttonmarkup
		if ( $.fn.buttonMarkup ) {
			this.element.find( $.fn.buttonMarkup.initSelector ).buttonMarkup();
		}
		// Enhance child widgets
		$.each( this._childWidgets, $.proxy( function( number, widgetName ) {
			if ( $.mobile[ widgetName ] ) {
				this.element.find( $.mobile[ widgetName ].initSelector ).not( $.mobile.page.prototype.keepNativeSelector() )[ widgetName ]();
			}
		}, this ));

		$.extend( this, {
			_ui: null,
			_initialRefresh: true
		});

		if ( opts.enhanced ) {
			this._ui = {
				groupLegend: elem.children( ".ui-controlgroup-label" ).children(),
				childWrapper: elem.children( ".ui-controlgroup-controls" )
			};
		} else {
			this._ui = this._enhance();
		}

	},

	_childWidgets: [ "checkboxradio", "selectmenu", "button" ],

	_themeClassFromOption: function( value ) {
		return ( value ? ( value === "none" ? "" : "ui-group-theme-" + value ) : "" );
	},

	_enhance: function() {
		var elem = this.element,
			opts = this.options,
			ui = {
				groupLegend: elem.children( "legend" ),
				childWrapper: elem
					.addClass( "ui-controlgroup " +
						"ui-controlgroup-" +
							( opts.type === "horizontal" ? "horizontal" : "vertical" ) + " " +
						this._themeClassFromOption( opts.theme ) + " " +
						( opts.corners ? "ui-corner-all " : "" ) +
						( opts.mini ? "ui-mini " : "" ) )
					.wrapInner( "<div " +
						"class='ui-controlgroup-controls " +
							( opts.shadow === true ? "ui-shadow" : "" ) + "'></div>" )
					.children()
			};

		if ( ui.groupLegend.length > 0 ) {
			$( "<div role='heading' class='ui-controlgroup-label'></div>" )
				.append( ui.groupLegend )
				.prependTo( elem );
		}

		return ui;
	},

	_init: function() {
		this.refresh();
	},

	_setOptions: function( options ) {
		var callRefresh, returnValue,
			elem = this.element;

		// Must have one of horizontal or vertical
		if ( options.type !== undefined ) {
			elem
				.removeClass( "ui-controlgroup-horizontal ui-controlgroup-vertical" )
				.addClass( "ui-controlgroup-" + ( options.type === "horizontal" ? "horizontal" : "vertical" ) );
			callRefresh = true;
		}

		if ( options.theme !== undefined ) {
			elem
				.removeClass( this._themeClassFromOption( this.options.theme ) )
				.addClass( this._themeClassFromOption( options.theme ) );
		}

		if ( options.corners !== undefined ) {
			elem.toggleClass( "ui-corner-all", options.corners );
		}

		if ( options.mini !== undefined ) {
			elem.toggleClass( "ui-mini", options.mini );
		}

		if ( options.shadow !== undefined ) {
			this._ui.childWrapper.toggleClass( "ui-shadow", options.shadow );
		}

		if ( options.excludeInvisible !== undefined ) {
			this.options.excludeInvisible = options.excludeInvisible;
			callRefresh = true;
		}

		returnValue = this._super( options );

		if ( callRefresh ) {
			this.refresh();
		}

		return returnValue;
	},

	container: function() {
		return this._ui.childWrapper;
	},

	refresh: function() {
		var $el = this.container(),
			els = $el.find( ".ui-btn" ).not( ".ui-slider-handle" ),
			create = this._initialRefresh;
		if ( $.mobile.checkboxradio ) {
			$el.find( ":mobile-checkboxradio" ).checkboxradio( "refresh" );
		}
		this._addFirstLastClasses( els,
			this.options.excludeInvisible ? this._getVisibles( els, create ) : els,
			create );
		this._initialRefresh = false;
	},

	// Caveat: If the legend is not the first child of the controlgroup at enhance
	// time, it will be after _destroy().
	_destroy: function() {
		var ui, buttons,
			opts = this.options;

		if ( opts.enhanced ) {
			return this;
		}

		ui = this._ui;
		buttons = this.element
			.removeClass( "ui-controlgroup " +
				"ui-controlgroup-horizontal ui-controlgroup-vertical ui-corner-all ui-mini " +
				this._themeClassFromOption( opts.theme ) )
			.find( ".ui-btn" )
			.not( ".ui-slider-handle" );

		this._removeFirstLastClasses( buttons );

		ui.groupLegend.unwrap();
		ui.childWrapper.children().unwrap();
	}
}, $.mobile.behaviors.addFirstLastClasses ) );

})(jQuery);

(function( $, undefined ) {

	$.widget( "mobile.toolbar", {
		initSelector: ":jqmData(role='footer'), :jqmData(role='header')",

		options: {
			theme: null,
			addBackBtn: false,
			backBtnTheme: null,
			backBtnText: "Back"
		},

		_create: function() {
			var leftbtn, rightbtn,
				role =  this.element.is( ":jqmData(role='header')" ) ? "header" : "footer",
				page = this.element.closest( ".ui-page" );
			if ( page.length === 0 ) {
				page = false;
				this._on( this.document, {
					"pageshow": "refresh"
				});
			}
			$.extend( this, {
				role: role,
				page: page,
				leftbtn: leftbtn,
				rightbtn: rightbtn
			});
			this.element.attr( "role", role === "header" ? "banner" : "contentinfo" ).addClass( "ui-" + role );
			this.refresh();
			this._setOptions( this.options );
		},
		_setOptions: function( o ) {
			if ( o.addBackBtn !== undefined ) {
				this._updateBackButton();
			}
			if ( o.backBtnTheme != null ) {
				this.element
					.find( ".ui-toolbar-back-btn" )
					.addClass( "ui-btn ui-btn-" + o.backBtnTheme );
			}
			if ( o.backBtnText !== undefined ) {
				this.element.find( ".ui-toolbar-back-btn .ui-btn-text" ).text( o.backBtnText );
			}
			if ( o.theme !== undefined ) {
				var currentTheme = this.options.theme ? this.options.theme : "inherit",
					newTheme = o.theme ? o.theme : "inherit";

				this.element.removeClass( "ui-bar-" + currentTheme ).addClass( "ui-bar-" + newTheme );
			}

			this._super( o );
		},
		refresh: function() {
			if ( this.role === "header" ) {
				this._addHeaderButtonClasses();
			}
			if ( !this.page ) {
				this._setRelative();
				if ( this.role === "footer" ) {
					this.element.appendTo( "body" );
				} else if ( this.role === "header" ) {
					this._updateBackButton();
				}
			}
			this._addHeadingClasses();
			this._btnMarkup();
		},

		//we only want this to run on non fixed toolbars so make it easy to override
		_setRelative: function() {
			$( "[data-"+ $.mobile.ns + "role='page']" ).css({ "position": "relative" });
		},

		// Deprecated in 1.4. As from 1.5 button classes have to be present in the markup.
		_btnMarkup: function() {
			this.element
				.children( "a" )
				.filter( ":not([data-" + $.mobile.ns + "role='none'])" )
				.attr( "data-" + $.mobile.ns + "role", "button" );
			this.element.trigger( "create" );
		},
		// Deprecated in 1.4. As from 1.5 ui-btn-left/right classes have to be present in the markup.
		_addHeaderButtonClasses: function() {
			var headerAnchors = this.element.children( "a, button" );

			// Do not mistake a back button for a left toolbar button
			this.leftbtn = headerAnchors.hasClass( "ui-btn-left" ) &&
				!headerAnchors.hasClass( "ui-toolbar-back-btn" );

			this.rightbtn = headerAnchors.hasClass( "ui-btn-right" );

			// Filter out right buttons and back buttons
			this.leftbtn = this.leftbtn ||
				headerAnchors.eq( 0 )
					.not( ".ui-btn-right,.ui-toolbar-back-btn" )
					.addClass( "ui-btn-left" )
					.length;

			this.rightbtn = this.rightbtn || headerAnchors.eq( 1 ).addClass( "ui-btn-right" ).length;
		},
		_updateBackButton: function() {
			var backButton,
				options = this.options,
				theme = options.backBtnTheme || options.theme;

			// Retrieve the back button or create a new, empty one
			backButton = this._backButton = ( this._backButton || {} );

			// We add a back button only if the option to do so is on
			if ( this.options.addBackBtn &&

					// This must also be a header toolbar
					this.role === "header" &&

					// There must be multiple pages in the DOM
					$( ".ui-page" ).length > 1 &&
					( this.page ?

						// If the toolbar is internal the page's URL must differ from the hash
						( this.page[ 0 ].getAttribute( "data-" + $.mobile.ns + "url" ) !==
							$.mobile.path.stripHash( location.hash ) ) :

						// Otherwise, if the toolbar is external there must be at least one
						// history item to which one can go back
						( $.mobile.navigate && $.mobile.navigate.history &&
							$.mobile.navigate.history.activeIndex > 0 ) ) &&

					// The toolbar does not have a left button
					!this.leftbtn ) {

				// Skip back button creation if one is already present
				if ( !backButton.attached ) {
					backButton.element = ( backButton.element ||
						$( "<a role='button' href='javascript:void(0);' " +
							"class='ui-btn ui-corner-all ui-shadow ui-btn-left " +
								( theme ? "ui-btn-" + theme + " " : "" ) +
								"ui-toolbar-back-btn ui-icon-carat-l ui-btn-icon-left' " +
							"data-" + $.mobile.ns + "rel='back'>" + options.backBtnText +
							"</a>" ) )
							.prependTo( this.element );
					backButton.attached = true;
				}

			// If we are not adding a back button, then remove the one present, if any
			} else if ( backButton.element ) {
				backButton.element.detach();
				backButton.attached = false;
			}
		},
		_addHeadingClasses: function() {
			this.element.children( "h1, h2, h3, h4, h5, h6" )
				.addClass( "ui-title" )
				// Regardless of h element number in src, it becomes h1 for the enhanced page
				.attr({
					"role": "heading",
					"aria-level": "1"
				});
		}
	});

})( jQuery );

(function( $, undefined ) {

	$.widget( "mobile.toolbar", $.mobile.toolbar, {
		options: {
			position:null,
			visibleOnPageShow: true,
			disablePageZoom: true,
			transition: "slide", //can be none, fade, slide (slide maps to slideup or slidedown)
			fullscreen: false,
			tapToggle: true,
			tapToggleBlacklist: "a, button, input, select, textarea, .ui-header-fixed, .ui-footer-fixed, .ui-flipswitch, .ui-popup, .ui-panel, .ui-panel-dismiss-open",
			hideDuringFocus: "input, textarea, select",
			updatePagePadding: true,
			trackPersistentToolbars: true,

			// Browser detection! Weeee, here we go...
			// Unfortunately, position:fixed is costly, not to mention probably impossible, to feature-detect accurately.
			// Some tests exist, but they currently return false results in critical devices and browsers, which could lead to a broken experience.
			// Testing fixed positioning is also pretty obtrusive to page load, requiring injected elements and scrolling the window
			// The following function serves to rule out some popular browsers with known fixed-positioning issues
			// This is a plugin option like any other, so feel free to improve or overwrite it
			supportBlacklist: function() {
				return !$.support.fixedPosition;
			}
		},

		_create: function() {
			this._super();
			if ( this.options.position === "fixed" && !this.options.supportBlacklist() ) {
				this._makeFixed();
			}
		},

		_makeFixed: function() {
			this.element.addClass( "ui-"+ this.role +"-fixed" );
			this.updatePagePadding();
			this._addTransitionClass();
			this._bindPageEvents();
			this._bindToggleHandlers();
		},

		_setOptions: function( o ) {
			if ( o.position === "fixed" && this.options.position !== "fixed" ) {
				this._makeFixed();
			}
			if ( this.options.position === "fixed" && !this.options.supportBlacklist() ) {
				var $page = ( !!this.page )? this.page: ( $(".ui-page-active").length > 0 )? $(".ui-page-active"): $(".ui-page").eq(0);

				if ( o.fullscreen !== undefined) {
					if ( o.fullscreen ) {
						this.element.addClass( "ui-"+ this.role +"-fullscreen" );
						$page.addClass( "ui-page-" + this.role + "-fullscreen" );
					}
					// If not fullscreen, add class to page to set top or bottom padding
					else {
						this.element.removeClass( "ui-"+ this.role +"-fullscreen" );
						$page.removeClass( "ui-page-" + this.role + "-fullscreen" ).addClass( "ui-page-" + this.role+ "-fixed" );
					}
				}
			}
			this._super(o);
		},

		_addTransitionClass: function() {
			var tclass = this.options.transition;

			if ( tclass && tclass !== "none" ) {
				// use appropriate slide for header or footer
				if ( tclass === "slide" ) {
					tclass = this.element.hasClass( "ui-header" ) ? "slidedown" : "slideup";
				}

				this.element.addClass( tclass );
			}
		},

		_bindPageEvents: function() {
			var page = ( !!this.page )? this.element.closest( ".ui-page" ): this.document;
			//page event bindings
			// Fixed toolbars require page zoom to be disabled, otherwise usability issues crop up
			// This method is meant to disable zoom while a fixed-positioned toolbar page is visible
			this._on( page , {
				"pagebeforeshow": "_handlePageBeforeShow",
				"webkitAnimationStart":"_handleAnimationStart",
				"animationstart":"_handleAnimationStart",
				"updatelayout": "_handleAnimationStart",
				"pageshow": "_handlePageShow",
				"pagebeforehide": "_handlePageBeforeHide"
			});
		},

		_handlePageBeforeShow: function( ) {
			var o = this.options;
			if ( o.disablePageZoom ) {
				$.mobile.zoom.disable( true );
			}
			if ( !o.visibleOnPageShow ) {
				this.hide( true );
			}
		},

		_handleAnimationStart: function() {
			if ( this.options.updatePagePadding ) {
				this.updatePagePadding( ( !!this.page )? this.page: ".ui-page-active" );
			}
		},

		_handlePageShow: function() {
			this.updatePagePadding( ( !!this.page )? this.page: ".ui-page-active" );
			if ( this.options.updatePagePadding ) {
				this._on( this.window, { "throttledresize": "updatePagePadding" } );
			}
		},

		_handlePageBeforeHide: function( e, ui ) {
			var o = this.options,
				thisFooter, thisHeader, nextFooter, nextHeader;

			if ( o.disablePageZoom ) {
				$.mobile.zoom.enable( true );
			}
			if ( o.updatePagePadding ) {
				this._off( this.window, "throttledresize" );
			}

			if ( o.trackPersistentToolbars ) {
				thisFooter = $( ".ui-footer-fixed:jqmData(id)", this.page );
				thisHeader = $( ".ui-header-fixed:jqmData(id)", this.page );
				nextFooter = thisFooter.length && ui.nextPage && $( ".ui-footer-fixed:jqmData(id='" + thisFooter.jqmData( "id" ) + "')", ui.nextPage ) || $();
				nextHeader = thisHeader.length && ui.nextPage && $( ".ui-header-fixed:jqmData(id='" + thisHeader.jqmData( "id" ) + "')", ui.nextPage ) || $();

				if ( nextFooter.length || nextHeader.length ) {

					nextFooter.add( nextHeader ).appendTo( $.mobile.pageContainer );

					ui.nextPage.one( "pageshow", function() {
						nextHeader.prependTo( this );
						nextFooter.appendTo( this );
					});
				}
			}
		},

		_visible: true,

		// This will set the content element's top or bottom padding equal to the toolbar's height
		updatePagePadding: function( tbPage ) {
			var $el = this.element,
				header = ( this.role ==="header" ),
				pos = parseFloat( $el.css( header ? "top" : "bottom" ) );

			// This behavior only applies to "fixed", not "fullscreen"
			if ( this.options.fullscreen ) { return; }
			// tbPage argument can be a Page object or an event, if coming from throttled resize.
			tbPage = ( tbPage && tbPage.type === undefined && tbPage ) || this.page || $el.closest( ".ui-page" );
			tbPage = ( !!this.page )? this.page: ".ui-page-active";
			$( tbPage ).css( "padding-" + ( header ? "top" : "bottom" ), $el.outerHeight() + pos );
		},

		_useTransition: function( notransition ) {
			var $win = this.window,
				$el = this.element,
				scroll = $win.scrollTop(),
				elHeight = $el.height(),
				pHeight = ( !!this.page )? $el.closest( ".ui-page" ).height():$(".ui-page-active").height(),
				viewportHeight = $.mobile.getScreenHeight();

			return !notransition &&
				( this.options.transition && this.options.transition !== "none" &&
				(
					( this.role === "header" && !this.options.fullscreen && scroll > elHeight ) ||
					( this.role === "footer" && !this.options.fullscreen && scroll + viewportHeight < pHeight - elHeight )
				) || this.options.fullscreen
				);
		},

		show: function( notransition ) {
			var hideClass = "ui-fixed-hidden",
				$el = this.element;

			if ( this._useTransition( notransition ) ) {
				$el
					.removeClass( "out " + hideClass )
					.addClass( "in" )
					.animationComplete(function () {
						$el.removeClass( "in" );
					});
			}
			else {
				$el.removeClass( hideClass );
			}
			this._visible = true;
		},

		hide: function( notransition ) {
			var hideClass = "ui-fixed-hidden",
				$el = this.element,
				// if it's a slide transition, our new transitions need the reverse class as well to slide outward
				outclass = "out" + ( this.options.transition === "slide" ? " reverse" : "" );

			if ( this._useTransition( notransition ) ) {
				$el
					.addClass( outclass )
					.removeClass( "in" )
					.animationComplete(function() {
						$el.addClass( hideClass ).removeClass( outclass );
					});
			}
			else {
				$el.addClass( hideClass ).removeClass( outclass );
			}
			this._visible = false;
		},

		toggle: function() {
			this[ this._visible ? "hide" : "show" ]();
		},

		_bindToggleHandlers: function() {
			var self = this,
				o = self.options,
				delayShow, delayHide,
				isVisible = true,
				page = ( !!this.page )? this.page: $(".ui-page");

			// tap toggle
			page
				.bind( "vclick", function( e ) {
					if ( o.tapToggle && !$( e.target ).closest( o.tapToggleBlacklist ).length ) {
						self.toggle();
					}
				})
				.bind( "focusin focusout", function( e ) {
					//this hides the toolbars on a keyboard pop to give more screen room and prevent ios bug which
					//positions fixed toolbars in the middle of the screen on pop if the input is near the top or
					//bottom of the screen addresses issues #4410 Footer navbar moves up when clicking on a textbox in an Android environment
					//and issue #4113 Header and footer change their position after keyboard popup - iOS
					//and issue #4410 Footer navbar moves up when clicking on a textbox in an Android environment
					if ( screen.width < 1025 && $( e.target ).is( o.hideDuringFocus ) && !$( e.target ).closest( ".ui-header-fixed, .ui-footer-fixed" ).length ) {
						//Fix for issue #4724 Moving through form in Mobile Safari with "Next" and "Previous" system
						//controls causes fixed position, tap-toggle false Header to reveal itself
						// isVisible instead of self._visible because the focusin and focusout events fire twice at the same time
						// Also use a delay for hiding the toolbars because on Android native browser focusin is direclty followed
						// by a focusout when a native selects opens and the other way around when it closes.
						if ( e.type === "focusout" && !isVisible ) {
							isVisible = true;
							//wait for the stack to unwind and see if we have jumped to another input
							clearTimeout( delayHide );
							delayShow = setTimeout( function() {
								self.show();
							}, 0 );
						} else if ( e.type === "focusin" && !!isVisible ) {
							//if we have jumped to another input clear the time out to cancel the show.
							clearTimeout( delayShow );
							isVisible = false;
							delayHide = setTimeout( function() {
								self.hide();
							}, 0 );
						}
					}
				});
		},

		_setRelative: function() {
			if( this.options.position !== "fixed" ){
				$( "[data-"+ $.mobile.ns + "role='page']" ).css({ "position": "relative" });
			}
		},

		_destroy: function() {
			var $el = this.element,
				header = $el.hasClass( "ui-header" );

			$el.closest( ".ui-page" ).css( "padding-" + ( header ? "top" : "bottom" ), "" );
			$el.removeClass( "ui-header-fixed ui-footer-fixed ui-header-fullscreen ui-footer-fullscreen in out fade slidedown slideup ui-fixed-hidden" );
			$el.closest( ".ui-page" ).removeClass( "ui-page-header-fixed ui-page-footer-fixed ui-page-header-fullscreen ui-page-footer-fullscreen" );
		}

	});
})( jQuery );

(function( $, undefined ) {
	$.widget( "mobile.toolbar", $.mobile.toolbar, {

		_makeFixed: function() {
			this._super();
			this._workarounds();
		},

		//check the browser and version and run needed workarounds
		_workarounds: function() {
			var ua = navigator.userAgent,
			platform = navigator.platform,
			// Rendering engine is Webkit, and capture major version
			wkmatch = ua.match( /AppleWebKit\/([0-9]+)/ ),
			wkversion = !!wkmatch && wkmatch[ 1 ],
			os = null,
			self = this;
			//set the os we are working in if it dosent match one with workarounds return
			if ( platform.indexOf( "iPhone" ) > -1 || platform.indexOf( "iPad" ) > -1  || platform.indexOf( "iPod" ) > -1 ) {
				os = "ios";
			} else if ( ua.indexOf( "Android" ) > -1 ) {
				os = "android";
			} else {
				return;
			}
			//check os version if it dosent match one with workarounds return
			if ( os === "ios" ) {
				//iOS  workarounds
				self._bindScrollWorkaround();
			} else if ( os === "android" && wkversion && wkversion < 534 ) {
				//Android 2.3 run all Android 2.3 workaround
				self._bindScrollWorkaround();
				self._bindListThumbWorkaround();
			} else {
				return;
			}
		},

		//Utility class for checking header and footer positions relative to viewport
		_viewportOffset: function() {
			var $el = this.element,
				header = $el.hasClass( "ui-header" ),
				offset = Math.abs( $el.offset().top - this.window.scrollTop() );
			if ( !header ) {
				offset = Math.round( offset - this.window.height() + $el.outerHeight() ) - 60;
			}
			return offset;
		},

		//bind events for _triggerRedraw() function
		_bindScrollWorkaround: function() {
			var self = this;
			//bind to scrollstop and check if the toolbars are correctly positioned
			this._on( this.window, { scrollstop: function() {
				var viewportOffset = self._viewportOffset();
				//check if the header is visible and if its in the right place
				if ( viewportOffset > 2 && self._visible ) {
					self._triggerRedraw();
				}
			}});
		},

		//this addresses issue #4250 Persistent footer instability in v1.1 with long select lists in Android 2.3.3
		//and issue #3748 Android 2.x: Page transitions broken when fixed toolbars used
		//the absolutely positioned thumbnail in a list view causes problems with fixed position buttons above in a nav bar
		//setting the li's to -webkit-transform:translate3d(0,0,0); solves this problem to avoide potential issues in other
		//platforms we scope this with the class ui-android-2x-fix
		_bindListThumbWorkaround: function() {
			this.element.closest( ".ui-page" ).addClass( "ui-android-2x-fixed" );
		},
		//this addresses issues #4337 Fixed header problem after scrolling content on iOS and Android
		//and device bugs project issue #1 Form elements can lose click hit area in position: fixed containers.
		//this also addresses not on fixed toolbars page in docs
		//adding 1px of padding to the bottom then removing it causes a "redraw"
		//which positions the toolbars correctly (they will always be visually correct)
		_triggerRedraw: function() {
			var paddingBottom = parseFloat( $( ".ui-page-active" ).css( "padding-bottom" ) );
			//trigger page redraw to fix incorrectly positioned fixed elements
			$( ".ui-page-active" ).css( "padding-bottom", ( paddingBottom + 1 ) + "px" );
			//if the padding is reset with out a timeout the reposition will not occure.
			//this is independant of JQM the browser seems to need the time to react.
			setTimeout( function() {
				$( ".ui-page-active" ).css( "padding-bottom", paddingBottom + "px" );
			}, 0 );
		},

		destroy: function() {
			this._super();
			//Remove the class we added to the page previously in android 2.x
			this.element.closest( ".ui-page-active" ).removeClass( "ui-android-2x-fix" );
		}
	});

})( jQuery );


( function( $, undefined ) {

var ieHack = ( $.mobile.browser.oldIE && $.mobile.browser.oldIE <= 8 ),
	uiTemplate = $(
		"<div class='ui-popup-arrow-guide'></div>" +
		"<div class='ui-popup-arrow-container" + ( ieHack ? " ie" : "" ) + "'>" +
			"<div class='ui-popup-arrow'></div>" +
		"</div>"
	);

function getArrow() {
	var clone = uiTemplate.clone(),
		gd = clone.eq( 0 ),
		ct = clone.eq( 1 ),
		ar = ct.children();

	return { arEls: ct.add( gd ), gd: gd, ct: ct, ar: ar };
}

$.widget( "mobile.popup", $.mobile.popup, {
	options: {

		arrow: ""
	},

	_create: function() {
		var ar,
			ret = this._super();

		if ( this.options.arrow ) {
			this._ui.arrow = ar = this._addArrow();
		}

		return ret;
	},

	_addArrow: function() {
		var theme,
			opts = this.options,
			ar = getArrow();

		theme = this._themeClassFromOption( "ui-body-", opts.theme );
		ar.ar.addClass( theme + ( opts.shadow ? " ui-overlay-shadow" : "" ) );
		ar.arEls.hide().appendTo( this.element );

		return ar;
	},

	_unenhance: function() {
		var ar = this._ui.arrow;

		if ( ar ) {
			ar.arEls.remove();
		}

		return this._super();
	},

	// Pretend to show an arrow described by @p and @dir and calculate the
	// distance from the desired point. If a best-distance is passed in, return
	// the minimum of the one passed in and the one calculated.
	_tryAnArrow: function( p, dir, desired, s, best ) {
		var result, r, diff, desiredForArrow = {}, tip = {};

		// If the arrow has no wiggle room along the edge of the popup, it cannot
		// be displayed along the requested edge without it sticking out.
		if ( s.arFull[ p.dimKey ] > s.guideDims[ p.dimKey ] ) {
			return best;
		}

		desiredForArrow[ p.fst ] = desired[ p.fst ] +
			( s.arHalf[ p.oDimKey ] + s.menuHalf[ p.oDimKey ] ) * p.offsetFactor -
			s.contentBox[ p.fst ] + ( s.clampInfo.menuSize[ p.oDimKey ] - s.contentBox[ p.oDimKey ] ) * p.arrowOffsetFactor;
		desiredForArrow[ p.snd ] = desired[ p.snd ];

		result = s.result || this._calculateFinalLocation( desiredForArrow, s.clampInfo );
		r = { x: result.left, y: result.top };

		tip[ p.fst ] = r[ p.fst ] + s.contentBox[ p.fst ] + p.tipOffset;
		tip[ p.snd ] = Math.max( result[ p.prop ] + s.guideOffset[ p.prop ] + s.arHalf[ p.dimKey ],
			Math.min( result[ p.prop ] + s.guideOffset[ p.prop ] + s.guideDims[ p.dimKey ] - s.arHalf[ p.dimKey ],
				desired[ p.snd ] ) );

		diff = Math.abs( desired.x - tip.x ) + Math.abs( desired.y - tip.y );
		if ( !best || diff < best.diff ) {
			// Convert tip offset to coordinates inside the popup
			tip[ p.snd ] -= s.arHalf[ p.dimKey ] + result[ p.prop ] + s.contentBox[ p.snd ];
			best = { dir: dir, diff: diff, result: result, posProp: p.prop, posVal: tip[ p.snd ] };
		}

		return best;
	},

	_getPlacementState: function( clamp ) {
		var offset, gdOffset,
			ar = this._ui.arrow,
			state = {
				clampInfo: this._clampPopupWidth( !clamp ),
				arFull: { cx: ar.ct.width(), cy: ar.ct.height() },
				guideDims: { cx: ar.gd.width(), cy: ar.gd.height() },
				guideOffset: ar.gd.offset()
			};

		offset = this.element.offset();

		ar.gd.css( { left: 0, top: 0, right: 0, bottom: 0 } );
		gdOffset = ar.gd.offset();
		state.contentBox = {
			x: gdOffset.left - offset.left,
			y: gdOffset.top - offset.top,
			cx: ar.gd.width(),
			cy: ar.gd.height()
		};
		ar.gd.removeAttr( "style" );

		// The arrow box moves between guideOffset and guideOffset + guideDims - arFull
		state.guideOffset = { left: state.guideOffset.left - offset.left, top: state.guideOffset.top - offset.top };
		state.arHalf = { cx: state.arFull.cx / 2, cy: state.arFull.cy / 2 };
		state.menuHalf = { cx: state.clampInfo.menuSize.cx / 2, cy: state.clampInfo.menuSize.cy / 2 };

		return state;
	},

	_placementCoords: function( desired ) {
		var state, best, params, elOffset, bgRef,
			optionValue = this.options.arrow,
			ar = this._ui.arrow;

		if ( !ar ) {
			return this._super( desired );
		}

		ar.arEls.show();

		bgRef = {};
		state = this._getPlacementState( true );
		params = {
			"l": { fst: "x", snd: "y", prop: "top", dimKey: "cy", oDimKey: "cx", offsetFactor: 1, tipOffset:  -state.arHalf.cx, arrowOffsetFactor: 0 },
			"r": { fst: "x", snd: "y", prop: "top", dimKey: "cy", oDimKey: "cx", offsetFactor: -1, tipOffset: state.arHalf.cx + state.contentBox.cx, arrowOffsetFactor: 1 },
			"b": { fst: "y", snd: "x", prop: "left", dimKey: "cx", oDimKey: "cy", offsetFactor: -1, tipOffset: state.arHalf.cy + state.contentBox.cy, arrowOffsetFactor: 1 },
			"t": { fst: "y", snd: "x", prop: "left", dimKey: "cx", oDimKey: "cy", offsetFactor: 1, tipOffset: -state.arHalf.cy, arrowOffsetFactor: 0 }
		};

		// Try each side specified in the options to see on which one the arrow
		// should be placed such that the distance between the tip of the arrow and
		// the desired coordinates is the shortest.
		$.each( ( optionValue === true ? "l,t,r,b" : optionValue ).split( "," ),
			$.proxy( function( key, value ) {
				best = this._tryAnArrow( params[ value ], value, desired, state, best );
			}, this ) );

		// Could not place the arrow along any of the edges - behave as if showing
		// the arrow was turned off.
		if ( !best ) {
			ar.arEls.hide();
			return this._super( desired );
		}

		// Move the arrow into place
		ar.ct
			.removeClass( "ui-popup-arrow-l ui-popup-arrow-t ui-popup-arrow-r ui-popup-arrow-b" )
			.addClass( "ui-popup-arrow-" + best.dir )
			.removeAttr( "style" ).css( best.posProp, best.posVal )
			.show();

		// Do not move/size the background div on IE, because we use the arrow div for background as well.
		if ( !ieHack ) {
			elOffset = this.element.offset();
			bgRef[ params[ best.dir ].fst ] = ar.ct.offset();
			bgRef[ params[ best.dir ].snd ] = {
				left: elOffset.left + state.contentBox.x,
				top: elOffset.top + state.contentBox.y
			};
		}

		return best.result;
	},

	_setOptions: function( opts ) {
		var newTheme,
			oldTheme = this.options.theme,
			ar = this._ui.arrow,
			ret = this._super( opts );

		if ( opts.arrow !== undefined ) {
			if ( !ar && opts.arrow ) {
				this._ui.arrow = this._addArrow();

				// Important to return here so we don't set the same options all over
				// again below.
				return;
			} else if ( ar && !opts.arrow ) {
				ar.arEls.remove();
				this._ui.arrow = null;
			}
		}

		// Reassign with potentially new arrow
		ar = this._ui.arrow;

		if ( ar ) {
			if ( opts.theme !== undefined ) {
				oldTheme = this._themeClassFromOption( "ui-body-", oldTheme );
				newTheme = this._themeClassFromOption( "ui-body-", opts.theme );
				ar.ar.removeClass( oldTheme ).addClass( newTheme );
			}

			if ( opts.shadow !== undefined ) {
				ar.ar.toggleClass( "ui-overlay-shadow", opts.shadow );
			}
		}

		return ret;
	},

	_destroy: function() {
		var ar = this._ui.arrow;

		if ( ar ) {
			ar.arEls.remove();
		}

		return this._super();
	}
});

})( jQuery );


(function( $, undefined ) {

$.widget( "mobile.panel", {
	options: {
		classes: {
			panel: "ui-panel",
			panelOpen: "ui-panel-open",
			panelClosed: "ui-panel-closed",
			panelFixed: "ui-panel-fixed",
			panelInner: "ui-panel-inner",
			modal: "ui-panel-dismiss",
			modalOpen: "ui-panel-dismiss-open",
			pageContainer: "ui-panel-page-container",
			pageWrapper: "ui-panel-wrapper",
			pageFixedToolbar: "ui-panel-fixed-toolbar",
			pageContentPrefix: "ui-panel-page-content", /* Used for wrapper and fixed toolbars position, display and open classes. */
			animate: "ui-panel-animate"
		},
		animate: true,
		theme: null,
		position: "left",
		dismissible: true,
		display: "reveal", //accepts reveal, push, overlay
		swipeClose: true,
		positionFixed: false
	},

	_closeLink: null,
	_parentPage: null,
	_page: null,
	_modal: null,
	_panelInner: null,
	_wrapper: null,
	_fixedToolbars: null,

	_create: function() {
		var el = this.element,
			parentPage = el.closest( ".ui-page, :jqmData(role='page')" );

		// expose some private props to other methods
		$.extend( this, {
			_closeLink: el.find( ":jqmData(rel='close')" ),
			_parentPage: ( parentPage.length > 0 ) ? parentPage : false,
			_openedPage: null,
			_page: this._getPage,
			_panelInner: this._getPanelInner(),
			_fixedToolbars: this._getFixedToolbars
		});
		if ( this.options.display !== "overlay" ){
			this._getWrapper();
		}
		this._addPanelClasses();

		// if animating, add the class to do so
		if ( $.support.cssTransform3d && !!this.options.animate ) {
			this.element.addClass( this.options.classes.animate );
		}

		this._bindUpdateLayout();
		this._bindCloseEvents();
		this._bindLinkListeners();
		this._bindPageEvents();

		if ( !!this.options.dismissible ) {
			this._createModal();
		}

		this._bindSwipeEvents();
	},

	_getPanelInner: function() {
		var panelInner = this.element.find( "." + this.options.classes.panelInner );

		if ( panelInner.length === 0 ) {
			panelInner = this.element.children().wrapAll( "<div class='" + this.options.classes.panelInner + "' />" ).parent();
		}

		return panelInner;
	},

	_createModal: function() {
		var self = this,
			target = self._parentPage ? self._parentPage.parent() : self.element.parent();

		self._modal = $( "<div class='" + self.options.classes.modal + "'></div>" )
			.on( "mousedown", function() {
				self.close();
			})
			.appendTo( target );
	},

	_getPage: function() {
		var page = this._openedPage || this._parentPage || $( "." + $.mobile.activePageClass );

		return page;
	},

	_getWrapper: function() {
		var wrapper = this._page().find( "." + this.options.classes.pageWrapper );
		if ( wrapper.length === 0 ) {
			wrapper = this._page().children( ".ui-header:not(.ui-header-fixed), .ui-content:not(.ui-popup), .ui-footer:not(.ui-footer-fixed)" )
				.wrapAll( "<div class='" + this.options.classes.pageWrapper + "'></div>" )
				.parent();
		}

		this._wrapper = wrapper;
	},

	_getFixedToolbars: function() {
		var extFixedToolbars = $( "body" ).children( ".ui-header-fixed, .ui-footer-fixed" ),
			intFixedToolbars = this._page().find( ".ui-header-fixed, .ui-footer-fixed" ),
			fixedToolbars = extFixedToolbars.add( intFixedToolbars ).addClass( this.options.classes.pageFixedToolbar );

		return fixedToolbars;
	},

	_getPosDisplayClasses: function( prefix ) {
		return prefix + "-position-" + this.options.position + " " + prefix + "-display-" + this.options.display;
	},

	_getPanelClasses: function() {
		var panelClasses = this.options.classes.panel +
			" " + this._getPosDisplayClasses( this.options.classes.panel ) +
			" " + this.options.classes.panelClosed +
			" " + "ui-body-" + ( this.options.theme ? this.options.theme : "inherit" );

		if ( !!this.options.positionFixed ) {
			panelClasses += " " + this.options.classes.panelFixed;
		}

		return panelClasses;
	},

	_addPanelClasses: function() {
		this.element.addClass( this._getPanelClasses() );
	},

	_handleCloseClick: function( event ) {
		if ( !event.isDefaultPrevented() ) {
			this.close();
		}
	},

	_bindCloseEvents: function() {
		this._on( this._closeLink, {
			"click": "_handleCloseClick"
		});

		this._on({
			"click a:jqmData(ajax='false')": "_handleCloseClick"
		});
	},

	_positionPanel: function( scrollToTop ) {
		var self = this,
			panelInnerHeight = self._panelInner.outerHeight(),
			expand = panelInnerHeight > $.mobile.getScreenHeight();

		if ( expand || !self.options.positionFixed ) {
			if ( expand ) {
				self._unfixPanel();
				$.mobile.resetActivePageHeight( panelInnerHeight );
			}
			if ( scrollToTop ) {
				this.window[ 0 ].scrollTo( 0, $.mobile.defaultHomeScroll );
			}
		} else {
			self._fixPanel();
		}
	},

	_bindFixListener: function() {
		this._on( $( window ), { "throttledresize": "_positionPanel" });
	},

	_unbindFixListener: function() {
		this._off( $( window ), "throttledresize" );
	},

	_unfixPanel: function() {
		if ( !!this.options.positionFixed && $.support.fixedPosition ) {
			this.element.removeClass( this.options.classes.panelFixed );
		}
	},

	_fixPanel: function() {
		if ( !!this.options.positionFixed && $.support.fixedPosition ) {
			this.element.addClass( this.options.classes.panelFixed );
		}
	},

	_bindUpdateLayout: function() {
		var self = this;

		self.element.on( "updatelayout", function(/* e */) {
			if ( self._open ) {
				self._positionPanel();
			}
		});
	},

	_bindLinkListeners: function() {
		this._on( "body", {
			"click a": "_handleClick"
		});

	},

	_handleClick: function( e ) {
		var link,
			panelId = this.element.attr( "id" );

		if ( e.currentTarget.href.split( "#" )[ 1 ] === panelId && panelId !== undefined ) {

			e.preventDefault();
			link = $( e.target );
			if ( link.hasClass( "ui-btn" ) ) {
				link.addClass( $.mobile.activeBtnClass );
				this.element.one( "panelopen panelclose", function() {
					link.removeClass( $.mobile.activeBtnClass );
				});
			}
			this.toggle();
		}
	},

	_bindSwipeEvents: function() {
		var self = this,
			area = self._modal ? self.element.add( self._modal ) : self.element;

		// on swipe, close the panel
		if ( !!self.options.swipeClose ) {
			if ( self.options.position === "left" ) {
				area.on( "swipeleft.panel", function(/* e */) {
					self.close();
				});
			} else {
				area.on( "swiperight.panel", function(/* e */) {
					self.close();
				});
			}
		}
	},

	_bindPageEvents: function() {
		var self = this;

		this.document
			// Close the panel if another panel on the page opens
			.on( "panelbeforeopen", function( e ) {
				if ( self._open && e.target !== self.element[ 0 ] ) {
					self.close();
				}
			})
			// On escape, close? might need to have a target check too...
			.on( "keyup.panel", function( e ) {
				if ( e.keyCode === 27 && self._open ) {
					self.close();
				}
			});
		if ( !this._parentPage && this.options.display !== "overlay" ) {
			this._on( this.document, {
				"pageshow": "_getWrapper"
			});
		}
		// Clean up open panels after page hide
		if ( self._parentPage ) {
			this.document.on( "pagehide", ":jqmData(role='page')", function() {
				if ( self._open ) {
					self.close( true );
				}
			});
		} else {
			this.document.on( "pagebeforehide", function() {
				if ( self._open ) {
					self.close( true );
				}
			});
		}
	},

	// state storage of open or closed
	_open: false,
	_pageContentOpenClasses: null,
	_modalOpenClasses: null,

	open: function( immediate ) {
		if ( !this._open ) {
			var self = this,
				o = self.options,

				_openPanel = function() {
					self._off( self.document , "panelclose" );
					self._page().jqmData( "panel", "open" );

					if ( $.support.cssTransform3d && !!o.animate && o.display !== "overlay" ) {
						self._wrapper.addClass( o.classes.animate );
						self._fixedToolbars().addClass( o.classes.animate );
					}

					if ( !immediate && $.support.cssTransform3d && !!o.animate ) {
						( self._wrapper || self.element )
							.animationComplete( complete, "transition" );
					} else {
						setTimeout( complete, 0 );
					}

					if ( o.theme && o.display !== "overlay" ) {
						self._page().parent()
							.addClass( o.classes.pageContainer + "-themed " + o.classes.pageContainer + "-" + o.theme );
					}

					self.element
						.removeClass( o.classes.panelClosed )
						.addClass( o.classes.panelOpen );

					self._positionPanel( true );

					self._pageContentOpenClasses = self._getPosDisplayClasses( o.classes.pageContentPrefix );

					if ( o.display !== "overlay" ) {
						self._page().parent().addClass( o.classes.pageContainer );
						self._wrapper.addClass( self._pageContentOpenClasses );
						self._fixedToolbars().addClass( self._pageContentOpenClasses );
					}

					self._modalOpenClasses = self._getPosDisplayClasses( o.classes.modal ) + " " + o.classes.modalOpen;
					if ( self._modal ) {
						self._modal
							.addClass( self._modalOpenClasses )
							.height( Math.max( self._modal.height(), self.document.height() ) );
					}
				},
				complete = function() {

					// Bail if the panel was closed before the opening animation has completed
					if ( !self._open ) {
						return;
					}

					if ( o.display !== "overlay" ) {
						self._wrapper.addClass( o.classes.pageContentPrefix + "-open" );
						self._fixedToolbars().addClass( o.classes.pageContentPrefix + "-open" );
					}

					self._bindFixListener();

					self._trigger( "open" );

					self._openedPage = self._page();
				};

			self._trigger( "beforeopen" );

			if ( self._page().jqmData( "panel" ) === "open" ) {
				self._on( self.document, {
					"panelclose": _openPanel
				});
			} else {
				_openPanel();
			}

			self._open = true;
		}
	},

	close: function( immediate ) {
		if ( this._open ) {
			var self = this,
				o = this.options,

				_closePanel = function() {

					self.element.removeClass( o.classes.panelOpen );

					if ( o.display !== "overlay" ) {
						self._wrapper.removeClass( self._pageContentOpenClasses );
						self._fixedToolbars().removeClass( self._pageContentOpenClasses );
					}

					if ( !immediate && $.support.cssTransform3d && !!o.animate ) {
						( self._wrapper || self.element )
							.animationComplete( complete, "transition" );
					} else {
						setTimeout( complete, 0 );
					}

					if ( self._modal ) {
						self._modal
							.removeClass( self._modalOpenClasses )
							.height( "" );
					}
				},
				complete = function() {
					if ( o.theme && o.display !== "overlay" ) {
						self._page().parent().removeClass( o.classes.pageContainer + "-themed " + o.classes.pageContainer + "-" + o.theme );
					}

					self.element.addClass( o.classes.panelClosed );

					if ( o.display !== "overlay" ) {
						self._page().parent().removeClass( o.classes.pageContainer );
						self._wrapper.removeClass( o.classes.pageContentPrefix + "-open" );
						self._fixedToolbars().removeClass( o.classes.pageContentPrefix + "-open" );
					}

					if ( $.support.cssTransform3d && !!o.animate && o.display !== "overlay" ) {
						self._wrapper.removeClass( o.classes.animate );
						self._fixedToolbars().removeClass( o.classes.animate );
					}

					self._fixPanel();
					self._unbindFixListener();
					$.mobile.resetActivePageHeight();

					self._page().jqmRemoveData( "panel" );

					self._trigger( "close" );

					self._openedPage = null;
				};

			self._trigger( "beforeclose" );

			_closePanel();

			self._open = false;
		}
	},

	toggle: function() {
		this[ this._open ? "close" : "open" ]();
	},

	_destroy: function() {
		var otherPanels,
		o = this.options,
		multiplePanels = ( $( "body > :mobile-panel" ).length + $.mobile.activePage.find( ":mobile-panel" ).length ) > 1;

		if ( o.display !== "overlay" ) {

			//  remove the wrapper if not in use by another panel
			otherPanels = $( "body > :mobile-panel" ).add( $.mobile.activePage.find( ":mobile-panel" ) );
			if ( otherPanels.not( ".ui-panel-display-overlay" ).not( this.element ).length === 0 ) {
				this._wrapper.children().unwrap();
			}

			if ( this._open ) {

				this._fixedToolbars().removeClass( o.classes.pageContentPrefix + "-open" );

				if ( $.support.cssTransform3d && !!o.animate ) {
					this._fixedToolbars().removeClass( o.classes.animate );
				}

				this._page().parent().removeClass( o.classes.pageContainer );

				if ( o.theme ) {
					this._page().parent().removeClass( o.classes.pageContainer + "-themed " + o.classes.pageContainer + "-" + o.theme );
				}
			}
		}

		if ( !multiplePanels ) {

			this.document.off( "panelopen panelclose" );

		}

		if ( this._open ) {
			this._page().jqmRemoveData( "panel" );
		}

		this._panelInner.children().unwrap();

		this.element
			.removeClass( [ this._getPanelClasses(), o.classes.panelOpen, o.classes.animate ].join( " " ) )
			.off( "swipeleft.panel swiperight.panel" )
			.off( "panelbeforeopen" )
			.off( "panelhide" )
			.off( "keyup.panel" )
			.off( "updatelayout" );

		if ( this._modal ) {
			this._modal.remove();
		}
	}
});

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.table", {
	options: {
		classes: {
			table: "ui-table"
		},
		enhanced: false
	},

	_create: function() {
		if ( !this.options.enhanced ) {
			this.element.addClass( this.options.classes.table );
		}

		// extend here, assign on refresh > _setHeaders
		$.extend( this, {

			// Expose headers and allHeaders properties on the widget
			// headers references the THs within the first TR in the table
			headers: undefined,

			// allHeaders references headers, plus all THs in the thead, which may
			// include several rows, or not
			allHeaders: undefined
		});

		this._refresh( true );
	},

	_setHeaders: function() {
		var trs = this.element.find( "thead tr" );

		this.headers = this.element.find( "tr:eq(0)" ).children();
		this.allHeaders = this.headers.add( trs.children() );
	},

	refresh: function() {
		this._refresh();
	},

	rebuild: $.noop,

	_refresh: function( /* create */ ) {
		var table = this.element,
			trs = table.find( "thead tr" );

		// updating headers on refresh (fixes #5880)
		this._setHeaders();

		// Iterate over the trs
		trs.each( function() {
			var columnCount = 0;

			// Iterate over the children of the tr
			$( this ).children().each( function() {
				var span = parseInt( this.getAttribute( "colspan" ), 10 ),
					selector = ":nth-child(" + ( columnCount + 1 ) + ")",
					j;

				this.setAttribute( "data-" + $.mobile.ns + "colstart", columnCount + 1 );

				if ( span ) {
					for( j = 0; j < span - 1; j++ ) {
						columnCount++;
						selector += ", :nth-child(" + ( columnCount + 1 ) + ")";
					}
				}

				// Store "cells" data on header as a reference to all cells in the
				// same column as this TH
				$( this ).jqmData( "cells", table.find( "tr" ).not( trs.eq( 0 ) ).not( this ).children( selector ) );

				columnCount++;
			});
		});
	}
});

})( jQuery );


(function( $, undefined ) {

$.widget( "mobile.table", $.mobile.table, {
	options: {
		mode: "columntoggle",
		columnBtnTheme: null,
		columnPopupTheme: null,
		columnBtnText: "Columns...",
		classes: $.extend( $.mobile.table.prototype.options.classes, {
			popup: "ui-table-columntoggle-popup",
			columnBtn: "ui-table-columntoggle-btn",
			priorityPrefix: "ui-table-priority-",
			columnToggleTable: "ui-table-columntoggle"
		})
	},

	_create: function() {
		this._super();

		if ( this.options.mode !== "columntoggle" ) {
			return;
		}

		$.extend( this, {
			_menu: null
		});

		if ( this.options.enhanced ) {
			this._menu = $( this.document[ 0 ].getElementById( this._id() + "-popup" ) ).children().first();
			this._addToggles( this._menu, true );
		} else {
			this._menu = this._enhanceColToggle();
			this.element.addClass( this.options.classes.columnToggleTable );
		}

		this._setupEvents();

		this._setToggleState();
	},

	_id: function() {
		return ( this.element.attr( "id" ) || ( this.widgetName + this.uuid ) );
	},

	_setupEvents: function() {
		//NOTE: inputs are bound in bindToggles,
		// so it can be called on refresh, too

		// update column toggles on resize
		this._on( this.window, {
			throttledresize: "_setToggleState"
		});
		this._on( this._menu, {
			"change input": "_menuInputChange"
		});
	},

	_addToggles: function( menu, keep ) {
		var inputs,
			checkboxIndex = 0,
			opts = this.options,
			container = menu.controlgroup( "container" );

		// allow update of menu on refresh (fixes #5880)
		if ( keep ) {
			inputs = menu.find( "input" );
		} else {
			container.empty();
		}

		// create the hide/show toggles
		this.headers.not( "td" ).each( function() {
			var input, cells,
				header = $( this ),
				priority = $.mobile.getAttribute( this, "priority" );

			if ( priority ) {
				cells = header.add( header.jqmData( "cells" ) );
				cells.addClass( opts.classes.priorityPrefix + priority );

				// Make sure the (new?) checkbox is associated with its header via .jqmData() and
				// that, vice versa, the header is also associated with the checkbox
				input = ( keep ? inputs.eq( checkboxIndex++ ) :
					$("<label><input type='checkbox' checked />" +
						( header.children( "abbr" ).first().attr( "title" ) ||
							header.text() ) +
						"</label>" )
						.appendTo( container )
						.children( 0 )
						.checkboxradio( {
							theme: opts.columnPopupTheme
						}) )

						// Associate the header with the checkbox
						.jqmData( "header", header )
						.jqmData( "cells", cells );

				// Associate the checkbox with the header
				header.jqmData( "input", input );
			}
		});

		// set bindings here
		if ( !keep ) {
			menu.controlgroup( "refresh" );
		}
	},

	_menuInputChange: function( evt ) {
		var input = $( evt.target ),
			checked = input[ 0 ].checked;

		input.jqmData( "cells" )
			.toggleClass( "ui-table-cell-hidden", !checked )
			.toggleClass( "ui-table-cell-visible", checked );
	},

	_unlockCells: function( cells ) {
		// allow hide/show via CSS only = remove all toggle-locks
		cells.removeClass( "ui-table-cell-hidden ui-table-cell-visible");
	},

	_enhanceColToggle: function() {
		var id , menuButton, popup, menu,
			table = this.element,
			opts = this.options,
			ns = $.mobile.ns,
			fragment = this.document[ 0 ].createDocumentFragment();

		id = this._id() + "-popup";
		menuButton = $( "<a href='#" + id + "' " +
			"class='" + opts.classes.columnBtn + " ui-btn " +
			"ui-btn-" + ( opts.columnBtnTheme || "a" ) +
			" ui-corner-all ui-shadow ui-mini' " +
			"data-" + ns + "rel='popup'>" + opts.columnBtnText + "</a>" );
		popup = $( "<div class='" + opts.classes.popup + "' id='" + id + "'></div>" );
		menu = $( "<fieldset></fieldset>" ).controlgroup();

		// set extension here, send "false" to trigger build/rebuild
		this._addToggles( menu, false );

		menu.appendTo( popup );

		fragment.appendChild( popup[ 0 ] );
		fragment.appendChild( menuButton[ 0 ] );
		table.before( fragment );

		popup.popup();

		return menu;
	},

	rebuild: function() {
		this._super();

		if ( this.options.mode === "columntoggle" ) {
			// NOTE: rebuild passes "false", while refresh passes "undefined"
			// both refresh the table, but inside addToggles, !false will be true,
			// so a rebuild call can be indentified
			this._refresh( false );
		}
	},

	_refresh: function( create ) {
		var headers, hiddenColumns, index;

		// Calling _super() here updates this.headers
		this._super( create );

		if ( !create && this.options.mode === "columntoggle" ) {
			headers = this.headers;
			hiddenColumns = [];

			// Find the index of the column header associated with each old checkbox among the
			// post-refresh headers and, if the header is still there, make sure the corresponding
			// column will be hidden if the pre-refresh checkbox indicates that the column is
			// hidden by recording its index in the array of hidden columns.
			this._menu.find( "input" ).each( function() {
				var input = $( this ),
					header = input.jqmData( "header" ),
					index = headers.index( header[ 0 ] );

				if ( index > -1 && !input.prop( "checked" ) ) {

					// The column header associated with /this/ checkbox is still present in the
					// post-refresh table and the checkbox is not checked, so the column associated
					// with this column header is currently hidden. Let's record that.
					hiddenColumns.push( index );
				}
			});

			// columns not being replaced must be cleared from input toggle-locks
			this._unlockCells( this.element.find( ".ui-table-cell-hidden, " +
				".ui-table-cell-visible" ) );

			// update columntoggles and cells
			this._addToggles( this._menu, create );

			// At this point all columns are visible, so uncheck the checkboxes that correspond to
			// those columns we've found to be hidden
			for ( index = hiddenColumns.length - 1 ; index > -1 ; index-- ) {
				headers.eq( hiddenColumns[ index ] ).jqmData( "input" )
					.prop( "checked", false )
					.checkboxradio( "refresh" )
					.trigger( "change" );
			}
		}
	},

	_setToggleState: function() {
		this._menu.find( "input" ).each( function() {
			var checkbox = $( this );

			this.checked = checkbox.jqmData( "cells" ).eq( 0 ).css( "display" ) === "table-cell";
			checkbox.checkboxradio( "refresh" );
		});
	},

	_destroy: function() {
		this._super();
	}
});

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.table", $.mobile.table, {
	options: {
		mode: "reflow",
		classes: $.extend( $.mobile.table.prototype.options.classes, {
			reflowTable: "ui-table-reflow",
			cellLabels: "ui-table-cell-label"
		})
	},

	_create: function() {
		this._super();

		// If it's not reflow mode, return here.
		if ( this.options.mode !== "reflow" ) {
			return;
		}

		if ( !this.options.enhanced ) {
			this.element.addClass( this.options.classes.reflowTable );

			this._updateReflow();
		}
	},

	rebuild: function() {
		this._super();

		if ( this.options.mode === "reflow" ) {
			this._refresh( false );
		}
	},

	_refresh: function( create ) {
		this._super( create );
		if ( !create && this.options.mode === "reflow" ) {
			this._updateReflow( );
		}
	},

	_updateReflow: function() {
		var table = this,
			opts = this.options;

		// get headers in reverse order so that top-level headers are appended last
		$( table.allHeaders.get().reverse() ).each( function() {
			var cells = $( this ).jqmData( "cells" ),
				colstart = $.mobile.getAttribute( this, "colstart" ),
				hierarchyClass = cells.not( this ).filter( "thead th" ).length && " ui-table-cell-label-top",
				contents = $( this ).clone().contents(),
				iteration, filter;

				if ( contents.length > 0  ) {

					if ( hierarchyClass ) {
						iteration = parseInt( this.getAttribute( "colspan" ), 10 );
						filter = "";

						if ( iteration ) {
							filter = "td:nth-child("+ iteration +"n + " + ( colstart ) +")";
						}

						table._addLabels( cells.filter( filter ),
							opts.classes.cellLabels + hierarchyClass, contents );
					} else {
						table._addLabels( cells, opts.classes.cellLabels, contents );
					}

				}
		});
	},

	_addLabels: function( cells, label, contents ) {
		// .not fixes #6006
		cells
			.not( ":has(b." + label + ")" )
				.prepend( $( "<b class='" + label + "'></b>" ).append( contents ) );
	}
});

})( jQuery );

(function( $, undefined ) {

// TODO rename filterCallback/deprecate and default to the item itself as the first argument
var defaultFilterCallback = function( index, searchValue ) {
	return ( ( "" + ( $.mobile.getAttribute( this, "filtertext" ) || $( this ).text() ) )
		.toLowerCase().indexOf( searchValue ) === -1 );
};

$.widget( "mobile.filterable", {

	initSelector: ":jqmData(filter='true')",

	options: {
		filterReveal: false,
		filterCallback: defaultFilterCallback,
		enhanced: false,
		input: null,
		children: "> li, > option, > optgroup option, > tbody tr, > .ui-controlgroup-controls > .ui-btn, > .ui-controlgroup-controls > .ui-checkbox, > .ui-controlgroup-controls > .ui-radio"
	},

	_create: function() {
		var opts = this.options;

		$.extend( this, {
			_search: null,
			_timer: 0
		});

		this._setInput( opts.input );
		if ( !opts.enhanced ) {
			this._filterItems( ( ( this._search && this._search.val() ) || "" ).toLowerCase() );
		}
	},

	_onKeyUp: function() {
		var val, lastval,
			search = this._search;

		if ( search ) {
			val = search.val().toLowerCase(),
			lastval = $.mobile.getAttribute( search[ 0 ], "lastval" ) + "";

			if ( lastval && lastval === val ) {
				// Execute the handler only once per value change
				return;
			}

			if ( this._timer ) {
				window.clearTimeout( this._timer );
				this._timer = 0;
			}

			this._timer = this._delay( function() {
				if ( this._trigger( "beforefilter", null, { input: search } ) === false ) {
					return false;
				}

				// Change val as lastval for next execution
				search[ 0 ].setAttribute( "data-" + $.mobile.ns + "lastval", val );

				this._filterItems( val );
				this._timer = 0;
			}, 250 );
		}
	},

	_getFilterableItems: function() {
		var elem = this.element,
			children = this.options.children,
			items = !children ? { length: 0 }:
				$.isFunction( children ) ? children():
				children.nodeName ? $( children ):
				children.jquery ? children:
				this.element.find( children );

		if ( items.length === 0 ) {
			items = elem.children();
		}

		return items;
	},

	_filterItems: function( val ) {
		var idx, callback, length, dst,
			show = [],
			hide = [],
			opts = this.options,
			filterItems = this._getFilterableItems();

		if ( val != null ) {
			callback = opts.filterCallback || defaultFilterCallback;
			length = filterItems.length;

			// Partition the items into those to be hidden and those to be shown
			for ( idx = 0 ; idx < length ; idx++ ) {
				dst = ( callback.call( filterItems[ idx ], idx, val ) ) ? hide : show;
				dst.push( filterItems[ idx ] );
			}
		}

		// If nothing is hidden, then the decision whether to hide or show the items
		// is based on the "filterReveal" option.
		if ( hide.length === 0 ) {
			filterItems[ ( opts.filterReveal && val.length === 0 ) ?
				"addClass" : "removeClass" ]( "ui-screen-hidden" );
		} else {
			$( hide ).addClass( "ui-screen-hidden" );
			$( show ).removeClass( "ui-screen-hidden" );
		}

		this._refreshChildWidget();

		this._trigger( "filter", null, {
			items: filterItems
		});
	},

	// The Default implementation of _refreshChildWidget attempts to call
	// refresh on collapsibleset, controlgroup, selectmenu, or listview
	_refreshChildWidget: function() {
		var widget, idx,
			recognizedWidgets = [ "collapsibleset", "selectmenu", "controlgroup", "listview" ];

		for ( idx = recognizedWidgets.length - 1 ; idx > -1 ; idx-- ) {
			widget = recognizedWidgets[ idx ];
			if ( $.mobile[ widget ] ) {
				widget = this.element.data( "mobile-" + widget );
				if ( widget && $.isFunction( widget.refresh ) ) {
					widget.refresh();
				}
			}
		}
	},

	// TODO: When the input is not internal, do not even store it in this._search
	_setInput: function ( selector ) {
		var search = this._search;

		// Stop a pending filter operation
		if ( this._timer ) {
			window.clearTimeout( this._timer );
			this._timer = 0;
		}

		if ( search ) {
			this._off( search, "keyup change input" );
			search = null;
		}

		if ( selector ) {
			search = selector.jquery ? selector:
				selector.nodeName ? $( selector ):
				this.document.find( selector );

			this._on( search, {
				keydown: "_onKeyDown",
				keypress: "_onKeyPress",
				keyup: "_onKeyUp",
				change: "_onKeyUp",
				input: "_onKeyUp"
			});
		}

		this._search = search;
	},

	// Prevent form submission
	_onKeyDown: function( event ) {
		if ( event.keyCode === $.ui.keyCode.ENTER ) {
			event.preventDefault();
			this._preventKeyPress = true;
		}
	},

	_onKeyPress: function( event ) {
		if ( this._preventKeyPress ) {
			event.preventDefault();
			this._preventKeyPress = false;
		}
	},

	_setOptions: function( options ) {
		var refilter = !( ( options.filterReveal === undefined ) &&
				( options.filterCallback === undefined ) &&
				( options.children === undefined ) );

		this._super( options );

		if ( options.input !== undefined ) {
			this._setInput( options.input );
			refilter = true;
		}

		if ( refilter ) {
			this.refresh();
		}
	},

	_destroy: function() {
		var opts = this.options,
			items = this._getFilterableItems();

		if ( opts.enhanced ) {
			items.toggleClass( "ui-screen-hidden", opts.filterReveal );
		} else {
			items.removeClass( "ui-screen-hidden" );
		}
	},

	refresh: function() {
		if ( this._timer ) {
			window.clearTimeout( this._timer );
			this._timer = 0;
		}
		this._filterItems( ( ( this._search && this._search.val() ) || "" ).toLowerCase() );
	}
});

})( jQuery );

(function( $, undefined ) {

// Create a function that will replace the _setOptions function of a widget,
// and will pass the options on to the input of the filterable.
var replaceSetOptions = function( self, orig ) {
		return function( options ) {
			orig.call( this, options );
			self._syncTextInputOptions( options );
		};
	},
	rDividerListItem = /(^|\s)ui-li-divider(\s|$)/,
	origDefaultFilterCallback = $.mobile.filterable.prototype.options.filterCallback;

// Override the default filter callback with one that does not hide list dividers
$.mobile.filterable.prototype.options.filterCallback = function( index, searchValue ) {
	return !this.className.match( rDividerListItem ) &&
		origDefaultFilterCallback.call( this, index, searchValue );
};

$.widget( "mobile.filterable", $.mobile.filterable, {
	options: {
		filterPlaceholder: "Filter items...",
		filterTheme: null
	},

	_create: function() {
		var idx, widgetName,
			elem = this.element,
			recognizedWidgets = [ "collapsibleset", "selectmenu", "controlgroup", "listview" ],
			createHandlers = {};

		this._super();

		$.extend( this, {
			_widget: null
		});

		for ( idx = recognizedWidgets.length - 1 ; idx > -1 ; idx-- ) {
			widgetName = recognizedWidgets[ idx ];
			if ( $.mobile[ widgetName ] ) {
				if ( this._setWidget( elem.data( "mobile-" + widgetName ) ) ) {
					break;
				} else {
					createHandlers[ widgetName + "create" ] = "_handleCreate";
				}
			}
		}

		if ( !this._widget ) {
			this._on( elem, createHandlers );
		}
	},

	_handleCreate: function( evt ) {
		this._setWidget( this.element.data( "mobile-" + evt.type.substring( 0, evt.type.length - 6 ) ) );
	},

	_trigger: function( type, event, data ) {
		if ( this._widget && this._widget.widgetFullName === "mobile-listview" &&
			type === "beforefilter" ) {

			// Also trigger listviewbeforefilter if this widget is also a listview
			this._widget._trigger( "beforefilter", event, data );
		}

		// Passing back the response enables calling preventDefault()
		return this._super( type, event, data );
	},

	_setWidget: function( widget ) {
		if ( !this._widget && widget ) {
			this._widget = widget;
			this._widget._setOptions = replaceSetOptions( this, this._widget._setOptions );
		}

		if ( !!this._widget ) {
			this._syncTextInputOptions( this._widget.options );
			if ( this._widget.widgetName === "listview" ) {
				this._widget.options.hideDividers = true;
				this._widget.element.listview( "refresh" );
			}
		}

		return !!this._widget;
	},

	_isSearchInternal: function() {
		return ( this._search && this._search.jqmData( "ui-filterable-" + this.uuid + "-internal" ) );
	},

	_setInput: function( selector ) {
		var opts = this.options,
			updatePlaceholder = true,
			textinputOpts = {};

		if ( !selector ) {
			if ( this._isSearchInternal() ) {

				// Ignore the call to set a new input if the selector goes to falsy and
				// the current textinput is already of the internally generated variety.
				return;
			} else {

				// Generating a new textinput widget. No need to set the placeholder
				// further down the function.
				updatePlaceholder = false;
				selector = $( "<input " +
					"data-" + $.mobile.ns + "type='search' " +
					"placeholder='" + opts.filterPlaceholder + "'></input>" )
					.jqmData( "ui-filterable-" + this.uuid + "-internal", true );
				$( "<form class='ui-filterable'></form>" )
					.append( selector )
					.submit( function( evt ) {
						evt.preventDefault();
						selector.blur();
					})
					.insertBefore( this.element );
				if ( $.mobile.textinput ) {
					if ( this.options.filterTheme != null ) {
						textinputOpts[ "theme" ] = opts.filterTheme;
					}

					selector.textinput( textinputOpts );
				}
			}
		}

		this._super( selector );

		if ( this._isSearchInternal() && updatePlaceholder ) {
			this._search.attr( "placeholder", this.options.filterPlaceholder );
		}
	},

	_setOptions: function( options ) {
		var ret = this._super( options );

		// Need to set the filterPlaceholder after having established the search input
		if ( options.filterPlaceholder !== undefined ) {
			if ( this._isSearchInternal() ) {
				this._search.attr( "placeholder", options.filterPlaceholder );
			}
		}

		if ( options.filterTheme !== undefined && this._search && $.mobile.textinput ) {
			this._search.textinput( "option", "theme", options.filterTheme );
		}

		return ret;
	},

	_destroy: function() {
		if ( this._isSearchInternal() ) {
			this._search.remove();
		}
		this._super();
	},

	_syncTextInputOptions: function( options ) {
		var idx,
			textinputOptions = {};

		// We only sync options if the filterable's textinput is of the internally
		// generated variety, rather than one specified by the user.
		if ( this._isSearchInternal() && $.mobile.textinput ) {

			// Apply only the options understood by textinput
			for ( idx in $.mobile.textinput.prototype.options ) {
				if ( options[ idx ] !== undefined ) {
					if ( idx === "theme" && this.options.filterTheme != null ) {
						textinputOptions[ idx ] = this.options.filterTheme;
					} else {
						textinputOptions[ idx ] = options[ idx ];
					}
				}
			}
			this._search.textinput( "option", textinputOptions );
		}
	}
});

// Instantiate a filterable on a listview that has the data-filter="true" attribute
// This is not necessary for static content, because the auto-enhance takes care of instantiating
// the filterable upon encountering data-filter="true". However, because of 1.3.x it is expected
// that a listview with data-filter="true" will be filterable even if you just instantiate a
// listview on it. The extension below ensures that this continues to happen in 1.4.x.
$.widget( "mobile.listview", $.mobile.listview, {
	options: {
		filter: false
	},
	_create: function() {
		if ( this.options.filter === true &&
				!this.element.data( "mobile-filterable" ) ) {
			this.element.filterable();
		}
		return this._super();
	},

	_afterListviewRefresh: function() {
		var filterable = this.element.data( "mobile-filterable" );

		if ( this.options.filter === true && filterable ) {
			this._preventRefreshLoop = true;
			filterable.refresh();
		}
	},

	// Eliminate infinite recursion caused by the fact that we call filterable.refresh() from
	// _afterListviewRefresh() above, which, in turn, calls _refreshChildWidget(), which, in
	// turn, calls listview refresh(), which would, in turn, calls _afterListviewRefresh()
	// above, if we wouldn't prevent that right here.
	refresh: function() {
		var returnValue;

		if ( !this._preventRefreshLoop ) {
			returnValue = this._superApply( arguments );
		}

		this._preventRefreshLoop = false;

		return returnValue;
	}
});

})( jQuery );

/*!
 * jQuery UI Tabs fadf2b312a05040436451c64bbfaf4814bc62c56
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/tabs/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var tabId = 0,
	rhash = /#.*$/;

function getNextTabId() {
	return ++tabId;
}

function isLocal( anchor ) {
	return anchor.hash.length > 1 &&
		decodeURIComponent( anchor.href.replace( rhash, "" ) ) ===
			decodeURIComponent( location.href.replace( rhash, "" ) );
}

$.widget( "ui.tabs", {
	version: "fadf2b312a05040436451c64bbfaf4814bc62c56",
	delay: 300,
	options: {
		active: null,
		collapsible: false,
		event: "click",
		heightStyle: "content",
		hide: null,
		show: null,

		// callbacks
		activate: null,
		beforeActivate: null,
		beforeLoad: null,
		load: null
	},

	_create: function() {
		var that = this,
			options = this.options;

		this.running = false;

		this.element
			.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )
			.toggleClass( "ui-tabs-collapsible", options.collapsible )
			// Prevent users from focusing disabled tabs via click
			.delegate( ".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function( event ) {
				if ( $( this ).is( ".ui-state-disabled" ) ) {
					event.preventDefault();
				}
			})
			// support: IE <9
			// Preventing the default action in mousedown doesn't prevent IE
			// from focusing the element, so if the anchor gets focused, blur.
			// We don't have to worry about focusing the previously focused
			// element since clicking on a non-focusable element should focus
			// the body anyway.
			.delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
				if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
					this.blur();
				}
			});

		this._processTabs();
		options.active = this._initialActive();

		// Take disabling tabs via class attribute from HTML
		// into account and update option properly.
		if ( $.isArray( options.disabled ) ) {
			options.disabled = $.unique( options.disabled.concat(
				$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
					return that.tabs.index( li );
				})
			) ).sort();
		}

		// check for length avoids error when initializing empty list
		if ( this.options.active !== false && this.anchors.length ) {
			this.active = this._findActive( options.active );
		} else {
			this.active = $();
		}

		this._refresh();

		if ( this.active.length ) {
			this.load( options.active );
		}
	},

	_initialActive: function() {
		var active = this.options.active,
			collapsible = this.options.collapsible,
			locationHash = location.hash.substring( 1 );

		if ( active === null ) {
			// check the fragment identifier in the URL
			if ( locationHash ) {
				this.tabs.each(function( i, tab ) {
					if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
						active = i;
						return false;
					}
				});
			}

			// check for a tab marked active via a class
			if ( active === null ) {
				active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
			}

			// no active tab, set to false
			if ( active === null || active === -1 ) {
				active = this.tabs.length ? 0 : false;
			}
		}

		// handle numbers: negative, out of range
		if ( active !== false ) {
			active = this.tabs.index( this.tabs.eq( active ) );
			if ( active === -1 ) {
				active = collapsible ? false : 0;
			}
		}

		// don't allow collapsible: false and active: false
		if ( !collapsible && active === false && this.anchors.length ) {
			active = 0;
		}

		return active;
	},

	_getCreateEventData: function() {
		return {
			tab: this.active,
			panel: !this.active.length ? $() : this._getPanelForTab( this.active )
		};
	},

	_tabKeydown: function( event ) {
		var focusedTab = $( this.document[0].activeElement ).closest( "li" ),
			selectedIndex = this.tabs.index( focusedTab ),
			goingForward = true;

		if ( this._handlePageNav( event ) ) {
			return;
		}

		switch ( event.keyCode ) {
			case $.ui.keyCode.RIGHT:
			case $.ui.keyCode.DOWN:
				selectedIndex++;
				break;
			case $.ui.keyCode.UP:
			case $.ui.keyCode.LEFT:
				goingForward = false;
				selectedIndex--;
				break;
			case $.ui.keyCode.END:
				selectedIndex = this.anchors.length - 1;
				break;
			case $.ui.keyCode.HOME:
				selectedIndex = 0;
				break;
			case $.ui.keyCode.SPACE:
				// Activate only, no collapsing
				event.preventDefault();
				clearTimeout( this.activating );
				this._activate( selectedIndex );
				return;
			case $.ui.keyCode.ENTER:
				// Toggle (cancel delayed activation, allow collapsing)
				event.preventDefault();
				clearTimeout( this.activating );
				// Determine if we should collapse or activate
				this._activate( selectedIndex === this.options.active ? false : selectedIndex );
				return;
			default:
				return;
		}

		// Focus the appropriate tab, based on which key was pressed
		event.preventDefault();
		clearTimeout( this.activating );
		selectedIndex = this._focusNextTab( selectedIndex, goingForward );

		// Navigating with control key will prevent automatic activation
		if ( !event.ctrlKey ) {
			// Update aria-selected immediately so that AT think the tab is already selected.
			// Otherwise AT may confuse the user by stating that they need to activate the tab,
			// but the tab will already be activated by the time the announcement finishes.
			focusedTab.attr( "aria-selected", "false" );
			this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );

			this.activating = this._delay(function() {
				this.option( "active", selectedIndex );
			}, this.delay );
		}
	},

	_panelKeydown: function( event ) {
		if ( this._handlePageNav( event ) ) {
			return;
		}

		// Ctrl+up moves focus to the current tab
		if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
			event.preventDefault();
			this.active.focus();
		}
	},

	// Alt+page up/down moves focus to the previous/next tab (and activates)
	_handlePageNav: function( event ) {
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
			this._activate( this._focusNextTab( this.options.active - 1, false ) );
			return true;
		}
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
			this._activate( this._focusNextTab( this.options.active + 1, true ) );
			return true;
		}
	},

	_findNextTab: function( index, goingForward ) {
		var lastTabIndex = this.tabs.length - 1;

		function constrain() {
			if ( index > lastTabIndex ) {
				index = 0;
			}
			if ( index < 0 ) {
				index = lastTabIndex;
			}
			return index;
		}

		while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
			index = goingForward ? index + 1 : index - 1;
		}

		return index;
	},

	_focusNextTab: function( index, goingForward ) {
		index = this._findNextTab( index, goingForward );
		this.tabs.eq( index ).focus();
		return index;
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "disabled" ) {
			// don't use the widget factory's disabled handling
			this._setupDisabled( value );
			return;
		}

		this._super( key, value);

		if ( key === "collapsible" ) {
			this.element.toggleClass( "ui-tabs-collapsible", value );
			// Setting collapsible: false while collapsed; open first panel
			if ( !value && this.options.active === false ) {
				this._activate( 0 );
			}
		}

		if ( key === "event" ) {
			this._setupEvents( value );
		}

		if ( key === "heightStyle" ) {
			this._setupHeightStyle( value );
		}
	},

	_tabId: function( tab ) {
		return tab.attr( "aria-controls" ) || "ui-tabs-" + getNextTabId();
	},

	_sanitizeSelector: function( hash ) {
		return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
	},

	refresh: function() {
		var options = this.options,
			lis = this.tablist.children( ":has(a[href])" );

		// get disabled tabs from class attribute from HTML
		// this will get converted to a boolean if needed in _refresh()
		options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
			return lis.index( tab );
		});

		this._processTabs();

		// was collapsed or no tabs
		if ( options.active === false || !this.anchors.length ) {
			options.active = false;
			this.active = $();
		// was active, but active tab is gone
		} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
			// all remaining tabs are disabled
			if ( this.tabs.length === options.disabled.length ) {
				options.active = false;
				this.active = $();
			// activate previous tab
			} else {
				this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
			}
		// was active, active tab still exists
		} else {
			// make sure active index is correct
			options.active = this.tabs.index( this.active );
		}

		this._refresh();
	},

	_refresh: function() {
		this._setupDisabled( this.options.disabled );
		this._setupEvents( this.options.event );
		this._setupHeightStyle( this.options.heightStyle );

		this.tabs.not( this.active ).attr({
			"aria-selected": "false",
			tabIndex: -1
		});
		this.panels.not( this._getPanelForTab( this.active ) )
			.hide()
			.attr({
				"aria-expanded": "false",
				"aria-hidden": "true"
			});

		// Make sure one tab is in the tab order
		if ( !this.active.length ) {
			this.tabs.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active
				.addClass( "ui-tabs-active ui-state-active" )
				.attr({
					"aria-selected": "true",
					tabIndex: 0
				});
			this._getPanelForTab( this.active )
				.show()
				.attr({
					"aria-expanded": "true",
					"aria-hidden": "false"
				});
		}
	},

	_processTabs: function() {
		var that = this;

		this.tablist = this._getList()
			.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.attr( "role", "tablist" );

		this.tabs = this.tablist.find( "> li:has(a[href])" )
			.addClass( "ui-state-default ui-corner-top" )
			.attr({
				role: "tab",
				tabIndex: -1
			});

		this.anchors = this.tabs.map(function() {
				return $( "a", this )[ 0 ];
			})
			.addClass( "ui-tabs-anchor" )
			.attr({
				role: "presentation",
				tabIndex: -1
			});

		this.panels = $();

		this.anchors.each(function( i, anchor ) {
			var selector, panel, panelId,
				anchorId = $( anchor ).uniqueId().attr( "id" ),
				tab = $( anchor ).closest( "li" ),
				originalAriaControls = tab.attr( "aria-controls" );

			// inline tab
			if ( isLocal( anchor ) ) {
				selector = anchor.hash;
				panel = that.element.find( that._sanitizeSelector( selector ) );
			// remote tab
			} else {
				panelId = that._tabId( tab );
				selector = "#" + panelId;
				panel = that.element.find( selector );
				if ( !panel.length ) {
					panel = that._createPanel( panelId );
					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
				}
				panel.attr( "aria-live", "polite" );
			}

			if ( panel.length) {
				that.panels = that.panels.add( panel );
			}
			if ( originalAriaControls ) {
				tab.data( "ui-tabs-aria-controls", originalAriaControls );
			}
			tab.attr({
				"aria-controls": selector.substring( 1 ),
				"aria-labelledby": anchorId
			});
			panel.attr( "aria-labelledby", anchorId );
		});

		this.panels
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.attr( "role", "tabpanel" );
	},

	// allow overriding how to find the list for rare usage scenarios (#7715)
	_getList: function() {
		return this.element.find( "ol,ul" ).eq( 0 );
	},

	_createPanel: function( id ) {
		return $( "<div>" )
			.attr( "id", id )
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.data( "ui-tabs-destroy", true );
	},

	_setupDisabled: function( disabled ) {
		if ( $.isArray( disabled ) ) {
			if ( !disabled.length ) {
				disabled = false;
			} else if ( disabled.length === this.anchors.length ) {
				disabled = true;
			}
		}

		// disable tabs
		for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
			if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
				$( li )
					.addClass( "ui-state-disabled" )
					.attr( "aria-disabled", "true" );
			} else {
				$( li )
					.removeClass( "ui-state-disabled" )
					.removeAttr( "aria-disabled" );
			}
		}

		this.options.disabled = disabled;
	},

	_setupEvents: function( event ) {
		var events = {
			click: function( event ) {
				event.preventDefault();
			}
		};
		if ( event ) {
			$.each( event.split(" "), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			});
		}

		this._off( this.anchors.add( this.tabs ).add( this.panels ) );
		this._on( this.anchors, events );
		this._on( this.tabs, { keydown: "_tabKeydown" } );
		this._on( this.panels, { keydown: "_panelKeydown" } );

		this._focusable( this.tabs );
		this._hoverable( this.tabs );
	},

	_setupHeightStyle: function( heightStyle ) {
		var maxHeight,
			parent = this.element.parent();

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			maxHeight -= this.element.outerHeight() - this.element.height();

			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});

			this.element.children().not( this.panels ).each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.panels.each(function() {
				$( this ).height( Math.max( 0, maxHeight -
					$( this ).innerHeight() + $( this ).height() ) );
			})
			.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.panels.each(function() {
				maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
			}).height( maxHeight );
		}
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			anchor = $( event.currentTarget ),
			tab = anchor.closest( "li" ),
			clickedIsActive = tab[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : this._getPanelForTab( tab ),
			toHide = !active.length ? $() : this._getPanelForTab( active ),
			eventData = {
				oldTab: active,
				oldPanel: toHide,
				newTab: collapsing ? $() : tab,
				newPanel: toShow
			};

		event.preventDefault();

		if ( tab.hasClass( "ui-state-disabled" ) ||
				// tab is already loading
				tab.hasClass( "ui-tabs-loading" ) ||
				// can't switch durning an animation
				this.running ||
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.tabs.index( tab );

		this.active = clickedIsActive ? $() : tab;
		if ( this.xhr ) {
			this.xhr.abort();
		}

		if ( !toHide.length && !toShow.length ) {
			$.error( "jQuery UI Tabs: Mismatching fragment identifier." );
		}

		if ( toShow.length ) {
			this.load( this.tabs.index( tab ), event );
		}
		this._toggle( event, eventData );
	},

	// handles show/hide for selecting tabs
	_toggle: function( event, eventData ) {
		var that = this,
			toShow = eventData.newPanel,
			toHide = eventData.oldPanel;

		this.running = true;

		function complete() {
			that.running = false;
			that._trigger( "activate", event, eventData );
		}

		function show() {
			eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );

			if ( toShow.length && that.options.show ) {
				that._show( toShow, that.options.show, complete );
			} else {
				toShow.show();
				complete();
			}
		}

		// start out by hiding, then showing, then completing
		if ( toHide.length && this.options.hide ) {
			this._hide( toHide, this.options.hide, function() {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				show();
			});
		} else {
			eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
			toHide.hide();
			show();
		}

		toHide.attr({
			"aria-expanded": "false",
			"aria-hidden": "true"
		});
		eventData.oldTab.attr( "aria-selected", "false" );
		// If we're switching tabs, remove the old tab from the tab order.
		// If we're opening from collapsed state, remove the previous tab from the tab order.
		// If we're collapsing, then keep the collapsing tab in the tab order.
		if ( toShow.length && toHide.length ) {
			eventData.oldTab.attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.tabs.filter(function() {
				return $( this ).attr( "tabIndex" ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow.attr({
			"aria-expanded": "true",
			"aria-hidden": "false"
		});
		eventData.newTab.attr({
			"aria-selected": "true",
			tabIndex: 0
		});
	},

	_activate: function( index ) {
		var anchor,
			active = this._findActive( index );

		// trying to activate the already active panel
		if ( active[ 0 ] === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the current active header
		if ( !active.length ) {
			active = this.active;
		}

		anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
		this._eventHandler({
			target: anchor,
			currentTarget: anchor,
			preventDefault: $.noop
		});
	},

	_findActive: function( index ) {
		return index === false ? $() : this.tabs.eq( index );
	},

	_getIndex: function( index ) {
		// meta-function to give users option to provide a href string instead of a numerical index.
		if ( typeof index === "string" ) {
			index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
		}

		return index;
	},

	_destroy: function() {
		if ( this.xhr ) {
			this.xhr.abort();
		}

		this.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );

		this.tablist
			.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.removeAttr( "role" );

		this.anchors
			.removeClass( "ui-tabs-anchor" )
			.removeAttr( "role" )
			.removeAttr( "tabIndex" )
			.removeUniqueId();

		this.tabs.add( this.panels ).each(function() {
			if ( $.data( this, "ui-tabs-destroy" ) ) {
				$( this ).remove();
			} else {
				$( this )
					.removeClass( "ui-state-default ui-state-active ui-state-disabled " +
						"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )
					.removeAttr( "tabIndex" )
					.removeAttr( "aria-live" )
					.removeAttr( "aria-busy" )
					.removeAttr( "aria-selected" )
					.removeAttr( "aria-labelledby" )
					.removeAttr( "aria-hidden" )
					.removeAttr( "aria-expanded" )
					.removeAttr( "role" );
			}
		});

		this.tabs.each(function() {
			var li = $( this ),
				prev = li.data( "ui-tabs-aria-controls" );
			if ( prev ) {
				li
					.attr( "aria-controls", prev )
					.removeData( "ui-tabs-aria-controls" );
			} else {
				li.removeAttr( "aria-controls" );
			}
		});

		this.panels.show();

		if ( this.options.heightStyle !== "content" ) {
			this.panels.css( "height", "" );
		}
	},

	enable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === false ) {
			return;
		}

		if ( index === undefined ) {
			disabled = false;
		} else {
			index = this._getIndex( index );
			if ( $.isArray( disabled ) ) {
				disabled = $.map( disabled, function( num ) {
					return num !== index ? num : null;
				});
			} else {
				disabled = $.map( this.tabs, function( li, num ) {
					return num !== index ? num : null;
				});
			}
		}
		this._setupDisabled( disabled );
	},

	disable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === true ) {
			return;
		}

		if ( index === undefined ) {
			disabled = true;
		} else {
			index = this._getIndex( index );
			if ( $.inArray( index, disabled ) !== -1 ) {
				return;
			}
			if ( $.isArray( disabled ) ) {
				disabled = $.merge( [ index ], disabled ).sort();
			} else {
				disabled = [ index ];
			}
		}
		this._setupDisabled( disabled );
	},

	load: function( index, event ) {
		index = this._getIndex( index );
		var that = this,
			tab = this.tabs.eq( index ),
			anchor = tab.find( ".ui-tabs-anchor" ),
			panel = this._getPanelForTab( tab ),
			eventData = {
				tab: tab,
				panel: panel
			};

		// not remote
		if ( isLocal( anchor[ 0 ] ) ) {
			return;
		}

		this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

		// support: jQuery <1.8
		// jQuery <1.8 returns false if the request is canceled in beforeSend,
		// but as of 1.8, $.ajax() always returns a jqXHR object.
		if ( this.xhr && this.xhr.statusText !== "canceled" ) {
			tab.addClass( "ui-tabs-loading" );
			panel.attr( "aria-busy", "true" );

			this.xhr
				.success(function( response ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						panel.html( response );
						that._trigger( "load", event, eventData );
					}, 1 );
				})
				.complete(function( jqXHR, status ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						if ( status === "abort" ) {
							that.panels.stop( false, true );
						}

						tab.removeClass( "ui-tabs-loading" );
						panel.removeAttr( "aria-busy" );

						if ( jqXHR === that.xhr ) {
							delete that.xhr;
						}
					}, 1 );
				});
		}
	},

	_ajaxSettings: function( anchor, event, eventData ) {
		var that = this;
		return {
			url: anchor.attr( "href" ),
			beforeSend: function( jqXHR, settings ) {
				return that._trigger( "beforeLoad", event,
					$.extend( { jqXHR : jqXHR, ajaxSettings: settings }, eventData ) );
			}
		};
	},

	_getPanelForTab: function( tab ) {
		var id = $( tab ).attr( "aria-controls" );
		return this.element.find( this._sanitizeSelector( "#" + id ) );
	}
});

})( jQuery );

(function( $, undefined ) {

})( jQuery );

(function( $, window ) {

	$.mobile.iosorientationfixEnabled = true;

	// This fix addresses an iOS bug, so return early if the UA claims it's something else.
	var ua = navigator.userAgent,
		zoom,
		evt, x, y, z, aig;
	if ( !( /iPhone|iPad|iPod/.test( navigator.platform ) && /OS [1-5]_[0-9_]* like Mac OS X/i.test( ua ) && ua.indexOf( "AppleWebKit" ) > -1 ) ) {
		$.mobile.iosorientationfixEnabled = false;
		return;
	}

	zoom = $.mobile.zoom;

	function checkTilt( e ) {
		evt = e.originalEvent;
		aig = evt.accelerationIncludingGravity;

		x = Math.abs( aig.x );
		y = Math.abs( aig.y );
		z = Math.abs( aig.z );

		// If portrait orientation and in one of the danger zones
		if ( !window.orientation && ( x > 7 || ( ( z > 6 && y < 8 || z < 8 && y > 6 ) && x > 5 ) ) ) {
				if ( zoom.enabled ) {
					zoom.disable();
				}
		}	else if ( !zoom.enabled ) {
				zoom.enable();
		}
	}

	$.mobile.document.on( "mobileinit", function() {
		if ( $.mobile.iosorientationfixEnabled ) {
			$.mobile.window
				.bind( "orientationchange.iosorientationfix", zoom.enable )
				.bind( "devicemotion.iosorientationfix", checkTilt );
		}
	});

}( jQuery, this ));

(function( $, window, undefined ) {
	var	$html = $( "html" ),
		$window = $.mobile.window;

	//remove initial build class (only present on first pageshow)
	function hideRenderingClass() {
		$html.removeClass( "ui-mobile-rendering" );
	}

	// trigger mobileinit event - useful hook for configuring $.mobile settings before they're used
	$( window.document ).trigger( "mobileinit" );

	// support conditions
	// if device support condition(s) aren't met, leave things as they are -> a basic, usable experience,
	// otherwise, proceed with the enhancements
	if ( !$.mobile.gradeA() ) {
		return;
	}

	// override ajaxEnabled on platforms that have known conflicts with hash history updates
	// or generally work better browsing in regular http for full page refreshes (BB5, Opera Mini)
	if ( $.mobile.ajaxBlacklist ) {
		$.mobile.ajaxEnabled = false;
	}

	// Add mobile, initial load "rendering" classes to docEl
	$html.addClass( "ui-mobile ui-mobile-rendering" );

	// This is a fallback. If anything goes wrong (JS errors, etc), or events don't fire,
	// this ensures the rendering class is removed after 5 seconds, so content is visible and accessible
	setTimeout( hideRenderingClass, 5000 );

	$.extend( $.mobile, {
		// find and enhance the pages in the dom and transition to the first page.
		initializePage: function() {
			// find present pages
			var path = $.mobile.path,
				$pages = $( ":jqmData(role='page'), :jqmData(role='dialog')" ),
				hash = path.stripHash( path.stripQueryParams(path.parseLocation().hash) ),
				theLocation = $.mobile.path.parseLocation(),
				hashPage = document.getElementById( hash );

			// if no pages are found, create one with body's inner html
			if ( !$pages.length ) {
				$pages = $( "body" ).wrapInner( "<div data-" + $.mobile.ns + "role='page'></div>" ).children( 0 );
			}

			// add dialogs, set data-url attrs
			$pages.each(function() {
				var $this = $( this );

				// unless the data url is already set set it to the pathname
				if ( !$this[ 0 ].getAttribute( "data-" + $.mobile.ns + "url" ) ) {
					$this.attr( "data-" + $.mobile.ns + "url", $this.attr( "id" ) ||
						theLocation.pathname + theLocation.search );
				}
			});

			// define first page in dom case one backs out to the directory root (not always the first page visited, but defined as fallback)
			$.mobile.firstPage = $pages.first();

			// define page container
			$.mobile.pageContainer = $.mobile.firstPage
				.parent()
				.addClass( "ui-mobile-viewport" )
				.pagecontainer();

			// initialize navigation events now, after mobileinit has occurred and the page container
			// has been created but before the rest of the library is alerted to that fact
			$.mobile.navreadyDeferred.resolve();

			// alert listeners that the pagecontainer has been determined for binding
			// to events triggered on it
			$window.trigger( "pagecontainercreate" );

			// cue page loading message
			$.mobile.loading( "show" );

			//remove initial build class (only present on first pageshow)
			hideRenderingClass();

			// if hashchange listening is disabled, there's no hash deeplink,
			// the hash is not valid (contains more than one # or does not start with #)
			// or there is no page with that hash, change to the first page in the DOM
			// Remember, however, that the hash can also be a path!
			if ( ! ( $.mobile.hashListeningEnabled &&
				$.mobile.path.isHashValid( location.hash ) &&
				( $( hashPage ).is( ":jqmData(role='page')" ) ||
					$.mobile.path.isPath( hash ) ||
					hash === $.mobile.dialogHashKey ) ) ) {

				// Store the initial destination
				if ( $.mobile.path.isHashValid( location.hash ) ) {
					$.mobile.navigate.history.initialDst = hash.replace( "#", "" );
				}

				// make sure to set initial popstate state if it exists
				// so that navigation back to the initial page works properly
				if ( $.event.special.navigate.isPushStateEnabled() ) {
					$.mobile.navigate.navigator.squash( path.parseLocation().href );
				}

				$.mobile.changePage( $.mobile.firstPage, {
					transition: "none",
					reverse: true,
					changeHash: false,
					fromHashChange: true
				});
			} else {
				// trigger hashchange or navigate to squash and record the correct
				// history entry for an initial hash path
				if ( !$.event.special.navigate.isPushStateEnabled() ) {
					$window.trigger( "hashchange", [true] );
				} else {
					// TODO figure out how to simplify this interaction with the initial history entry
					// at the bottom js/navigate/navigate.js
					$.mobile.navigate.history.stack = [];
					$.mobile.navigate( $.mobile.path.isPath( location.hash ) ? location.hash : location.href );
				}
			}
		}
	});

	$(function() {
		//Run inlineSVG support test
		$.support.inlineSVG();

		// check which scrollTop value should be used by scrolling to 1 immediately at domready
		// then check what the scroll top is. Android will report 0... others 1
		// note that this initial scroll won't hide the address bar. It's just for the check.

		// hide iOS browser chrome on load if hideUrlBar is true this is to try and do it as soon as possible
		if ( $.mobile.hideUrlBar ) {
			window.scrollTo( 0, 1 );
		}

		// if defaultHomeScroll hasn't been set yet, see if scrollTop is 1
		// it should be 1 in most browsers, but android treats 1 as 0 (for hiding addr bar)
		// so if it's 1, use 0 from now on
		$.mobile.defaultHomeScroll = ( !$.support.scrollTop || $.mobile.window.scrollTop() === 1 ) ? 0 : 1;

		//dom-ready inits
		if ( $.mobile.autoInitializePage ) {
			$.mobile.initializePage();
		}

		// window load event
		// hide iOS browser chrome on load if hideUrlBar is true this is as fall back incase we were too early before
		if ( $.mobile.hideUrlBar ) {
			$window.load( $.mobile.silentScroll );
		}

		if ( !$.support.cssPointerEvents ) {
			// IE and Opera don't support CSS pointer-events: none that we use to disable link-based buttons
			// by adding the 'ui-disabled' class to them. Using a JavaScript workaround for those browser.
			// https://github.com/jquery/jquery-mobile/issues/3558

			// DEPRECATED as of 1.4.0 - remove ui-disabled after 1.4.0 release
			// only ui-state-disabled should be present thereafter
			$.mobile.document.delegate( ".ui-state-disabled,.ui-disabled", "vclick",
				function( e ) {
					e.preventDefault();
					e.stopImmediatePropagation();
				}
			);
		}
	});
}( jQuery, this ));


}));

},{}],"libs/jquery.mobile-1.4.3-psalted":[function(require,module,exports){
module.exports=require('U3u7kb');
},{}],"libs/song_utils":[function(require,module,exports){
module.exports=require('EAptEV');
},{}],"EAptEV":[function(require,module,exports){
module.exports = {
  getSpotifySelectOptions: function (title, artist, preload_id, cb) {
    var searchURL = 'http://ws.spotify.com/search/1/track.json?q=' + title + '+'+ artist;
    jQuery.get(searchURL, function (data, textStatus, jqXHR) {
      var options = '';
      var songIdTable = {};
      for (var i=0; i < Math.min(5, data.tracks.length); i++) {
        if (data.tracks[i]['external-ids'] && data.tracks[i]['external-ids'][0]) {
          var id = data.tracks[i]['external-ids'][0].id;
          if (! songIdTable[id]) {
            songIdTable[id] = true;
            options += '<option value="'+data.tracks[i].href+'">'+data.tracks[i].name +' (' +data.tracks[i].artists[0].name + ')';
          }
        }
      }
      options += '<option value="">(None of the above)';
      cb(options)
    }, 'json' )
  }
}
},{}],"dztHS2":[function(require,module,exports){
var $;

$ = require('jquery');

$.mobile = require('jquery-mobile');

$(document).delegate("#admin-groups", "pageinit", function() {
  return $('.admin-groups-delete-link').on('click', function(e) {
    var popup;
    $('#admin-groups-delete-form').attr('action', '/admin/groups/' + $(this).attr('data-id'));
    popup = $(e.currentTarget).closest('[data-role=popup]');
    popup.on('popupafterclose', function() {
      return setTimeout(function() {
        $($(e.currentTarget).attr('href')).popup('open');
        return popup.off('popupafterclose');
      }, 100);
    });
    return popup.popup('close');
  });
});


},{}],"main/admin/groups":[function(require,module,exports){
module.exports=require('dztHS2');
},{}],"b4GRNz":[function(require,module,exports){
var $;

$ = require('jquery');

$.mobile = require('jquery-mobile');

$(document).delegate("#admin-users", "pageinit", function() {
  return $('.admin-users-delete-link').on('click', function(e) {
    var popup;
    $('#admin-users-delete-form').attr('action', '/admin/users/' + $(this).attr('data-id'));
    popup = $(e.currentTarget).closest('[data-role=popup]');
    popup.on('popupafterclose', function() {
      return setTimeout(function() {
        $($(e.currentTarget).attr('href')).popup('open');
        return popup.off('popupafterclose');
      }, 100);
    });
    return popup.popup('close');
  });
});


},{}],"main/admin/users":[function(require,module,exports){
module.exports=require('b4GRNz');
},{}],"WLfaCu":[function(require,module,exports){
var $;

$ = require('jquery');

$.mobile = require('jquery-mobile');

$(document).delegate("#groups-edit", "pageinit", function() {
  $("#groups-new-member-choices").on("filterablebeforefilter", function(e, data) {
    var $input, $ul, html, value;
    $ul = $(this);
    $input = $(data.input);
    value = $input.val();
    html = '';
    $ul.html('');
    if ((value != null ? value.length : void 0) > 1) {
      $ul.html('<li><div class="ui-loader"><span class="ui-icon ui-icon-loading"></span></div>');
      $ul.listview('refresh');
      return $.ajax({
        url: "/search/users/" + value,
        dataType: "json"
      }).then(function(response) {
        $.each(response, function(i, val) {
          if ($("#groups-new-members li[data-id=" + val.id + "]").length === 0) {
            return html += "<li><a href=\"#\" data-id=\"" + val.id + "\">" + val.first_name + " " + val.last_name + "</a>";
          }
        });
        $ul.html(html);
        $ul.listview("refresh");
        return $ul.trigger("updatelayout");
      });
    }
  });
  $(document).on('click', '#groups-new-member-choices a[data-id]', function(e) {
    var $this;
    $this = $(this);
    if ($('#groups-new-members li[data-id=' + $this.attr('data-id') + ']').length === 0) {
      $('#groups-new-members').append("<li data-id=\"" + ($this.attr('data-id')) + "\"><a href=\"#\">" + ($this.text()) + "</a><a data-theme=\"b\" href=\"#\" class=\"remove-member\">Remove Member</a><input type=\"hidden\" name=\"members[]\" value=\"" + ($this.attr('data-id')) + "\">").listview('refresh');
      $('#groups-new-member-choices-box .ui-input-clear').click();
      return $('#groups-new-member-choices').html('');
    }
  });
  return $(document).on('click', '.remove-member', function(e) {
    return $(this).closest('li').remove();
  });
});


},{}],"main/groups/edit":[function(require,module,exports){
module.exports=require('WLfaCu');
},{}],"NjaUxx":[function(require,module,exports){
var $;

$ = require('jquery');

$.mobile = require('jquery-mobile');

$(document).delegate("#groups-view", "pageinit", function() {
  return $('.groups-delete-link').on('click', function(e) {
    return $('#group-delete-form').attr('action', '/groups/' + $(this).attr('data-url'));
  });
});


},{}],"main/groups/view":[function(require,module,exports){
module.exports=require('NjaUxx');
},{}],"SCyoyC":[function(require,module,exports){
var $;

$ = require('jquery');

$.mobile = require('jquery-mobile');

$(document).delegate("#index", "pagehide", function() {
  return $(this).remove();
});


},{}],"main/index":[function(require,module,exports){
module.exports=require('SCyoyC');
},{}],"main/register":[function(require,module,exports){
module.exports=require('orecHj');
},{}],"orecHj":[function(require,module,exports){
var $;

$ = require('jquery');

$.mobile = require('jquery-mobile');

$(document).delegate("#register, #users-password", "pageinit", function() {
  var $page;
  $page = $(this);
  return $page.on('change', '#password, #password-confirm', function(e) {
    var $btn, password, password_confirm;
    password = $page.find('#password').val();
    password_confirm = $page.find('#password-confirm').val();
    $btn = $page.find('#submit-form');
    if (password !== "" && password_confirm !== "") {
      if (password === password_confirm) {
        return $btn.val($btn.attr('data-valid-label')).button('refresh').button('enable', 'refresh');
      } else {
        return $btn.val("Why u so like dat one? Passwords don't match lah").button('refresh').button('disable', 'refresh');
      }
    }
  });
});

$(document).delegate("#register, #users-password", "pagehide", function() {
  return $(this).remove();
});


},{}],"main/setlists/edit":[function(require,module,exports){
module.exports=require('04IWFn');
},{}],"04IWFn":[function(require,module,exports){
var $;

$ = require('jquery');

$.mobile = require('jquery-mobile');

$(document).delegate("#setlists-edit", "pageinit", function() {
  var checkSetlistLength, keyTexts, nextIndex, submitText;
  keyTexts = ["C", "D", "D", "E", "E", "F", "F", "G", "A", "A", "B", "B"];
  nextIndex = $('#setlists-new-songs li[data-id]').length;
  checkSetlistLength = function() {
    var songs;
    songs = [];
    $("#setlists-new-songs [data-id]").each(function(i, song) {
      return songs.push($(song).attr("data-id"));
    });
    return $.getJSON("/setlists/length", {
      songs: songs
    }, function(data) {
      if (data.error === "") {
        $("#setlists-warning-pages-count").text(data.pages);
        return $("#setlists-warning-pages").toggleClass("hidden", data.pages < 2);
      }
    });
  };
  checkSetlistLength();
  $("#setlists-new-song-choices").on("filterablebeforefilter", function(e, data) {
    var $input, $ul, html, value;
    $ul = $(this);
    $input = $(data.input);
    value = $input.val();
    html = "";
    $ul.html("");
    if (value && value.length > 2) {
      $ul.html("<li><div class='ui-loader'><span class='ui-icon ui-icon-loading'></span></div></li>");
      $ul.listview("refresh");
      return $.ajax({
        url: "/search/song_titles/" + $input.val(),
        dataType: "json"
      }).then(function(response) {
        $.each(response, function(i, val) {
          if ($("#setlists-new-songs li[data-id=" + val.id + "]").length === 0) {
            return html += "<li data-icon=\"false\">\n  <a href=\"#\" class=\"song-label " + (val.artist === "" ? "song-no-artist" : "") + " \" data-artist=\"" + val.artist + "\" data-id=\"" + val.id + "\" data-key=\"" + val.key + "\">\n    <div class=\"song-label-key\" data-chord=\"" + val.key + "\">" + keyTexts[+val.key] + "</div>\n    <h2 class=\"listview-heading\">" + val.title + "</h2>\n    " + (val.artist !== "" ? "<span class=\"listview-footer\">" + val.artist + "</span>" : "") + "\n  </a>\n</li>";
          }
        });
        $ul.html(html);
        $ul.listview("refresh");
        return $ul.trigger("updatelayout");
      });
    }
  });
  $(document).on('click', '#setlists-new-song-choices a[data-id]', function(e) {
    var $this, songArtist, songId, songKey, songTitle;
    $this = $(this);
    songId = $this.attr('data-id');
    songTitle = $this.find('h2').text();
    songArtist = $this.attr('data-artist');
    songKey = $this.attr('data-key') || 0;
    $('#setlists-song-chosen-by-popup').popup('open');
    $('#setlists-song-chosen-by-popup').attr('data-id', songId);
    $('#setlists-song-chosen-by-popup').attr('data-title', songTitle);
    $('#setlists-song-chosen-by-popup').attr('data-artist', songArtist);
    $('#setlists-song-chosen-by-popup h2').text(songTitle);
    $('#setlists-songs-key').val(songKey);
    return $('#setlists-songs-key').selectmenu('refresh');
  });
  $(document).on('click', '#setlist-chosen-by-submit', function(e) {
    var $chosenSong, artist, chosenBy, setlistKey, setlistKeyText, songID, title;
    $chosenSong = $('#setlists-song-chosen-by-popup');
    if ($('#setlists-new-songs li[data-id=' + songID + ']').length === 0) {
      $('#setlists-new-songs-empty').addClass('hidden');
      songID = $chosenSong.attr('data-id');
      title = $chosenSong.attr('data-title');
      artist = $chosenSong.attr('data-artist');
      chosenBy = $('#setlists-song-chosen-by-select').val();
      setlistKey = +$('#setlists-songs-key').val();
      setlistKeyText = keyTexts[setlistKey];
      $('#setlists-new-songs').append("<li data-id=\"" + songID + "\" class=\"setlist-view-song\">\n  <a href=\"#\" class=\"song-label " + (artist === "" ? "song-no-artist" : "") + " \">\n    <div class=\"song-label-key\" data-chord=\"" + setlistKey + "\">" + setlistKeyText + "</div>\n    <h2 class=\"listview-heading\">" + title + "</h2>\n    " + (artist !== "" ? "<span class=\"listview-footer\">" + artist + "</span>" : "") + "\n  </a>\n  <a href=\"#\" class=\"remove-song\">Remove Song</a>\n  <input type=\"hidden\" name=\"songs[" + nextIndex + "][id]\" value=\"" + songID + "\">\n  <input type=\"hidden\" name=\"songs[" + nextIndex + "][chosen_by]\" value=\"" + chosenBy + "\">\n  <input type=\"hidden\" name=\"songs[" + nextIndex + "][key]\" value=\"" + setlistKey + "\">\n</li>");
      $('#setlists-new-songs').listview('refresh');
      $('#setlists-new-song-choices-box .ui-input-clear').click();
      $('#setlists-new-song-choices').html('');
      $chosenSong.popup('close');
      nextIndex++;
    }
    return checkSetlistLength();
  });
  $(document).on('click', '.remove-song', function(e) {
    $(this).closest('li').remove();
    if ($('#setlists-new-songs li[data-id]').length === 0) {
      $('#setlists-new-songs-empty').removeClass('hidden');
    }
    $('#setlists-new-songs').listview('refresh');
    return checkSetlistLength();
  });
  submitText = $('#setlist-submit').attr('value');
  return $(document).on('input', '#setlist-title', function(e) {
    if ($('#setlist-title').val() === '') {
      $('#setlist-submit').val('Walau-eh! Need a Setlist name').button('refresh');
      return $('#setlist-submit').button('disable', 'refresh');
    } else {
      $('#setlist-submit').button('enable', 'refresh');
      return $('#setlist-submit').val(submitText).button('refresh');
    }
  });
});


},{}],"8mfMhF":[function(require,module,exports){
var $;

$ = require('jquery');

$.mobile = require('jquery-mobile');

$(document).delegate("#setlists-settings", "pageinit", function() {
  var $page, $useGroup, applySettings, groupSettings, settings, updateSettings;
  $page = $(this);
  $useGroup = $page.find('#setlist-use-group');
  settings = JSON.parse($page.find('#setlist-settings-target .settings-this').attr('data-settings'));
  groupSettings = JSON.parse($page.find('#setlist-settings-target .settings-group').attr('data-settings'));
  updateSettings = function(settings) {
    var $el, key, value;
    for (key in settings) {
      value = settings[key];
      $el = $page.find('[name="settings\\[' + key + '\\]"]');
      settings[key] = $el.val();
    }
    return settings;
  };
  applySettings = function(settings) {
    var $el, key, value, _results;
    _results = [];
    for (key in settings) {
      value = settings[key];
      $el = $page.find('[name="settings\\[' + key + '\\]"]');
      $el.val(value);
      if ($el.attr('data-role') === 'slider') {
        _results.push($el.slider("refresh"));
      } else {
        _results.push($el.selectmenu("refresh"));
      }
    }
    return _results;
  };
  return $useGroup.change(function() {
    var $section;
    $section = $page.find('#setlist-settings-section');
    $section.fadeOut(200, function() {
      if ($useGroup.val() === "1") {
        settings = updateSettings(settings);
        applySettings(groupSettings);
        $page.find('#setlist-settings-target .settings-this').addClass("hidden");
        return $page.find('#setlist-settings-target .settings-group').removeClass("hidden");
      } else {
        groupSettings = updateSettings(groupSettings);
        applySettings(settings);
        $page.find('#setlist-settings-target .settings-group').addClass("hidden");
        return $page.find('#setlist-settings-target .settings-this').removeClass("hidden");
      }
    });
    return $section.fadeIn(200);
  });
});


},{}],"main/setlists/settings":[function(require,module,exports){
module.exports=require('8mfMhF');
},{}],"hfujVA":[function(require,module,exports){
var $;

$ = require('jquery');

$.mobile = require('jquery-mobile');

$(document).delegate("#setlists-songs", "pagecreate", function() {
  var $chordsify, $page;
  $page = $(this);
  $chordsify = $('.chordsify-raw');
  if ($chordsify.length > 0) {
    $chordsify.chordsify();
  }
  $page.find('.transpose select').change(function(e) {
    var $select, $song, key;
    $select = $(e.currentTarget);
    key = $select.val();
    $song = $select.parents('.setlist-songs-song');
    return $song.find('.chordsify').chordsify('transpose', key).chordsify('position');
  });
  $page.find('.transpose-all').click(function(e) {
    var $select, $song, index, key;
    $song = $(e.currentTarget).parents('.setlist-songs-song');
    $select = $song.find('.transpose select');
    key = $select.val();
    index = $select[0].selectedIndex;
    $page.find('.transpose select').each(function(i, sel) {
      sel.selectedIndex = index;
      return $(sel).selectmenu('refresh');
    });
    return $page.find('.chordsify').chordsify('transpose', key).chordsify('position');
  });
  return $(":mobile-pagecontainer").on("pagecontainershow", function(event, ui) {
    $chordsify = $('.chordsify:not(.chordsify-raw)');
    if ($chordsify.length > 0) {
      return $chordsify.chordsify('position');
    }
  });
});


},{}],"main/setlists/songs":[function(require,module,exports){
module.exports=require('hfujVA');
},{}],"main/setlists/view":[function(require,module,exports){
module.exports=require('ogTvGP');
},{}],"ogTvGP":[function(require,module,exports){
var $;

$ = require('jquery');

$.mobile = require('jquery-mobile');

$(document).delegate("#setlists-view", "pagecreate", function() {
  var self;
  self = this;
  $('#setlists-view').each(function(i, e) {
    if (e !== self) {
      return e.remove();
    }
  });
  return $("#btn-pdf-save").on('click', function(e) {
    return $.get($(e.currentTarget).attr('data-url'), function(data) {
      if (data.error) {
        return alert(data.error);
      }
    }, 'json');
  });
});


},{}],"vuUuYo":[function(require,module,exports){
var $, songutils;

$ = require('jquery');

$.mobile = require('jquery-mobile');

songutils = require('libs/song_utils');

$(document).delegate("#songs-edit", "pagecreate", function() {
  var key, spotifySearchTimeout, spotify_id, updateSpotifyOptions, updateSpotifyPreview;
  if (key = $('select[name=key]').attr('data-key')) {
    $('select[name=key] option[value=' + key + ']').attr('selected', 'selected');
    $('select[name=key]').selectmenu('refresh');
  }
  updateSpotifyPreview = function() {
    var songUrl;
    songUrl = $('#spotify').val();
    if (songUrl) {
      return $('#spotify-preview').html('<iframe src="https://embed.spotify.com/?uri=' + songUrl + '" width=100%"' + $('#play').width() + '" height="80" frameborder="0" allowtransparency="true"></iframe>');
    } else {
      return $('#spotify-preview').html('');
    }
  };
  updateSpotifyOptions = function(title, artist, preload_id) {
    return songutils.getSpotifySelectOptions($('#song-edit-title-input').val(), $('#song-edit-artist-input').val(), preload_id, function(options) {
      $('#spotify').html(options);
      if (preload_id) {
        $('#spotify').val(spotify_id);
      }
      $('#spotify').selectmenu('refresh');
      return updateSpotifyPreview();
    });
  };
  spotifySearchTimeout = null;
  if (spotify_id = $('#spotify').attr('data-spotify-id')) {
    updateSpotifyOptions($('#song-edit-title-input').val(), $('#song-edit-artist-input').val(), spotify_id);
  }
  $('.song-preview').click(function(e) {
    return $('#song-chords').attr('data-original-key', $('#original-key').val()).chordsify().chordsify('replace', $('#chords').val());
  });
  $('#spotify').change(function(e) {
    return updateSpotifyPreview();
  });
  $('#chords-as-lyrics').change(function(e) {
    if ($(e.currentTarget).prop('checked')) {
      return $('#lyrics-container').addClass('hidden');
    } else {
      $('#lyrics-container').removeClass('hidden');
      return $('#lyrics-container textarea').change();
    }
  });
  $('#song-edit-title-input, #song-edit-artist-input').keyup(function(e) {
    if (spotifySearchTimeout) {
      clearTimeout(spotifySearchTimeout);
    }
    return spotifySearchTimeout = setTimeout(function() {
      return updateSpotifyOptions($('#song-edit-title-input').val(), $('#song-edit-artist-input').val());
    }, 150);
  });
  $("#new-tag-choices").on("filterablebeforefilter", function(e, data) {
    var $input, $ul, html, tag_exists, value;
    $ul = $(this);
    $input = $(data.input);
    value = $input.val();
    tag_exists = false;
    html = '';
    $ul.html('');
    if ((value != null ? value.length : void 0) > 1) {
      $ul.html('<li><div class="ui-loader"><span class="ui-icon ui-icon-loading"></span></div>');
      $ul.listview('refresh');
      return $.ajax({
        url: "/search/tags/" + value,
        dataType: "json"
      }).then(function(response) {
        $.each(response, function(i, val) {
          if ($("#song-tags li[data-id=" + val.id + "]").length === 0) {
            html += "<li><a href=\"#\" data-id=\"" + val.id + "\">" + val.name + "</a>";
          }
          if (val.name === value) {
            return tag_exists = true;
          }
        });
        if (!tag_exists) {
          html += "<li><a href=\"#\" new-tag=\"" + value + "\">Add \"" + value + "\" as a new tag</a>";
        }
        $ul.html(html);
        $ul.listview("refresh");
        return $ul.trigger("updatelayout");
      });
    }
  });
  $(document).on('click', '#new-tag-choices a[data-id]', function(e) {
    var $this;
    $this = $(this);
    if ($('#song-tags li[data-id=' + $this.attr('data-id') + ']').length === 0) {
      $('#song-tags').append("<li data-id=\"" + ($this.attr('data-id')) + "\"><a href=\"#\">" + ($this.text()) + "</a><a data-theme=\"b\" href=\"#\" class=\"remove-tag\">X</a><input type=\"hidden\" name=\"tags[]\" value=\"" + ($this.attr('data-id')) + "\">").listview('refresh');
      $('#new-tag-choices-box .ui-input-clear').click();
      return $('#new-tag-choices').html('');
    }
  });
  $(document).on('click', '#new-tag-choices a[new-tag]', function(e) {
    var $this;
    $this = $(this);
    if ($('#song-tags li[value="' + $this.attr('new-tag') + '"]').length === 0) {
      $('#song-tags').append("<li value=\"" + ($this.attr('new-tag')) + "\"><a href=\"#\">" + ($this.attr('new-tag')) + "</a><a data-theme=\"b\" href=\"#\" class=\"remove-tag\">X</a><input type=\"hidden\" name=\"new_tags[]\" value=\"" + ($this.attr('new-tag')) + "\">").listview('refresh');
      $('#new-tag-choices-box .ui-input-clear').click();
      return $('#new-tag-choices').html('');
    }
  });
  return $(document).on('click', '.remove-tag', function(e) {
    return $(this).closest('li').remove();
  });
});


},{"libs/song_utils":"EAptEV"}],"main/songs/edit":[function(require,module,exports){
module.exports=require('vuUuYo');
},{}],"main/songs/list":[function(require,module,exports){
module.exports=require('RrB5Oo');
},{}],"RrB5Oo":[function(require,module,exports){
var $;

$ = require('jquery');

$.mobile = require('jquery-mobile');

$(document).delegate("#songs-list", "pagecreate", function() {
  $(this).find('[name="view"]').change(function() {
    var $children, $list, view;
    view = $(this).val();
    $list = $('#songs-list-songs');
    $children = $list.children('.listview-checkbox').removeClass('hidden ui-last-child');
    if (view === 'certified') {
      $children.filter('[data-certified="0"]').addClass('hidden');
      return $children.filter('[data-certified="1"]').last().addClass('ui-last-child');
    } else if (view === 'chords') {
      $children.filter('[data-chords="0"]').addClass('hidden');
      return $children.filter('[data-chords="1"]').last().addClass('ui-last-child');
    } else {
      return $children.last().addClass('ui-last-child');
    }
  });
  $(this).find('[name="sortby"]').change(function() {
    var $children, $list, order, sortby;
    sortby = $(this).val();
    order = sortby === 'pop' ? -1 : 1;
    $list = $('#songs-list-songs');
    $children = $list.children('.listview-checkbox');
    $children.last().removeClass('ui-last-child');
    $children.sort(function(a, b) {
      var aText, bText;
      aText = $(a).attr('data-' + sortby);
      bText = $(b).attr('data-' + sortby);
      if (sortby === 'key') {
        if (aText === '') {
          aText = 12;
        } else {
          aText = +aText;
        }
        if (bText === '') {
          bText = 12;
        } else {
          bText = +bText;
        }
      }
      if (aText > bText) {
        return order;
      }
      if (bText > aText) {
        return -order;
      }
      return 0;
    });
    $children.detach().appendTo($list);
    return $children.last().addClass('ui-last-child');
  });
  return $('input[name="checked_songs[]"]').on('change', function() {
    var count, songlist;
    if ((count = $('input[name="checked_songs[]"]:checked').length) > 0) {
      $('.ui-footer-fixed').removeClass('hidden');
      $('.songs-list-selected-count').text(count);
      songlist = "";
      $('input[name="checked_songs[]"]:checked').each(function() {
        return songlist += $(this).val() + ",";
      });
      songlist = songlist.substr(0, songlist.length - 1);
      $('#song-setlist-popup-form input[name=songs]').val(songlist);
      return $('#song-setlist-popup-new').attr('href', '/setlists/new?songs=' + songlist);
    } else {
      return $('.ui-footer-fixed').addClass('hidden');
    }
  });
});


},{}],"sbYsL1":[function(require,module,exports){
var $;

$ = require('jquery');

$.mobile = require('jquery-mobile');

$(document).delegate("#songs-view", "pagecreate", function() {
  var $chordsify, $page, $transpose;
  $page = $(this);
  $transpose = $page.find('#select-transpose');
  $chordsify = $page.find('.chordsify-raw');
  if ($chordsify.length > 0) {
    $chordsify.chordsify();
    return $transpose.on('change', function(e) {
      var key;
      key = $(e.currentTarget).val();
      return $chordsify.chordsify('transpose', key);
    });
  }
});

$(document).on("pagecontainershow", ":mobile-pagecontainer", function(event, ui) {
  var $chordsify;
  $chordsify = $('.chordsify:not(.chordsify-raw)');
  if ($chordsify.length > 0) {
    return $chordsify.chordsify('position');
  }
});


},{}],"main/songs/view":[function(require,module,exports){
module.exports=require('sbYsL1');
},{}],"main/users/home":[function(require,module,exports){
module.exports=require('KlIhGG');
},{}],"KlIhGG":[function(require,module,exports){
var $;

$ = require('jquery');

$.mobile = require('jquery-mobile');

$(document).delegate("#home", "pageinit", function() {});


},{}]},{},["dztHS2","b4GRNz","WLfaCu","NjaUxx","SCyoyC","orecHj","04IWFn","8mfMhF","hfujVA","ogTvGP","vuUuYo","RrB5Oo","sbYsL1","KlIhGG"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9DaHJpcy9kZXYvcHNhbHRlZC9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL1VzZXJzL0NocmlzL2Rldi9wc2FsdGVkL3B1YmxpY19zcmMvbGlicy9qcXVlcnktMi4xLjEuanMiLCIvVXNlcnMvQ2hyaXMvZGV2L3BzYWx0ZWQvcHVibGljX3NyYy9saWJzL2pxdWVyeS5tb2JpbGUtMS40LjMtcHNhbHRlZC5qcyIsIi9Vc2Vycy9DaHJpcy9kZXYvcHNhbHRlZC9wdWJsaWNfc3JjL2xpYnMvc29uZ191dGlscy5qcyIsIi9Vc2Vycy9DaHJpcy9kZXYvcHNhbHRlZC9wdWJsaWNfc3JjL21haW4vYWRtaW4vZ3JvdXBzLmNvZmZlZSIsIi9Vc2Vycy9DaHJpcy9kZXYvcHNhbHRlZC9wdWJsaWNfc3JjL21haW4vYWRtaW4vdXNlcnMuY29mZmVlIiwiL1VzZXJzL0NocmlzL2Rldi9wc2FsdGVkL3B1YmxpY19zcmMvbWFpbi9ncm91cHMvZWRpdC5jb2ZmZWUiLCIvVXNlcnMvQ2hyaXMvZGV2L3BzYWx0ZWQvcHVibGljX3NyYy9tYWluL2dyb3Vwcy92aWV3LmNvZmZlZSIsIi9Vc2Vycy9DaHJpcy9kZXYvcHNhbHRlZC9wdWJsaWNfc3JjL21haW4vaW5kZXguY29mZmVlIiwiL1VzZXJzL0NocmlzL2Rldi9wc2FsdGVkL3B1YmxpY19zcmMvbWFpbi9yZWdpc3Rlci5jb2ZmZWUiLCIvVXNlcnMvQ2hyaXMvZGV2L3BzYWx0ZWQvcHVibGljX3NyYy9tYWluL3NldGxpc3RzL2VkaXQuY29mZmVlIiwiL1VzZXJzL0NocmlzL2Rldi9wc2FsdGVkL3B1YmxpY19zcmMvbWFpbi9zZXRsaXN0cy9zZXR0aW5ncy5jb2ZmZWUiLCIvVXNlcnMvQ2hyaXMvZGV2L3BzYWx0ZWQvcHVibGljX3NyYy9tYWluL3NldGxpc3RzL3NvbmdzLmNvZmZlZSIsIi9Vc2Vycy9DaHJpcy9kZXYvcHNhbHRlZC9wdWJsaWNfc3JjL21haW4vc2V0bGlzdHMvdmlldy5jb2ZmZWUiLCIvVXNlcnMvQ2hyaXMvZGV2L3BzYWx0ZWQvcHVibGljX3NyYy9tYWluL3NvbmdzL2VkaXQuY29mZmVlIiwiL1VzZXJzL0NocmlzL2Rldi9wc2FsdGVkL3B1YmxpY19zcmMvbWFpbi9zb25ncy9saXN0LmNvZmZlZSIsIi9Vc2Vycy9DaHJpcy9kZXYvcHNhbHRlZC9wdWJsaWNfc3JjL21haW4vc29uZ3Mvdmlldy5jb2ZmZWUiLCIvVXNlcnMvQ2hyaXMvZGV2L3BzYWx0ZWQvcHVibGljX3NyYy9tYWluL3VzZXJzL2hvbWUuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3QrUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdCtkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQSxDQUFBLEdBQUE7O0FBQUEsQ0FBQSxFQUFJLElBQUEsQ0FBQTs7QUFDSixDQURBLEVBQ1csR0FBWCxDQUFXLFFBQUE7O0FBRVgsQ0FIQSxDQUdzQyxDQUFZLEtBQWxELENBQWtELENBQWxELEtBQUE7Q0FDRSxDQUFBLENBQTJDLElBQTNDLEVBQUEsa0JBQUE7Q0FDRSxJQUFBLEdBQUE7Q0FBQSxDQUE4QyxDQUFtQixDQUFqRSxJQUFBLENBQWlFLE9BQW5CLFdBQTlDO0NBQUEsRUFDUSxDQUFSLENBQUEsRUFBUSxNQUFBLE1BQUE7Q0FEUixDQUVBLENBQTRCLENBQTVCLENBQUssSUFBdUIsUUFBNUI7Q0FDYSxFQUFBLE1BQUEsQ0FBWCxHQUFBO0NBQ0UsR0FBRSxDQUFGLENBQUUsRUFBRixLQUFFO0NBQ0ksRUFBTixFQUFLLFVBQUwsRUFBQTtDQUZGLENBR0UsQ0FIRixJQUFXO0NBRGIsSUFBNEI7Q0FLdEIsSUFBRCxFQUFMLElBQUE7Q0FSRixFQUEyQztDQURLOzs7Ozs7QUNIbEQsQ0FBQSxHQUFBOztBQUFBLENBQUEsRUFBSSxJQUFBLENBQUE7O0FBQ0osQ0FEQSxFQUNXLEdBQVgsQ0FBVyxRQUFBOztBQUVYLENBSEEsQ0FHcUMsQ0FBWSxLQUFqRCxDQUFpRCxDQUFqRCxJQUFBO0NBQ0UsQ0FBQSxDQUEwQyxJQUExQyxFQUFBLGlCQUFBO0NBQ0UsSUFBQSxHQUFBO0NBQUEsQ0FBNkMsQ0FBa0IsQ0FBL0QsSUFBQSxDQUErRCxNQUFsQixXQUE3QztDQUFBLEVBQ1EsQ0FBUixDQUFBLEVBQVEsTUFBQSxNQUFBO0NBRFIsQ0FFQSxDQUE0QixDQUE1QixDQUFLLElBQXVCLFFBQTVCO0NBQ2EsRUFBQSxNQUFBLENBQVgsR0FBQTtDQUNFLEdBQUUsQ0FBRixDQUFFLEVBQUYsS0FBRTtDQUNJLEVBQU4sRUFBSyxVQUFMLEVBQUE7Q0FGRixDQUdFLENBSEYsSUFBVztDQURiLElBQTRCO0NBS3RCLElBQUQsRUFBTCxJQUFBO0NBUkYsRUFBMEM7Q0FESzs7Ozs7O0FDSGpELENBQUEsR0FBQTs7QUFBQSxDQUFBLEVBQUksSUFBQSxDQUFBOztBQUNKLENBREEsRUFDVyxHQUFYLENBQVcsUUFBQTs7QUFFWCxDQUhBLENBR3FDLENBQVksS0FBakQsQ0FBaUQsQ0FBakQsSUFBQTtDQUNFLENBQUEsQ0FBNkQsQ0FBQSxLQUFDLGVBQTlELElBQUE7Q0FDRSxPQUFBLGdCQUFBO0NBQUEsRUFBQSxDQUFBO0NBQUEsRUFDUyxDQUFULENBQVMsQ0FBVDtDQURBLEVBRVEsQ0FBUixDQUFBLENBQWM7Q0FGZCxDQUFBLENBR08sQ0FBUDtDQUhBLENBSUEsQ0FBRyxDQUFIO0NBQ0EsRUFBRyxDQUFILENBQVE7Q0FDTixFQUFHLENBQUgsRUFBQSwwRUFBQTtDQUFBLEVBQ0csR0FBSCxFQUFBLENBQUE7Q0FDQyxHQUFELFNBQUE7Q0FDRSxDQUFNLENBQU4sRUFBQSxHQUFBLFFBQU07Q0FBTixDQUNVLElBRFYsRUFDQTtDQUNGLEVBQU0sQ0FITixJQUFBLENBR087Q0FDTCxDQUFpQixDQUFBLENBQWpCLElBQUEsQ0FBa0I7Q0FDaEIsQ0FBTSxDQUFnQyxDQUFuQyxDQUF5RCxDQUF6RCxJQUFILHVCQUFNO0NBQ3NDLENBQWpDLENBQTZCLENBQXRDLENBQVMsSUFBQSxDQUFBLFNBQVQsV0FBUztZQUZJO0NBQWpCLFFBQWlCO0NBQWpCLEVBR0csQ0FBSCxJQUFBO0NBSEEsRUFJRyxLQUFILENBQUE7Q0FDSSxFQUFELElBQUgsT0FBQSxDQUFBO0NBVEYsTUFHTTtNQVptRDtDQUE3RCxFQUE2RDtDQUE3RCxDQW9CQSxDQUFpRSxJQUFqRSxDQUFBLENBQWtFLDhCQUFsRTtDQUNFLElBQUEsR0FBQTtDQUFBLEVBQVEsQ0FBUixDQUFBO0NBQ0EsRUFBeUMsQ0FBekMsQ0FBOEMsQ0FBM0MsR0FBc0Msd0JBQXBDO0NBQ0gsRUFBZ0QsQ0FBQSxDQUFLLENBQXJELEVBQUEsQ0FBZ0QsT0FBZixHQUFBLEVBQWpDLDJHQUFpQztDQUFqQyxJQUVBLENBQUEsMENBQUE7Q0FDQSxDQUFBLEVBQUEsU0FBQSxlQUFBO01BTjZEO0NBQWpFLEVBQWlFO0NBUWpFLENBQUEsQ0FBMEMsSUFBMUMsQ0FBQSxDQUFBLE9BQUE7Q0FDRSxHQUFBLEVBQUEsQ0FBQSxJQUFBO0NBREYsRUFBMEM7Q0E3Qks7Ozs7OztBQ0hqRCxDQUFBLEdBQUE7O0FBQUEsQ0FBQSxFQUFJLElBQUEsQ0FBQTs7QUFDSixDQURBLEVBQ1csR0FBWCxDQUFXLFFBQUE7O0FBRVgsQ0FIQSxDQUdxQyxDQUFZLEtBQWpELENBQWlELENBQWpELElBQUE7Q0FDRSxDQUFBLENBQXFDLElBQXJDLEVBQUEsWUFBQTtDQUNFLENBQXVDLENBQWEsQ0FBcEQsSUFBQSxFQUF1QyxDQUF2QyxTQUFBO0NBREYsRUFBcUM7Q0FEVTs7Ozs7O0FDSGpELENBQUEsR0FBQTs7QUFBQSxDQUFBLEVBQUksSUFBQSxDQUFBOztBQUNKLENBREEsRUFDVyxHQUFYLENBQVcsUUFBQTs7QUFLWCxDQU5BLENBTStCLENBQVksS0FBM0MsQ0FBMkMsQ0FBM0M7Q0FFQyxHQUFBLEVBQUEsR0FBQTtDQUYwQzs7Ozs7Ozs7QUNOM0MsQ0FBQSxHQUFBOztBQUFBLENBQUEsRUFBSSxJQUFBLENBQUE7O0FBQ0osQ0FEQSxFQUNXLEdBQVgsQ0FBVyxRQUFBOztBQUVYLENBSEEsQ0FHbUQsQ0FBWSxLQUEvRCxDQUErRCxDQUEvRCxrQkFBQTtDQUNFLElBQUEsQ0FBQTtDQUFBLENBQUEsQ0FBUSxDQUFBLENBQVI7Q0FDTSxDQUFOLENBQW1ELEVBQTlDLEdBQUwsQ0FBQSxxQkFBQTtDQUNFLE9BQUEsd0JBQUE7Q0FBQSxFQUFXLENBQVgsQ0FBZ0IsR0FBaEIsR0FBVztDQUFYLEVBQ21CLENBQW5CLENBQXdCLFdBQXhCLEdBQW1CO0NBRG5CLEVBRU8sQ0FBUCxDQUFZLFNBQUw7Q0FDUCxDQUFHLEVBQUgsQ0FBaUIsR0FBZCxRQUFxQjtDQUN0QixHQUFHLENBQVksQ0FBZixFQUFHLFFBQUg7Q0FDTyxDQUVjLENBRm5CLENBQUksRUFBSixFQUFBLENBQUEsTUFBQSxHQUFTO01BRFgsRUFBQTtDQUtPLENBRWUsQ0FGcEIsQ0FBSSxFQUFKLEdBQUEsTUFBQSxtQ0FBQTtRQU5KO01BSmlEO0NBQW5ELEVBQW1EO0NBRlU7O0FBZ0IvRCxDQW5CQSxDQW1CbUQsQ0FBWSxLQUEvRCxDQUErRCxDQUEvRCxrQkFBQTtDQUNFLEdBQUEsRUFBQSxHQUFBO0NBRDZEOzs7Ozs7QUNuQi9ELENBQUEsR0FBQTs7QUFBQSxDQUFBLEVBQUksSUFBQSxDQUFBOztBQUNKLENBREEsRUFDVyxHQUFYLENBQVcsUUFBQTs7QUFFWCxDQUhBLENBR3VDLENBQVksS0FBbkQsQ0FBbUQsQ0FBbkQsTUFBQTtDQUNFLEtBQUEsNkNBQUE7Q0FBQSxDQUFBLENBQVcsQ0FBQSxJQUFYO0NBQUEsQ0FFQSxDQUFZLEdBRlosR0FFQSx3QkFBWTtDQUZaLENBSUEsQ0FBcUIsTUFBQSxTQUFyQjtDQUNFLElBQUEsR0FBQTtDQUFBLENBQUEsQ0FBUSxDQUFSLENBQUE7Q0FBQSxDQUMyQyxDQUFILENBQXhDLEtBQXlDLHNCQUF6QztDQUNRLEdBQU4sQ0FBSyxJQUFNLElBQVg7Q0FERixJQUF3QztDQUV2QyxDQUE2QixLQUE5QixJQUFBLE9BQUE7Q0FBOEIsQ0FBUyxHQUFQLENBQUE7RUFBZ0IsQ0FBQSxDQUFBLEVBQWhELEdBQWlEO0NBQy9DLENBQUEsRUFBRyxDQUFBLENBQUg7Q0FDRSxHQUFBLENBQUEsR0FBQSx1QkFBQTtDQUNBLENBQW1ELENBQWEsQ0FBVCxDQUFKLEdBQW5ELEdBQUEsSUFBQSxVQUFBO1FBSDRDO0NBQWhELElBQWdEO0NBUmxELEVBSXFCO0NBSnJCLENBYUEsZ0JBQUE7Q0FiQSxDQWVBLENBQTZELENBQUEsS0FBQyxlQUE5RCxJQUFBO0NBQ0UsT0FBQSxnQkFBQTtDQUFBLEVBQUEsQ0FBQTtDQUFBLEVBQ1MsQ0FBVCxDQUFTLENBQVQ7Q0FEQSxFQUVRLENBQVIsQ0FBQSxDQUFjO0NBRmQsQ0FBQSxDQUdPLENBQVA7Q0FIQSxDQUlBLENBQUcsQ0FBSDtDQUNBLEVBQTJCLENBQTNCLENBQUcsQ0FBUztDQUNWLEVBQUcsQ0FBSCxFQUFBLCtFQUFBO0NBQUEsRUFDRyxHQUFILEVBQUEsQ0FBQTtDQUNDLEdBQUQsU0FBQTtDQUNFLENBQUssQ0FBTCxHQUFvQyxFQUFwQyxjQUFLO0NBQUwsQ0FDVSxJQURWLEVBQ0E7Q0FDRixFQUFNLENBSE4sSUFBQSxDQUdPO0NBQ0wsQ0FBaUIsQ0FBQSxDQUFqQixJQUFBLENBQWtCO0NBQ2hCLENBQU0sQ0FBZ0MsQ0FBbkMsQ0FBeUQsQ0FBekQsSUFBSCx1QkFBTTtBQUd1QyxDQURuQixDQUFILENBQUEsQ0FEckIsQ0FDc0MsQ0FBZCxFQUNrQixDQUN0QixJQUhULEVBQUEsQ0FDVSxHQURyQixDQUFXLGNBR3FDLFdBSHJDLFNBQUEsU0FBQTtZQUZFO0NBQWpCLFFBQWlCO0NBQWpCLEVBU0csQ0FBSCxJQUFBO0NBVEEsRUFVRyxLQUFILENBQUE7Q0FDSSxFQUFELElBQUgsT0FBQSxDQUFBO0NBZkYsTUFHTTtNQVptRDtDQUE3RCxFQUE2RDtDQWY3RCxDQXlDQSxDQUFpRSxJQUFqRSxDQUFBLENBQWtFLDhCQUFsRTtDQUNFLE9BQUEscUNBQUE7Q0FBQSxFQUFRLENBQVIsQ0FBQTtDQUFBLEVBQ1MsQ0FBVCxDQUFjLENBQWQsR0FBUztDQURULEVBRVksQ0FBWixDQUFpQixJQUFqQjtDQUZBLEVBR2EsQ0FBYixDQUFrQixLQUFsQixHQUFhO0NBSGIsRUFJVSxDQUFWLENBQWUsRUFBZixHQUFVO0NBSlYsR0FLQSxDQUFBLENBQUEsMEJBQUE7Q0FMQSxDQU1vRCxFQUFwRCxFQUFBLEdBQUEsdUJBQUE7Q0FOQSxDQU91RCxFQUF2RCxLQUFBLEdBQUEsb0JBQUE7Q0FQQSxDQVF3RCxFQUF4RCxNQUFBLEdBQUEsbUJBQUE7Q0FSQSxHQVNBLEtBQUEsMEJBQUE7Q0FUQSxFQVVBLENBQUEsR0FBQSxjQUFBO0NBQ0EsUUFBQSxDQUFBLENBQUEsVUFBQTtDQVpGLEVBQWlFO0NBekNqRSxDQXVEQSxDQUFxRCxJQUFyRCxDQUFBLENBQXNELGtCQUF0RDtDQUNFLE9BQUEsZ0VBQUE7Q0FBQSxFQUFjLENBQWQsT0FBQSxxQkFBYztDQUVkLEVBQXlDLENBQXpDLENBQWlFLENBQTVELDJCQUFBO0NBQ0gsS0FBQSxFQUFBLG1CQUFBO0NBQUEsRUFFUyxDQUFBLEVBQVQsR0FBUyxFQUFXO0NBRnBCLEVBR1EsQ0FBQSxDQUFSLENBQUEsS0FBbUIsQ0FBWDtDQUhSLEVBSVMsQ0FBQSxFQUFULEtBQW9CLEVBQVg7Q0FKVCxFQUtXLEdBQVgsRUFBQSx5QkFBVztBQUNHLENBTmQsRUFNYSxHQUFiLElBQUEsV0FBYztDQU5kLEVBT2lCLEdBQWpCLEVBQTBCLEVBQUEsSUFBMUI7Q0FQQSxDQVdrQixDQURYLEVBQ3dCLENBRi9CLEVBQW1DLENBSWQsQ0FKYyxFQUFuQyxDQUFtQyxDQUFBLEVBQUEsRUFBQSxDQUFBLEVBQW5DLElBQW1DLFNBSVUsV0FKVixVQUFBLGVBQUEsbUNBQUE7Q0FUbkMsS0FzQkEsRUFBQSxDQUFBLFlBQUE7Q0F0QkEsSUF1QkEsQ0FBQSwwQ0FBQTtDQXZCQSxDQXdCQSxFQUFBLEVBQUEsc0JBQUE7Q0F4QkEsSUF5QkEsQ0FBQSxDQUFBLElBQVc7QUFDWCxDQTFCQSxDQUFBLElBMEJBLEdBQUE7TUE3QkY7Q0ErQkEsVUFBQSxPQUFBO0NBaENGLEVBQXFEO0NBdkRyRCxDQXlGQSxDQUF3QyxJQUF4QyxDQUFBLENBQXlDLEtBQXpDO0NBQ0UsR0FBQSxFQUFBLENBQUE7Q0FDQSxHQUFBLENBQWtELENBQS9DLDJCQUFBO0NBQ0QsS0FBQSxFQUFBLEdBQUEsZ0JBQUE7TUFGRjtDQUFBLEdBR0EsSUFBQSxDQUFBLFlBQUE7Q0FDQSxVQUFBLE9BQUE7Q0FMRixFQUF3QztDQXpGeEMsQ0FnR0EsQ0FBYSxDQUFBLEdBQUEsR0FBYixPQUFhO0NBQ2IsQ0FBQSxDQUEwQyxJQUExQyxDQUFBLENBQUEsT0FBQTtDQUNFLENBQUEsQ0FBRyxDQUFILENBQWdDLFdBQTdCO0NBQ0QsRUFBQSxHQUFBLEdBQUEsUUFBQSxjQUFBO0NBQ0EsQ0FBc0MsSUFBdEMsR0FBQSxJQUFBLElBQUE7TUFGRjtDQUlFLENBQXFDLElBQXJDLEVBQUEsQ0FBQSxRQUFBO0NBQ0EsRUFBQSxHQUFBLEdBQUEsQ0FBQSxHQUFBLElBQUE7TUFOc0M7Q0FBMUMsRUFBMEM7Q0FsR087Ozs7QUNIbkQsQ0FBQSxHQUFBOztBQUFBLENBQUEsRUFBSSxJQUFBLENBQUE7O0FBQ0osQ0FEQSxFQUNXLEdBQVgsQ0FBVyxRQUFBOztBQUVYLENBSEEsQ0FHMkMsQ0FBWSxLQUF2RCxDQUF1RCxDQUF2RCxVQUFBO0NBQ0UsS0FBQSxrRUFBQTtDQUFBLENBQUEsQ0FBUSxDQUFBLENBQVI7Q0FBQSxDQUNBLENBQVksQ0FBQSxDQUFLLElBQWpCLFdBQVk7Q0FEWixDQUVBLENBQVcsQ0FBSSxDQUFKLEdBQVgsT0FBc0IsMEJBQUE7Q0FGdEIsQ0FHQSxDQUFnQixDQUFJLENBQUosUUFBaEIsRUFBMkIsMkJBQUE7Q0FIM0IsQ0FLQSxDQUFpQixLQUFBLENBQUMsS0FBbEI7Q0FDRSxPQUFBLE9BQUE7QUFBQSxDQUFBLFFBQUEsTUFBQTs2QkFBQTtDQUNFLEVBQUEsQ0FBTSxDQUFLLENBQVgsQ0FBTSxhQUFXO0NBQWpCLEVBQ1MsR0FBVCxFQUFTO0NBRlgsSUFBQTtDQUdBLE9BQUEsR0FBTztDQVRULEVBS2lCO0NBTGpCLENBV0EsQ0FBZ0IsS0FBQSxDQUFDLElBQWpCO0NBQ0UsT0FBQSxpQkFBQTtBQUFBLENBQUE7VUFBQSxLQUFBOzZCQUFBO0NBQ0UsRUFBQSxDQUFNLENBQUssQ0FBWCxDQUFNLGFBQVc7Q0FBakIsRUFDRyxFQUFILENBQUE7Q0FDQSxFQUFNLENBQUgsQ0FBeUIsQ0FBNUIsRUFBQSxHQUFHO0NBQ0QsRUFBRyxHQUFILEdBQUE7TUFERixFQUFBO0NBR0UsRUFBRyxNQUFILENBQUE7UUFOSjtDQUFBO3FCQURjO0NBWGhCLEVBV2dCO0NBU04sRUFBTyxHQUFqQixHQUFBO0NBQ0UsT0FBQTtDQUFBLEVBQVcsQ0FBWCxDQUFnQixHQUFoQixtQkFBVztDQUFYLENBQ3NCLENBQXRCLENBQUEsR0FBQSxDQUFRLENBQWM7Q0FDcEIsRUFBRyxDQUFBLENBQW1CLENBQXRCLEdBQVk7Q0FDVixFQUFXLEtBQVgsTUFBVztDQUFYLE9BQ0EsS0FBQTtDQURBLEdBRUEsQ0FBSyxHQUFMLGlDQUFBO0NBQ00sR0FBTixDQUFLLEdBQUwsR0FBQSxJQUFBLDJCQUFBO01BSkYsRUFBQTtDQU1FLEVBQWdCLEtBQWhCLEtBQUEsQ0FBZ0I7Q0FBaEIsT0FDQSxLQUFBO0NBREEsR0FFQSxDQUFLLEdBQUwsa0NBQUE7Q0FDTSxHQUFOLENBQUssR0FBTCxHQUFBLElBQUEsMEJBQUE7UUFWa0I7Q0FBdEIsSUFBc0I7Q0FXYixFQUFULEdBQUEsRUFBUSxHQUFSO0NBYkYsRUFBaUI7Q0FyQm9DOzs7Ozs7QUNIdkQsQ0FBQSxHQUFBOztBQUFBLENBQUEsRUFBSSxJQUFBLENBQUE7O0FBQ0osQ0FEQSxFQUNXLEdBQVgsQ0FBVyxRQUFBOztBQUVYLENBSEEsQ0FHd0MsQ0FBYyxLQUF0RCxDQUFzRCxHQUF0RCxLQUFBO0NBQ0UsS0FBQSxXQUFBO0NBQUEsQ0FBQSxDQUFRLENBQUEsQ0FBUjtDQUFBLENBQ0EsQ0FBYSxPQUFiLE1BQWE7Q0FDYixDQUFBLENBQXVCLENBQXBCLEVBQUEsSUFBVTtDQUNYLEdBQUEsS0FBQSxDQUFVO0lBSFo7Q0FBQSxDQUtBLENBQXVDLENBQXZDLENBQUssQ0FBTCxHQUF3QyxVQUF4QztDQUNFLE9BQUEsV0FBQTtDQUFBLEVBQVUsQ0FBVixHQUFBLE1BQVU7Q0FBVixFQUNBLENBQUEsR0FBYTtDQURiLEVBRVEsQ0FBUixDQUFBLEVBQWUsY0FBUDtDQUNGLENBQTBDLENBQWhELENBQUEsQ0FBSyxJQUFMLENBQUEsQ0FBQSxDQUFBO0NBSkYsRUFBdUM7Q0FMdkMsQ0FXQSxDQUFtQyxDQUFuQyxDQUFLLElBQStCLE9BQXBDO0NBQ0UsT0FBQSxrQkFBQTtDQUFBLEVBQVEsQ0FBUixDQUFBLEVBQVEsTUFBQSxRQUFBO0NBQVIsRUFDVSxDQUFWLENBQWUsRUFBZixZQUFVO0NBRFYsRUFFQSxDQUFBLEdBQWE7Q0FGYixFQUdRLENBQVIsQ0FBQSxFQUFnQixNQUhoQjtDQUFBLENBSXlDLENBQUosQ0FBckMsQ0FBSyxJQUFpQyxVQUF0QztDQUNFLEVBQUcsRUFBSCxDQUFBLE9BQUE7Q0FDQSxFQUFBLE1BQUEsQ0FBQSxHQUFBO0NBRkYsSUFBcUM7Q0FHL0IsQ0FBMEMsQ0FBaEQsQ0FBQSxDQUFLLElBQUwsQ0FBQSxDQUFBLENBQUE7Q0FSRixFQUFtQztDQVVuQyxDQUFBLENBQW1ELEVBQUEsSUFBbkQsVUFBQSxJQUFBO0NBQ0UsRUFBYSxDQUFiLE1BQUEsc0JBQWE7Q0FDYixFQUF1QixDQUF2QixFQUFHLElBQVU7Q0FDQSxRQUFYLENBQVUsR0FBVjtNQUgrQztDQUFuRCxFQUFtRDtDQXRCQzs7Ozs7Ozs7QUNIdEQsQ0FBQSxHQUFBOztBQUFBLENBQUEsRUFBSSxJQUFBLENBQUE7O0FBQ0osQ0FEQSxFQUNXLEdBQVgsQ0FBVyxRQUFBOztBQUVYLENBSEEsQ0FHdUMsQ0FBYyxLQUFyRCxDQUFxRCxHQUFyRCxJQUFBO0NBRUUsR0FBQSxFQUFBO0NBQUEsQ0FBQSxDQUFPLENBQVA7Q0FBQSxDQUNBLENBQXlCLENBQXpCLEtBQTBCLE9BQTFCO0NBQ0UsR0FBQSxDQUFxQjtDQUFwQixLQUFELE9BQUE7TUFEdUI7Q0FBekIsRUFBeUI7Q0FFekIsQ0FBQSxDQUErQixJQUEvQixFQUFBLE1BQUE7Q0FDRyxDQUEwQyxDQUEzQyxDQUFNLEtBQXNDLENBQXRDLENBQU4sRUFBTTtDQUNKLEdBQTRCLENBQTVCLENBQUE7Q0FBQSxHQUFpQixDQUFWLFVBQUE7UUFEa0M7Q0FBM0MsQ0FJRSxHQUp5QyxDQUEzQztDQURGLEVBQStCO0NBTG9COzs7O0FDSHJELElBQUEsUUFBQTs7QUFBQSxDQUFBLEVBQUksSUFBQSxDQUFBOztBQUNKLENBREEsRUFDVyxHQUFYLENBQVcsUUFBQTs7QUFDWCxDQUZBLEVBRVksSUFBQSxFQUFaLFFBQVk7O0FBRVosQ0FKQSxDQUlvQyxDQUFjLEtBQWxELENBQWtELEdBQWxELENBQUE7Q0FDRSxLQUFBLDJFQUFBO0NBQUEsQ0FBQSxDQUFHLENBQUEsTUFBTSxRQUFBO0NBQ1AsQ0FBaUUsQ0FBNUIsQ0FBckMsTUFBQSxzQkFBRTtDQUFGLEdBQ0EsS0FBQSxDQUFBLFFBQUE7SUFGRjtDQUFBLENBSUEsQ0FBdUIsTUFBQSxXQUF2QjtDQUNFLE1BQUEsQ0FBQTtDQUFBLEVBQVUsQ0FBVixHQUFBLEdBQVU7Q0FDVixHQUFBLEdBQUE7Q0FDRSxFQUEyRSxDQUEzRSxDQUFxRyxFQUExRSxNQUEzQixFQUEyQixHQUEzQiw0QkFBMkIsb0JBQTNCO01BREY7Q0FHRSxDQUFBLEVBQUEsU0FBQSxLQUFBO01BTG1CO0NBSnZCLEVBSXVCO0NBSnZCLENBV0EsQ0FBdUIsRUFBQSxDQUFBLEdBQUMsQ0FBRCxVQUF2QjtDQUNZLENBQTJELENBQW5DLElBQW1GLEVBQTVHLENBQVQsQ0FBQSxZQUFBLENBQWtDLENBQW1DO0NBQ25FLEdBQUEsRUFBQSxDQUFBLEdBQUE7Q0FDQSxHQUFJLEVBQUosSUFBQTtDQUNFLEVBQUEsS0FBQSxFQUFBO1FBRkY7Q0FBQSxLQUdBLEdBQUEsQ0FBQTtDQUNBLFlBQUEsT0FBQTtDQUxGLElBQXFIO0NBWnZILEVBV3VCO0NBWHZCLENBbUJBLENBQXVCLENBbkJ2QixnQkFtQkE7Q0FFQSxDQUFBLENBQWdCLENBQWIsTUFBQSxPQUFhO0NBQ2QsQ0FBd0QsQ0FBbkMsQ0FBckIsTUFBQSxVQUFBLElBQXFCLENBQW1DO0lBdEIxRDtDQUFBLENBd0JBLENBQXlCLEVBQXpCLElBQTBCLE1BQTFCO0NBQ0UsQ0FBNEMsQ0FBQSxDQUE1QyxLQUFBLEVBQUEsR0FBQSxDQUE0QyxJQUE1QztDQURGLEVBQXlCO0NBeEJ6QixDQTJCQSxDQUFxQixHQUFyQixHQUFzQixDQUF0QjtDQUNFLFVBQUEsU0FBQTtDQURGLEVBQXFCO0NBM0JyQixDQThCQSxDQUE4QixHQUE5QixHQUErQixVQUEvQjtDQUNFLEdBQUEsS0FBRyxJQUFBO0NBQ0QsT0FBQSxLQUFBLE1BQUE7TUFERjtDQUdFLEtBQUEsRUFBQSxHQUFBLFFBQUE7Q0FDQSxLQUFBLE9BQUEsZUFBQTtNQUwwQjtDQUE5QixFQUE4QjtDQTlCOUIsQ0FxQ0EsQ0FBMkQsRUFBM0QsSUFBNEQsd0NBQTVEO0NBQ0UsR0FBQSxnQkFBQTtDQUFBLEtBQUEsTUFBQSxRQUFBO01BQUE7Q0FDa0MsRUFBWCxNQUFXLENBQVgsQ0FBdkIsU0FBQTtDQUN1QixDQUFtQyxDQUFuQyxVQUFyQixPQUFBLElBQXFCLENBQW1DO0NBRG5DLENBRXJCLENBRnFCLEVBQVc7Q0FGcEMsRUFBMkQ7Q0FyQzNELENBMkNBLENBQW1ELENBQUEsS0FBQyxTQUFwRCxNQUFBO0NBQ0UsT0FBQSw0QkFBQTtDQUFBLEVBQUEsQ0FBQTtDQUFBLEVBQ1MsQ0FBVCxDQUFTLENBQVQ7Q0FEQSxFQUVRLENBQVIsQ0FBQSxDQUFjO0NBRmQsRUFHYSxDQUFiLENBSEEsS0FHQTtDQUhBLENBQUEsQ0FJTyxDQUFQO0NBSkEsQ0FLQSxDQUFHLENBQUg7Q0FDQSxFQUFHLENBQUgsQ0FBUTtDQUNOLEVBQUcsQ0FBSCxFQUFBLDBFQUFBO0NBQUEsRUFDRyxHQUFILEVBQUEsQ0FBQTtDQUNDLEdBQUQsU0FBQTtDQUNFLENBQU0sQ0FBTixFQUFBLEdBQUEsT0FBTTtDQUFOLENBQ1UsSUFEVixFQUNBO0NBQ0YsRUFBTSxDQUhOLElBQUEsQ0FHTztDQUNMLENBQWlCLENBQUEsQ0FBakIsSUFBQSxDQUFrQjtDQUNoQixDQUFNLENBQXVCLENBQTFCLENBQWdELENBQWhELElBQUgsY0FBTTtDQUNKLENBQVMsQ0FBNkIsQ0FBdEMsQ0FBUyxDQUFULE1BQUEsa0JBQVM7WUFEWDtDQUVBLEVBQU0sQ0FBSCxDQUFZLEtBQWY7Q0FBQSxFQUNlLE9BQWIsU0FBQTtZQUphO0NBQWpCLFFBQWlCO0FBS2IsQ0FBSixHQUFHLElBQUgsRUFBQTtDQUNFLEVBQXNDLENBQXRDLENBQVMsS0FBVCxDQUFTLFVBQVQsU0FBUztVQU5YO0NBQUEsRUFPRyxDQUFILElBQUE7Q0FQQSxFQVFHLEtBQUgsQ0FBQTtDQUNJLEVBQUQsSUFBSCxPQUFBLENBQUE7Q0FiRixNQUdNO01BYnlDO0NBQW5ELEVBQW1EO0NBM0NuRCxDQW9FQSxDQUF1RCxJQUF2RCxDQUFBLENBQXdELG9CQUF4RDtDQUNFLElBQUEsR0FBQTtDQUFBLEVBQVEsQ0FBUixDQUFBO0NBQ0EsRUFBZ0MsQ0FBaEMsQ0FBcUMsQ0FBbEMsR0FBNkIsZUFBM0I7Q0FDSCxFQUF1QyxDQUFBLENBQUssQ0FBNUMsRUFBQSxDQUF1QyxHQUF2QyxJQUF3QixHQUFBLDJGQUFBO0NBQXhCLElBRUEsQ0FBQSxnQ0FBQTtDQUNBLENBQUEsRUFBQSxTQUFBLEtBQUE7TUFObUQ7Q0FBdkQsRUFBdUQ7Q0FwRXZELENBNEVBLENBQXVELElBQXZELENBQUEsQ0FBd0Qsb0JBQXhEO0NBQ0UsSUFBQSxHQUFBO0NBQUEsRUFBUSxDQUFSLENBQUE7Q0FDQSxFQUErQixDQUEvQixDQUFvQyxDQUFqQyxHQUE0QixjQUExQjtDQUNILEVBQXFDLENBQUEsQ0FBSyxDQUExQyxFQUFBLENBQXFDLEdBQXJDLEVBQXdCLEtBQUEsK0ZBQUE7Q0FBeEIsSUFFQSxDQUFBLGdDQUFBO0NBQ0EsQ0FBQSxFQUFBLFNBQUEsS0FBQTtNQU5tRDtDQUF2RCxFQUF1RDtDQVF2RCxDQUFBLENBQXVDLElBQXZDLENBQUEsQ0FBQSxJQUFBO0NBQ0UsR0FBQSxFQUFBLENBQUEsSUFBQTtDQURGLEVBQXVDO0NBckZTOzs7Ozs7OztBQ0psRCxDQUFBLEdBQUE7O0FBQUEsQ0FBQSxFQUFJLElBQUEsQ0FBQTs7QUFDSixDQURBLEVBQ1csR0FBWCxDQUFXLFFBQUE7O0FBRVgsQ0FIQSxDQUdvQyxDQUFjLEtBQWxELENBQWtELEdBQWxELENBQUE7Q0FDRSxDQUFBLENBQXFDLENBQXJDLEVBQUEsR0FBcUMsTUFBckM7Q0FDRSxPQUFBLGNBQUE7Q0FBQSxFQUFPLENBQVA7Q0FBQSxFQUVRLENBQVIsQ0FBQSxjQUFRO0NBRlIsRUFHWSxDQUFaLENBQWlCLEdBQUwsQ0FBWixFQUFZLFNBQUEsRUFBQTtDQUVaLEdBQUEsQ0FBVyxNQUFYO0NBQ0UsS0FBQSxFQUFBLENBQVMsYUFBVDtDQUNVLEdBQVYsRUFBQSxFQUFBLENBQVMsSUFBVCxFQUFBLE9BQUE7SUFDTSxDQUFRLENBSGhCLEVBQUE7Q0FJRSxLQUFBLEVBQUEsQ0FBUyxVQUFUO0NBQ1UsR0FBVixFQUFBLEVBQUEsQ0FBUyxJQUFULEVBQUEsSUFBQTtNQUxGO0NBT1ksR0FBVixJQUFBLENBQVMsSUFBVCxFQUFBO01BYmlDO0NBQXJDLEVBQXFDO0NBQXJDLENBZUEsQ0FBdUMsQ0FBdkMsRUFBQSxHQUF1QyxRQUF2QztDQUNFLE9BQUEsdUJBQUE7Q0FBQSxFQUFTLENBQVQsRUFBQTtBQUNpQyxDQURqQyxFQUNXLENBQVgsQ0FBQSxDQUFXO0NBRFgsRUFFUSxDQUFSLENBQUEsY0FBUTtDQUZSLEVBR1ksQ0FBWixDQUFpQixHQUFMLENBQVosV0FBWTtDQUhaLEdBSUEsS0FBUyxFQUFULElBQUE7Q0FKQSxDQU9tQixDQUFKLENBQWYsS0FBUztDQUNQLFNBQUEsRUFBQTtDQUFBLEVBQVEsQ0FBQSxDQUFSLENBQUEsQ0FBa0I7Q0FBbEIsRUFDUSxDQUFBLENBQVIsQ0FBQSxDQUFrQjtDQUNsQixHQUFHLENBQVUsQ0FBYjtDQUNFLENBQUEsRUFBRyxDQUFBLEdBQUg7Q0FBb0IsQ0FBQSxDQUFRLEVBQVIsS0FBQTtNQUFwQixJQUFBO0FBQTZDLENBQVQsRUFBUSxFQUFSLEtBQUE7VUFBcEM7Q0FDQSxDQUFBLEVBQUcsQ0FBQSxHQUFIO0NBQW9CLENBQUEsQ0FBUSxFQUFSLEtBQUE7TUFBcEIsSUFBQTtBQUE2QyxDQUFULEVBQVEsRUFBUixLQUFBO1VBRnRDO1FBRkE7Q0FLQSxFQUFXLENBQVIsQ0FBQSxDQUFIO0NBQ0UsSUFBQSxVQUFPO1FBTlQ7Q0FPQSxFQUFXLENBQVIsQ0FBQSxDQUFIO0FBQ1UsQ0FBUixJQUFBLFVBQU87UUFSVDtDQVNBLFlBQU87Q0FWVCxJQUFlO0NBUGYsR0FtQkEsQ0FBQSxDQUFBLEVBQUEsQ0FBUztDQUNDLEdBQVYsSUFBQSxDQUFTLEVBQVQsSUFBQTtDQXJCRixFQUF1QztDQXVCdkMsQ0FBQSxDQUFnRCxLQUFoRCxDQUFBLHNCQUFBO0NBQ0UsT0FBQSxPQUFBO0NBQUEsRUFBWSxDQUFaLENBQUksQ0FBRCxpQ0FBUztDQUNWLEtBQUEsRUFBQSxHQUFBLE9BQUE7Q0FBQSxHQUNBLENBQUEsQ0FBQSxzQkFBQTtDQURBLENBQUEsQ0FFVyxHQUFYLEVBQUE7Q0FGQSxFQUdnRCxDQUFoRCxFQUFBLEdBQWdELDhCQUFoRDtDQUNjLEVBQUEsQ0FBQSxJQUFaLE9BQUE7Q0FERixNQUFnRDtDQUhoRCxDQUs4QixDQUFuQixHQUFYLEVBQUE7Q0FMQSxFQU1BLEdBQUEsRUFBQSxvQ0FBQTtDQUNBLENBQTBDLENBQXVCLENBQWpFLEVBQUEsRUFBQSxLQUFBLFNBQTBDLEdBQTFDO01BUkY7Q0FVRSxPQUFBLEtBQUEsS0FBQTtNQVg0QztDQUFoRCxFQUFnRDtDQXZDQTs7OztBQ0hsRCxDQUFBLEdBQUE7O0FBQUEsQ0FBQSxFQUFJLElBQUEsQ0FBQTs7QUFDSixDQURBLEVBQ1csR0FBWCxDQUFXLFFBQUE7O0FBRVgsQ0FIQSxDQUdvQyxDQUFjLEtBQWxELENBQWtELEdBQWxELENBQUE7Q0FDRSxLQUFBLHVCQUFBO0NBQUEsQ0FBQSxDQUFRLENBQUEsQ0FBUjtDQUFBLENBQ0EsQ0FBYSxDQUFBLENBQUssS0FBbEIsU0FBYTtDQURiLENBRUEsQ0FBYSxDQUFBLENBQUssS0FBbEIsTUFBYTtDQUNiLENBQUEsQ0FBdUIsQ0FBcEIsRUFBQSxJQUFVO0NBQ1gsR0FBQSxLQUFBLENBQVU7Q0FDQyxDQUFYLENBQXdCLEtBQXhCLENBQXlCLENBQWYsQ0FBVjtDQUNFLEVBQUEsT0FBQTtDQUFBLEVBQUEsR0FBQSxPQUFNO0NBQ0ssQ0FBdUIsQ0FBbEMsTUFBQSxDQUFVLENBQVYsRUFBQTtDQUZGLElBQXdCO0lBTnNCO0NBQUE7O0FBVWxELENBYkEsQ0FhQSxDQUE2RCxFQUFBLEdBQTdELENBQThELFVBQTlELElBQUE7Q0FDRSxLQUFBLElBQUE7Q0FBQSxDQUFBLENBQWEsT0FBYixzQkFBYTtDQUNiLENBQUEsQ0FBdUIsQ0FBcEIsRUFBQSxJQUFVO0NBQ0EsUUFBWCxDQUFVLENBQVY7SUFIeUQ7Q0FBQTs7Ozs7Ozs7QUNiN0QsQ0FBQSxHQUFBOztBQUFBLENBQUEsRUFBSSxJQUFBLENBQUE7O0FBQ0osQ0FEQSxFQUNXLEdBQVgsQ0FBVyxRQUFBOztBQUVYLENBSEEsQ0FHOEIsQ0FBWSxJQUExQyxDQUFBLENBQTBDLENBQTFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2Mi4xLjFcbiAqIGh0dHA6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAwNSwgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE0LTA1LTAxVDE3OjExWlxuICovXG5cbihmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciB3aW5kb3cgaXMgcHJlc2VudCxcblx0XHQvLyBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5XG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBpbmhlcmVudGx5IHBvc3NlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgalF1ZXJ5LW1ha2luZyBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCB3aW5kb3dcblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mb1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIENhbid0IGRvIHRoaXMgYmVjYXVzZSBzZXZlcmFsIGFwcHMgaW5jbHVkaW5nIEFTUC5ORVQgdHJhY2Vcbi8vIHRoZSBzdGFjayB2aWEgYXJndW1lbnRzLmNhbGxlci5jYWxsZWUgYW5kIEZpcmVmb3ggZGllcyBpZlxuLy8geW91IHRyeSB0byB0cmFjZSB0aHJvdWdoIFwidXNlIHN0cmljdFwiIGNhbGwgY2hhaW5zLiAoIzEzMzM1KVxuLy8gU3VwcG9ydDogRmlyZWZveCAxOCtcbi8vXG5cbnZhciBhcnIgPSBbXTtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cblxuXG52YXJcblx0Ly8gVXNlIHRoZSBjb3JyZWN0IGRvY3VtZW50IGFjY29yZGluZ2x5IHdpdGggd2luZG93IGFyZ3VtZW50IChzYW5kYm94KVxuXHRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcblxuXHR2ZXJzaW9uID0gXCIyLjEuMVwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjFcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLFxuXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuXHRybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW1xcZGEtel0pL2dpLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gU3RhcnQgd2l0aCBhbiBlbXB0eSBzZWxlY3RvclxuXHRzZWxlY3RvcjogXCJcIixcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0cmV0dXJuIG51bSAhPSBudWxsID9cblxuXHRcdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdFx0KCBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdICkgOlxuXG5cdFx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0XHRzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXHRcdHJldC5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdC8vIChZb3UgY2FuIHNlZWQgdGhlIGFyZ3VtZW50cyB3aXRoIGFuIGFycmF5IG9mIGFyZ3MsIGJ1dCB0aGlzIGlzXG5cdC8vIG9ubHkgdXNlZCBpbnRlcm5hbGx5Lilcblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrLCBhcmdzICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2ssIGFyZ3MgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAodGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0pKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzW2pdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKG51bGwpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24odGFyZ2V0KSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIGV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheShjb3B5KSkgKSApIHtcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0Ly8gU2VlIHRlc3QvdW5pdC9jb3JlLmpzIGZvciBkZXRhaWxzIGNvbmNlcm5pbmcgaXNGdW5jdGlvbi5cblx0Ly8gU2luY2UgdmVyc2lvbiAxLjMsIERPTSBtZXRob2RzIGFuZCBmdW5jdGlvbnMgbGlrZSBhbGVydFxuXHQvLyBhcmVuJ3Qgc3VwcG9ydGVkLiBUaGV5IHJldHVybiBmYWxzZSBvbiBJRSAoIzI5NjgpLlxuXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZShvYmopID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAobnVsbHx0cnVlfGZhbHNlfFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdHJldHVybiAhalF1ZXJ5LmlzQXJyYXkoIG9iaiApICYmIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApID49IDA7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHQvLyBOb3QgcGxhaW4gb2JqZWN0czpcblx0XHQvLyAtIEFueSBvYmplY3Qgb3IgdmFsdWUgd2hvc2UgaW50ZXJuYWwgW1tDbGFzc11dIHByb3BlcnR5IGlzIG5vdCBcIltvYmplY3QgT2JqZWN0XVwiXG5cdFx0Ly8gLSBET00gbm9kZXNcblx0XHQvLyAtIHdpbmRvd1xuXHRcdGlmICggalF1ZXJ5LnR5cGUoIG9iaiApICE9PSBcIm9iamVjdFwiIHx8IG9iai5ub2RlVHlwZSB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICggb2JqLmNvbnN0cnVjdG9yICYmXG5cdFx0XHRcdCFoYXNPd24uY2FsbCggb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIgKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgZnVuY3Rpb24gaGFzbid0IHJldHVybmVkIGFscmVhZHksIHdlJ3JlIGNvbmZpZGVudCB0aGF0XG5cdFx0Ly8gfG9ianwgaXMgYSBwbGFpbiBvYmplY3QsIGNyZWF0ZWQgYnkge30gb3IgY29uc3RydWN0ZWQgd2l0aCBuZXcgT2JqZWN0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgbmFtZTtcblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdFx0fVxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPCA0LjAsIGlPUyA8IDYgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbChvYmopIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdHZhciBzY3JpcHQsXG5cdFx0XHRpbmRpcmVjdCA9IGV2YWw7XG5cblx0XHRjb2RlID0galF1ZXJ5LnRyaW0oIGNvZGUgKTtcblxuXHRcdGlmICggY29kZSApIHtcblx0XHRcdC8vIElmIHRoZSBjb2RlIGluY2x1ZGVzIGEgdmFsaWQsIHByb2xvZ3VlIHBvc2l0aW9uXG5cdFx0XHQvLyBzdHJpY3QgbW9kZSBwcmFnbWEsIGV4ZWN1dGUgY29kZSBieSBpbmplY3RpbmcgYVxuXHRcdFx0Ly8gc2NyaXB0IHRhZyBpbnRvIHRoZSBkb2N1bWVudC5cblx0XHRcdGlmICggY29kZS5pbmRleE9mKFwidXNlIHN0cmljdFwiKSA9PT0gMSApIHtcblx0XHRcdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcblx0XHRcdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBPdGhlcndpc2UsIGF2b2lkIHRoZSBET00gbm9kZSBjcmVhdGlvbiwgaW5zZXJ0aW9uXG5cdFx0XHQvLyBhbmQgcmVtb3ZhbCBieSB1c2luZyBhbiBpbmRpcmVjdCBnbG9iYWwgZXZhbFxuXHRcdFx0XHRpbmRpcmVjdCggY29kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHQvLyBhcmdzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrLCBhcmdzICkge1xuXHRcdHZhciB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aCxcblx0XHRcdGlzQXJyYXkgPSBpc0FycmF5bGlrZSggb2JqICk7XG5cblx0XHRpZiAoIGFyZ3MgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXkgKSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suYXBwbHkoIG9ialsgaSBdLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5hcHBseSggb2JqWyBpIF0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBIHNwZWNpYWwsIGZhc3QsIGNhc2UgZm9yIHRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgZWFjaFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGlzQXJyYXkgKSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICk7XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5bGlrZSggT2JqZWN0KGFycikgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0aXNBcnJheSA9IGlzQXJyYXlsaWtlKCBlbGVtcyApLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogRGF0ZS5ub3csXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0pO1xuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvclwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oaSwgbmFtZSkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0pO1xuXG5mdW5jdGlvbiBpc0FycmF5bGlrZSggb2JqICkge1xuXHR2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aCxcblx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXG5cdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBvYmoubm9kZVR5cGUgPT09IDEgJiYgbGVuZ3RoICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYxLjEwLjE5XG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDEzIGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTQtMDQtMThcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAtKG5ldyBEYXRlKCkpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gR2VuZXJhbC1wdXJwb3NlIGNvbnN0YW50c1xuXHRzdHJ1bmRlZmluZWQgPSB0eXBlb2YgdW5kZWZpbmVkLFxuXHRNQVhfTkVHQVRJVkUgPSAxIDw8IDMxLFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBpZiB3ZSBjYW4ndCB1c2UgYSBuYXRpdmUgb25lXG5cdGluZGV4T2YgPSBhcnIuaW5kZXhPZiB8fCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggdGhpc1tpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gV2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc3ludGF4LyNjaGFyYWN0ZXJzXG5cdGNoYXJhY3RlckVuY29kaW5nID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXFxceDAwLVxcXFx4YTBdKStcIixcblxuXHQvLyBMb29zZWx5IG1vZGVsZWQgb24gQ1NTIGlkZW50aWZpZXIgY2hhcmFjdGVyc1xuXHQvLyBBbiB1bnF1b3RlZCB2YWx1ZSBzaG91bGQgYmUgYSBDU1MgaWRlbnRpZmllciBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHQvLyBQcm9wZXIgc3ludGF4OiBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IGNoYXJhY3RlckVuY29kaW5nLnJlcGxhY2UoIFwid1wiLCBcIncjXCIgKSxcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGNoYXJhY3RlckVuY29kaW5nLnJlcGxhY2UoIFwid1wiLCBcIncqXCIgKSArIFwiKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXHRyZXNjYXBlID0gLyd8XFxcXC9nLFxuXG5cdC8vIENTUyBlc2NhcGVzIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbWF0Y2gsIGVsZW0sIG0sIG5vZGVUeXBlLFxuXHRcdC8vIFFTQSB2YXJzXG5cdFx0aSwgZ3JvdXBzLCBvbGQsIG5pZCwgbmV3Q29udGV4dCwgbmV3U2VsZWN0b3I7XG5cblx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cblx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdGlmICggIXNlbGVjdG9yIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdGlmICggKG5vZGVUeXBlID0gY29udGV4dC5ub2RlVHlwZSkgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0aWYgKCBkb2N1bWVudElzSFRNTCAmJiAhc2VlZCApIHtcblxuXHRcdC8vIFNob3J0Y3V0c1xuXHRcdGlmICggKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIjSURcIilcblx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKTtcblx0XHRcdFx0XHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuXHRcdFx0XHRcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKGpRdWVyeSAjNjk2Mylcblx0XHRcdFx0XHRpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIElFLCBPcGVyYSwgYW5kIFdlYmtpdCByZXR1cm4gaXRlbXNcblx0XHRcdFx0XHRcdC8vIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBDb250ZXh0IGlzIG5vdCBhIGRvY3VtZW50XG5cdFx0XHRcdFx0aWYgKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgJiYgKGVsZW0gPSBjb250ZXh0Lm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiYgZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCJUQUdcIilcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiLkNMQVNTXCIpXG5cdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBRU0EgcGF0aFxuXHRcdGlmICggc3VwcG9ydC5xc2EgJiYgKCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblx0XHRcdG5pZCA9IG9sZCA9IGV4cGFuZG87XG5cdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdG5ld1NlbGVjdG9yID0gbm9kZVR5cGUgPT09IDkgJiYgc2VsZWN0b3I7XG5cblx0XHRcdC8vIHFTQSB3b3JrcyBzdHJhbmdlbHkgb24gRWxlbWVudC1yb290ZWQgcXVlcmllc1xuXHRcdFx0Ly8gV2UgY2FuIHdvcmsgYXJvdW5kIHRoaXMgYnkgc3BlY2lmeWluZyBhbiBleHRyYSBJRCBvbiB0aGUgcm9vdFxuXHRcdFx0Ly8gYW5kIHdvcmtpbmcgdXAgZnJvbSB0aGVyZSAoVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoZSB0ZWNobmlxdWUpXG5cdFx0XHQvLyBJRSA4IGRvZXNuJ3Qgd29yayBvbiBvYmplY3QgZWxlbWVudHNcblx0XHRcdGlmICggbm9kZVR5cGUgPT09IDEgJiYgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblxuXHRcdFx0XHRpZiAoIChvbGQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZShcImlkXCIpKSApIHtcblx0XHRcdFx0XHRuaWQgPSBvbGQucmVwbGFjZSggcmVzY2FwZSwgXCJcXFxcJCZcIiApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIG5pZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5pZCA9IFwiW2lkPSdcIiArIG5pZCArIFwiJ10gXCI7XG5cblx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGdyb3Vwc1tpXSA9IG5pZCArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0O1xuXHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKFwiLFwiKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaChxc2FFcnJvcikge1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggIW9sZCApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbihzdHJpbmcsIE9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZGl2IGFuZCBleHBlY3RzIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZGl2ICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBkaXYucGFyZW50Tm9kZSApIHtcblx0XHRcdGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBkaXYgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRkaXYgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGF0dHJzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHQoIH5iLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApIC1cblx0XHRcdCggfmEuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICk7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBzdHJ1bmRlZmluZWQgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2MsXG5cdFx0cGFyZW50ID0gZG9jLmRlZmF1bHRWaWV3O1xuXG5cdC8vIElmIG5vIGRvY3VtZW50IGFuZCBkb2N1bWVudEVsZW1lbnQgaXMgYXZhaWxhYmxlLCByZXR1cm5cblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBTZXQgb3VyIGRvY3VtZW50XG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuXHQvLyBTdXBwb3J0IHRlc3RzXG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2MgKTtcblxuXHQvLyBTdXBwb3J0OiBJRT44XG5cdC8vIElmIGlmcmFtZSBkb2N1bWVudCBpcyBhc3NpZ25lZCB0byBcImRvY3VtZW50XCIgdmFyaWFibGUgYW5kIGlmIGlmcmFtZSBoYXMgYmVlbiByZWxvYWRlZCxcblx0Ly8gSUUgd2lsbCB0aHJvdyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBhY2Nlc3NpbmcgXCJkb2N1bWVudFwiIHZhcmlhYmxlLCBzZWUgalF1ZXJ5ICMxMzkzNlxuXHQvLyBJRTYtOCBkbyBub3Qgc3VwcG9ydCB0aGUgZGVmYXVsdFZpZXcgcHJvcGVydHkgc28gcGFyZW50IHdpbGwgYmUgdW5kZWZpbmVkXG5cdGlmICggcGFyZW50ICYmIHBhcmVudCAhPT0gcGFyZW50LnRvcCApIHtcblx0XHQvLyBJRTExIGRvZXMgbm90IGhhdmUgYXR0YWNoRXZlbnQsIHNvIGFsbCBtdXN0IHN1ZmZlclxuXHRcdGlmICggcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNldERvY3VtZW50KCk7XG5cdFx0XHR9LCBmYWxzZSApO1xuXHRcdH0gZWxzZSBpZiAoIHBhcmVudC5hdHRhY2hFdmVudCApIHtcblx0XHRcdHBhcmVudC5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2V0RG9jdW1lbnQoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFkaXYuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSBjYW4gYmUgdHJ1c3RlZFxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkgJiYgYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiPGRpdiBjbGFzcz0nYSc+PC9kaXY+PGRpdiBjbGFzcz0nYSBpJz48L2Rpdj5cIjtcblxuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaTw0XG5cdFx0Ly8gQ2F0Y2ggY2xhc3Mgb3Zlci1jYWNoaW5nXG5cdFx0ZGl2LmZpcnN0Q2hpbGQuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0Ly8gU3VwcG9ydDogT3BlcmE8MTBcblx0XHQvLyBDYXRjaCBnRUJDTiBmYWlsdXJlIHRvIGZpbmQgbm9uLWxlYWRpbmcgY2xhc3Nlc1xuXHRcdHJldHVybiBkaXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImlcIikubGVuZ3RoID09PSAyO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvYy5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jLmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaW5kIGFuZCBmaWx0ZXJcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBzdHJ1bmRlZmluZWQgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcblx0XHRcdFx0Ly8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAjNjk2M1xuXHRcdFx0XHRyZXR1cm4gbSAmJiBtLnBhcmVudE5vZGUgPyBbIG0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdC8vIFN1cHBvcnQ6IElFNi83XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdGRlbGV0ZSBFeHByLmZpbmRbXCJJRFwiXTtcblxuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gc3RydW5kZWZpbmVkICYmIGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IHN0cnVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gc3RydW5kZWZpbmVkICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2MucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gXCI8c2VsZWN0IG1zYWxsb3djbGlwPScnPjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NsaXBePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2MuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZGl2LCBcImRpdlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZGl2LCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IGRvZXMgbm90IGltcGxlbWVudCBpbmNsdXNpdmUgZGVzY2VuZGVudFxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2MgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2MgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mLmNhbGwoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZi5jYWxsKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2MgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvYyA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YuY2FsbCggc29ydElucHV0LCBhICkgLSBpbmRleE9mLmNhbGwoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2M7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2goZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IHN0cnVuZGVmaW5lZCAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdCArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBkaWZmLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6IG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IHBhcmVudFsgZXhwYW5kbyBdIHx8IChwYXJlbnRbIGV4cGFuZG8gXSA9IHt9KTtcblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSBvdXRlckNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMl07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdXNlQ2FjaGUgJiYgKGNhY2hlID0gKGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pKVsgdHlwZSBdKSAmJiBjYWNoZVswXSA9PT0gZGlycnVucyApIHtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IGNhY2hlWzFdO1xuXG5cdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDogbm9kZS5ub2RlVHlwZSA9PT0gMSApICYmICsrZGlmZiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdChub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KSlbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YuY2FsbCggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBmYWxzZTtcblx0XHR9LFxuXG5cdFx0XCJkaXNhYmxlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGRpciA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBkaXIgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cdFx0XHRcdFx0XHRpZiAoIChvbGRDYWNoZSA9IG91dGVyQ2FjaGVbIGRpciBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyBkaXIgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZi5jYWxsKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHJldHVybiAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgIT09IGRvY3VtZW50ICYmIGNvbnRleHQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBLZWVwIGBpYCBhIHN0cmluZyBpZiB0aGVyZSBhcmUgbm8gZWxlbWVudHMgc28gYG1hdGNoZWRDb3VudGAgd2lsbCBiZSBcIjAwXCIgYmVsb3dcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG5vIHNlZWQgYW5kIG9ubHkgb25lIGdyb3VwXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gVGFrZSBhIHNob3J0Y3V0IGFuZCBzZXQgdGhlIGNvbnRleHQgaWYgdGhlIHJvb3Qgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRzdXBwb3J0LmdldEJ5SWQgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdFx0XHRFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHRyc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lPDE0XG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZGl2MSApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBkaXYxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZGl2LmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0cmV0dXJuIGRpdi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xualF1ZXJ5LmV4cHJbXCI6XCJdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5cblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxudmFyIHJzaW5nbGVUYWcgPSAoL148KFxcdyspXFxzKlxcLz8+KD86PFxcL1xcMT58KSQvKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9KTtcblxuXHR9XG5cblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0pO1xuXG5cdH1cblxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdFx0fVxuXG5cdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+PSAwICkgIT09IG5vdDtcblx0fSk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRyZXR1cm4gZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXSA6XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHRcdH0pKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHQvLyBOZWVkZWQgYmVjYXVzZSAkKCBzZWxlY3RvciwgY29udGV4dCApIGJlY29tZXMgJCggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yIClcblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggbGVuID4gMSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0ICk7XG5cdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcIiBcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3codGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59KTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSopKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbMF0gPT09IFwiPFwiICYmIHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmIHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKG1hdGNoWzFdIHx8ICFjb250ZXh0KSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsxXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbMF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbMV0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbMV0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbMl0gKTtcblxuXHRcdFx0XHRcdC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG5cdFx0XHRcdFx0Ly8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAjNjk2M1xuXHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdFx0dGhpc1swXSA9IGVsZW07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5jb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290alF1ZXJ5ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gdGhpc1swXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHJvb3RqUXVlcnkucmVhZHkgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0XHRyb290alF1ZXJ5LnJlYWR5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXHQvLyBtZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0ZGlyOiBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWF0Y2hlZDtcblx0fSxcblxuXHRzaWJsaW5nOiBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdFx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlZDtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1tpXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHRwb3MgPSBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApIHx8IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9ycywgY29udGV4dCB8fCB0aGlzLmNvbnRleHQgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRmb3IgKCBjdXIgPSB0aGlzW2ldOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKHBvcyA/XG5cdFx0XHRcdFx0cG9zLmluZGV4KGN1cikgPiAtMSA6XG5cblx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihjdXIsIHNlbGVjdG9ycykpICkge1xuXG5cdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZSggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW5cblx0Ly8gdGhlIG1hdGNoZWQgc2V0IG9mIGVsZW1lbnRzXG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBpbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWUoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihzZWxlY3Rvcilcblx0XHQpO1xuXHR9XG59KTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKGN1ciA9IGN1cltkaXJdKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCh7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnNpYmxpbmcoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5zaWJsaW5nKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudCB8fCBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZSggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0pO1xudmFyIHJub3R3aGl0ZSA9ICgvXFxTKy9nKTtcblxuXG5cbi8vIFN0cmluZyB0byBPYmplY3Qgb3B0aW9ucyBmb3JtYXQgY2FjaGVcbnZhciBvcHRpb25zQ2FjaGUgPSB7fTtcblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXMgYW5kIHN0b3JlIGluIGNhY2hlXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0gb3B0aW9uc0NhY2hlWyBvcHRpb25zIF0gPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0pO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdCggb3B0aW9uc0NhY2hlWyBvcHRpb25zIF0gfHwgY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIExhc3QgZmlyZSB2YWx1ZSAoZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0cylcblx0XHRtZW1vcnksXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXHRcdC8vIEZpcnN0IGNhbGxiYWNrIHRvIGZpcmUgKHVzZWQgaW50ZXJuYWxseSBieSBhZGQgYW5kIGZpcmVXaXRoKVxuXHRcdGZpcmluZ1N0YXJ0LFxuXHRcdC8vIEVuZCBvZiB0aGUgbG9vcCB3aGVuIGZpcmluZ1xuXHRcdGZpcmluZ0xlbmd0aCxcblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSByZW1vdmUgaWYgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4LFxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXHRcdC8vIFN0YWNrIG9mIGZpcmUgY2FsbHMgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRzdGFjayA9ICFvcHRpb25zLm9uY2UgJiYgW10sXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRtZW1vcnkgPSBvcHRpb25zLm1lbW9yeSAmJiBkYXRhO1xuXHRcdFx0ZmlyZWQgPSB0cnVlO1xuXHRcdFx0ZmlyaW5nSW5kZXggPSBmaXJpbmdTdGFydCB8fCAwO1xuXHRcdFx0ZmlyaW5nU3RhcnQgPSAwO1xuXHRcdFx0ZmlyaW5nTGVuZ3RoID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBsaXN0ICYmIGZpcmluZ0luZGV4IDwgZmlyaW5nTGVuZ3RoOyBmaXJpbmdJbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIGRhdGFbIDAgXSwgZGF0YVsgMSBdICkgPT09IGZhbHNlICYmIG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7IC8vIFRvIHByZXZlbnQgZnVydGhlciBjYWxscyB1c2luZyBhZGRcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdGlmICggc3RhY2sgKSB7XG5cdFx0XHRcdFx0aWYgKCBzdGFjay5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCBzdGFjay5zaGlmdCgpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuZGlzYWJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0Ly8gRmlyc3QsIHdlIHNhdmUgdGhlIGN1cnJlbnQgbGVuZ3RoXG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0KGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KSggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0Ly8gRG8gd2UgbmVlZCB0byBhZGQgdGhlIGNhbGxiYWNrcyB0byB0aGVcblx0XHRcdFx0XHQvLyBjdXJyZW50IGZpcmluZyBiYXRjaD9cblx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdC8vIFdpdGggbWVtb3J5LCBpZiB3ZSdyZSBub3QgZmlyaW5nIHRoZW5cblx0XHRcdFx0XHQvLyB3ZSBzaG91bGQgY2FsbCByaWdodCBhd2F5XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nU3RhcnQgPSBzdGFydDtcblx0XHRcdFx0XHRcdGZpcmUoIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRcdGlmICggZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nTGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlyaW5nTGVuZ3RoLS07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gPyBqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDogISEoIGxpc3QgJiYgbGlzdC5sZW5ndGggKTtcblx0XHRcdH0sXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0ZmlyaW5nTGVuZ3RoID0gMDtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSGF2ZSB0aGUgbGlzdCBkbyBub3RoaW5nIGFueW1vcmVcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsaXN0ID0gc3RhY2sgPSBtZW1vcnkgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIElzIGl0IGRpc2FibGVkP1xuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gTG9jayB0aGUgbGlzdCBpbiBpdHMgY3VycmVudCBzdGF0ZVxuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHN0YWNrID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgKSB7XG5cdFx0XHRcdFx0c2VsZi5kaXNhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSXMgaXQgbG9ja2VkP1xuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFzdGFjaztcblx0XHRcdH0sXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggbGlzdCAmJiAoICFmaXJlZCB8fCBzdGFjayApICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRzdGFjay5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZpcmUoIGFyZ3MgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmpRdWVyeS5leHRlbmQoe1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgbGlzdGVuZXIgbGlzdCwgZmluYWwgc3RhdGVcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgXCJyZWplY3RlZFwiIF0sXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKFwibWVtb3J5XCIpIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZChmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIGkgXSApICYmIGZuc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZFsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdIGZvciBmb3J3YXJkaW5nIGFjdGlvbnMgdG8gbmV3RGVmZXJcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzFdIF0oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IHByb21pc2UgPyBuZXdEZWZlci5wcm9taXNlKCkgOiB0aGlzLCBmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdHByb21pc2UucGlwZSA9IHByb21pc2UudGhlbjtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDMgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZVsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWzFdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvLyBzdGF0ZSA9IFsgcmVzb2x2ZWQgfCByZWplY3RlZCBdXG5cdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblxuXHRcdFx0XHQvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXG5cdFx0XHRcdH0sIHR1cGxlc1sgaSBeIDEgXVsgMiBdLmRpc2FibGUsIHR1cGxlc1sgMiBdWyAyIF0ubG9jayApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWZlcnJlZFsgcmVzb2x2ZSB8IHJlamVjdCB8IG5vdGlmeSBdXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHByb21pc2UgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzdWJvcmRpbmF0ZSAvKiAsIC4uLiwgc3Vib3JkaW5hdGVOICovICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblx0XHRcdGxlbmd0aCA9IHJlc29sdmVWYWx1ZXMubGVuZ3RoLFxuXG5cdFx0XHQvLyB0aGUgY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBsZW5ndGggIT09IDEgfHwgKCBzdWJvcmRpbmF0ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggc3Vib3JkaW5hdGUucHJvbWlzZSApICkgPyBsZW5ndGggOiAwLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkLiBJZiByZXNvbHZlVmFsdWVzIGNvbnNpc3Qgb2Ygb25seSBhIHNpbmdsZSBEZWZlcnJlZCwganVzdCB1c2UgdGhhdC5cblx0XHRcdGRlZmVycmVkID0gcmVtYWluaW5nID09PSAxID8gc3Vib3JkaW5hdGUgOiBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gVXBkYXRlIGZ1bmN0aW9uIGZvciBib3RoIHJlc29sdmUgYW5kIHByb2dyZXNzIHZhbHVlc1xuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpLCBjb250ZXh0cywgdmFsdWVzICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdGNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggdmFsdWVzID09PSBwcm9ncmVzc1ZhbHVlcyApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXG5cdFx0XHRwcm9ncmVzc1ZhbHVlcywgcHJvZ3Jlc3NDb250ZXh0cywgcmVzb2x2ZUNvbnRleHRzO1xuXG5cdFx0Ly8gYWRkIGxpc3RlbmVycyB0byBEZWZlcnJlZCBzdWJvcmRpbmF0ZXM7IHRyZWF0IG90aGVycyBhcyByZXNvbHZlZFxuXHRcdGlmICggbGVuZ3RoID4gMSApIHtcblx0XHRcdHByb2dyZXNzVmFsdWVzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdHByb2dyZXNzQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHQuZG9uZSggdXBkYXRlRnVuYyggaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICkgKVxuXHRcdFx0XHRcdFx0LmZhaWwoIGRlZmVycmVkLnJlamVjdCApXG5cdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIHVwZGF0ZUZ1bmMoIGksIHByb2dyZXNzQ29udGV4dHMsIHByb2dyZXNzVmFsdWVzICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQtLXJlbWFpbmluZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGlmIHdlJ3JlIG5vdCB3YWl0aW5nIG9uIGFueXRoaW5nLCByZXNvbHZlIHRoZSBtYXN0ZXJcblx0XHRpZiAoICFyZW1haW5pbmcgKSB7XG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcblx0fVxufSk7XG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0O1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cdC8vIEFkZCB0aGUgY2FsbGJhY2tcblx0alF1ZXJ5LnJlYWR5LnByb21pc2UoKS5kb25lKCBmbiApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxuXHRob2xkUmVhZHk6IGZ1bmN0aW9uKCBob2xkICkge1xuXHRcdGlmICggaG9sZCApIHtcblx0XHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblxuXHRcdC8vIFRyaWdnZXIgYW55IGJvdW5kIHJlYWR5IGV2ZW50c1xuXHRcdGlmICggalF1ZXJ5LmZuLnRyaWdnZXJIYW5kbGVyICkge1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLnRyaWdnZXJIYW5kbGVyKCBcInJlYWR5XCIgKTtcblx0XHRcdGpRdWVyeSggZG9jdW1lbnQgKS5vZmYoIFwicmVhZHlcIiApO1xuXHRcdH1cblx0fVxufSk7XG5cbi8qKlxuICogVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbiAqL1xuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbmpRdWVyeS5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24oIG9iaiApIHtcblx0aWYgKCAhcmVhZHlMaXN0ICkge1xuXG5cdFx0cmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cblx0XHQvLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZCBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0XHQvLyB3ZSBvbmNlIHRyaWVkIHRvIHVzZSByZWFkeVN0YXRlIFwiaW50ZXJhY3RpdmVcIiBoZXJlLCBidXQgaXQgY2F1c2VkIGlzc3VlcyBsaWtlIHRoZSBvbmVcblx0XHQvLyBkaXNjb3ZlcmVkIGJ5IENocmlzUyBoZXJlOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjI4MiNjb21tZW50OjE1XG5cdFx0aWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgKSB7XG5cdFx0XHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0XHRcdHNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblxuXHRcdFx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVhZHlMaXN0LnByb21pc2UoIG9iaiApO1xufTtcblxuLy8gS2ljayBvZmYgdGhlIERPTSByZWFkeSBjaGVjayBldmVuIGlmIHRoZSB1c2VyIGRvZXMgbm90XG5qUXVlcnkucmVhZHkucHJvbWlzZSgpO1xuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGpRdWVyeS5hY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCBqUXVlcnkudHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGpRdWVyeS5hY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5W2ldLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbiggZWxlbXNbaV0sIGtleSwgcmF3ID8gdmFsdWUgOiB2YWx1ZS5jYWxsKCBlbGVtc1tpXSwgaSwgZm4oIGVsZW1zW2ldLCBrZXkgKSApICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNoYWluYWJsZSA/XG5cdFx0ZWxlbXMgOlxuXG5cdFx0Ly8gR2V0c1xuXHRcdGJ1bGsgP1xuXHRcdFx0Zm4uY2FsbCggZWxlbXMgKSA6XG5cdFx0XHRsZW4gPyBmbiggZWxlbXNbMF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIG9iamVjdCBjYW4gaGF2ZSBkYXRhXG4gKi9cbmpRdWVyeS5hY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0LyoganNoaW50IC1XMDE4ICovXG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8IDQsXG5cdC8vIE9sZCBXZWJLaXQgZG9lcyBub3QgaGF2ZSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMvZnJlZXplIG1ldGhvZCxcblx0Ly8gcmV0dXJuIG5ldyBlbXB0eSBvYmplY3QgaW5zdGVhZCB3aXRoIG5vIFtbc2V0XV0gYWNjZXNzb3Jcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLmNhY2hlID0ge30sIDAsIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHt9O1xuXHRcdH1cblx0fSk7XG5cblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBNYXRoLnJhbmRvbSgpO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5EYXRhLmFjY2VwdHMgPSBqUXVlcnkuYWNjZXB0RGF0YTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cdGtleTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0Ly8gQWx3YXlzIHJldHVybiB0aGUga2V5IGZvciBhIGZyb3plbiBvYmplY3QuXG5cdFx0aWYgKCAhRGF0YS5hY2NlcHRzKCBvd25lciApICkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGRlc2NyaXB0b3IgPSB7fSxcblx0XHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZSBrZXlcblx0XHRcdHVubG9jayA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXVubG9jayApIHtcblx0XHRcdHVubG9jayA9IERhdGEudWlkKys7XG5cblx0XHRcdC8vIFNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlLCBub24td3JpdGFibGUgcHJvcGVydHlcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRlc2NyaXB0b3JbIHRoaXMuZXhwYW5kbyBdID0geyB2YWx1ZTogdW5sb2NrIH07XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBvd25lciwgZGVzY3JpcHRvciApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDwgNFxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gYSBsZXNzIHNlY3VyZSBkZWZpbml0aW9uXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0ZGVzY3JpcHRvclsgdGhpcy5leHBhbmRvIF0gPSB1bmxvY2s7XG5cdFx0XHRcdGpRdWVyeS5leHRlbmQoIG93bmVyLCBkZXNjcmlwdG9yICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRpZiAoICF0aGlzLmNhY2hlWyB1bmxvY2sgXSApIHtcblx0XHRcdHRoaXMuY2FjaGVbIHVubG9jayBdID0ge307XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVubG9jaztcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Ly8gVGhlcmUgbWF5IGJlIGFuIHVubG9jayBhc3NpZ25lZCB0byB0aGlzIG5vZGUsXG5cdFx0XHQvLyBpZiB0aGVyZSBpcyBubyBlbnRyeSBmb3IgdGhpcyBcIm93bmVyXCIsIGNyZWF0ZSBvbmUgaW5saW5lXG5cdFx0XHQvLyBhbmQgc2V0IHRoZSB1bmxvY2sgYXMgdGhvdWdoIGFuIG93bmVyIGVudHJ5IGhhZCBhbHdheXMgZXhpc3RlZFxuXHRcdFx0dW5sb2NrID0gdGhpcy5rZXkoIG93bmVyICksXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGVbIHVubG9jayBdO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgZGF0YSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBGcmVzaCBhc3NpZ25tZW50cyBieSBvYmplY3QgYXJlIHNoYWxsb3cgY29waWVkXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXHRcdFx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLmNhY2hlWyB1bmxvY2sgXSwgZGF0YSApO1xuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGNhY2hlWyBwcm9wIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdC8vIEVpdGhlciBhIHZhbGlkIGNhY2hlIGlzIGZvdW5kLCBvciB3aWxsIGJlIGNyZWF0ZWQuXG5cdFx0Ly8gTmV3IGNhY2hlcyB3aWxsIGJlIGNyZWF0ZWQgYW5kIHRoZSB1bmxvY2sgcmV0dXJuZWQsXG5cdFx0Ly8gYWxsb3dpbmcgZGlyZWN0IGFjY2VzcyB0byB0aGUgbmV3bHkgY3JlYXRlZFxuXHRcdC8vIGVtcHR5IGRhdGEgb2JqZWN0LiBBIHZhbGlkIG93bmVyIG9iamVjdCBtdXN0IGJlIHByb3ZpZGVkLlxuXHRcdHZhciBjYWNoZSA9IHRoaXMuY2FjaGVbIHRoaXMua2V5KCBvd25lciApIF07XG5cblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0Y2FjaGUgOiBjYWNoZVsga2V5IF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBzdG9yZWQ7XG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KChrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgKSB7XG5cblx0XHRcdHN0b3JlZCA9IHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cblx0XHRcdHJldHVybiBzdG9yZWQgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHN0b3JlZCA6IHRoaXMuZ2V0KCBvd25lciwgalF1ZXJ5LmNhbWVsQ2FzZShrZXkpICk7XG5cdFx0fVxuXG5cdFx0Ly8gWypdV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLCBuYW1lLCBjYW1lbCxcblx0XHRcdHVubG9jayA9IHRoaXMua2V5KCBvd25lciApLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlWyB1bmxvY2sgXTtcblxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLmNhY2hlWyB1bmxvY2sgXSA9IHt9O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBrZXkgKSApIHtcblx0XHRcdFx0Ly8gSWYgXCJuYW1lXCIgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXaGVuIGRhdGEgaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIHZpYSAoXCJrZXlcIiwgXCJ2YWxcIikgc2lnbmF0dXJlLFxuXHRcdFx0XHQvLyBrZXlzIHdpbGwgYmUgY29udmVydGVkIHRvIGNhbWVsQ2FzZS5cblx0XHRcdFx0Ly8gU2luY2UgdGhlcmUgaXMgbm8gd2F5IHRvIHRlbGwgX2hvd18gYSBrZXkgd2FzIGFkZGVkLCByZW1vdmVcblx0XHRcdFx0Ly8gYm90aCBwbGFpbiBrZXkgYW5kIGNhbWVsQ2FzZSBrZXkuICMxMjc4NlxuXHRcdFx0XHQvLyBUaGlzIHdpbGwgb25seSBwZW5hbGl6ZSB0aGUgYXJyYXkgYXJndW1lbnQgcGF0aC5cblx0XHRcdFx0bmFtZSA9IGtleS5jb25jYXQoIGtleS5tYXAoIGpRdWVyeS5jYW1lbENhc2UgKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FtZWwgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblx0XHRcdFx0Ly8gVHJ5IHRoZSBzdHJpbmcgYXMgYSBrZXkgYmVmb3JlIGFueSBtYW5pcHVsYXRpb25cblx0XHRcdFx0aWYgKCBrZXkgaW4gY2FjaGUgKSB7XG5cdFx0XHRcdFx0bmFtZSA9IFsga2V5LCBjYW1lbCBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRcdG5hbWUgPSBjYW1lbDtcblx0XHRcdFx0XHRuYW1lID0gbmFtZSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0XHRbIG5hbWUgXSA6ICggbmFtZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpID0gbmFtZS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBuYW1lWyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHRyZXR1cm4gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KFxuXHRcdFx0dGhpcy5jYWNoZVsgb3duZXJbIHRoaXMuZXhwYW5kbyBdIF0gfHwge31cblx0XHQpO1xuXHR9LFxuXHRkaXNjYXJkOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0aWYgKCBvd25lclsgdGhpcy5leHBhbmRvIF0gKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5jYWNoZVsgb3duZXJbIHRoaXMuZXhwYW5kbyBdIF07XG5cdFx0fVxuXHR9XG59O1xudmFyIGRhdGFfcHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhX3VzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLypcblx0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuXG5cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcblx0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG5cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG5cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcbiovXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gLyhbQS1aXSkvZztcblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQxXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhID09PSBcInRydWVcIiA/IHRydWUgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcIm51bGxcIiA/IG51bGwgOlxuXHRcdFx0XHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0XHRcdFx0K2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBqUXVlcnkucGFyc2VKU09OKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhX3VzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YV91c2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhX3ByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhX3VzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YV91c2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFfcHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFfcHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhX3ByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUxMStcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoNSkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YV9wcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YV91c2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YSxcblx0XHRcdFx0Y2FtZWxLZXkgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIHdpdGggdGhlIGtleSBhcy1pc1xuXHRcdFx0XHRkYXRhID0gZGF0YV91c2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyB3aXRoIHRoZSBrZXkgY2FtZWxpemVkXG5cdFx0XHRcdGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCBlbGVtLCBjYW1lbEtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBjYW1lbEtleSwgdW5kZWZpbmVkICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBGaXJzdCwgYXR0ZW1wdCB0byBzdG9yZSBhIGNvcHkgb3IgcmVmZXJlbmNlIG9mIGFueVxuXHRcdFx0XHQvLyBkYXRhIHRoYXQgbWlnaHQndmUgYmVlbiBzdG9yZSB3aXRoIGEgY2FtZWxDYXNlZCBrZXkuXG5cdFx0XHRcdHZhciBkYXRhID0gZGF0YV91c2VyLmdldCggdGhpcywgY2FtZWxLZXkgKTtcblxuXHRcdFx0XHQvLyBGb3IgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZSBpbnRlcm9wLCB3ZSBoYXZlIHRvXG5cdFx0XHRcdC8vIHN0b3JlIHByb3BlcnR5IG5hbWVzIHdpdGggZGFzaGVzIGluIGEgY2FtZWxDYXNlIGZvcm0uXG5cdFx0XHRcdC8vIFRoaXMgbWlnaHQgbm90IGFwcGx5IHRvIGFsbCBwcm9wZXJ0aWVzLi4uKlxuXHRcdFx0XHRkYXRhX3VzZXIuc2V0KCB0aGlzLCBjYW1lbEtleSwgdmFsdWUgKTtcblxuXHRcdFx0XHQvLyAqLi4uIEluIHRoZSBjYXNlIG9mIHByb3BlcnRpZXMgdGhhdCBtaWdodCBfYWN0dWFsbHlfXG5cdFx0XHRcdC8vIGhhdmUgZGFzaGVzLCB3ZSBuZWVkIHRvIGFsc28gc3RvcmUgYSBjb3B5IG9mIHRoYXRcblx0XHRcdFx0Ly8gdW5jaGFuZ2VkIHByb3BlcnR5LlxuXHRcdFx0XHRpZiAoIGtleS5pbmRleE9mKFwiLVwiKSAhPT0gLTEgJiYgZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGRhdGFfdXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YV91c2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5cbmpRdWVyeS5leHRlbmQoe1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YV9wcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KGRhdGEpICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gbm90IGludGVuZGVkIGZvciBwdWJsaWMgY29uc3VtcHRpb24gLSBnZW5lcmF0ZXMgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJucyB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFfcHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKS5hZGQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFfcHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0pXG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbMF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBlbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVswXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0pO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YV9wcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSk7XG52YXIgcG51bSA9ICgvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLykuc291cmNlO1xuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblx0XHQvLyBpc0hpZGRlbiBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIiB8fCAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0fTtcblxudmFyIHJjaGVja2FibGVUeXBlID0gKC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pKTtcblxuXG5cbihmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vICMxMTIxNyAtIFdlYktpdCBsb3NlcyBjaGVjayB3aGVuIHRoZSBuYW1lIGlzIGFmdGVyIHRoZSBjaGVja2VkIGF0dHJpYnV0ZVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG5lZWQgLnNldEF0dHJpYnV0ZSBmb3IgV1dBXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBTYWZhcmkgNS4xLCBpT1MgNS4xLCBBbmRyb2lkIDQueCwgQW5kcm9pZCAyLjNcblx0Ly8gb2xkIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0Ly8gU3VwcG9ydDogSUU5LUlFMTErXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59KSgpO1xudmFyIHN0cnVuZGVmaW5lZCA9IHR5cGVvZiB1bmRlZmluZWQ7XG5cblxuXG5zdXBwb3J0LmZvY3VzaW5CdWJibGVzID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnUpfGNsaWNrLyxcblx0cmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpJC87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFfcHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IHN0cnVuZGVmaW5lZCAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbdF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsyXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0pICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8IHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFfcHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YV9wcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbdF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsyXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbMl0gJiYgbmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fCBzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkZWxldGUgZWxlbURhdGEuaGFuZGxlO1xuXHRcdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgXCJldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpIDogW107XG5cblx0XHRjdXIgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKFwiLlwiKSA+PSAwICkge1xuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoXCIuXCIpO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoXCI6XCIpIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZV9yZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoIChjdXIgPSBldmVudFBhdGhbaSsrXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFfcHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJiBkYXRhX3ByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgalF1ZXJ5LmFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICghc3BlY2lhbC5fZGVmYXVsdCB8fCBzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UpICYmXG5cdFx0XHRcdGpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFfcHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1swXSA9IGV2ZW50O1xuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0pICYmICFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3Jcblx0XHRcdFx0Ly8gMikgaGF2ZSBuYW1lc3BhY2UocykgYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50Lm5hbWVzcGFjZV9yZSB8fCBldmVudC5uYW1lc3BhY2VfcmUudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSkuaGFuZGxlIHx8IGhhbmRsZU9iai5oYW5kbGVyIClcblx0XHRcdFx0XHRcdFx0LmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChldmVudC5yZXN1bHQgPSByZXQpID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIG1hdGNoZXMsIHNlbCwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAoIzEzMTgwKVxuXHRcdC8vIEF2b2lkIG5vbi1sZWZ0LWNsaWNrIGJ1YmJsaW5nIGluIEZpcmVmb3ggKCMzODYxKVxuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJiBjdXIubm9kZVR5cGUgJiYgKCFldmVudC5idXR0b24gfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLmRpc2FibGVkICE9PSB0cnVlIHx8IGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIiApIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gW107XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+PSAwIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlcyB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdC8vIEluY2x1ZGVzIHNvbWUgZXZlbnQgcHJvcHMgc2hhcmVkIGJ5IEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50XG5cdHByb3BzOiBcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGV2ZW50UGhhc2UgbWV0YUtleSByZWxhdGVkVGFyZ2V0IHNoaWZ0S2V5IHRhcmdldCB0aW1lU3RhbXAgdmlldyB3aGljaFwiLnNwbGl0KFwiIFwiKSxcblxuXHRmaXhIb29rczoge30sXG5cblx0a2V5SG9va3M6IHtcblx0XHRwcm9wczogXCJjaGFyIGNoYXJDb2RlIGtleSBrZXlDb2RlXCIuc3BsaXQoXCIgXCIpLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50LndoaWNoID0gb3JpZ2luYWwuY2hhckNvZGUgIT0gbnVsbCA/IG9yaWdpbmFsLmNoYXJDb2RlIDogb3JpZ2luYWwua2V5Q29kZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXHRtb3VzZUhvb2tzOiB7XG5cdFx0cHJvcHM6IFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIuc3BsaXQoXCIgXCIpLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblx0XHRcdHZhciBldmVudERvYywgZG9jLCBib2R5LFxuXHRcdFx0XHRidXR0b24gPSBvcmlnaW5hbC5idXR0b247XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcblx0XHRcdGlmICggZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0XHRcdGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0Ym9keSA9IGV2ZW50RG9jLmJvZHk7XG5cblx0XHRcdFx0ZXZlbnQucGFnZVggPSBvcmlnaW5hbC5jbGllbnRYICsgKCBkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCApIC0gKCBkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCApO1xuXHRcdFx0XHRldmVudC5wYWdlWSA9IG9yaWdpbmFsLmNsaWVudFkgKyAoIGRvYyAmJiBkb2Muc2Nyb2xsVG9wICB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wICB8fCAwICkgLSAoIGRvYyAmJiBkb2MuY2xpZW50VG9wICB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wICB8fCAwICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRcdC8vIE5vdGU6IGJ1dHRvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28gZG9uJ3QgdXNlIGl0XG5cdFx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSAoIGJ1dHRvbiAmIDEgPyAxIDogKCBidXR0b24gJiAyID8gMyA6ICggYnV0dG9uICYgNCA/IDIgOiAwICkgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRlIGEgd3JpdGFibGUgY29weSBvZiB0aGUgZXZlbnQgb2JqZWN0IGFuZCBub3JtYWxpemUgc29tZSBwcm9wZXJ0aWVzXG5cdFx0dmFyIGksIHByb3AsIGNvcHksXG5cdFx0XHR0eXBlID0gZXZlbnQudHlwZSxcblx0XHRcdG9yaWdpbmFsRXZlbnQgPSBldmVudCxcblx0XHRcdGZpeEhvb2sgPSB0aGlzLmZpeEhvb2tzWyB0eXBlIF07XG5cblx0XHRpZiAoICFmaXhIb29rICkge1xuXHRcdFx0dGhpcy5maXhIb29rc1sgdHlwZSBdID0gZml4SG9vayA9XG5cdFx0XHRcdHJtb3VzZUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMubW91c2VIb29rcyA6XG5cdFx0XHRcdHJrZXlFdmVudC50ZXN0KCB0eXBlICkgPyB0aGlzLmtleUhvb2tzIDpcblx0XHRcdFx0e307XG5cdFx0fVxuXHRcdGNvcHkgPSBmaXhIb29rLnByb3BzID8gdGhpcy5wcm9wcy5jb25jYXQoIGZpeEhvb2sucHJvcHMgKSA6IHRoaXMucHJvcHM7XG5cblx0XHRldmVudCA9IG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblxuXHRcdGkgPSBjb3B5Lmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHByb3AgPSBjb3B5WyBpIF07XG5cdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ2luYWxFdmVudFsgcHJvcCBdO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IENvcmRvdmEgMi41IChXZWJLaXQpICgjMTMyNTUpXG5cdFx0Ly8gQWxsIGV2ZW50cyBzaG91bGQgaGF2ZSBhIHRhcmdldDsgQ29yZG92YSBkZXZpY2VyZWFkeSBkb2Vzbid0XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDYuMCssIENocm9tZSA8IDI4XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHRpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmaXhIb29rLmZpbHRlciA/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQsIGJ1YmJsZSApIHtcblx0XHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmUuXG5cdFx0Ly8gRmFrZSBvcmlnaW5hbEV2ZW50IHRvIGF2b2lkIGRvbm9yJ3Mgc3RvcFByb3BhZ2F0aW9uLCBidXQgaWYgdGhlXG5cdFx0Ly8gc2ltdWxhdGVkIGV2ZW50IHByZXZlbnRzIGRlZmF1bHQgdGhlbiB3ZSBkbyB0aGUgc2FtZSBvbiB0aGUgZG9ub3IuXG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlLFxuXHRcdFx0XHRvcmlnaW5hbEV2ZW50OiB7fVxuXHRcdFx0fVxuXHRcdCk7XG5cdFx0aWYgKCBidWJibGUgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guY2FsbCggZWxlbSwgZSApO1xuXHRcdH1cblx0XHRpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUsIGZhbHNlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQpICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8IDQuMFxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmIGUucHJldmVudERlZmF1bHQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgZS5zdG9wUHJvcGFnYXRpb24gKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIFN1cHBvcnQ6IENocm9tZSAxNStcbmpRdWVyeS5lYWNoKHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59KTtcblxuLy8gQ3JlYXRlIFwiYnViYmxpbmdcIiBmb2N1cyBhbmQgYmx1ciBldmVudHNcbi8vIFN1cHBvcnQ6IEZpcmVmb3gsIENocm9tZSwgU2FmYXJpXG5pZiAoICFzdXBwb3J0LmZvY3VzaW5CdWJibGVzICkge1xuXHRqUXVlcnkuZWFjaCh7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApLCB0cnVlICk7XG5cdFx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YV9wcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YV9wcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhX3ByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YV9wcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAvKklOVEVSTkFMKi8gb25lICkge1xuXHRcdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0XHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9uKCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXHRcdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRcdGZuID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0XHRvcmlnRm4gPSBmbjtcblx0XHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdH07XG5cdFx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHRcdH0pO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgPyBoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOiBoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9KTtcblx0fSxcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9KTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1swXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5cbnZhclxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFx3Ol0rKVtePl0qKVxcLz4vZ2ksXG5cdHJ0YWdOYW1lID0gLzwoW1xcdzpdKykvLFxuXHRyaHRtbCA9IC88fCYjP1xcdys7Lyxcblx0cm5vSW5uZXJodG1sID0gLzwoPzpzY3JpcHR8c3R5bGV8bGluaykvaSxcblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGUgPSAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pLFxuXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2csXG5cblx0Ly8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcblx0d3JhcE1hcCA9IHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDlcblx0XHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHRcdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0XHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHRcdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0XHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0XHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cblx0fTtcblxuLy8gU3VwcG9ydDogSUUgOVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbi8vIFN1cHBvcnQ6IDEueCBjb21wYXRpYmlsaXR5XG4vLyBNYW5pcHVsYXRpbmcgdGFibGVzIHJlcXVpcmVzIGEgdGJvZHlcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgP1xuXG5cdFx0ZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpWzBdIHx8XG5cdFx0XHRlbGVtLmFwcGVuZENoaWxkKCBlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpICkgOlxuXHRcdGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9IChlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikgIT09IG51bGwpICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0dmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyggZWxlbS50eXBlICk7XG5cblx0aWYgKCBtYXRjaCApIHtcblx0XHRlbGVtLnR5cGUgPSBtYXRjaFsgMSBdO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFfcHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLCBcImdsb2JhbEV2YWxcIiwgIXJlZkVsZW1lbnRzIHx8IGRhdGFfcHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFfcHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFfcHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YV9wcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YV91c2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YV91c2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFfdXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cdHZhciByZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lID8gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0Y29udGV4dC5xdWVyeVNlbGVjdG9yQWxsID8gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHRbXTtcblxuXHRyZXR1cm4gdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZSggY29udGV4dCwgdGFnICkgP1xuXHRcdGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApIDpcblx0XHRyZXQ7XG59XG5cbi8vIFN1cHBvcnQ6IElFID49IDlcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA+PSA5XG5cdFx0Ly8gRml4IENsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cDovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRidWlsZEZyYWdtZW50OiBmdW5jdGlvbiggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiApIHtcblx0XHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRcdG5vZGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBRdFdlYktpdFxuXHRcdFx0XHRcdC8vIGpRdWVyeS5tZXJnZSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Ncblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKTtcblxuXHRcdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgZWxlbS5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHRcdFx0Ly8galF1ZXJ5Lm1lcmdlIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0XHQvLyBGaXhlcyAjMTIzNDZcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBXZWJraXQsIElFXG5cdFx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0XHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0XHRpID0gMDtcblx0XHR3aGlsZSAoIChlbGVtID0gbm9kZXNbIGkrKyBdKSApIHtcblxuXHRcdFx0Ly8gIzQwODcgLSBJZiBvcmlnaW4gYW5kIGRlc3RpbmF0aW9uIGVsZW1lbnRzIGFyZSB0aGUgc2FtZSwgYW5kIHRoaXMgaXNcblx0XHRcdC8vIHRoYXQgZWxlbWVudCwgZG8gbm90IGRvIGFueXRoaW5nXG5cdFx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgIT09IC0xICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHRtcFsgaisrIF0pICkge1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmcmFnbWVudDtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSwga2V5LFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IChlbGVtID0gZWxlbXNbIGkgXSkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRrZXkgPSBlbGVtWyBkYXRhX3ByaXYuZXhwYW5kbyBdO1xuXG5cdFx0XHRcdGlmICgga2V5ICYmIChkYXRhID0gZGF0YV9wcml2LmNhY2hlWyBrZXkgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggZGF0YV9wcml2LmNhY2hlWyBrZXkgXSApIHtcblx0XHRcdFx0XHRcdC8vIERpc2NhcmQgYW55IHJlbWFpbmluZyBgcHJpdmF0ZWAgZGF0YVxuXHRcdFx0XHRcdFx0ZGVsZXRlIGRhdGFfcHJpdi5jYWNoZVsga2V5IF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBEaXNjYXJkIGFueSByZW1haW5pbmcgYHVzZXJgIGRhdGFcblx0XHRcdGRlbGV0ZSBkYXRhX3VzZXIuY2FjaGVbIGVsZW1bIGRhdGFfdXNlci5leHBhbmRvIF0gXTtcblx0XHR9XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IsIGtlZXBEYXRhIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0ZWxlbXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCB0aGlzICkgOiB0aGlzLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggIWtlZXBEYXRhICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSApICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKGVsZW0gPSB0aGlzW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2goIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1sgMCBdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0dGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGFyZyA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblxuXHRcdFx0aWYgKCBhcmcgKSB7XG5cdFx0XHRcdGFyZy5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEZvcmNlIHJlbW92YWwgaWYgdGhlcmUgd2FzIG5vIG5ldyBjb250ZW50IChlLmcuLCBmcm9tIGVtcHR5IGFyZ3VtZW50cylcblx0XHRyZXR1cm4gYXJnICYmIChhcmcubGVuZ3RoIHx8IGFyZy5ub2RlVHlwZSkgPyB0aGlzIDogdGhpcy5yZW1vdmUoKTtcblx0fSxcblxuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmUoIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0ZG9tTWFuaXA6IGZ1bmN0aW9uKCBhcmdzLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdFx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZXQgPSB0aGlzLFxuXHRcdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdFx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdFx0dmFyIHNlbGYgPSBzZXQuZXEoIGluZGV4ICk7XG5cdFx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLmRvbU1hbmlwKCBhcmdzLCBjYWxsYmFjayApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCBsICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBqUXVlcnkuYnVpbGRGcmFnbWVudCggYXJncywgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCB0aGlzICk7XG5cdFx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZmlyc3QgKSB7XG5cdFx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW0gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHRcdFx0XHRcdC8vIGpRdWVyeS5tZXJnZSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIHRoaXNbIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHQhZGF0YV9wcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJiBqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICkgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxualF1ZXJ5LmVhY2goe1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBRdFdlYktpdFxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59KTtcblxuXG52YXIgaWZyYW1lLFxuXHRlbGVtZGlzcGxheSA9IHt9O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhY3R1YWwgZGlzcGxheSBvZiBhIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5vZGVOYW1lIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIERvY3VtZW50IG9iamVjdFxuICovXG4vLyBDYWxsZWQgb25seSBmcm9tIHdpdGhpbiBkZWZhdWx0RGlzcGxheVxuZnVuY3Rpb24gYWN0dWFsRGlzcGxheSggbmFtZSwgZG9jICkge1xuXHR2YXIgc3R5bGUsXG5cdFx0ZWxlbSA9IGpRdWVyeSggZG9jLmNyZWF0ZUVsZW1lbnQoIG5hbWUgKSApLmFwcGVuZFRvKCBkb2MuYm9keSApLFxuXG5cdFx0Ly8gZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUgbWlnaHQgYmUgcmVsaWFibHkgdXNlZCBvbmx5IG9uIGF0dGFjaGVkIGVsZW1lbnRcblx0XHRkaXNwbGF5ID0gd2luZG93LmdldERlZmF1bHRDb21wdXRlZFN0eWxlICYmICggc3R5bGUgPSB3aW5kb3cuZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUoIGVsZW1bIDAgXSApICkgP1xuXG5cdFx0XHQvLyBVc2Ugb2YgdGhpcyBtZXRob2QgaXMgYSB0ZW1wb3JhcnkgZml4IChtb3JlIGxpa2Ugb3B0bWl6YXRpb24pIHVudGlsIHNvbWV0aGluZyBiZXR0ZXIgY29tZXMgYWxvbmcsXG5cdFx0XHQvLyBzaW5jZSBpdCB3YXMgcmVtb3ZlZCBmcm9tIHNwZWNpZmljYXRpb24gYW5kIHN1cHBvcnRlZCBvbmx5IGluIEZGXG5cdFx0XHRzdHlsZS5kaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbVsgMCBdLCBcImRpc3BsYXlcIiApO1xuXG5cdC8vIFdlIGRvbid0IGhhdmUgYW55IGRhdGEgc3RvcmVkIG9uIHRoZSBlbGVtZW50LFxuXHQvLyBzbyB1c2UgXCJkZXRhY2hcIiBtZXRob2QgYXMgZmFzdCB3YXkgdG8gZ2V0IHJpZCBvZiB0aGUgZWxlbWVudFxuXHRlbGVtLmRldGFjaCgpO1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG4vKipcbiAqIFRyeSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgZGlzcGxheSB2YWx1ZSBvZiBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkoIG5vZGVOYW1lICkge1xuXHR2YXIgZG9jID0gZG9jdW1lbnQsXG5cdFx0ZGlzcGxheSA9IGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdO1xuXG5cdGlmICggIWRpc3BsYXkgKSB7XG5cdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblxuXHRcdC8vIElmIHRoZSBzaW1wbGUgd2F5IGZhaWxzLCByZWFkIGZyb20gaW5zaWRlIGFuIGlmcmFtZVxuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgfHwgIWRpc3BsYXkgKSB7XG5cblx0XHRcdC8vIFVzZSB0aGUgYWxyZWFkeS1jcmVhdGVkIGlmcmFtZSBpZiBwb3NzaWJsZVxuXHRcdFx0aWZyYW1lID0gKGlmcmFtZSB8fCBqUXVlcnkoIFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlwiICkpLmFwcGVuZFRvKCBkb2MuZG9jdW1lbnRFbGVtZW50ICk7XG5cblx0XHRcdC8vIEFsd2F5cyB3cml0ZSBhIG5ldyBIVE1MIHNrZWxldG9uIHNvIFdlYmtpdCBhbmQgRmlyZWZveCBkb24ndCBjaG9rZSBvbiByZXVzZVxuXHRcdFx0ZG9jID0gaWZyYW1lWyAwIF0uY29udGVudERvY3VtZW50O1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdFx0ZG9jLndyaXRlKCk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblxuXHRcdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblx0XHRcdGlmcmFtZS5kZXRhY2goKTtcblx0XHR9XG5cblx0XHQvLyBTdG9yZSB0aGUgY29ycmVjdCBkZWZhdWx0IGRpc3BsYXlcblx0XHRlbGVtZGlzcGxheVsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cdH1cblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cbnZhciBybWFyZ2luID0gKC9ebWFyZ2luLyk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSwgbnVsbCApO1xuXHR9O1xuXG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRTlcblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBvbmx5IG5lZWRlZCBmb3IgLmNzcygnZmlsdGVyJykgaW4gSUU5LCBzZWUgIzEyNTM3XG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cdH1cblxuXHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBpT1MgPCA2XG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIGlPUyA8IDYgKGF0IGxlYXN0KSByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIGEgbGFyZ2VyIHNldCBvZiB2YWx1ZXMsIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHNcblx0XHQvLyB0aGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6IGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cdFx0Ly8gU3VwcG9ydDogSUVcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksXG5cdFx0XHRcdC8vIHJlbW92ZSBpdC5cblx0XHRcdFx0Ly8gU2luY2UgdGhlcmUgYXJlIG5vIG90aGVyIGhvb2tzIGZvciBtYXJnaW5SaWdodCwgcmVtb3ZlIHRoZSB3aG9sZSBvYmplY3QuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblxuXHRcdFx0cmV0dXJuICh0aGlzLmdldCA9IGhvb2tGbikuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCxcblx0XHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7d2lkdGg6MDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7bWFyZ2luLXRvcDoxcHg7XCIgK1xuXHRcdFwicG9zaXRpb246YWJzb2x1dGVcIjtcblx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVBpeGVsUG9zaXRpb25BbmRCb3hTaXppbmdSZWxpYWJsZSgpIHtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xuXHRcdFx0Ly8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nXG5cdFx0XHRcIi13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O1wiICtcblx0XHRcdFwiYm94LXNpemluZzpib3JkZXItYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luLXRvcDoxJTt0b3A6MSU7XCIgK1xuXHRcdFx0XCJib3JkZXI6MXB4O3BhZGRpbmc6MXB4O3dpZHRoOjRweDtwb3NpdGlvbjphYnNvbHV0ZVwiO1xuXHRcdGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiwgbnVsbCApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IGRpdlN0eWxlLndpZHRoID09PSBcIjRweFwiO1xuXG5cdFx0ZG9jRWxlbS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBub2RlLmpzIGpzZG9tXG5cdC8vIERvbid0IGFzc3VtZSB0aGF0IGdldENvbXB1dGVkU3R5bGUgaXMgYSBwcm9wZXJ0eSBvZiB0aGUgZ2xvYmFsIG9iamVjdFxuXHRpZiAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBUaGlzIHRlc3QgaXMgZXhlY3V0ZWQgb25seSBvbmNlIGJ1dCB3ZSBzdGlsbCBkbyBtZW1vaXppbmdcblx0XHRcdFx0Ly8gc2luY2Ugd2UgY2FuIHVzZSB0aGUgYm94U2l6aW5nUmVsaWFibGUgcHJlLWNvbXB1dGluZy5cblx0XHRcdFx0Ly8gTm8gbmVlZCB0byBjaGVjayBpZiB0aGUgdGVzdCB3YXMgYWxyZWFkeSBwZXJmb3JtZWQsIHRob3VnaC5cblx0XHRcdFx0Y29tcHV0ZVBpeGVsUG9zaXRpb25BbmRCb3hTaXppbmdSZWxpYWJsZSgpO1xuXHRcdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHRcdH0sXG5cdFx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdFx0fSxcblx0XHRcdHJlbGlhYmxlTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBDaGVjayBpZiBkaXYgd2l0aCBleHBsaWNpdCB3aWR0aCBhbmQgbm8gbWFyZ2luLXJpZ2h0IGluY29ycmVjdGx5XG5cdFx0XHRcdC8vIGdldHMgY29tcHV0ZWQgbWFyZ2luLXJpZ2h0IGJhc2VkIG9uIHdpZHRoIG9mIGNvbnRhaW5lci4gKCMzMzMzKVxuXHRcdFx0XHQvLyBXZWJLaXQgQnVnIDEzMzQzIC0gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHdyb25nIHZhbHVlIGZvciBtYXJnaW4tcmlnaHRcblx0XHRcdFx0Ly8gVGhpcyBzdXBwb3J0IGZ1bmN0aW9uIGlzIG9ubHkgZXhlY3V0ZWQgb25jZSBzbyBubyBtZW1vaXppbmcgaXMgbmVlZGVkLlxuXHRcdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHRcdG1hcmdpbkRpdiA9IGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gUmVzZXQgQ1NTOiBib3gtc2l6aW5nOyBkaXNwbGF5OyBtYXJnaW47IGJvcmRlcjsgcGFkZGluZ1xuXHRcdFx0XHRtYXJnaW5EaXYuc3R5bGUuY3NzVGV4dCA9IGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xuXHRcdFx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy1tb3otYm94LXNpemluZzpjb250ZW50LWJveDtcIiArXG5cdFx0XHRcdFx0XCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowXCI7XG5cdFx0XHRcdG1hcmdpbkRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IG1hcmdpbkRpdi5zdHlsZS53aWR0aCA9IFwiMFwiO1xuXHRcdFx0XHRkaXYuc3R5bGUud2lkdGggPSBcIjFweFwiO1xuXHRcdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdFx0XHRyZXQgPSAhcGFyc2VGbG9hdCggd2luZG93LmdldENvbXB1dGVkU3R5bGUoIG1hcmdpbkRpdiwgbnVsbCApLm1hcmdpblJpZ2h0ICk7XG5cblx0XHRcdFx0ZG9jRWxlbS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSkoKTtcblxuXG4vLyBBIG1ldGhvZCBmb3IgcXVpY2tseSBzd2FwcGluZyBpbi9vdXQgQ1NTIHByb3BlcnRpZXMgdG8gZ2V0IGNvcnJlY3QgY2FsY3VsYXRpb25zLlxualF1ZXJ5LnN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG52YXJcblx0Ly8gc3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZSBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gc2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cm51bXNwbGl0ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSguKikkXCIsIFwiaVwiICksXG5cdHJyZWxOdW0gPSBuZXcgUmVnRXhwKCBcIl4oWystXSk9KFwiICsgcG51bSArIFwiKVwiLCBcImlcIiApLFxuXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk9cIiwgXCJNb3pcIiwgXCJtc1wiIF07XG5cbi8vIHJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBzdHlsZSwgbmFtZSApIHtcblxuXHQvLyBzaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gc3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBjaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSxcblx0XHRvcmlnTmFtZSA9IG5hbWUsXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIHN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG9yaWdOYW1lO1xufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXHR2YXIgbWF0Y2hlcyA9IHJudW1zcGxpdC5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMSBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMiBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzICkge1xuXHR2YXIgaSA9IGV4dHJhID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgP1xuXHRcdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRcdDQgOlxuXHRcdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0XHRuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcblxuXHRcdHZhbCA9IDA7XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXHRcdC8vIGJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdGlmICggaXNCb3JkZXJCb3ggKSB7XG5cdFx0XHQvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gYXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gYXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cdHZhciB2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZSxcblx0XHR2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIHNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuXHQvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcblx0Ly8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG5cdGlmICggdmFsIDw9IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0Ly8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0XHR2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KHZhbCkgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdC8vIHdlIG5lZWQgdGhlIGNoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHRcdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXHR9XG5cblx0Ly8gdXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlc1xuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSwgaGlkZGVuLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFfcHJpdi5nZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiICk7XG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cdFx0XHQvLyBSZXNldCB0aGUgaW5saW5lIGRpc3BsYXkgb2YgdGhpcyBlbGVtZW50IHRvIGxlYXJuIGlmIGl0IGlzXG5cdFx0XHQvLyBiZWluZyBoaWRkZW4gYnkgY2FzY2FkZWQgcnVsZXMgb3Igbm90XG5cdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gJiYgZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBlbGVtZW50cyB3aGljaCBoYXZlIGJlZW4gb3ZlcnJpZGRlbiB3aXRoIGRpc3BsYXk6IG5vbmVcblx0XHRcdC8vIGluIGEgc3R5bGVzaGVldCB0byB3aGF0ZXZlciB0aGUgZGVmYXVsdCBicm93c2VyIHN0eWxlIGlzXG5cdFx0XHQvLyBmb3Igc3VjaCBhbiBlbGVtZW50XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbiggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCBcIm9sZGRpc3BsYXlcIiwgZGVmYXVsdERpc3BsYXkoZWxlbS5ub2RlTmFtZSkgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aGlkZGVuID0gaXNIaWRkZW4oIGVsZW0gKTtcblxuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiB8fCAhaGlkZGVuICkge1xuXHRcdFx0XHRkYXRhX3ByaXYuc2V0KCBlbGVtLCBcIm9sZGRpc3BsYXlcIiwgaGlkZGVuID8gZGlzcGxheSA6IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgbW9zdCBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxuXHQvLyB0byBhdm9pZCB0aGUgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKCAhc2hvdyB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IHNob3cgPyB2YWx1ZXNbIGluZGV4IF0gfHwgXCJcIiA6IFwibm9uZVwiO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHtcblx0XHQvLyBub3JtYWxpemUgZmxvYXQgY3NzIHByb3BlcnR5XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fCAoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBzdHlsZSwgb3JpZ05hbWUgKSApO1xuXG5cdFx0Ly8gZ2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvblxuXHRcdC8vIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIGNvbnZlcnQgcmVsYXRpdmUgbnVtYmVyIHN0cmluZ3MgKCs9IG9yIC09KSB0byByZWxhdGl2ZSBudW1iZXJzLiAjNzM0NVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmIChyZXQgPSBycmVsTnVtLmV4ZWMoIHZhbHVlICkpICkge1xuXHRcdFx0XHR2YWx1ZSA9ICggcmV0WzFdICsgMSApICogcmV0WzJdICsgcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApICk7XG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0LiBTZWU6ICM3MTE2XG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCAncHgnIHRvIHRoZSAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdICkge1xuXHRcdFx0XHR2YWx1ZSArPSBcInB4XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZpeGVzICM4OTA4LCBpdCBjYW4gYmUgZG9uZSBtb3JlIGNvcnJlY3RseSBieSBzcGVjaWZ5aW5nIHNldHRlcnMgaW4gY3NzSG9va3MsXG5cdFx0XHQvLyBidXQgaXQgd291bGQgbWVhbiB0byBkZWZpbmUgZWlnaHQgKGZvciBldmVyeSBwcm9ibGVtYXRpYyBwcm9wZXJ0eSkgaWRlbnRpY2FsIGZ1bmN0aW9uc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCAodmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8ICggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIGVsZW0uc3R5bGUsIG9yaWdOYW1lICkgKTtcblxuXHRcdC8vIGdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb25cblx0XHQvLyBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vY29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4sIGNvbnZlcnRpbmcgdG8gbnVtYmVyIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGpRdWVyeS5pc051bWVyaWMoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaChbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Ly8gY2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGhvd2V2ZXIsIGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXQgZnJvbSB0aGlzXG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmIGVsZW0ub2Zmc2V0V2lkdGggPT09IDAgP1xuXHRcdFx0XHRcdGpRdWVyeS5zd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgc3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBleHRyYSA/XG5cdFx0XHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpIDogMFxuXHRcdFx0KTtcblx0XHR9XG5cdH07XG59KTtcblxuLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5SaWdodCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxuXHRcdFx0Ly8gV29yayBhcm91bmQgYnkgdGVtcG9yYXJpbHkgc2V0dGluZyBlbGVtZW50IGRpc3BsYXkgdG8gaW5saW5lLWJsb2NrXG5cdFx0XHRyZXR1cm4galF1ZXJ5LnN3YXAoIGVsZW0sIHsgXCJkaXNwbGF5XCI6IFwiaW5saW5lLWJsb2NrXCIgfSxcblx0XHRcdFx0Y3VyQ1NTLCBbIGVsZW0sIFwibWFyZ2luUmlnaHRcIiBdICk7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCh7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBhc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdChcIiBcIikgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW4oIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgXCJzd2luZ1wiO1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJlxuXHRcdFx0XHQoIXR3ZWVuLmVsZW0uc3R5bGUgfHwgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwpICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHNcblx0XHRcdC8vIHNvLCBzaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdC5cblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMgaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHQvLyB1c2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdCAtIHVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZSAtIHVzZSAuc3R5bGUgaWYgaXRzXG5cdFx0XHQvLyBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZVxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5zdHlsZSAmJiAoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fCBqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFOVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9XG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBDb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgdGltZXJJZCxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJmeG51bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICksXG5cdHJydW4gPSAvcXVldWVIb29rcyQvLFxuXHRhbmltYXRpb25QcmVmaWx0ZXJzID0gWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cdHR3ZWVuZXJzID0ge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICksXG5cdFx0XHRcdHRhcmdldCA9IHR3ZWVuLmN1cigpLFxuXHRcdFx0XHRwYXJ0cyA9IHJmeG51bS5leGVjKCB2YWx1ZSApLFxuXHRcdFx0XHR1bml0ID0gcGFydHMgJiYgcGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdFx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdFx0XHRzdGFydCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiArdGFyZ2V0ICkgJiZcblx0XHRcdFx0XHRyZnhudW0uZXhlYyggalF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgcHJvcCApICksXG5cdFx0XHRcdHNjYWxlID0gMSxcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDIwO1xuXG5cdFx0XHRpZiAoIHN0YXJ0ICYmIHN0YXJ0WyAzIF0gIT09IHVuaXQgKSB7XG5cdFx0XHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHRcdFx0dW5pdCA9IHVuaXQgfHwgc3RhcnRbIDMgXTtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0XHRcdHBhcnRzID0gcGFydHMgfHwgW107XG5cblx0XHRcdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRcdFx0c3RhcnQgPSArdGFyZ2V0IHx8IDE7XG5cblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdC8vIElmIHByZXZpb3VzIGl0ZXJhdGlvbiB6ZXJvZWQgb3V0LCBkb3VibGUgdW50aWwgd2UgZ2V0ICpzb21ldGhpbmcqXG5cdFx0XHRcdFx0Ly8gVXNlIGEgc3RyaW5nIGZvciBkb3VibGluZyBmYWN0b3Igc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHNlZSBzY2FsZSBhcyB1bmNoYW5nZWQgYmVsb3dcblx0XHRcdFx0XHRzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuXHRcdFx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdFx0XHRzdGFydCA9IHN0YXJ0IC8gc2NhbGU7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCBwcm9wLCBzdGFydCArIHVuaXQgKTtcblxuXHRcdFx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdFx0XHQvLyBBbmQgYnJlYWtpbmcgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaFxuXHRcdFx0XHR9IHdoaWxlICggc2NhbGUgIT09IChzY2FsZSA9IHR3ZWVuLmN1cigpIC8gdGFyZ2V0KSAmJiBzY2FsZSAhPT0gMSAmJiAtLW1heEl0ZXJhdGlvbnMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIHR3ZWVuIHByb3BlcnRpZXNcblx0XHRcdGlmICggcGFydHMgKSB7XG5cdFx0XHRcdHN0YXJ0ID0gdHdlZW4uc3RhcnQgPSArc3RhcnQgfHwgK3RhcmdldCB8fCAwO1xuXHRcdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdFx0Ly8gSWYgYSArPS8tPSB0b2tlbiB3YXMgcHJvdmlkZWQsIHdlJ3JlIGRvaW5nIGEgcmVsYXRpdmUgYW5pbWF0aW9uXG5cdFx0XHRcdHR3ZWVuLmVuZCA9IHBhcnRzWyAxIF0gP1xuXHRcdFx0XHRcdHN0YXJ0ICsgKCBwYXJ0c1sgMSBdICsgMSApICogcGFydHNbIDIgXSA6XG5cdFx0XHRcdFx0K3BhcnRzWyAyIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fTtcblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0pO1xuXHRyZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBpZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIGlmIHdlIGRvbid0IGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQgOyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggdHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggdHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAodHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSkgKSB7XG5cblx0XHRcdC8vIHdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHQvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCB0d2VlbiwgaG9va3MsIG9sZGZpcmUsIGRpc3BsYXksIGNoZWNrRGlzcGxheSxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW4oIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFfcHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBoYW5kbGUgcXVldWU6IGZhbHNlIHByb21pc2VzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdC8vIGRvaW5nIHRoaXMgbWFrZXMgc3VyZSB0aGF0IHRoZSBjb21wbGV0ZSBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkXG5cdFx0XHQvLyBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gaGVpZ2h0L3dpZHRoIG92ZXJmbG93IHBhc3Ncblx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCJoZWlnaHRcIiBpbiBwcm9wcyB8fCBcIndpZHRoXCIgaW4gcHJvcHMgKSApIHtcblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBub3RoaW5nIHNuZWFrcyBvdXRcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFOS0xMCBkbyBub3Rcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cblx0XHQvLyBUZXN0IGRlZmF1bHQgZGlzcGxheSBpZiBkaXNwbGF5IGlzIGN1cnJlbnRseSBcIm5vbmVcIlxuXHRcdGNoZWNrRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID9cblx0XHRcdGRhdGFfcHJpdi5nZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiICkgfHwgZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA6IGRpc3BsYXk7XG5cblx0XHRpZiAoIGNoZWNrRGlzcGxheSA9PT0gXCJpbmxpbmVcIiAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBzaG93L2hpZGUgcGFzc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLmV4ZWMoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGRhdGFTaG93IGxlZnQgb3ZlciBmcm9tIGEgc3RvcHBlZCBoaWRlIG9yIHNob3cgYW5kIHdlIGFyZSBnb2luZyB0byBwcm9jZWVkIHdpdGggc2hvdywgd2Ugc2hvdWxkIHByZXRlbmQgdG8gYmUgaGlkZGVuXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXG5cdFx0Ly8gQW55IG5vbi1meCB2YWx1ZSBzdG9wcyB1cyBmcm9tIHJlc3RvcmluZyB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXNwbGF5ID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhU2hvdyA9IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHt9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gc3RvcmUgc3RhdGUgaWYgaXRzIHRvZ2dsZSAtIGVuYWJsZXMgLnN0b3AoKS50b2dnbGUoKSB0byBcInJldmVyc2VcIlxuXHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHR9XG5cdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRqUXVlcnkoIGVsZW0gKS5zaG93KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW0uZG9uZShmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5KCBlbGVtICkuaGlkZSgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGFuaW0uZG9uZShmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwcm9wO1xuXG5cdFx0XHRkYXRhX3ByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0dHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblxuXHRcdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdFx0dHdlZW4uZW5kID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdFx0dHdlZW4uc3RhcnQgPSBwcm9wID09PSBcIndpZHRoXCIgfHwgcHJvcCA9PT0gXCJoZWlnaHRcIiA/IDEgOiAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdC8vIElmIHRoaXMgaXMgYSBub29wIGxpa2UgLmhpZGUoKS5oaWRlKCksIHJlc3RvcmUgYW4gb3ZlcndyaXR0ZW4gZGlzcGxheSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCAoZGlzcGxheSA9PT0gXCJub25lXCIgPyBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheSkgPT09IFwiaW5saW5lXCIgKSB7XG5cdFx0c3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIG5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b250IG92ZXJ3cml0ZSBrZXlzIGFscmVhZHkgcHJlc2VudC5cblx0XHRcdC8vIGFsc28gLSByZXVzaW5nICdpbmRleCcgZnJvbSBhYm92ZSBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGFuaW1hdGlvblByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdC8vIGRvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9KSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblx0XHRcdFx0Ly8gYXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIDEgLSAoIDAuNSB8fCAwICkgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0pO1xuXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2Uoe1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwgeyBzcGVjaWFsRWFzaW5nOiB7fSB9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblx0XHRcdFx0XHQvLyBpZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lXG5cdFx0XHRcdC8vIG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9KSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IGFuaW1hdGlvblByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9KVxuXHQpO1xuXG5cdC8vIGF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5zcGxpdChcIiBcIik7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdHR3ZWVuZXJzWyBwcm9wIF0gPSB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0dHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRhbmltYXRpb25QcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW1hdGlvblByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/IG9wdC5kdXJhdGlvbiA6XG5cdFx0b3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgPyBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXSA6IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cblx0Ly8gbm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gc2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbiApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gYW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSh7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFfcHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFfcHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmICh0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlKSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gc3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZFxuXHRcdFx0Ly8gdGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaCB3aWxsIGRlcXVldWVcblx0XHRcdC8vIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFfcHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gZW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBlbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGxvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaChbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0pO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCh7XG5cdHNsaWRlRG93bjogZ2VuRngoXCJzaG93XCIpLFxuXHRzbGlkZVVwOiBnZW5GeChcImhpZGVcIiksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeChcInRvZ2dsZVwiKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59KTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0aWYgKCB0aW1lcigpICkge1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xuXG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCAhdGltZXJJZCApIHtcblx0XHR0aW1lcklkID0gc2V0SW50ZXJ2YWwoIGpRdWVyeS5meC50aWNrLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0Y2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXHR0aW1lcklkID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0pO1xufTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogaU9TIDUuMSwgQW5kcm9pZCA0LngsIEFuZHJvaWQgMi4zXG5cdC8vIENoZWNrIHRoZSBkZWZhdWx0IGNoZWNrYm94L3JhZGlvIHZhbHVlIChcIlwiIG9uIG9sZCBXZWJLaXQ7IFwib25cIiBlbHNld2hlcmUpXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIE11c3QgYWNjZXNzIHRoZSBwYXJlbnQgdG8gbWFrZSBhbiBvcHRpb24gc2VsZWN0IHByb3Blcmx5XG5cdC8vIFN1cHBvcnQ6IElFOSwgSUUxMFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBvcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZW4ndCBtYXJrZWQgYXMgZGlzYWJsZWRcblx0Ly8gKFdlYktpdCBtYXJrcyB0aGVtIGFzIGRpc2FibGVkKVxuXHRzZWxlY3QuZGlzYWJsZWQgPSB0cnVlO1xuXHRzdXBwb3J0Lm9wdERpc2FibGVkID0gIW9wdC5kaXNhYmxlZDtcblxuXHQvLyBDaGVjayBpZiBhbiBpbnB1dCBtYWludGFpbnMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0Ly8gU3VwcG9ydDogSUU5LCBJRTEwXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0pKCk7XG5cblxudmFyIG5vZGVIb29rLCBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIGRvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IHN0cnVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgYXR0cmlidXRlcyBhcmUgbG93ZXJjYXNlXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IG5vZGVIb29rICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkpICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgP1xuXHRcdFx0XHR1bmRlZmluZWQgOlxuXHRcdFx0XHRyZXQ7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSwgcHJvcE5hbWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoIChuYW1lID0gYXR0ck5hbWVzW2krK10pICkge1xuXHRcdFx0XHRwcm9wTmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblxuXHRcdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgZ2V0IHNwZWNpYWwgdHJlYXRtZW50ICgjMTA4NzApXG5cdFx0XHRcdGlmICggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdFx0Ly8gU2V0IGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdG8gZmFsc2Vcblx0XHRcdFx0XHRlbGVtWyBwcm9wTmFtZSBdID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdC8vIFNldHRpbmcgdGhlIHR5cGUgb24gYSByYWRpbyBidXR0b24gYWZ0ZXIgdGhlIHZhbHVlIHJlc2V0cyB0aGUgdmFsdWUgaW4gSUU2LTlcblx0XHRcdFx0XHQvLyBSZXNldCB2YWx1ZSB0byBkZWZhdWx0IGluIGNhc2UgdHlwZSBpcyBzZXQgYWZ0ZXIgdmFsdWUgZHVyaW5nIGNyZWF0aW9uXG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH0sXG5cblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLCBub3R4bWwsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBkb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRub3R4bWwgPSBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICk7XG5cblx0XHRpZiAoIG5vdHhtbCApIHtcblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApKSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cmV0IDpcblx0XHRcdFx0KCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgP1xuXHRcdFx0XHRyZXQgOlxuXHRcdFx0XHRlbGVtWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5oYXNBdHRyaWJ1dGUoIFwidGFiaW5kZXhcIiApIHx8IHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8IGVsZW0uaHJlZiA/XG5cdFx0XHRcdFx0ZWxlbS50YWJJbmRleCA6XG5cdFx0XHRcdFx0LTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gU3VwcG9ydDogSUU5K1xuLy8gU2VsZWN0ZWRuZXNzIGZvciBhbiBvcHRpb24gaW4gYW4gb3B0Z3JvdXAgY2FuIGJlIGluYWNjdXJhdGVcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0pO1xuXG5cblxuXG52YXIgcmNsYXNzID0gL1tcXHRcXHJcXG5cXGZdL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0cHJvY2VlZCA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lICkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICggcHJvY2VlZCApIHtcblx0XHRcdC8vIFRoZSBkaXNqdW5jdGlvbiBoZXJlIGlzIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgcmVtb3ZlQ2xhc3MpXG5cdFx0XHRjbGFzc2VzID0gKCB2YWx1ZSB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIGVsZW0uY2xhc3NOYW1lID9cblx0XHRcdFx0XHQoIFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKSA6XG5cdFx0XHRcdFx0XCIgXCJcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChjbGF6eiA9IGNsYXNzZXNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIG9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGVsZW0uY2xhc3NOYW1lICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5jbGFzc05hbWUgPSBmaW5hbFZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRwcm9jZWVkID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCB0aGlzLmNsYXNzTmFtZSApICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0aWYgKCBwcm9jZWVkICkge1xuXHRcdFx0Y2xhc3NlcyA9ICggdmFsdWUgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF07XG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBlbGVtLmNsYXNzTmFtZSA/XG5cdFx0XHRcdFx0KCBcIiBcIiArIGVsZW0uY2xhc3NOYW1lICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICkgOlxuXHRcdFx0XHRcdFwiXCJcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChjbGF6eiA9IGNsYXNzZXNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+PSAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIG9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHZhbHVlID8galF1ZXJ5LnRyaW0oIGN1ciApIDogXCJcIjtcblx0XHRcdFx0XHRpZiAoIGVsZW0uY2xhc3NOYW1lICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5jbGFzc05hbWUgPSBmaW5hbFZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoIHZhbHVlLmNhbGwodGhpcywgaSwgdGhpcy5jbGFzc05hbWUsIHN0YXRlVmFsKSwgc3RhdGVWYWwgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdC8vIHRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdHZhciBjbGFzc05hbWUsXG5cdFx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdFx0d2hpbGUgKCAoY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0pICkge1xuXHRcdFx0XHRcdC8vIGNoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBzdHJ1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5jbGFzc05hbWUgKSB7XG5cdFx0XHRcdFx0Ly8gc3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFfcHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCB0aGlzLmNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgXCJmYWxzZVwiLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID8gXCJcIiA6IGRhdGFfcHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIjtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRpZiAoIHRoaXNbaV0ubm9kZVR5cGUgPT09IDEgJiYgKFwiIFwiICsgdGhpc1tpXS5jbGFzc05hbWUgKyBcIiBcIikucmVwbGFjZShyY2xhc3MsIFwiIFwiKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+PSAwICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbMF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0cmV0dXJuIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdC8vIGhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXQucmVwbGFjZShycmV0dXJuLCBcIlwiKSA6XG5cdFx0XHRcdFx0Ly8gaGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdFx0cmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKFwic2V0XCIgaW4gaG9va3MpIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTEwLTExK1xuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHRqUXVlcnkudHJpbSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIgfHwgaW5kZXggPCAwLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aCxcblx0XHRcdFx0XHRpID0gaW5kZXggPCAwID9cblx0XHRcdFx0XHRcdG1heCA6XG5cdFx0XHRcdFx0XHRvbmUgPyBpbmRleCA6IDA7XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBJRTYtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQoIHN1cHBvcnQub3B0RGlzYWJsZWQgPyAhb3B0aW9uLmRpc2FibGVkIDogb3B0aW9uLmdldEF0dHJpYnV0ZSggXCJkaXNhYmxlZFwiICkgPT09IG51bGwgKSAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fCAhalF1ZXJ5Lm5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggKG9wdGlvbi5zZWxlY3RlZCA9IGpRdWVyeS5pbkFycmF5KCBvcHRpb24udmFsdWUsIHZhbHVlcyApID49IDApICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBmb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KGVsZW0pLnZhbCgpLCB2YWx1ZSApID49IDAgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIFN1cHBvcnQ6IFdlYmtpdFxuXHRcdFx0Ly8gXCJcIiBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIFwib25cIiBpZiBhIHZhbHVlIGlzbid0IHNwZWNpZmllZFxuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxualF1ZXJ5LmVhY2goIChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVwiKS5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH0sXG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyB0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDogdGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0pO1xuXG5cbnZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICgvXFw/Lyk7XG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuLy8gV29ya2Fyb3VuZCBmYWlsdXJlIHRvIHN0cmluZy1jYXN0IG51bGwgaW5wdXRcbmpRdWVyeS5wYXJzZUpTT04gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKyBcIlwiICk7XG59O1xuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sLCB0bXA7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTlcblx0dHJ5IHtcblx0XHR0bXAgPSBuZXcgRE9NUGFyc2VyKCk7XG5cdFx0eG1sID0gdG1wLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHQvLyBEb2N1bWVudCBsb2NhdGlvblxuXHRhamF4TG9jUGFydHMsXG5cdGFqYXhMb2NhdGlvbixcblxuXHRyaGFzaCA9IC8jLiokLyxcblx0cnRzID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXHRydXJsID0gL14oW1xcdy4rLV0rOikoPzpcXC9cXC8oPzpbXlxcLz8jXSpAfCkoW15cXC8/IzpdKikoPzo6KFxcZCspfCl8KS8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdChcIipcIik7XG5cbi8vICM4MTM4LCBJRSBtYXkgdGhyb3cgYW4gZXhjZXB0aW9uIHdoZW4gYWNjZXNzaW5nXG4vLyBhIGZpZWxkIGZyb20gd2luZG93LmxvY2F0aW9uIGlmIGRvY3VtZW50LmRvbWFpbiBoYXMgYmVlbiBzZXRcbnRyeSB7XG5cdGFqYXhMb2NhdGlvbiA9IGxvY2F0aW9uLmhyZWY7XG59IGNhdGNoKCBlICkge1xuXHQvLyBVc2UgdGhlIGhyZWYgYXR0cmlidXRlIG9mIGFuIEEgZWxlbWVudFxuXHQvLyBzaW5jZSBJRSB3aWxsIG1vZGlmeSBpdCBnaXZlbiBkb2N1bWVudC5sb2NhdGlvblxuXHRhamF4TG9jYXRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRhamF4TG9jYXRpb24uaHJlZiA9IFwiXCI7XG5cdGFqYXhMb2NhdGlvbiA9IGFqYXhMb2NhdGlvbi5ocmVmO1xufVxuXG4vLyBTZWdtZW50IGxvY2F0aW9uIGludG8gcGFydHNcbmFqYXhMb2NQYXJ0cyA9IHJ1cmwuZXhlYyggYWpheExvY2F0aW9uLnRvTG93ZXJDYXNlKCkgKSB8fCBbXTtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKGRhdGFUeXBlID0gZGF0YVR5cGVzW2krK10pICkge1xuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWzBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmICFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKGRlZXAgPSB7fSkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1swXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHNbIFwidGhyb3dzXCIgXSApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7IHN0YXRlOiBcInBhcnNlcmVycm9yXCIsIGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudCB9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogYWpheExvY2F0aW9uLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggYWpheExvY1BhcnRzWyAxIF0gKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC94bWwvLFxuXHRcdFx0aHRtbDogL2h0bWwvLFxuXHRcdFx0anNvbjogL2pzb24vXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IGpRdWVyeS5wYXJzZUpTT04sXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblx0XHRcdC8vIENyb3NzLWRvbWFpbiBkZXRlY3Rpb24gdmFyc1xuXHRcdFx0cGFydHMsXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmICggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblx0XHRcdC8vIFRoZSBqcVhIUiBzdGF0ZVxuXHRcdFx0c3RhdGUgPSAwLFxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2sgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKS5jb21wbGV0ZSA9IGNvbXBsZXRlRGVmZXJyZWQuYWRkO1xuXHRcdGpxWEhSLnN1Y2Nlc3MgPSBqcVhIUi5kb25lO1xuXHRcdGpxWEhSLmVycm9yID0ganFYSFIuZmFpbDtcblxuXHRcdC8vIFJlbW92ZSBoYXNoIGNoYXJhY3RlciAoIzc1MzE6IGFuZCBzdHJpbmcgcHJvbW90aW9uKVxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGFqYXhMb2NhdGlvbiApICsgXCJcIiApLnJlcGxhY2UoIHJoYXNoLCBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGFqYXhMb2NQYXJ0c1sgMSBdICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0galF1ZXJ5LnRyaW0oIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB3ZSBoYXZlIGEgcHJvdG9jb2w6aG9zdDpwb3J0IG1pc21hdGNoXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHRwYXJ0cyA9IHJ1cmwuZXhlYyggcy51cmwudG9Mb3dlckNhc2UoKSApO1xuXHRcdFx0cy5jcm9zc0RvbWFpbiA9ICEhKCBwYXJ0cyAmJlxuXHRcdFx0XHQoIHBhcnRzWyAxIF0gIT09IGFqYXhMb2NQYXJ0c1sgMSBdIHx8IHBhcnRzWyAyIF0gIT09IGFqYXhMb2NQYXJ0c1sgMiBdIHx8XG5cdFx0XHRcdFx0KCBwYXJ0c1sgMyBdIHx8ICggcGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gXCI4MFwiIDogXCI0NDNcIiApICkgIT09XG5cdFx0XHRcdFx0XHQoIGFqYXhMb2NQYXJ0c1sgMyBdIHx8ICggYWpheExvY1BhcnRzWyAxIF0gPT09IFwiaHR0cDpcIiA/IFwiODBcIiA6IFwiNDQzXCIgKSApIClcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHRmaXJlR2xvYmFscyA9IHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RhcnRcIik7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybDtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSAoIHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGEgKTtcblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRzLnVybCA9IHJ0cy50ZXN0KCBjYWNoZVVSTCApID9cblxuXHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSAnXycgcGFyYW1ldGVyLCBzZXQgaXRzIHZhbHVlXG5cdFx0XHRcdFx0Y2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIG5vbmNlKysgKSA6XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgYWRkIG9uZSB0byB0aGUgZW5kXG5cdFx0XHRcdFx0Y2FjaGVVUkwgKyAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgbm9uY2UrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdICsgKCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiYgKCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBzdGF0ZSA9PT0gMiApICkge1xuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBhYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcblx0XHRcdGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydChcInRpbWVvdXRcIik7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZSA9IDE7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBleGNlcHRpb24gYXMgZXJyb3IgaWYgbm90IGRvbmVcblx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdFx0Ly8gU2ltcGx5IHJldGhyb3cgb3RoZXJ3aXNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIENhbGxlZCBvbmNlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXRlIGlzIFwiZG9uZVwiIG5vd1xuXHRcdFx0c3RhdGUgPSAyO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiZXRhZ1wiKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdlIGV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0XG5cdFx0XHRcdC8vIHRoZW4gbm9ybWFsaXplIHN0YXR1c1RleHQgYW5kIHN0YXR1cyBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdG9wXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59KTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXHRcdC8vIHNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkuYWpheCh7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSk7XG5cdH07XG59KTtcblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbIFwiYWpheFN0YXJ0XCIsIFwiYWpheFN0b3BcIiwgXCJhamF4Q29tcGxldGVcIiwgXCJhamF4RXJyb3JcIiwgXCJhamF4U3VjY2Vzc1wiLCBcImFqYXhTZW5kXCIgXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KHtcblx0XHR1cmw6IHVybCxcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWwuY2FsbCh0aGlzLCBpKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCh0aGlzLCBpKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBpc0Z1bmN0aW9uID8gaHRtbC5jYWxsKHRoaXMsIGkpIDogaHRtbCApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdFx0fVxuXHRcdH0pLmVuZCgpO1xuXHR9XG59KTtcblxuXG5qUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBTdXBwb3J0OiBPcGVyYSA8PSAxMi4xMlxuXHQvLyBPcGVyYSByZXBvcnRzIG9mZnNldFdpZHRocyBhbmQgb2Zmc2V0SGVpZ2h0cyBsZXNzIHRoYW4gemVybyBvbiBzb21lIGVsZW1lbnRzXG5cdHJldHVybiBlbGVtLm9mZnNldFdpZHRoIDw9IDAgJiYgZWxlbS5vZmZzZXRIZWlnaHQgPD0gMDtcbn07XG5qUXVlcnkuZXhwci5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiggZWxlbSApO1xufTtcblxuXG5cblxudmFyIHIyMCA9IC8lMjAvZyxcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggb2JqICkgKSB7XG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiID8gaSA6IFwiXCIgKSArIFwiXVwiLCB2LCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCByZXR1cm4gaXRzIHZhbHVlXG5cdFx0XHR2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApID8gdmFsdWUoKSA6ICggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIFNldCB0cmFkaXRpb25hbCB0byB0cnVlIGZvciBqUXVlcnkgPD0gMS4zLjIgYmVoYXZpb3IuXG5cdGlmICggdHJhZGl0aW9uYWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHR0cmFkaXRpb25hbCA9IGpRdWVyeS5hamF4U2V0dGluZ3MgJiYgalF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9KTtcblxuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0pXG5cdFx0LmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSlcblx0XHQubWFwKGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRyZXR1cm4gdmFsID09IG51bGwgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0alF1ZXJ5LmlzQXJyYXkoIHZhbCApID9cblx0XHRcdFx0XHRqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHR7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSkuZ2V0KCk7XG5cdH1cbn0pO1xuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoKCBlICkge31cbn07XG5cbnZhciB4aHJJZCA9IDAsXG5cdHhockNhbGxiYWNrcyA9IHt9LFxuXHR4aHJTdWNjZXNzU3RhdHVzID0ge1xuXHRcdC8vIGZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG4vLyBTdXBwb3J0OiBJRTlcbi8vIE9wZW4gcmVxdWVzdHMgbXVzdCBiZSBtYW51YWxseSBhYm9ydGVkIG9uIHVubG9hZCAoIzUyODApXG5pZiAoIHdpbmRvdy5BY3RpdmVYT2JqZWN0ICkge1xuXHRqUXVlcnkoIHdpbmRvdyApLm9uKCBcInVubG9hZFwiLCBmdW5jdGlvbigpIHtcblx0XHRmb3IgKCB2YXIga2V5IGluIHhockNhbGxiYWNrcyApIHtcblx0XHRcdHhockNhbGxiYWNrc1sga2V5IF0oKTtcblx0XHR9XG5cdH0pO1xufVxuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpLFxuXHRcdFx0XHRcdGlkID0gKyt4aHJJZDtcblxuXHRcdFx0XHR4aHIub3Blbiggb3B0aW9ucy50eXBlLCBvcHRpb25zLnVybCwgb3B0aW9ucy5hc3luYywgb3B0aW9ucy51c2VybmFtZSwgb3B0aW9ucy5wYXNzd29yZCApO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgeGhyQ2FsbGJhY2tzWyBpZCBdO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IHhoci5vbmxvYWQgPSB4aHIub25lcnJvciA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gQWNjZXNzaW5nIGJpbmFyeS1kYXRhIHJlc3BvbnNlVGV4dCB0aHJvd3MgYW4gZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyAoIzExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgPT09IFwic3RyaW5nXCIgPyB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRleHQ6IHhoci5yZXNwb25zZVRleHRcblx0XHRcdFx0XHRcdFx0XHRcdH0gOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHR4aHIub25lcnJvciA9IGNhbGxiYWNrKFwiZXJyb3JcIik7XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IHhockNhbGxiYWNrc1sgaWQgXSA9IGNhbGxiYWNrKFwiYWJvcnRcIik7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59KTtcblxuXG5cblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoe1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC8oPzpqYXZhfGVjbWEpc2NyaXB0L1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoXCI8c2NyaXB0PlwiKS5wcm9wKHtcblx0XHRcdFx0XHRhc3luYzogdHJ1ZSxcblx0XHRcdFx0XHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXG5cdFx0XHRcdFx0c3JjOiBzLnVybFxuXHRcdFx0XHR9KS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCh7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiYgISggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSAmJiByanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1tcInNjcmlwdCBqc29uXCJdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gZm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdC8vIFJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cdFx0XHRcdC8vIG1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gc2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9KTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59KTtcblxuXG5cblxuLy8gZGF0YTogc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCwgZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHR2YXIgcGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICksXG5cdFx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWzFdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vLyBLZWVwIGEgY29weSBvZiB0aGUgb2xkIGxvYWQgbWV0aG9kXG52YXIgX2xvYWQgPSBqUXVlcnkuZm4ubG9hZDtcblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0aWYgKCB0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiICYmIF9sb2FkICkge1xuXHRcdHJldHVybiBfbG9hZC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdH1cblxuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKFwiIFwiKTtcblxuXHRpZiAoIG9mZiA+PSAwICkge1xuXHRcdHNlbGVjdG9yID0galF1ZXJ5LnRyaW0oIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCh7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gaWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZFxuXHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0pLmRvbmUoZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoXCI8ZGl2PlwiKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHR9KS5jb21wbGV0ZSggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGNhbGxiYWNrLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSkubGVuZ3RoO1xufTtcblxuXG5cblxudmFyIGRvY0VsZW0gPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4vKipcbiAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID8gZWxlbSA6IGVsZW0ubm9kZVR5cGUgPT09IDkgJiYgZWxlbS5kZWZhdWx0Vmlldztcbn1cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKFwiYXV0b1wiKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXIgdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBjdXJPZmZzZXQgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBkb2NFbGVtLCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0Ym94ID0geyB0b3A6IDAsIGxlZnQ6IDAgfSxcblx0XHRcdGRvYyA9IGVsZW0gJiYgZWxlbS5vd25lckRvY3VtZW50O1xuXG5cdFx0aWYgKCAhZG9jICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGl0J3Mgbm90IGEgZGlzY29ubmVjdGVkIERPTSBub2RlXG5cdFx0aWYgKCAhalF1ZXJ5LmNvbnRhaW5zKCBkb2NFbGVtLCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm4gYm94O1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGRvbid0IGhhdmUgZ0JDUiwganVzdCB1c2UgMCwwIHJhdGhlciB0aGFuIGVycm9yXG5cdFx0Ly8gQmxhY2tCZXJyeSA1LCBpT1MgMyAob3JpZ2luYWwgaVBob25lKVxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSBzdHJ1bmRlZmluZWQgKSB7XG5cdFx0XHRib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdH1cblx0XHR3aW4gPSBnZXRXaW5kb3coIGRvYyApO1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IGJveC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcblx0XHRcdGxlZnQ6IGJveC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XG5cdFx0fTtcblx0fSxcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSwgYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXHRcdFx0Ly8gV2UgYXNzdW1lIHRoYXQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIGF2YWlsYWJsZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG5cdFx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQgfHwgZG9jRWxlbTtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnQsIFwiaHRtbFwiICkgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY0VsZW07XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cdFx0XHR2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW5kb3cucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luZG93LnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoLCBudWxsICk7XG5cdH07XG59KTtcblxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodFxuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIHdlIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cdFx0XHRcdC8vIGlmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSwgZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cdFx0Ly8gbWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHRcdC8vIEFzIG9mIDUvOC8yMDEyIHRoaXMgd2lsbCB5aWVsZCBpbmNvcnJlY3QgcmVzdWx0cyBmb3IgTW9iaWxlIFNhZmFyaSwgYnV0IHRoZXJlXG5cdFx0XHRcdFx0Ly8gaXNuJ3QgYSB3aG9sZSBsb3Qgd2UgY2FuIGRvLiBTZWUgcHVsbCByZXF1ZXN0IGF0IHRoaXMgVVJMIGZvciBkaXNjdXNzaW9uOlxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNzY0XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSwgbnVsbCApO1xuXHRcdH07XG5cdH0pO1xufSk7XG5cblxuLy8gVGhlIG51bWJlciBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXRcbmpRdWVyeS5mbi5zaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbmpRdWVyeS5mbi5hbmRTZWxmID0galF1ZXJ5LmZuLmFkZEJhY2s7XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSk7XG59XG5cblxuXG5cbnZhclxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW5cbi8vIEFNRCAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoIHR5cGVvZiBub0dsb2JhbCA9PT0gc3RydW5kZWZpbmVkICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG5cbn0pKTtcbiIsIi8qIVxuKiBqUXVlcnkgTW9iaWxlIDEuNC4zXG4qIEdpdCBIRUFEIGhhc2g6IGI5YzY0NzNlM2Q5MGFmMjY1NzBlNmYxNGU1YTAzMDc4OTdhYjM4NWMgPD4gRGF0ZTogVHVlIEp1bCAxIDIwMTQgMTU6Mzc6MzYgVVRDXG4qIGh0dHA6Ly9qcXVlcnltb2JpbGUuY29tXG4qXG4qIENvcHlyaWdodCAyMDEwLCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlcmNvbnRyaWJ1dG9yc1xuKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbipcbiovXG5cblxuKGZ1bmN0aW9uICggcm9vdCwgZG9jLCBmYWN0b3J5ICkge1xuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBQU0FMVEVEOiBhZGRlZCBieSBDaHJpcyBCYWlrIDEwLzI5LzIwMTMgdG8gc3VwcG9ydCBjb21tb25qc1xuXHRcdCQgPSByZXF1aXJlKCdqcXVlcnknKVxuXHRcdGZhY3RvcnkoICQsIHJvb3QsIGRvYyApO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gJC5tb2JpbGU7XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoIFsgXCJqcXVlcnlcIiBdLCBmdW5jdGlvbiAoICQgKSB7XG5cdFx0XHRmYWN0b3J5KCAkLCByb290LCBkb2MgKTtcblx0XHRcdHJldHVybiAkLm1vYmlsZTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KCByb290LmpRdWVyeSwgcm9vdCwgZG9jICk7XG5cdH1cbn0oIHRoaXMsIGRvY3VtZW50LCBmdW5jdGlvbiAoIGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkICkge1xuKGZ1bmN0aW9uKCAkICkge1xuXHQkLm1vYmlsZSA9IHt9O1xufSggalF1ZXJ5ICkpO1xuXG4oZnVuY3Rpb24oICQsIHdpbmRvdywgdW5kZWZpbmVkICkge1xuXHQkLmV4dGVuZCggJC5tb2JpbGUsIHtcblxuXHRcdC8vIFZlcnNpb24gb2YgdGhlIGpRdWVyeSBNb2JpbGUgRnJhbWV3b3JrXG5cdFx0dmVyc2lvbjogXCIxLjQuM1wiLFxuXG5cdFx0Ly8gRGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIHVzZWQgaW4gMS40IHJlbW92ZSBpbiAxLjVcblx0XHQvLyBEZWZpbmUgdGhlIHVybCBwYXJhbWV0ZXIgdXNlZCBmb3IgcmVmZXJlbmNpbmcgd2lkZ2V0LWdlbmVyYXRlZCBzdWItcGFnZXMuXG5cdFx0Ly8gVHJhbnNsYXRlcyB0byBleGFtcGxlLmh0bWwmdWktcGFnZT1zdWJwYWdlSWRlbnRpZmllclxuXHRcdC8vIGhhc2ggc2VnbWVudCBiZWZvcmUgJnVpLXBhZ2U9IGlzIHVzZWQgdG8gbWFrZSBBamF4IHJlcXVlc3Rcblx0XHRzdWJQYWdlVXJsS2V5OiBcInVpLXBhZ2VcIixcblxuXHRcdGhpZGVVcmxCYXI6IHRydWUsXG5cblx0XHQvLyBLZWVwbmF0aXZlIFNlbGVjdG9yXG5cdFx0a2VlcE5hdGl2ZTogXCI6anFtRGF0YShyb2xlPSdub25lJyksIDpqcW1EYXRhKHJvbGU9J25vanMnKVwiLFxuXG5cdFx0Ly8gRGVwcmVjYXRlZCBpbiAxLjQgcmVtb3ZlIGluIDEuNVxuXHRcdC8vIENsYXNzIGFzc2lnbmVkIHRvIHBhZ2UgY3VycmVudGx5IGluIHZpZXcsIGFuZCBkdXJpbmcgdHJhbnNpdGlvbnNcblx0XHRhY3RpdmVQYWdlQ2xhc3M6IFwidWktcGFnZS1hY3RpdmVcIixcblxuXHRcdC8vIERlcHJlY2F0ZWQgaW4gMS40IHJlbW92ZSBpbiAxLjVcblx0XHQvLyBDbGFzcyB1c2VkIGZvciBcImFjdGl2ZVwiIGJ1dHRvbiBzdGF0ZSwgZnJvbSBDU1MgZnJhbWV3b3JrXG5cdFx0YWN0aXZlQnRuQ2xhc3M6IFwidWktYnRuLWFjdGl2ZVwiLFxuXG5cdFx0Ly8gRGVwcmVjYXRlZCBpbiAxLjQgcmVtb3ZlIGluIDEuNVxuXHRcdC8vIENsYXNzIHVzZWQgZm9yIFwiZm9jdXNcIiBmb3JtIGVsZW1lbnQgc3RhdGUsIGZyb20gQ1NTIGZyYW1ld29ya1xuXHRcdGZvY3VzQ2xhc3M6IFwidWktZm9jdXNcIixcblxuXHRcdC8vIEF1dG9tYXRpY2FsbHkgaGFuZGxlIGNsaWNrcyBhbmQgZm9ybSBzdWJtaXNzaW9ucyB0aHJvdWdoIEFqYXgsIHdoZW4gc2FtZS1kb21haW5cblx0XHRhamF4RW5hYmxlZDogdHJ1ZSxcblxuXHRcdC8vIEF1dG9tYXRpY2FsbHkgbG9hZCBhbmQgc2hvdyBwYWdlcyBiYXNlZCBvbiBsb2NhdGlvbi5oYXNoXG5cdFx0aGFzaExpc3RlbmluZ0VuYWJsZWQ6IHRydWUsXG5cblx0XHQvLyBkaXNhYmxlIHRvIHByZXZlbnQganF1ZXJ5IGZyb20gYm90aGVyaW5nIHdpdGggbGlua3Ncblx0XHRsaW5rQmluZGluZ0VuYWJsZWQ6IHRydWUsXG5cblx0XHQvLyBTZXQgZGVmYXVsdCBwYWdlIHRyYW5zaXRpb24gLSAnbm9uZScgZm9yIG5vIHRyYW5zaXRpb25zXG5cdFx0ZGVmYXVsdFBhZ2VUcmFuc2l0aW9uOiBcImZhZGVcIixcblxuXHRcdC8vIFNldCBtYXhpbXVtIHdpbmRvdyB3aWR0aCBmb3IgdHJhbnNpdGlvbnMgdG8gYXBwbHkgLSAnZmFsc2UnIGZvciBubyBsaW1pdFxuXHRcdG1heFRyYW5zaXRpb25XaWR0aDogZmFsc2UsXG5cblx0XHQvLyBNaW5pbXVtIHNjcm9sbCBkaXN0YW5jZSB0aGF0IHdpbGwgYmUgcmVtZW1iZXJlZCB3aGVuIHJldHVybmluZyB0byBhIHBhZ2Vcblx0XHQvLyBEZXByZWNhdGVkIHJlbW92ZSBpbiAxLjVcblx0XHRtaW5TY3JvbGxCYWNrOiAwLFxuXG5cdFx0Ly8gU2V0IGRlZmF1bHQgZGlhbG9nIHRyYW5zaXRpb24gLSAnbm9uZScgZm9yIG5vIHRyYW5zaXRpb25zXG5cdFx0ZGVmYXVsdERpYWxvZ1RyYW5zaXRpb246IFwicG9wXCIsXG5cblx0XHQvLyBFcnJvciByZXNwb25zZSBtZXNzYWdlIC0gYXBwZWFycyB3aGVuIGFuIEFqYXggcGFnZSByZXF1ZXN0IGZhaWxzXG5cdFx0cGFnZUxvYWRFcnJvck1lc3NhZ2U6IFwiRXJyb3IgTG9hZGluZyBQYWdlXCIsXG5cblx0XHQvLyBGb3IgZXJyb3IgbWVzc2FnZXMsIHdoaWNoIHRoZW1lIGRvZXMgdGhlIGJveCB1c2U/XG5cdFx0cGFnZUxvYWRFcnJvck1lc3NhZ2VUaGVtZTogXCJhXCIsXG5cblx0XHQvLyByZXBsYWNlIGNhbGxzIHRvIHdpbmRvdy5oaXN0b3J5LmJhY2sgd2l0aCBwaG9uZWdhcHMgbmF2aWdhdGlvbiBoZWxwZXJcblx0XHQvLyB3aGVyZSBpdCBpcyBwcm92aWRlZCBvbiB0aGUgd2luZG93IG9iamVjdFxuXHRcdHBob25lZ2FwTmF2aWdhdGlvbkVuYWJsZWQ6IGZhbHNlLFxuXG5cdFx0Ly9hdXRvbWF0aWNhbGx5IGluaXRpYWxpemUgdGhlIERPTSB3aGVuIGl0J3MgcmVhZHlcblx0XHRhdXRvSW5pdGlhbGl6ZVBhZ2U6IHRydWUsXG5cblx0XHRwdXNoU3RhdGVFbmFibGVkOiB0cnVlLFxuXG5cdFx0Ly8gYWxsb3dzIHVzZXJzIHRvIG9wdCBpbiB0byBpZ25vcmluZyBjb250ZW50IGJ5IG1hcmtpbmcgYSBwYXJlbnQgZWxlbWVudCBhc1xuXHRcdC8vIGRhdGEtaWdub3JlZFxuXHRcdGlnbm9yZUNvbnRlbnRFbmFibGVkOiBmYWxzZSxcblxuXHRcdGJ1dHRvbk1hcmt1cDoge1xuXHRcdFx0aG92ZXJEZWxheTogMjAwXG5cdFx0fSxcblxuXHRcdC8vIGRpc2FibGUgdGhlIGFsdGVyYXRpb24gb2YgdGhlIGR5bmFtaWMgYmFzZSB0YWcgb3IgbGlua3MgaW4gdGhlIGNhc2Vcblx0XHQvLyB0aGF0IGEgZHluYW1pYyBiYXNlIHRhZyBpc24ndCBzdXBwb3J0ZWRcblx0XHRkeW5hbWljQmFzZUVuYWJsZWQ6IHRydWUsXG5cblx0XHQvLyBkZWZhdWx0IHRoZSBwcm9wZXJ0eSB0byByZW1vdmUgZGVwZW5kZW5jeSBvbiBhc3NpZ25tZW50IGluIGluaXQgbW9kdWxlXG5cdFx0cGFnZUNvbnRhaW5lcjogJCgpLFxuXG5cdFx0Ly9lbmFibGUgY3Jvc3MtZG9tYWluIHBhZ2Ugc3VwcG9ydFxuXHRcdGFsbG93Q3Jvc3NEb21haW5QYWdlczogZmFsc2UsXG5cblx0XHRkaWFsb2dIYXNoS2V5OiBcIiZ1aS1zdGF0ZT1kaWFsb2dcIlxuXHR9KTtcbn0pKCBqUXVlcnksIHRoaXMgKTtcblxuKGZ1bmN0aW9uKCAkLCB3aW5kb3csIHVuZGVmaW5lZCApIHtcblx0dmFyIG5zTm9ybWFsaXplRGljdCA9IHt9LFxuXHRcdG9sZEZpbmQgPSAkLmZpbmQsXG5cdFx0cmJyYWNlID0gLyg/Olxce1tcXHNcXFNdKlxcfXxcXFtbXFxzXFxTXSpcXF0pJC8sXG5cdFx0anFtRGF0YVJFID0gLzpqcW1EYXRhXFwoKFteKV0qKVxcKS9nO1xuXG5cdCQuZXh0ZW5kKCAkLm1vYmlsZSwge1xuXG5cdFx0Ly8gTmFtZXNwYWNlIHVzZWQgZnJhbWV3b3JrLXdpZGUgZm9yIGRhdGEtYXR0cnMuIERlZmF1bHQgaXMgbm8gbmFtZXNwYWNlXG5cblx0XHRuczogXCJcIixcblxuXHRcdC8vIFJldHJpZXZlIGFuIGF0dHJpYnV0ZSBmcm9tIGFuIGVsZW1lbnQgYW5kIHBlcmZvcm0gc29tZSBtYXNzYWdpbmcgb2YgdGhlIHZhbHVlXG5cblx0XHRnZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uKCBlbGVtZW50LCBrZXkgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQuanF1ZXJ5ID8gZWxlbWVudFswXSA6IGVsZW1lbnQ7XG5cblx0XHRcdGlmICggZWxlbWVudCAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0ZGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCBcImRhdGEtXCIgKyAkLm1vYmlsZS5ucyArIGtleSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb3BpZWQgZnJvbSBjb3JlJ3Mgc3JjL2RhdGEuanM6ZGF0YUF0dHIoKVxuXHRcdFx0Ly8gQ29udmVydCBmcm9tIGEgc3RyaW5nIHRvIGEgcHJvcGVyIGRhdGEgdHlwZVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGRhdGEgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwibnVsbFwiID8gbnVsbCA6XG5cdFx0XHRcdFx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0XHRcdFx0XHQrZGF0YSArIFwiXCIgPT09IGRhdGEgPyArZGF0YSA6XG5cdFx0XHRcdFx0cmJyYWNlLnRlc3QoIGRhdGEgKSA/IEpTT04ucGFyc2UoIGRhdGEgKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH0gY2F0Y2goIGVyciApIHt9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH0sXG5cblx0XHQvLyBFeHBvc2Ugb3VyIGNhY2hlIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuXHRcdG5zTm9ybWFsaXplRGljdDogbnNOb3JtYWxpemVEaWN0LFxuXG5cdFx0Ly8gVGFrZSBhIGRhdGEgYXR0cmlidXRlIHByb3BlcnR5LCBwcmVwZW5kIHRoZSBuYW1lc3BhY2Vcblx0XHQvLyBhbmQgdGhlbiBjYW1lbCBjYXNlIHRoZSBhdHRyaWJ1dGUgc3RyaW5nLiBBZGQgdGhlIHJlc3VsdFxuXHRcdC8vIHRvIG91ciBuc05vcm1hbGl6ZURpY3Qgc28gd2UgZG9uJ3QgaGF2ZSB0byBkbyB0aGlzIGFnYWluLlxuXHRcdG5zTm9ybWFsaXplOiBmdW5jdGlvbiggcHJvcCApIHtcblx0XHRcdHJldHVybiBuc05vcm1hbGl6ZURpY3RbIHByb3AgXSB8fFxuXHRcdFx0XHQoIG5zTm9ybWFsaXplRGljdFsgcHJvcCBdID0gJC5jYW1lbENhc2UoICQubW9iaWxlLm5zICsgcHJvcCApICk7XG5cdFx0fSxcblxuXHRcdC8vIEZpbmQgdGhlIGNsb3Nlc3QgamF2YXNjcmlwdCBwYWdlIGVsZW1lbnQgdG8gZ2F0aGVyIHNldHRpbmdzIGRhdGEganNwZXJmIHRlc3Rcblx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS9zaW5nbGUtY29tcGxleC1zZWxlY3Rvci12cy1tYW55LWNvbXBsZXgtc2VsZWN0b3JzL2VkaXRcblx0XHQvLyBwb3NzaWJseSBuYWl2ZSwgYnV0IGl0IHNob3dzIHRoYXQgdGhlIHBhcnNpbmcgb3ZlcmhlYWQgZm9yICpqdXN0KiB0aGUgcGFnZSBzZWxlY3RvciB2c1xuXHRcdC8vIHRoZSBwYWdlIGFuZCBkaWFsb2cgc2VsZWN0b3IgaXMgbmVnbGlnYWJsZS4gVGhpcyBjb3VsZCBwcm9iYWJseSBiZSBzcGVlZCB1cCBieVxuXHRcdC8vIGRvaW5nIGEgc2ltaWxhciBwYXJlbnQgbm9kZSB0cmF2ZXJzYWwgdG8gdGhlIG9uZSBmb3VuZCBpbiB0aGUgaW5oZXJpdGVkIHRoZW1lIGNvZGUgYWJvdmVcblx0XHRjbG9zZXN0UGFnZURhdGE6IGZ1bmN0aW9uKCAkdGFyZ2V0ICkge1xuXHRcdFx0cmV0dXJuICR0YXJnZXRcblx0XHRcdFx0LmNsb3Nlc3QoIFwiOmpxbURhdGEocm9sZT0ncGFnZScpLCA6anFtRGF0YShyb2xlPSdkaWFsb2cnKVwiIClcblx0XHRcdFx0LmRhdGEoIFwibW9iaWxlLXBhZ2VcIiApO1xuXHRcdH1cblxuXHR9KTtcblxuXHQvLyBNb2JpbGUgdmVyc2lvbiBvZiBkYXRhIGFuZCByZW1vdmVEYXRhIGFuZCBoYXNEYXRhIG1ldGhvZHNcblx0Ly8gZW5zdXJlcyBhbGwgZGF0YSBpcyBzZXQgYW5kIHJldHJpZXZlZCB1c2luZyBqUXVlcnkgTW9iaWxlJ3MgZGF0YSBuYW1lc3BhY2Vcblx0JC5mbi5qcW1EYXRhID0gZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdHZhciByZXN1bHQ7XG5cdFx0aWYgKCB0eXBlb2YgcHJvcCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdGlmICggcHJvcCApIHtcblx0XHRcdFx0cHJvcCA9ICQubW9iaWxlLm5zTm9ybWFsaXplKCBwcm9wICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHVuZGVmaW5lZCBpcyBwZXJtaXR0ZWQgYXMgYW4gZXhwbGljaXQgaW5wdXQgZm9yIHRoZSBzZWNvbmQgcGFyYW1cblx0XHRcdC8vIGluIHRoaXMgY2FzZSBpdCByZXR1cm5zIHRoZSB2YWx1ZSBhbmQgZG9lcyBub3Qgc2V0IGl0IHRvIHVuZGVmaW5lZFxuXHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgMiB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXN1bHQgPSB0aGlzLmRhdGEoIHByb3AgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdCA9IHRoaXMuZGF0YSggcHJvcCwgdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQkLmpxbURhdGEgPSBmdW5jdGlvbiggZWxlbSwgcHJvcCwgdmFsdWUgKSB7XG5cdFx0dmFyIHJlc3VsdDtcblx0XHRpZiAoIHR5cGVvZiBwcm9wICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmVzdWx0ID0gJC5kYXRhKCBlbGVtLCBwcm9wID8gJC5tb2JpbGUubnNOb3JtYWxpemUoIHByb3AgKSA6IHByb3AsIHZhbHVlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0JC5mbi5qcW1SZW1vdmVEYXRhID0gZnVuY3Rpb24oIHByb3AgKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlRGF0YSggJC5tb2JpbGUubnNOb3JtYWxpemUoIHByb3AgKSApO1xuXHR9O1xuXG5cdCQuanFtUmVtb3ZlRGF0YSA9IGZ1bmN0aW9uKCBlbGVtLCBwcm9wICkge1xuXHRcdHJldHVybiAkLnJlbW92ZURhdGEoIGVsZW0sICQubW9iaWxlLm5zTm9ybWFsaXplKCBwcm9wICkgKTtcblx0fTtcblxuXHQkLmZpbmQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJldCwgZXh0cmEgKSB7XG5cdFx0aWYgKCBzZWxlY3Rvci5pbmRleE9mKCBcIjpqcW1EYXRhXCIgKSA+IC0xICkge1xuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKCBqcW1EYXRhUkUsIFwiW2RhdGEtXCIgKyAoICQubW9iaWxlLm5zIHx8IFwiXCIgKSArIFwiJDFdXCIgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gb2xkRmluZC5jYWxsKCB0aGlzLCBzZWxlY3RvciwgY29udGV4dCwgcmV0LCBleHRyYSApO1xuXHR9O1xuXG5cdCQuZXh0ZW5kKCAkLmZpbmQsIG9sZEZpbmQgKTtcblxufSkoIGpRdWVyeSwgdGhpcyApO1xuXG4vKiFcbiAqIGpRdWVyeSBVSSBDb3JlIGMwYWI3MTA1NmI5MzY2MjdlOGE3ODIxZjAzYzA0NGFlYzYyODBhNDBcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAxMyBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vY2F0ZWdvcnkvdWktY29yZS9cbiAqL1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbnZhciB1dWlkID0gMCxcblx0cnVuaXF1ZUlkID0gL151aS1pZC1cXGQrJC87XG5cbi8vICQudWkgbWlnaHQgZXhpc3QgZnJvbSBjb21wb25lbnRzIHdpdGggbm8gZGVwZW5kZW5jaWVzLCBlLmcuLCAkLnVpLnBvc2l0aW9uXG4kLnVpID0gJC51aSB8fCB7fTtcblxuJC5leHRlbmQoICQudWksIHtcblx0dmVyc2lvbjogXCJjMGFiNzEwNTZiOTM2NjI3ZThhNzgyMWYwM2MwNDRhZWM2MjgwYTQwXCIsXG5cblx0a2V5Q29kZToge1xuXHRcdEJBQ0tTUEFDRTogOCxcblx0XHRDT01NQTogMTg4LFxuXHRcdERFTEVURTogNDYsXG5cdFx0RE9XTjogNDAsXG5cdFx0RU5EOiAzNSxcblx0XHRFTlRFUjogMTMsXG5cdFx0RVNDQVBFOiAyNyxcblx0XHRIT01FOiAzNixcblx0XHRMRUZUOiAzNyxcblx0XHRQQUdFX0RPV046IDM0LFxuXHRcdFBBR0VfVVA6IDMzLFxuXHRcdFBFUklPRDogMTkwLFxuXHRcdFJJR0hUOiAzOSxcblx0XHRTUEFDRTogMzIsXG5cdFx0VEFCOiA5LFxuXHRcdFVQOiAzOFxuXHR9XG59KTtcblxuLy8gcGx1Z2luc1xuJC5mbi5leHRlbmQoe1xuXHRmb2N1czogKGZ1bmN0aW9uKCBvcmlnICkge1xuXHRcdHJldHVybiBmdW5jdGlvbiggZGVsYXksIGZuICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBkZWxheSA9PT0gXCJudW1iZXJcIiA/XG5cdFx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdCQoIGVsZW0gKS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0aWYgKCBmbiApIHtcblx0XHRcdFx0XHRcdFx0Zm4uY2FsbCggZWxlbSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIGRlbGF5ICk7XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0b3JpZy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblx0fSkoICQuZm4uZm9jdXMgKSxcblxuXHRzY3JvbGxQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzY3JvbGxQYXJlbnQ7XG5cdFx0aWYgKCgkLnVpLmllICYmICgvKHN0YXRpY3xyZWxhdGl2ZSkvKS50ZXN0KHRoaXMuY3NzKFwicG9zaXRpb25cIikpKSB8fCAoL2Fic29sdXRlLykudGVzdCh0aGlzLmNzcyhcInBvc2l0aW9uXCIpKSkge1xuXHRcdFx0c2Nyb2xsUGFyZW50ID0gdGhpcy5wYXJlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gKC8ocmVsYXRpdmV8YWJzb2x1dGV8Zml4ZWQpLykudGVzdCgkLmNzcyh0aGlzLFwicG9zaXRpb25cIikpICYmICgvKGF1dG98c2Nyb2xsKS8pLnRlc3QoJC5jc3ModGhpcyxcIm92ZXJmbG93XCIpKyQuY3NzKHRoaXMsXCJvdmVyZmxvdy15XCIpKyQuY3NzKHRoaXMsXCJvdmVyZmxvdy14XCIpKTtcblx0XHRcdH0pLmVxKDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzY3JvbGxQYXJlbnQgPSB0aGlzLnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KCQuY3NzKHRoaXMsXCJvdmVyZmxvd1wiKSskLmNzcyh0aGlzLFwib3ZlcmZsb3cteVwiKSskLmNzcyh0aGlzLFwib3ZlcmZsb3cteFwiKSk7XG5cdFx0XHR9KS5lcSgwKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKCAvZml4ZWQvICkudGVzdCggdGhpcy5jc3MoIFwicG9zaXRpb25cIikgKSB8fCAhc2Nyb2xsUGFyZW50Lmxlbmd0aCA/ICQoIHRoaXNbIDAgXS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgOiBzY3JvbGxQYXJlbnQ7XG5cdH0sXG5cblx0dW5pcXVlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICF0aGlzLmlkICkge1xuXHRcdFx0XHR0aGlzLmlkID0gXCJ1aS1pZC1cIiArICgrK3V1aWQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHJlbW92ZVVuaXF1ZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBydW5pcXVlSWQudGVzdCggdGhpcy5pZCApICkge1xuXHRcdFx0XHQkKCB0aGlzICkucmVtb3ZlQXR0ciggXCJpZFwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG4vLyBzZWxlY3RvcnNcbmZ1bmN0aW9uIGZvY3VzYWJsZSggZWxlbWVudCwgaXNUYWJJbmRleE5vdE5hTiApIHtcblx0dmFyIG1hcCwgbWFwTmFtZSwgaW1nLFxuXHRcdG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRpZiAoIFwiYXJlYVwiID09PSBub2RlTmFtZSApIHtcblx0XHRtYXAgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cdFx0bWFwTmFtZSA9IG1hcC5uYW1lO1xuXHRcdGlmICggIWVsZW1lbnQuaHJlZiB8fCAhbWFwTmFtZSB8fCBtYXAubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJtYXBcIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aW1nID0gJCggXCJpbWdbdXNlbWFwPSNcIiArIG1hcE5hbWUgKyBcIl1cIiApWzBdO1xuXHRcdHJldHVybiAhIWltZyAmJiB2aXNpYmxlKCBpbWcgKTtcblx0fVxuXHRyZXR1cm4gKCAvaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3QvLnRlc3QoIG5vZGVOYW1lICkgP1xuXHRcdCFlbGVtZW50LmRpc2FibGVkIDpcblx0XHRcImFcIiA9PT0gbm9kZU5hbWUgP1xuXHRcdFx0ZWxlbWVudC5ocmVmIHx8IGlzVGFiSW5kZXhOb3ROYU4gOlxuXHRcdFx0aXNUYWJJbmRleE5vdE5hTikgJiZcblx0XHQvLyB0aGUgZWxlbWVudCBhbmQgYWxsIG9mIGl0cyBhbmNlc3RvcnMgbXVzdCBiZSB2aXNpYmxlXG5cdFx0dmlzaWJsZSggZWxlbWVudCApO1xufVxuXG5mdW5jdGlvbiB2aXNpYmxlKCBlbGVtZW50ICkge1xuXHRyZXR1cm4gJC5leHByLmZpbHRlcnMudmlzaWJsZSggZWxlbWVudCApICYmXG5cdFx0ISQoIGVsZW1lbnQgKS5wYXJlbnRzKCkuYWRkQmFjaygpLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAkLmNzcyggdGhpcywgXCJ2aXNpYmlsaXR5XCIgKSA9PT0gXCJoaWRkZW5cIjtcblx0XHR9KS5sZW5ndGg7XG59XG5cbiQuZXh0ZW5kKCAkLmV4cHJbIFwiOlwiIF0sIHtcblx0ZGF0YTogJC5leHByLmNyZWF0ZVBzZXVkbyA/XG5cdFx0JC5leHByLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiggZGF0YU5hbWUgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAhISQuZGF0YSggZWxlbSwgZGF0YU5hbWUgKTtcblx0XHRcdH07XG5cdFx0fSkgOlxuXHRcdC8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGksIG1hdGNoICkge1xuXHRcdFx0cmV0dXJuICEhJC5kYXRhKCBlbGVtLCBtYXRjaFsgMyBdICk7XG5cdFx0fSxcblxuXHRmb2N1c2FibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHJldHVybiBmb2N1c2FibGUoIGVsZW1lbnQsICFpc05hTiggJC5hdHRyKCBlbGVtZW50LCBcInRhYmluZGV4XCIgKSApICk7XG5cdH0sXG5cblx0dGFiYmFibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciB0YWJJbmRleCA9ICQuYXR0ciggZWxlbWVudCwgXCJ0YWJpbmRleFwiICksXG5cdFx0XHRpc1RhYkluZGV4TmFOID0gaXNOYU4oIHRhYkluZGV4ICk7XG5cdFx0cmV0dXJuICggaXNUYWJJbmRleE5hTiB8fCB0YWJJbmRleCA+PSAwICkgJiYgZm9jdXNhYmxlKCBlbGVtZW50LCAhaXNUYWJJbmRleE5hTiApO1xuXHR9XG59KTtcblxuLy8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcbmlmICggISQoIFwiPGE+XCIgKS5vdXRlcldpZHRoKCAxICkuanF1ZXJ5ICkge1xuXHQkLmVhY2goIFsgXCJXaWR0aFwiLCBcIkhlaWdodFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRcdHZhciBzaWRlID0gbmFtZSA9PT0gXCJXaWR0aFwiID8gWyBcIkxlZnRcIiwgXCJSaWdodFwiIF0gOiBbIFwiVG9wXCIsIFwiQm90dG9tXCIgXSxcblx0XHRcdHR5cGUgPSBuYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRvcmlnID0ge1xuXHRcdFx0XHRpbm5lcldpZHRoOiAkLmZuLmlubmVyV2lkdGgsXG5cdFx0XHRcdGlubmVySGVpZ2h0OiAkLmZuLmlubmVySGVpZ2h0LFxuXHRcdFx0XHRvdXRlcldpZHRoOiAkLmZuLm91dGVyV2lkdGgsXG5cdFx0XHRcdG91dGVySGVpZ2h0OiAkLmZuLm91dGVySGVpZ2h0XG5cdFx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVkdWNlKCBlbGVtLCBzaXplLCBib3JkZXIsIG1hcmdpbiApIHtcblx0XHRcdCQuZWFjaCggc2lkZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNpemUgLT0gcGFyc2VGbG9hdCggJC5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgdGhpcyApICkgfHwgMDtcblx0XHRcdFx0aWYgKCBib3JkZXIgKSB7XG5cdFx0XHRcdFx0c2l6ZSAtPSBwYXJzZUZsb2F0KCAkLmNzcyggZWxlbSwgXCJib3JkZXJcIiArIHRoaXMgKyBcIldpZHRoXCIgKSApIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXJnaW4gKSB7XG5cdFx0XHRcdFx0c2l6ZSAtPSBwYXJzZUZsb2F0KCAkLmNzcyggZWxlbSwgXCJtYXJnaW5cIiArIHRoaXMgKSApIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHNpemU7XG5cdFx0fVxuXG5cdFx0JC5mblsgXCJpbm5lclwiICsgbmFtZSBdID0gZnVuY3Rpb24oIHNpemUgKSB7XG5cdFx0XHRpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIG9yaWdbIFwiaW5uZXJcIiArIG5hbWUgXS5jYWxsKCB0aGlzICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5jc3MoIHR5cGUsIHJlZHVjZSggdGhpcywgc2l6ZSApICsgXCJweFwiICk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0JC5mblsgXCJvdXRlclwiICsgbmFtZV0gPSBmdW5jdGlvbiggc2l6ZSwgbWFyZ2luICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc2l6ZSAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0cmV0dXJuIG9yaWdbIFwib3V0ZXJcIiArIG5hbWUgXS5jYWxsKCB0aGlzLCBzaXplICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoIHRoaXMpLmNzcyggdHlwZSwgcmVkdWNlKCB0aGlzLCBzaXplLCB0cnVlLCBtYXJnaW4gKSArIFwicHhcIiApO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0fSk7XG59XG5cbi8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XG5pZiAoICEkLmZuLmFkZEJhY2sgKSB7XG5cdCQuZm4uYWRkQmFjayA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH07XG59XG5cbi8vIHN1cHBvcnQ6IGpRdWVyeSAxLjYuMSwgMS42LjIgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzk0MTMpXG5pZiAoICQoIFwiPGE+XCIgKS5kYXRhKCBcImEtYlwiLCBcImFcIiApLnJlbW92ZURhdGEoIFwiYS1iXCIgKS5kYXRhKCBcImEtYlwiICkgKSB7XG5cdCQuZm4ucmVtb3ZlRGF0YSA9IChmdW5jdGlvbiggcmVtb3ZlRGF0YSApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbW92ZURhdGEuY2FsbCggdGhpcywgJC5jYW1lbENhc2UoIGtleSApICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gcmVtb3ZlRGF0YS5jYWxsKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSkoICQuZm4ucmVtb3ZlRGF0YSApO1xufVxuXG5cblxuXG5cbi8vIGRlcHJlY2F0ZWRcbiQudWkuaWUgPSAhIS9tc2llIFtcXHcuXSsvLmV4ZWMoIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSApO1xuXG4kLnN1cHBvcnQuc2VsZWN0c3RhcnQgPSBcIm9uc2VsZWN0c3RhcnRcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG4kLmZuLmV4dGVuZCh7XG5cdGRpc2FibGVTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmJpbmQoICggJC5zdXBwb3J0LnNlbGVjdHN0YXJ0ID8gXCJzZWxlY3RzdGFydFwiIDogXCJtb3VzZWRvd25cIiApICtcblx0XHRcdFwiLnVpLWRpc2FibGVTZWxlY3Rpb25cIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSk7XG5cdH0sXG5cblx0ZW5hYmxlU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy51bmJpbmQoIFwiLnVpLWRpc2FibGVTZWxlY3Rpb25cIiApO1xuXHR9LFxuXG5cdHpJbmRleDogZnVuY3Rpb24oIHpJbmRleCApIHtcblx0XHRpZiAoIHpJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3NzKCBcInpJbmRleFwiLCB6SW5kZXggKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0dmFyIGVsZW0gPSAkKCB0aGlzWyAwIF0gKSwgcG9zaXRpb24sIHZhbHVlO1xuXHRcdFx0d2hpbGUgKCBlbGVtLmxlbmd0aCAmJiBlbGVtWyAwIF0gIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHQvLyBJZ25vcmUgei1pbmRleCBpZiBwb3NpdGlvbiBpcyBzZXQgdG8gYSB2YWx1ZSB3aGVyZSB6LWluZGV4IGlzIGlnbm9yZWQgYnkgdGhlIGJyb3dzZXJcblx0XHRcdFx0Ly8gVGhpcyBtYWtlcyBiZWhhdmlvciBvZiB0aGlzIGZ1bmN0aW9uIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzXG5cdFx0XHRcdC8vIFdlYktpdCBhbHdheXMgcmV0dXJucyBhdXRvIGlmIHRoZSBlbGVtZW50IGlzIHBvc2l0aW9uZWRcblx0XHRcdFx0cG9zaXRpb24gPSBlbGVtLmNzcyggXCJwb3NpdGlvblwiICk7XG5cdFx0XHRcdGlmICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJyZWxhdGl2ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSB7XG5cdFx0XHRcdFx0Ly8gSUUgcmV0dXJucyAwIHdoZW4gekluZGV4IGlzIG5vdCBzcGVjaWZpZWRcblx0XHRcdFx0XHQvLyBvdGhlciBicm93c2VycyByZXR1cm4gYSBzdHJpbmdcblx0XHRcdFx0XHQvLyB3ZSBpZ25vcmUgdGhlIGNhc2Ugb2YgbmVzdGVkIGVsZW1lbnRzIHdpdGggYW4gZXhwbGljaXQgdmFsdWUgb2YgMFxuXHRcdFx0XHRcdC8vIDxkaXYgc3R5bGU9XCJ6LWluZGV4OiAtMTA7XCI+PGRpdiBzdHlsZT1cInotaW5kZXg6IDA7XCI+PC9kaXY+PC9kaXY+XG5cdFx0XHRcdFx0dmFsdWUgPSBwYXJzZUludCggZWxlbS5jc3MoIFwiekluZGV4XCIgKSwgMTAgKTtcblx0XHRcdFx0XHRpZiAoICFpc05hTiggdmFsdWUgKSAmJiB2YWx1ZSAhPT0gMCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxlbSA9IGVsZW0ucGFyZW50KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDA7XG5cdH1cbn0pO1xuXG4vLyAkLnVpLnBsdWdpbiBpcyBkZXByZWNhdGVkLiBVc2UgJC53aWRnZXQoKSBleHRlbnNpb25zIGluc3RlYWQuXG4kLnVpLnBsdWdpbiA9IHtcblx0YWRkOiBmdW5jdGlvbiggbW9kdWxlLCBvcHRpb24sIHNldCApIHtcblx0XHR2YXIgaSxcblx0XHRcdHByb3RvID0gJC51aVsgbW9kdWxlIF0ucHJvdG90eXBlO1xuXHRcdGZvciAoIGkgaW4gc2V0ICkge1xuXHRcdFx0cHJvdG8ucGx1Z2luc1sgaSBdID0gcHJvdG8ucGx1Z2luc1sgaSBdIHx8IFtdO1xuXHRcdFx0cHJvdG8ucGx1Z2luc1sgaSBdLnB1c2goIFsgb3B0aW9uLCBzZXRbIGkgXSBdICk7XG5cdFx0fVxuXHR9LFxuXHRjYWxsOiBmdW5jdGlvbiggaW5zdGFuY2UsIG5hbWUsIGFyZ3MsIGFsbG93RGlzY29ubmVjdGVkICkge1xuXHRcdHZhciBpLFxuXHRcdFx0c2V0ID0gaW5zdGFuY2UucGx1Z2luc1sgbmFtZSBdO1xuXG5cdFx0aWYgKCAhc2V0ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggIWFsbG93RGlzY29ubmVjdGVkICYmICggIWluc3RhbmNlLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlIHx8IGluc3RhbmNlLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxMSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrICkge1xuXHRcdFx0aWYgKCBpbnN0YW5jZS5vcHRpb25zWyBzZXRbIGkgXVsgMCBdIF0gKSB7XG5cdFx0XHRcdHNldFsgaSBdWyAxIF0uYXBwbHkoIGluc3RhbmNlLmVsZW1lbnQsIGFyZ3MgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbn0pKCBqUXVlcnkgKTtcblxuKGZ1bmN0aW9uKCAkLCB3aW5kb3csIHVuZGVmaW5lZCApIHtcblxuXHQvLyBTdWJ0cmFjdCB0aGUgaGVpZ2h0IG9mIGV4dGVybmFsIHRvb2xiYXJzIGZyb20gdGhlIHBhZ2UgaGVpZ2h0LCBpZiB0aGUgcGFnZSBkb2VzIG5vdCBoYXZlXG5cdC8vIGludGVybmFsIHRvb2xiYXJzIG9mIHRoZSBzYW1lIHR5cGVcblx0dmFyIGNvbXBlbnNhdGVUb29sYmFycyA9IGZ1bmN0aW9uKCBwYWdlLCBkZXNpcmVkSGVpZ2h0ICkge1xuXHRcdHZhciBwYWdlUGFyZW50ID0gcGFnZS5wYXJlbnQoKSxcblx0XHRcdHRvb2xiYXJzQWZmZWN0aW5nSGVpZ2h0ID0gW10sXG5cdFx0XHRleHRlcm5hbEhlYWRlcnMgPSBwYWdlUGFyZW50LmNoaWxkcmVuKCBcIjpqcW1EYXRhKHJvbGU9J2hlYWRlcicpXCIgKSxcblx0XHRcdGludGVybmFsSGVhZGVycyA9IHBhZ2UuY2hpbGRyZW4oIFwiOmpxbURhdGEocm9sZT0naGVhZGVyJylcIiApLFxuXHRcdFx0ZXh0ZXJuYWxGb290ZXJzID0gcGFnZVBhcmVudC5jaGlsZHJlbiggXCI6anFtRGF0YShyb2xlPSdmb290ZXInKVwiICksXG5cdFx0XHRpbnRlcm5hbEZvb3RlcnMgPSBwYWdlLmNoaWxkcmVuKCBcIjpqcW1EYXRhKHJvbGU9J2Zvb3RlcicpXCIgKTtcblxuXHRcdC8vIElmIHdlIGhhdmUgbm8gaW50ZXJuYWwgaGVhZGVycywgYnV0IHdlIGRvIGhhdmUgZXh0ZXJuYWwgaGVhZGVycywgdGhlbiB0aGVpciBoZWlnaHRcblx0XHQvLyByZWR1Y2VzIHRoZSBwYWdlIGhlaWdodFxuXHRcdGlmICggaW50ZXJuYWxIZWFkZXJzLmxlbmd0aCA9PT0gMCAmJiBleHRlcm5hbEhlYWRlcnMubGVuZ3RoID4gMCApIHtcblx0XHRcdHRvb2xiYXJzQWZmZWN0aW5nSGVpZ2h0ID0gdG9vbGJhcnNBZmZlY3RpbmdIZWlnaHQuY29uY2F0KCBleHRlcm5hbEhlYWRlcnMudG9BcnJheSgpICk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgaGF2ZSBubyBpbnRlcm5hbCBmb290ZXJzLCBidXQgd2UgZG8gaGF2ZSBleHRlcm5hbCBmb290ZXJzLCB0aGVuIHRoZWlyIGhlaWdodFxuXHRcdC8vIHJlZHVjZXMgdGhlIHBhZ2UgaGVpZ2h0XG5cdFx0aWYgKCBpbnRlcm5hbEZvb3RlcnMubGVuZ3RoID09PSAwICYmIGV4dGVybmFsRm9vdGVycy5sZW5ndGggPiAwICkge1xuXHRcdFx0dG9vbGJhcnNBZmZlY3RpbmdIZWlnaHQgPSB0b29sYmFyc0FmZmVjdGluZ0hlaWdodC5jb25jYXQoIGV4dGVybmFsRm9vdGVycy50b0FycmF5KCkgKTtcblx0XHR9XG5cblx0XHQkLmVhY2goIHRvb2xiYXJzQWZmZWN0aW5nSGVpZ2h0LCBmdW5jdGlvbiggaW5kZXgsIHZhbHVlICkge1xuXHRcdFx0ZGVzaXJlZEhlaWdodCAtPSAkKCB2YWx1ZSApLm91dGVySGVpZ2h0KCk7XG5cdFx0fSk7XG5cblx0XHQvLyBIZWlnaHQgbXVzdCBiZSBhdCBsZWFzdCB6ZXJvXG5cdFx0cmV0dXJuIE1hdGgubWF4KCAwLCBkZXNpcmVkSGVpZ2h0ICk7XG5cdH07XG5cblx0JC5leHRlbmQoICQubW9iaWxlLCB7XG5cdFx0Ly8gZGVmaW5lIHRoZSB3aW5kb3cgYW5kIHRoZSBkb2N1bWVudCBvYmplY3RzXG5cdFx0d2luZG93OiAkKCB3aW5kb3cgKSxcblx0XHRkb2N1bWVudDogJCggZG9jdW1lbnQgKSxcblxuXHRcdC8vIFRPRE86IFJlbW92ZSBhbmQgdXNlICQudWkua2V5Q29kZSBkaXJlY3RseVxuXHRcdGtleUNvZGU6ICQudWkua2V5Q29kZSxcblxuXHRcdC8vIFBsYWNlIHRvIHN0b3JlIHZhcmlvdXMgd2lkZ2V0IGV4dGVuc2lvbnNcblx0XHRiZWhhdmlvcnM6IHt9LFxuXG5cdFx0Ly8gU2Nyb2xsIHBhZ2UgdmVydGljYWxseTogc2Nyb2xsIHRvIDAgdG8gaGlkZSBpT1MgYWRkcmVzcyBiYXIsIG9yIHBhc3MgYSBZIHZhbHVlXG5cdFx0c2lsZW50U2Nyb2xsOiBmdW5jdGlvbiggeXBvcyApIHtcblx0XHRcdGlmICggJC50eXBlKCB5cG9zICkgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHlwb3MgPSAkLm1vYmlsZS5kZWZhdWx0SG9tZVNjcm9sbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJldmVudCBzY3JvbGxzdGFydCBhbmQgc2Nyb2xsc3RvcCBldmVudHNcblx0XHRcdCQuZXZlbnQuc3BlY2lhbC5zY3JvbGxzdGFydC5lbmFibGVkID0gZmFsc2U7XG5cblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHdpbmRvdy5zY3JvbGxUbyggMCwgeXBvcyApO1xuXHRcdFx0XHQkLm1vYmlsZS5kb2N1bWVudC50cmlnZ2VyKCBcInNpbGVudHNjcm9sbFwiLCB7IHg6IDAsIHk6IHlwb3MgfSk7XG5cdFx0XHR9LCAyMCApO1xuXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkLmV2ZW50LnNwZWNpYWwuc2Nyb2xsc3RhcnQuZW5hYmxlZCA9IHRydWU7XG5cdFx0XHR9LCAxNTAgKTtcblx0XHR9LFxuXG5cdFx0Z2V0Q2xvc2VzdEJhc2VVcmw6IGZ1bmN0aW9uKCBlbGUgKVx0e1xuXHRcdFx0Ly8gRmluZCB0aGUgY2xvc2VzdCBwYWdlIGFuZCBleHRyYWN0IG91dCBpdHMgdXJsLlxuXHRcdFx0dmFyIHVybCA9ICQoIGVsZSApLmNsb3Nlc3QoIFwiLnVpLXBhZ2VcIiApLmpxbURhdGEoIFwidXJsXCIgKSxcblx0XHRcdFx0YmFzZSA9ICQubW9iaWxlLnBhdGguZG9jdW1lbnRCYXNlLmhyZWZOb0hhc2g7XG5cblx0XHRcdGlmICggISQubW9iaWxlLmR5bmFtaWNCYXNlRW5hYmxlZCB8fCAhdXJsIHx8ICEkLm1vYmlsZS5wYXRoLmlzUGF0aCggdXJsICkgKSB7XG5cdFx0XHRcdHVybCA9IGJhc2U7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAkLm1vYmlsZS5wYXRoLm1ha2VVcmxBYnNvbHV0ZSggdXJsLCBiYXNlICk7XG5cdFx0fSxcblx0XHRyZW1vdmVBY3RpdmVMaW5rQ2xhc3M6IGZ1bmN0aW9uKCBmb3JjZVJlbW92YWwgKSB7XG5cdFx0XHRpZiAoICEhJC5tb2JpbGUuYWN0aXZlQ2xpY2tlZExpbmsgJiZcblx0XHRcdFx0KCAhJC5tb2JpbGUuYWN0aXZlQ2xpY2tlZExpbmsuY2xvc2VzdCggXCIuXCIgKyAkLm1vYmlsZS5hY3RpdmVQYWdlQ2xhc3MgKS5sZW5ndGggfHxcblx0XHRcdFx0XHRmb3JjZVJlbW92YWwgKSApIHtcblxuXHRcdFx0XHQkLm1vYmlsZS5hY3RpdmVDbGlja2VkTGluay5yZW1vdmVDbGFzcyggJC5tb2JpbGUuYWN0aXZlQnRuQ2xhc3MgKTtcblx0XHRcdH1cblx0XHRcdCQubW9iaWxlLmFjdGl2ZUNsaWNrZWRMaW5rID0gbnVsbDtcblx0XHR9LFxuXG5cdFx0Ly8gREVQUkVDQVRFRCBpbiAxLjRcblx0XHQvLyBGaW5kIHRoZSBjbG9zZXN0IHBhcmVudCB3aXRoIGEgdGhlbWUgY2xhc3Mgb24gaXQuIE5vdGUgdGhhdFxuXHRcdC8vIHdlIGFyZSBub3QgdXNpbmcgJC5mbi5jbG9zZXN0KCkgb24gcHVycG9zZSBoZXJlIGJlY2F1c2UgdGhpc1xuXHRcdC8vIG1ldGhvZCBnZXRzIGNhbGxlZCBxdWl0ZSBhIGJpdCBhbmQgd2UgbmVlZCBpdCB0byBiZSBhcyBmYXN0XG5cdFx0Ly8gYXMgcG9zc2libGUuXG5cdFx0Z2V0SW5oZXJpdGVkVGhlbWU6IGZ1bmN0aW9uKCBlbCwgZGVmYXVsdFRoZW1lICkge1xuXHRcdFx0dmFyIGUgPSBlbFsgMCBdLFxuXHRcdFx0XHRsdHIgPSBcIlwiLFxuXHRcdFx0XHRyZSA9IC91aS0oYmFyfGJvZHl8b3ZlcmxheSktKFthLXpdKVxcYi8sXG5cdFx0XHRcdGMsIG07XG5cdFx0XHR3aGlsZSAoIGUgKSB7XG5cdFx0XHRcdGMgPSBlLmNsYXNzTmFtZSB8fCBcIlwiO1xuXHRcdFx0XHRpZiAoIGMgJiYgKCBtID0gcmUuZXhlYyggYyApICkgJiYgKCBsdHIgPSBtWyAyIF0gKSApIHtcblx0XHRcdFx0XHQvLyBXZSBmb3VuZCBhIHBhcmVudCB3aXRoIGEgdGhlbWUgY2xhc3Ncblx0XHRcdFx0XHQvLyBvbiBpdCBzbyBiYWlsIGZyb20gdGhpcyBsb29wLlxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZSA9IGUucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdC8vIFJldHVybiB0aGUgdGhlbWUgbGV0dGVyIHdlIGZvdW5kLCBpZiBub25lLCByZXR1cm4gdGhlXG5cdFx0XHQvLyBzcGVjaWZpZWQgZGVmYXVsdC5cblx0XHRcdHJldHVybiBsdHIgfHwgZGVmYXVsdFRoZW1lIHx8IFwiYVwiO1xuXHRcdH0sXG5cblx0XHRlbmhhbmNlYWJsZTogZnVuY3Rpb24oIGVsZW1lbnRzICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaGF2ZVBhcmVudHMoIGVsZW1lbnRzLCBcImVuaGFuY2VcIiApO1xuXHRcdH0sXG5cblx0XHRoaWphY2thYmxlOiBmdW5jdGlvbiggZWxlbWVudHMgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5oYXZlUGFyZW50cyggZWxlbWVudHMsIFwiYWpheFwiICk7XG5cdFx0fSxcblxuXHRcdGhhdmVQYXJlbnRzOiBmdW5jdGlvbiggZWxlbWVudHMsIGF0dHIgKSB7XG5cdFx0XHRpZiAoICEkLm1vYmlsZS5pZ25vcmVDb250ZW50RW5hYmxlZCApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW1lbnRzO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY291bnQgPSBlbGVtZW50cy5sZW5ndGgsXG5cdFx0XHRcdCRuZXdTZXQgPSAkKCksXG5cdFx0XHRcdGUsICRlbGVtZW50LCBleGNsdWRlZCxcblx0XHRcdFx0aSwgYztcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjb3VudDsgaSsrICkge1xuXHRcdFx0XHQkZWxlbWVudCA9IGVsZW1lbnRzLmVxKCBpICk7XG5cdFx0XHRcdGV4Y2x1ZGVkID0gZmFsc2U7XG5cdFx0XHRcdGUgPSBlbGVtZW50c1sgaSBdO1xuXG5cdFx0XHRcdHdoaWxlICggZSApIHtcblx0XHRcdFx0XHRjID0gZS5nZXRBdHRyaWJ1dGUgPyBlLmdldEF0dHJpYnV0ZSggXCJkYXRhLVwiICsgJC5tb2JpbGUubnMgKyBhdHRyICkgOiBcIlwiO1xuXG5cdFx0XHRcdFx0aWYgKCBjID09PSBcImZhbHNlXCIgKSB7XG5cdFx0XHRcdFx0XHRleGNsdWRlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlID0gZS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCAhZXhjbHVkZWQgKSB7XG5cdFx0XHRcdFx0JG5ld1NldCA9ICRuZXdTZXQuYWRkKCAkZWxlbWVudCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAkbmV3U2V0O1xuXHRcdH0sXG5cblx0XHRnZXRTY3JlZW5IZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gTmF0aXZlIGlubmVySGVpZ2h0IHJldHVybnMgbW9yZSBhY2N1cmF0ZSB2YWx1ZSBmb3IgdGhpcyBhY3Jvc3MgcGxhdGZvcm1zLFxuXHRcdFx0Ly8galF1ZXJ5IHZlcnNpb24gaXMgaGVyZSBhcyBhIG5vcm1hbGl6ZWQgZmFsbGJhY2sgZm9yIHBsYXRmb3JtcyBsaWtlIFN5bWJpYW5cblx0XHRcdHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgJC5tb2JpbGUud2luZG93LmhlaWdodCgpO1xuXHRcdH0sXG5cblx0XHQvL3NpbXBseSBzZXQgdGhlIGFjdGl2ZSBwYWdlJ3MgbWluaW11bSBoZWlnaHQgdG8gc2NyZWVuIGhlaWdodCwgZGVwZW5kaW5nIG9uIG9yaWVudGF0aW9uXG5cdFx0cmVzZXRBY3RpdmVQYWdlSGVpZ2h0OiBmdW5jdGlvbiggaGVpZ2h0ICkge1xuXHRcdFx0dmFyIHBhZ2UgPSAkKCBcIi5cIiArICQubW9iaWxlLmFjdGl2ZVBhZ2VDbGFzcyApLFxuXHRcdFx0XHRwYWdlSGVpZ2h0ID0gcGFnZS5oZWlnaHQoKSxcblx0XHRcdFx0cGFnZU91dGVySGVpZ2h0ID0gcGFnZS5vdXRlckhlaWdodCggdHJ1ZSApO1xuXG5cdFx0XHRoZWlnaHQgPSBjb21wZW5zYXRlVG9vbGJhcnMoIHBhZ2UsXG5cdFx0XHRcdCggdHlwZW9mIGhlaWdodCA9PT0gXCJudW1iZXJcIiApID8gaGVpZ2h0IDogJC5tb2JpbGUuZ2V0U2NyZWVuSGVpZ2h0KCkgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIGFueSBwcmV2aW91cyBtaW4taGVpZ2h0IHNldHRpbmdcblx0XHRcdHBhZ2UuY3NzKCBcIm1pbi1oZWlnaHRcIiwgXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIG1pbmltdW0gaGVpZ2h0IG9ubHkgaWYgdGhlIGhlaWdodCBhcyBkZXRlcm1pbmVkIGJ5IENTUyBpcyBpbnN1ZmZpY2llbnRcblx0XHRcdGlmICggcGFnZS5oZWlnaHQoKSA8IGhlaWdodCApIHtcblx0XHRcdFx0cGFnZS5jc3MoIFwibWluLWhlaWdodFwiLCBoZWlnaHQgLSAoIHBhZ2VPdXRlckhlaWdodCAtIHBhZ2VIZWlnaHQgKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRsb2FkaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwgdG8gdGhpcyBmdW5jdGlvbiwgaW5zdGFudGlhdGUgYSBsb2FkZXIgd2lkZ2V0XG5cdFx0XHR2YXIgbG9hZGVyID0gdGhpcy5sb2FkaW5nLl93aWRnZXQgfHwgJCggJC5tb2JpbGUubG9hZGVyLnByb3RvdHlwZS5kZWZhdWx0SHRtbCApLmxvYWRlcigpLFxuXG5cdFx0XHRcdC8vIENhbGwgdGhlIGFwcHJvcHJpYXRlIG1ldGhvZCBvbiB0aGUgbG9hZGVyXG5cdFx0XHRcdHJldHVyblZhbHVlID0gbG9hZGVyLmxvYWRlci5hcHBseSggbG9hZGVyLCBhcmd1bWVudHMgKTtcblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoZSBsb2FkZXIgaXMgcmV0YWluZWQgZm9yIGZ1dHVyZSBjYWxscyB0byB0aGlzIGZ1bmN0aW9uLlxuXHRcdFx0dGhpcy5sb2FkaW5nLl93aWRnZXQgPSBsb2FkZXI7XG5cblx0XHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0XHR9XG5cdH0pO1xuXG5cdCQuYWRkRGVwZW5kZW50cyA9IGZ1bmN0aW9uKCBlbGVtLCBuZXdEZXBlbmRlbnRzICkge1xuXHRcdHZhciAkZWxlbSA9ICQoIGVsZW0gKSxcblx0XHRcdGRlcGVuZGVudHMgPSAkZWxlbS5qcW1EYXRhKCBcImRlcGVuZGVudHNcIiApIHx8ICQoKTtcblxuXHRcdCRlbGVtLmpxbURhdGEoIFwiZGVwZW5kZW50c1wiLCAkKCBkZXBlbmRlbnRzICkuYWRkKCBuZXdEZXBlbmRlbnRzICkgKTtcblx0fTtcblxuXHQvLyBwbHVnaW5zXG5cdCQuZm4uZXh0ZW5kKHtcblx0XHRyZW1vdmVXaXRoRGVwZW5kZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHQkLnJlbW92ZVdpdGhEZXBlbmRlbnRzKCB0aGlzICk7XG5cdFx0fSxcblxuXHRcdC8vIEVuaGFuY2UgY2hpbGQgZWxlbWVudHNcblx0XHRlbmhhbmNlV2l0aGluOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0d2lkZ2V0RWxlbWVudHMgPSB7fSxcblx0XHRcdFx0a2VlcE5hdGl2ZSA9ICQubW9iaWxlLnBhZ2UucHJvdG90eXBlLmtlZXBOYXRpdmVTZWxlY3RvcigpLFxuXHRcdFx0XHR0aGF0ID0gdGhpcztcblxuXHRcdFx0Ly8gQWRkIG5vIGpzIGNsYXNzIHRvIGVsZW1lbnRzXG5cdFx0XHRpZiAoICQubW9iaWxlLm5vanMgKSB7XG5cdFx0XHRcdCQubW9iaWxlLm5vanMoIHRoaXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQmluZCBsaW5rcyBmb3IgYWpheCBuYXZcblx0XHRcdGlmICggJC5tb2JpbGUubGlua3MgKSB7XG5cdFx0XHRcdCQubW9iaWxlLmxpbmtzKCB0aGlzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlZ3JhZGUgaW5wdXRzIGZvciBzdHlsZWluZ1xuXHRcdFx0aWYgKCAkLm1vYmlsZS5kZWdyYWRlSW5wdXRzV2l0aGluICkge1xuXHRcdFx0XHQkLm1vYmlsZS5kZWdyYWRlSW5wdXRzV2l0aGluKCB0aGlzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJ1biBidXR0b25tYXJrdXBcblx0XHRcdGlmICggJC5mbi5idXR0b25NYXJrdXAgKSB7XG5cdFx0XHRcdHRoaXMuZmluZCggJC5mbi5idXR0b25NYXJrdXAuaW5pdFNlbGVjdG9yICkubm90KCBrZWVwTmF0aXZlIClcblx0XHRcdFx0LmpxbUVuaGFuY2VhYmxlKCkuYnV0dG9uTWFya3VwKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBjbGFzc2VzIGZvciBmaWVsZENvbnRhaW5cblx0XHRcdGlmICggJC5mbi5maWVsZGNvbnRhaW4gKSB7XG5cdFx0XHRcdHRoaXMuZmluZCggXCI6anFtRGF0YShyb2xlPSdmaWVsZGNvbnRhaW4nKVwiICkubm90KCBrZWVwTmF0aXZlIClcblx0XHRcdFx0LmpxbUVuaGFuY2VhYmxlKCkuZmllbGRjb250YWluKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEVuaGFuY2Ugd2lkZ2V0c1xuXHRcdFx0JC5lYWNoKCAkLm1vYmlsZS53aWRnZXRzLCBmdW5jdGlvbiggbmFtZSwgY29uc3RydWN0b3IgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaW5pdFNlbGVjdG9yIG5vdCBmYWxzZSBmaW5kIGVsZW1lbnRzXG5cdFx0XHRcdGlmICggY29uc3RydWN0b3IuaW5pdFNlbGVjdG9yICkge1xuXG5cdFx0XHRcdFx0Ly8gRmlsdGVyIGVsZW1lbnRzIHRoYXQgc2hvdWxkIG5vdCBiZSBlbmhhbmNlZCBiYXNlZCBvbiBwYXJlbnRzXG5cdFx0XHRcdFx0dmFyIGVsZW1lbnRzID0gJC5tb2JpbGUuZW5oYW5jZWFibGUoIHRoYXQuZmluZCggY29uc3RydWN0b3IuaW5pdFNlbGVjdG9yICkgKTtcblxuXHRcdFx0XHRcdC8vIElmIGFueSBtYXRjaGluZyBlbGVtZW50cyByZW1haW4gZmlsdGVyIG9uZXMgd2l0aCBrZWVwTmF0aXZlU2VsZWN0b3Jcblx0XHRcdFx0XHRpZiAoIGVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdC8vICQubW9iaWxlLnBhZ2UucHJvdG90eXBlLmtlZXBOYXRpdmVTZWxlY3RvciBpcyBkZXByZWNhdGVkIHRoaXMgaXMganVzdCBmb3IgYmFja2NvbXBhdFxuXHRcdFx0XHRcdFx0Ly8gU3dpdGNoIHRvICQubW9iaWxlLmtlZXBOYXRpdmUgaW4gMS41IHdoaWNoIGlzIGp1c3QgYSB2YWx1ZSBub3QgYSBmdW5jdGlvblxuXHRcdFx0XHRcdFx0ZWxlbWVudHMgPSBlbGVtZW50cy5ub3QoIGtlZXBOYXRpdmUgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbmhhbmNlIHdoYXRldmVyIGlzIGxlZnRcblx0XHRcdFx0XHRpZiAoIGVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aWRnZXRFbGVtZW50c1sgY29uc3RydWN0b3IucHJvdG90eXBlLndpZGdldE5hbWUgXSA9IGVsZW1lbnRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGZvciAoIGluZGV4IGluIHdpZGdldEVsZW1lbnRzICkge1xuXHRcdFx0XHR3aWRnZXRFbGVtZW50c1sgaW5kZXggXVsgaW5kZXggXSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0YWRkRGVwZW5kZW50czogZnVuY3Rpb24oIG5ld0RlcGVuZGVudHMgKSB7XG5cdFx0XHQkLmFkZERlcGVuZGVudHMoIHRoaXMsIG5ld0RlcGVuZGVudHMgKTtcblx0XHR9LFxuXG5cdFx0Ly8gbm90ZSB0aGF0IHRoaXMgaGVscGVyIGRvZXNuJ3QgYXR0ZW1wdCB0byBoYW5kbGUgdGhlIGNhbGxiYWNrXG5cdFx0Ly8gb3Igc2V0dGluZyBvZiBhbiBodG1sIGVsZW1lbnQncyB0ZXh0LCBpdHMgb25seSBwdXJwb3NlIGlzXG5cdFx0Ly8gdG8gcmV0dXJuIHRoZSBodG1sIGVuY29kZWQgdmVyc2lvbiBvZiB0aGUgdGV4dCBpbiBhbGwgY2FzZXMuICh0aHVzIHRoZSBuYW1lKVxuXHRcdGdldEVuY29kZWRUZXh0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAkKCBcIjxhPlwiICkudGV4dCggdGhpcy50ZXh0KCkgKS5odG1sKCk7XG5cdFx0fSxcblxuXHRcdC8vIGZsdWVudCBoZWxwZXIgZnVuY3Rpb24gZm9yIHRoZSBtb2JpbGUgbmFtZXNwYWNlZCBlcXVpdmFsZW50XG5cdFx0anFtRW5oYW5jZWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICQubW9iaWxlLmVuaGFuY2VhYmxlKCB0aGlzICk7XG5cdFx0fSxcblxuXHRcdGpxbUhpamFja2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICQubW9iaWxlLmhpamFja2FibGUoIHRoaXMgKTtcblx0XHR9XG5cdH0pO1xuXG5cdCQucmVtb3ZlV2l0aERlcGVuZGVudHMgPSBmdW5jdGlvbiggbmF0aXZlRWxlbWVudCApIHtcblx0XHR2YXIgZWxlbWVudCA9ICQoIG5hdGl2ZUVsZW1lbnQgKTtcblxuXHRcdCggZWxlbWVudC5qcW1EYXRhKCBcImRlcGVuZGVudHNcIiApIHx8ICQoKSApLnJlbW92ZSgpO1xuXHRcdGVsZW1lbnQucmVtb3ZlKCk7XG5cdH07XG5cdCQuYWRkRGVwZW5kZW50cyA9IGZ1bmN0aW9uKCBuYXRpdmVFbGVtZW50LCBuZXdEZXBlbmRlbnRzICkge1xuXHRcdHZhciBlbGVtZW50ID0gJCggbmF0aXZlRWxlbWVudCApLFxuXHRcdFx0ZGVwZW5kZW50cyA9IGVsZW1lbnQuanFtRGF0YSggXCJkZXBlbmRlbnRzXCIgKSB8fCAkKCk7XG5cblx0XHRlbGVtZW50LmpxbURhdGEoIFwiZGVwZW5kZW50c1wiLCAkKCBkZXBlbmRlbnRzICkuYWRkKCBuZXdEZXBlbmRlbnRzICkgKTtcblx0fTtcblxuXHQkLmZpbmQubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBzZXQgKSB7XG5cdFx0cmV0dXJuICQuZmluZCggZXhwciwgbnVsbCwgbnVsbCwgc2V0ICk7XG5cdH07XG5cblx0JC5maW5kLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBub2RlLCBleHByICkge1xuXHRcdHJldHVybiAkLmZpbmQoIGV4cHIsIG51bGwsIG51bGwsIFsgbm9kZSBdICkubGVuZ3RoID4gMDtcblx0fTtcblxufSkoIGpRdWVyeSwgdGhpcyApO1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIFdpZGdldCBjMGFiNzEwNTZiOTM2NjI3ZThhNzgyMWYwM2MwNDRhZWM2MjgwYTQwXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTMgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2pRdWVyeS53aWRnZXQvXG4gKi9cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgdXVpZCA9IDAsXG5cdHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuXHRfY2xlYW5EYXRhID0gJC5jbGVhbkRhdGE7XG4kLmNsZWFuRGF0YSA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0Zm9yICggdmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0dHJ5IHtcblx0XHRcdCQoIGVsZW0gKS50cmlnZ2VySGFuZGxlciggXCJyZW1vdmVcIiApO1xuXHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzgyMzVcblx0XHR9IGNhdGNoKCBlICkge31cblx0fVxuXHRfY2xlYW5EYXRhKCBlbGVtcyApO1xufTtcblxuJC53aWRnZXQgPSBmdW5jdGlvbiggbmFtZSwgYmFzZSwgcHJvdG90eXBlICkge1xuXHR2YXIgZnVsbE5hbWUsIGV4aXN0aW5nQ29uc3RydWN0b3IsIGNvbnN0cnVjdG9yLCBiYXNlUHJvdG90eXBlLFxuXHRcdC8vIHByb3hpZWRQcm90b3R5cGUgYWxsb3dzIHRoZSBwcm92aWRlZCBwcm90b3R5cGUgdG8gcmVtYWluIHVubW9kaWZpZWRcblx0XHQvLyBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGFzIGEgbWl4aW4gZm9yIG11bHRpcGxlIHdpZGdldHMgKCM4ODc2KVxuXHRcdHByb3hpZWRQcm90b3R5cGUgPSB7fSxcblx0XHRuYW1lc3BhY2UgPSBuYW1lLnNwbGl0KCBcIi5cIiApWyAwIF07XG5cblx0bmFtZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDEgXTtcblx0ZnVsbE5hbWUgPSBuYW1lc3BhY2UgKyBcIi1cIiArIG5hbWU7XG5cblx0aWYgKCAhcHJvdG90eXBlICkge1xuXHRcdHByb3RvdHlwZSA9IGJhc2U7XG5cdFx0YmFzZSA9ICQuV2lkZ2V0O1xuXHR9XG5cblx0Ly8gY3JlYXRlIHNlbGVjdG9yIGZvciBwbHVnaW5cblx0JC5leHByWyBcIjpcIiBdWyBmdWxsTmFtZS50b0xvd2VyQ2FzZSgpIF0gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIGZ1bGxOYW1lICk7XG5cdH07XG5cblx0JFsgbmFtZXNwYWNlIF0gPSAkWyBuYW1lc3BhY2UgXSB8fCB7fTtcblx0ZXhpc3RpbmdDb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF07XG5cdGNvbnN0cnVjdG9yID0gJFsgbmFtZXNwYWNlIF1bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zLCBlbGVtZW50ICkge1xuXHRcdC8vIGFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCBcIm5ld1wiIGtleXdvcmRcblx0XHRpZiAoICF0aGlzLl9jcmVhdGVXaWRnZXQgKSB7XG5cdFx0XHRyZXR1cm4gbmV3IGNvbnN0cnVjdG9yKCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0Ly8gYWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IGluaXRpYWxpemluZyBmb3Igc2ltcGxlIGluaGVyaXRhbmNlXG5cdFx0Ly8gbXVzdCB1c2UgXCJuZXdcIiBrZXl3b3JkICh0aGUgY29kZSBhYm92ZSBhbHdheXMgcGFzc2VzIGFyZ3MpXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5fY3JlYXRlV2lkZ2V0KCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXHR9O1xuXHQvLyBleHRlbmQgd2l0aCB0aGUgZXhpc3RpbmcgY29uc3RydWN0b3IgdG8gY2Fycnkgb3ZlciBhbnkgc3RhdGljIHByb3BlcnRpZXNcblx0JC5leHRlbmQoIGNvbnN0cnVjdG9yLCBleGlzdGluZ0NvbnN0cnVjdG9yLCB7XG5cdFx0dmVyc2lvbjogcHJvdG90eXBlLnZlcnNpb24sXG5cdFx0Ly8gY29weSB0aGUgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoZSBwcm90b3R5cGUgaW4gY2FzZSB3ZSBuZWVkIHRvXG5cdFx0Ly8gcmVkZWZpbmUgdGhlIHdpZGdldCBsYXRlclxuXHRcdF9wcm90bzogJC5leHRlbmQoIHt9LCBwcm90b3R5cGUgKSxcblx0XHQvLyB0cmFjayB3aWRnZXRzIHRoYXQgaW5oZXJpdCBmcm9tIHRoaXMgd2lkZ2V0IGluIGNhc2UgdGhpcyB3aWRnZXQgaXNcblx0XHQvLyByZWRlZmluZWQgYWZ0ZXIgYSB3aWRnZXQgaW5oZXJpdHMgZnJvbSBpdFxuXHRcdF9jaGlsZENvbnN0cnVjdG9yczogW11cblx0fSk7XG5cblx0YmFzZVByb3RvdHlwZSA9IG5ldyBiYXNlKCk7XG5cdC8vIHdlIG5lZWQgdG8gbWFrZSB0aGUgb3B0aW9ucyBoYXNoIGEgcHJvcGVydHkgZGlyZWN0bHkgb24gdGhlIG5ldyBpbnN0YW5jZVxuXHQvLyBvdGhlcndpc2Ugd2UnbGwgbW9kaWZ5IHRoZSBvcHRpb25zIGhhc2ggb24gdGhlIHByb3RvdHlwZSB0aGF0IHdlJ3JlXG5cdC8vIGluaGVyaXRpbmcgZnJvbVxuXHRiYXNlUHJvdG90eXBlLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LCBiYXNlUHJvdG90eXBlLm9wdGlvbnMgKTtcblx0JC5lYWNoKCBwcm90b3R5cGUsIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRpZiAoICEkLmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSB2YWx1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cHJveGllZFByb3RvdHlwZVsgcHJvcCBdID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIF9zdXBlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBiYXNlLnByb3RvdHlwZVsgcHJvcCBdLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0X3N1cGVyQXBwbHkgPSBmdW5jdGlvbiggYXJncyApIHtcblx0XHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgX19zdXBlciA9IHRoaXMuX3N1cGVyLFxuXHRcdFx0XHRcdF9fc3VwZXJBcHBseSA9IHRoaXMuX3N1cGVyQXBwbHksXG5cdFx0XHRcdFx0cmV0dXJuVmFsdWU7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfc3VwZXJBcHBseTtcblxuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHZhbHVlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHR0aGlzLl9zdXBlciA9IF9fc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHRcdFx0fTtcblx0XHR9KSgpO1xuXHR9KTtcblx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gJC53aWRnZXQuZXh0ZW5kKCBiYXNlUHJvdG90eXBlLCB7XG5cdFx0Ly8gVE9ETzogcmVtb3ZlIHN1cHBvcnQgZm9yIHdpZGdldEV2ZW50UHJlZml4XG5cdFx0Ly8gYWx3YXlzIHVzZSB0aGUgbmFtZSArIGEgY29sb24gYXMgdGhlIHByZWZpeCwgZS5nLiwgZHJhZ2dhYmxlOnN0YXJ0XG5cdFx0Ly8gZG9uJ3QgcHJlZml4IGZvciB3aWRnZXRzIHRoYXQgYXJlbid0IERPTS1iYXNlZFxuXHRcdHdpZGdldEV2ZW50UHJlZml4OiBleGlzdGluZ0NvbnN0cnVjdG9yID8gKGJhc2VQcm90b3R5cGUud2lkZ2V0RXZlbnRQcmVmaXggfHwgbmFtZSkgOiBuYW1lXG5cdH0sIHByb3hpZWRQcm90b3R5cGUsIHtcblx0XHRjb25zdHJ1Y3RvcjogY29uc3RydWN0b3IsXG5cdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UsXG5cdFx0d2lkZ2V0TmFtZTogbmFtZSxcblx0XHR3aWRnZXRGdWxsTmFtZTogZnVsbE5hbWVcblx0fSk7XG5cblx0Ly8gSWYgdGhpcyB3aWRnZXQgaXMgYmVpbmcgcmVkZWZpbmVkIHRoZW4gd2UgbmVlZCB0byBmaW5kIGFsbCB3aWRnZXRzIHRoYXRcblx0Ly8gYXJlIGluaGVyaXRpbmcgZnJvbSBpdCBhbmQgcmVkZWZpbmUgYWxsIG9mIHRoZW0gc28gdGhhdCB0aGV5IGluaGVyaXQgZnJvbVxuXHQvLyB0aGUgbmV3IHZlcnNpb24gb2YgdGhpcyB3aWRnZXQuIFdlJ3JlIGVzc2VudGlhbGx5IHRyeWluZyB0byByZXBsYWNlIG9uZVxuXHQvLyBsZXZlbCBpbiB0aGUgcHJvdG90eXBlIGNoYWluLlxuXHRpZiAoIGV4aXN0aW5nQ29uc3RydWN0b3IgKSB7XG5cdFx0JC5lYWNoKCBleGlzdGluZ0NvbnN0cnVjdG9yLl9jaGlsZENvbnN0cnVjdG9ycywgZnVuY3Rpb24oIGksIGNoaWxkICkge1xuXHRcdFx0dmFyIGNoaWxkUHJvdG90eXBlID0gY2hpbGQucHJvdG90eXBlO1xuXG5cdFx0XHQvLyByZWRlZmluZSB0aGUgY2hpbGQgd2lkZ2V0IHVzaW5nIHRoZSBzYW1lIHByb3RvdHlwZSB0aGF0IHdhc1xuXHRcdFx0Ly8gb3JpZ2luYWxseSB1c2VkLCBidXQgaW5oZXJpdCBmcm9tIHRoZSBuZXcgdmVyc2lvbiBvZiB0aGUgYmFzZVxuXHRcdFx0JC53aWRnZXQoIGNoaWxkUHJvdG90eXBlLm5hbWVzcGFjZSArIFwiLlwiICsgY2hpbGRQcm90b3R5cGUud2lkZ2V0TmFtZSwgY29uc3RydWN0b3IsIGNoaWxkLl9wcm90byApO1xuXHRcdH0pO1xuXHRcdC8vIHJlbW92ZSB0aGUgbGlzdCBvZiBleGlzdGluZyBjaGlsZCBjb25zdHJ1Y3RvcnMgZnJvbSB0aGUgb2xkIGNvbnN0cnVjdG9yXG5cdFx0Ly8gc28gdGhlIG9sZCBjaGlsZCBjb25zdHJ1Y3RvcnMgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG5cdFx0ZGVsZXRlIGV4aXN0aW5nQ29uc3RydWN0b3IuX2NoaWxkQ29uc3RydWN0b3JzO1xuXHR9IGVsc2Uge1xuXHRcdGJhc2UuX2NoaWxkQ29uc3RydWN0b3JzLnB1c2goIGNvbnN0cnVjdG9yICk7XG5cdH1cblxuXHQkLndpZGdldC5icmlkZ2UoIG5hbWUsIGNvbnN0cnVjdG9yICk7XG5cblx0cmV0dXJuIGNvbnN0cnVjdG9yO1xufTtcblxuJC53aWRnZXQuZXh0ZW5kID0gZnVuY3Rpb24oIHRhcmdldCApIHtcblx0dmFyIGlucHV0ID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICksXG5cdFx0aW5wdXRJbmRleCA9IDAsXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0a2V5LFxuXHRcdHZhbHVlO1xuXHRmb3IgKCA7IGlucHV0SW5kZXggPCBpbnB1dExlbmd0aDsgaW5wdXRJbmRleCsrICkge1xuXHRcdGZvciAoIGtleSBpbiBpbnB1dFsgaW5wdXRJbmRleCBdICkge1xuXHRcdFx0dmFsdWUgPSBpbnB1dFsgaW5wdXRJbmRleCBdWyBrZXkgXTtcblx0XHRcdGlmICggaW5wdXRbIGlucHV0SW5kZXggXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gQ2xvbmUgb2JqZWN0c1xuXHRcdFx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggdmFsdWUgKSApIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gJC5pc1BsYWluT2JqZWN0KCB0YXJnZXRbIGtleSBdICkgP1xuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdGFyZ2V0WyBrZXkgXSwgdmFsdWUgKSA6XG5cdFx0XHRcdFx0XHQvLyBEb24ndCBleHRlbmQgc3RyaW5ncywgYXJyYXlzLCBldGMuIHdpdGggb2JqZWN0c1xuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdmFsdWUgKTtcblx0XHRcdFx0Ly8gQ29weSBldmVyeXRoaW5nIGVsc2UgYnkgcmVmZXJlbmNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG4kLndpZGdldC5icmlkZ2UgPSBmdW5jdGlvbiggbmFtZSwgb2JqZWN0ICkge1xuXHR2YXIgZnVsbE5hbWUgPSBvYmplY3QucHJvdG90eXBlLndpZGdldEZ1bGxOYW1lIHx8IG5hbWU7XG5cdCQuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBpc01ldGhvZENhbGwgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIixcblx0XHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSxcblx0XHRcdHJldHVyblZhbHVlID0gdGhpcztcblxuXHRcdC8vIGFsbG93IG11bHRpcGxlIGhhc2hlcyB0byBiZSBwYXNzZWQgb24gaW5pdFxuXHRcdG9wdGlvbnMgPSAhaXNNZXRob2RDYWxsICYmIGFyZ3MubGVuZ3RoID9cblx0XHRcdCQud2lkZ2V0LmV4dGVuZC5hcHBseSggbnVsbCwgWyBvcHRpb25zIF0uY29uY2F0KGFyZ3MpICkgOlxuXHRcdFx0b3B0aW9ucztcblxuXHRcdGlmICggaXNNZXRob2RDYWxsICkge1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbWV0aG9kVmFsdWUsXG5cdFx0XHRcdFx0aW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XG5cdFx0XHRcdGlmICggb3B0aW9ucyA9PT0gXCJpbnN0YW5jZVwiICkge1xuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gaW5zdGFuY2U7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIWluc3RhbmNlICkge1xuXHRcdFx0XHRcdHJldHVybiAkLmVycm9yKCBcImNhbm5vdCBjYWxsIG1ldGhvZHMgb24gXCIgKyBuYW1lICsgXCIgcHJpb3IgdG8gaW5pdGlhbGl6YXRpb247IFwiICtcblx0XHRcdFx0XHRcdFwiYXR0ZW1wdGVkIHRvIGNhbGwgbWV0aG9kICdcIiArIG9wdGlvbnMgKyBcIidcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggISQuaXNGdW5jdGlvbiggaW5zdGFuY2Vbb3B0aW9uc10gKSB8fCBvcHRpb25zLmNoYXJBdCggMCApID09PSBcIl9cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJubyBzdWNoIG1ldGhvZCAnXCIgKyBvcHRpb25zICsgXCInIGZvciBcIiArIG5hbWUgKyBcIiB3aWRnZXQgaW5zdGFuY2VcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1ldGhvZFZhbHVlID0gaW5zdGFuY2VbIG9wdGlvbnMgXS5hcHBseSggaW5zdGFuY2UsIGFyZ3MgKTtcblx0XHRcdFx0aWYgKCBtZXRob2RWYWx1ZSAhPT0gaW5zdGFuY2UgJiYgbWV0aG9kVmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IG1ldGhvZFZhbHVlICYmIG1ldGhvZFZhbHVlLmpxdWVyeSA/XG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZS5wdXNoU3RhY2soIG1ldGhvZFZhbHVlLmdldCgpICkgOlxuXHRcdFx0XHRcdFx0bWV0aG9kVmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XG5cdFx0XHRcdGlmICggaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0aW5zdGFuY2Uub3B0aW9uKCBvcHRpb25zIHx8IHt9ICkuX2luaXQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lLCBuZXcgb2JqZWN0KCBvcHRpb25zLCB0aGlzICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHR9O1xufTtcblxuJC5XaWRnZXQgPSBmdW5jdGlvbiggLyogb3B0aW9ucywgZWxlbWVudCAqLyApIHt9O1xuJC5XaWRnZXQuX2NoaWxkQ29uc3RydWN0b3JzID0gW107XG5cbiQuV2lkZ2V0LnByb3RvdHlwZSA9IHtcblx0d2lkZ2V0TmFtZTogXCJ3aWRnZXRcIixcblx0d2lkZ2V0RXZlbnRQcmVmaXg6IFwiXCIsXG5cdGRlZmF1bHRFbGVtZW50OiBcIjxkaXY+XCIsXG5cdG9wdGlvbnM6IHtcblx0XHRkaXNhYmxlZDogZmFsc2UsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRjcmVhdGU6IG51bGxcblx0fSxcblx0X2NyZWF0ZVdpZGdldDogZnVuY3Rpb24oIG9wdGlvbnMsIGVsZW1lbnQgKSB7XG5cdFx0ZWxlbWVudCA9ICQoIGVsZW1lbnQgfHwgdGhpcy5kZWZhdWx0RWxlbWVudCB8fCB0aGlzIClbIDAgXTtcblx0XHR0aGlzLmVsZW1lbnQgPSAkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy51dWlkID0gdXVpZCsrO1xuXHRcdHRoaXMuZXZlbnROYW1lc3BhY2UgPSBcIi5cIiArIHRoaXMud2lkZ2V0TmFtZSArIHRoaXMudXVpZDtcblx0XHR0aGlzLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LFxuXHRcdFx0dGhpcy5vcHRpb25zLFxuXHRcdFx0dGhpcy5fZ2V0Q3JlYXRlT3B0aW9ucygpLFxuXHRcdFx0b3B0aW9ucyApO1xuXG5cdFx0dGhpcy5iaW5kaW5ncyA9ICQoKTtcblx0XHR0aGlzLmhvdmVyYWJsZSA9ICQoKTtcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoKTtcblxuXHRcdGlmICggZWxlbWVudCAhPT0gdGhpcyApIHtcblx0XHRcdCQuZGF0YSggZWxlbWVudCwgdGhpcy53aWRnZXRGdWxsTmFtZSwgdGhpcyApO1xuXHRcdFx0dGhpcy5fb24oIHRydWUsIHRoaXMuZWxlbWVudCwge1xuXHRcdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRpZiAoIGV2ZW50LnRhcmdldCA9PT0gZWxlbWVudCApIHtcblx0XHRcdFx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmRvY3VtZW50ID0gJCggZWxlbWVudC5zdHlsZSA/XG5cdFx0XHRcdC8vIGVsZW1lbnQgd2l0aGluIHRoZSBkb2N1bWVudFxuXHRcdFx0XHRlbGVtZW50Lm93bmVyRG9jdW1lbnQgOlxuXHRcdFx0XHQvLyBlbGVtZW50IGlzIHdpbmRvdyBvciBkb2N1bWVudFxuXHRcdFx0XHRlbGVtZW50LmRvY3VtZW50IHx8IGVsZW1lbnQgKTtcblx0XHRcdHRoaXMud2luZG93ID0gJCggdGhpcy5kb2N1bWVudFswXS5kZWZhdWx0VmlldyB8fCB0aGlzLmRvY3VtZW50WzBdLnBhcmVudFdpbmRvdyApO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NyZWF0ZSgpO1xuXHRcdHRoaXMuX3RyaWdnZXIoIFwiY3JlYXRlXCIsIG51bGwsIHRoaXMuX2dldENyZWF0ZUV2ZW50RGF0YSgpICk7XG5cdFx0dGhpcy5faW5pdCgpO1xuXHR9LFxuXHRfZ2V0Q3JlYXRlT3B0aW9uczogJC5ub29wLFxuXHRfZ2V0Q3JlYXRlRXZlbnREYXRhOiAkLm5vb3AsXG5cdF9jcmVhdGU6ICQubm9vcCxcblx0X2luaXQ6ICQubm9vcCxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9kZXN0cm95KCk7XG5cdFx0Ly8gd2UgY2FuIHByb2JhYmx5IHJlbW92ZSB0aGUgdW5iaW5kIGNhbGxzIGluIDIuMFxuXHRcdC8vIGFsbCBldmVudCBiaW5kaW5ncyBzaG91bGQgZ28gdGhyb3VnaCB0aGlzLl9vbigpXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQudW5iaW5kKCB0aGlzLmV2ZW50TmFtZXNwYWNlIClcblx0XHRcdC5yZW1vdmVEYXRhKCB0aGlzLndpZGdldEZ1bGxOYW1lIClcblx0XHRcdC8vIHN1cHBvcnQ6IGpxdWVyeSA8MS42LjNcblx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzk0MTNcblx0XHRcdC5yZW1vdmVEYXRhKCAkLmNhbWVsQ2FzZSggdGhpcy53aWRnZXRGdWxsTmFtZSApICk7XG5cdFx0dGhpcy53aWRnZXQoKVxuXHRcdFx0LnVuYmluZCggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKVxuXHRcdFx0LnJlbW92ZUNsYXNzKFxuXHRcdFx0XHR0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWQgXCIgK1xuXHRcdFx0XHRcInVpLXN0YXRlLWRpc2FibGVkXCIgKTtcblxuXHRcdC8vIGNsZWFuIHVwIGV2ZW50cyBhbmQgc3RhdGVzXG5cdFx0dGhpcy5iaW5kaW5ncy51bmJpbmQoIHRoaXMuZXZlbnROYW1lc3BhY2UgKTtcblx0XHR0aGlzLmhvdmVyYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0dGhpcy5mb2N1c2FibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHR9LFxuXHRfZGVzdHJveTogJC5ub29wLFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0fSxcblxuXHRvcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBvcHRpb25zID0ga2V5LFxuXHRcdFx0cGFydHMsXG5cdFx0XHRjdXJPcHRpb24sXG5cdFx0XHRpO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0Ly8gZG9uJ3QgcmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBoYXNoXG5cdFx0XHRyZXR1cm4gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Ly8gaGFuZGxlIG5lc3RlZCBrZXlzLCBlLmcuLCBcImZvby5iYXJcIiA9PiB7IGZvbzogeyBiYXI6IF9fXyB9IH1cblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdHBhcnRzID0ga2V5LnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0a2V5ID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdGlmICggcGFydHMubGVuZ3RoICkge1xuXHRcdFx0XHRjdXJPcHRpb24gPSBvcHRpb25zWyBrZXkgXSA9ICQud2lkZ2V0LmV4dGVuZCgge30sIHRoaXMub3B0aW9uc1sga2V5IF0gKTtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKysgKSB7XG5cdFx0XHRcdFx0Y3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF0gPSBjdXJPcHRpb25bIHBhcnRzWyBpIF0gXSB8fCB7fTtcblx0XHRcdFx0XHRjdXJPcHRpb24gPSBjdXJPcHRpb25bIHBhcnRzWyBpIF0gXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXkgPSBwYXJ0cy5wb3AoKTtcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBjdXJPcHRpb25bIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogY3VyT3B0aW9uWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdXJPcHRpb25bIGtleSBdID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uc1sga2V5IF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiB0aGlzLm9wdGlvbnNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0T3B0aW9ucyggb3B0aW9ucyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0Zm9yICgga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb24oIGtleSwgb3B0aW9uc1sga2V5IF0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dGhpcy5vcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHRoaXMud2lkZ2V0KClcblx0XHRcdFx0LnRvZ2dsZUNsYXNzKCB0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWRcIiwgISF2YWx1ZSApO1xuXHRcdFx0dGhpcy5ob3ZlcmFibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0dGhpcy5mb2N1c2FibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVuYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbnMoeyBkaXNhYmxlZDogZmFsc2UgfSk7XG5cdH0sXG5cdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRPcHRpb25zKHsgZGlzYWJsZWQ6IHRydWUgfSk7XG5cdH0sXG5cblx0X29uOiBmdW5jdGlvbiggc3VwcHJlc3NEaXNhYmxlZENoZWNrLCBlbGVtZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgZGVsZWdhdGVFbGVtZW50LFxuXHRcdFx0aW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0Ly8gbm8gc3VwcHJlc3NEaXNhYmxlZENoZWNrIGZsYWcsIHNodWZmbGUgYXJndW1lbnRzXG5cdFx0aWYgKCB0eXBlb2Ygc3VwcHJlc3NEaXNhYmxlZENoZWNrICE9PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSBzdXBwcmVzc0Rpc2FibGVkQ2hlY2s7XG5cdFx0XHRzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBubyBlbGVtZW50IGFyZ3VtZW50LCBzaHVmZmxlIGFuZCB1c2UgdGhpcy5lbGVtZW50XG5cdFx0aWYgKCAhaGFuZGxlcnMgKSB7XG5cdFx0XHRoYW5kbGVycyA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0ZGVsZWdhdGVFbGVtZW50ID0gdGhpcy53aWRnZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gYWNjZXB0IHNlbGVjdG9ycywgRE9NIGVsZW1lbnRzXG5cdFx0XHRlbGVtZW50ID0gZGVsZWdhdGVFbGVtZW50ID0gJCggZWxlbWVudCApO1xuXHRcdFx0dGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuYWRkKCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0JC5lYWNoKCBoYW5kbGVycywgZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVyICkge1xuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXHRcdFx0XHQvLyBhbGxvdyB3aWRnZXRzIHRvIGN1c3RvbWl6ZSB0aGUgZGlzYWJsZWQgaGFuZGxpbmdcblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBhcyBhbiBhcnJheSBpbnN0ZWFkIG9mIGJvb2xlYW5cblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBjbGFzcyBhcyBtZXRob2QgZm9yIGRpc2FibGluZyBpbmRpdmlkdWFsIHBhcnRzXG5cdFx0XHRcdGlmICggIXN1cHByZXNzRGlzYWJsZWRDaGVjayAmJlxuXHRcdFx0XHRcdFx0KCBpbnN0YW5jZS5vcHRpb25zLmRpc2FibGVkID09PSB0cnVlIHx8XG5cdFx0XHRcdFx0XHRcdCQoIHRoaXMgKS5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvcHkgdGhlIGd1aWQgc28gZGlyZWN0IHVuYmluZGluZyB3b3Jrc1xuXHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0aGFuZGxlclByb3h5Lmd1aWQgPSBoYW5kbGVyLmd1aWQgPVxuXHRcdFx0XHRcdGhhbmRsZXIuZ3VpZCB8fCBoYW5kbGVyUHJveHkuZ3VpZCB8fCAkLmd1aWQrKztcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1hdGNoID0gZXZlbnQubWF0Y2goIC9eKFxcdyspXFxzKiguKikkLyApLFxuXHRcdFx0XHRldmVudE5hbWUgPSBtYXRjaFsxXSArIGluc3RhbmNlLmV2ZW50TmFtZXNwYWNlLFxuXHRcdFx0XHRzZWxlY3RvciA9IG1hdGNoWzJdO1xuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0ZGVsZWdhdGVFbGVtZW50LmRlbGVnYXRlKCBzZWxlY3RvciwgZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnQuYmluZCggZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfb2ZmOiBmdW5jdGlvbiggZWxlbWVudCwgZXZlbnROYW1lICkge1xuXHRcdGV2ZW50TmFtZSA9IChldmVudE5hbWUgfHwgXCJcIikuc3BsaXQoIFwiIFwiICkuam9pbiggdGhpcy5ldmVudE5hbWVzcGFjZSArIFwiIFwiICkgKyB0aGlzLmV2ZW50TmFtZXNwYWNlO1xuXHRcdGVsZW1lbnQudW5iaW5kKCBldmVudE5hbWUgKS51bmRlbGVnYXRlKCBldmVudE5hbWUgKTtcblx0fSxcblxuXHRfZGVsYXk6IGZ1bmN0aW9uKCBoYW5kbGVyLCBkZWxheSApIHtcblx0XHRmdW5jdGlvbiBoYW5kbGVyUHJveHkoKSB7XG5cdFx0XHRyZXR1cm4gKCB0eXBlb2YgaGFuZGxlciA9PT0gXCJzdHJpbmdcIiA/IGluc3RhbmNlWyBoYW5kbGVyIF0gOiBoYW5kbGVyIClcblx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0fVxuXHRcdHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0cmV0dXJuIHNldFRpbWVvdXQoIGhhbmRsZXJQcm94eSwgZGVsYXkgfHwgMCApO1xuXHR9LFxuXG5cdF9ob3ZlcmFibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHRoaXMuaG92ZXJhYmxlID0gdGhpcy5ob3ZlcmFibGUuYWRkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy5fb24oIGVsZW1lbnQsIHtcblx0XHRcdG1vdXNlZW50ZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLmFkZENsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRtb3VzZWxlYXZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X2ZvY3VzYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dGhpcy5mb2N1c2FibGUgPSB0aGlzLmZvY3VzYWJsZS5hZGQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLl9vbiggZWxlbWVudCwge1xuXHRcdFx0Zm9jdXNpbjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fSxcblx0XHRcdGZvY3Vzb3V0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X3RyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBldmVudCwgZGF0YSApIHtcblx0XHR2YXIgcHJvcCwgb3JpZyxcblx0XHRcdGNhbGxiYWNrID0gdGhpcy5vcHRpb25zWyB0eXBlIF07XG5cblx0XHRkYXRhID0gZGF0YSB8fCB7fTtcblx0XHRldmVudCA9ICQuRXZlbnQoIGV2ZW50ICk7XG5cdFx0ZXZlbnQudHlwZSA9ICggdHlwZSA9PT0gdGhpcy53aWRnZXRFdmVudFByZWZpeCA/XG5cdFx0XHR0eXBlIDpcblx0XHRcdHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggKyB0eXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHQvLyB0aGUgb3JpZ2luYWwgZXZlbnQgbWF5IGNvbWUgZnJvbSBhbnkgZWxlbWVudFxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHRhcmdldCBvbiB0aGUgbmV3IGV2ZW50XG5cdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcy5lbGVtZW50WyAwIF07XG5cblx0XHQvLyBjb3B5IG9yaWdpbmFsIGV2ZW50IHByb3BlcnRpZXMgb3ZlciB0byB0aGUgbmV3IGV2ZW50XG5cdFx0b3JpZyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cdFx0aWYgKCBvcmlnICkge1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRpZiAoICEoIHByb3AgaW4gZXZlbnQgKSApIHtcblx0XHRcdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ1sgcHJvcCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIGV2ZW50LCBkYXRhICk7XG5cdFx0cmV0dXJuICEoICQuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSAmJlxuXHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMuZWxlbWVudFswXSwgWyBldmVudCBdLmNvbmNhdCggZGF0YSApICkgPT09IGZhbHNlIHx8XG5cdFx0XHRldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApO1xuXHR9XG59O1xuXG4kLmVhY2goIHsgc2hvdzogXCJmYWRlSW5cIiwgaGlkZTogXCJmYWRlT3V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgZGVmYXVsdEVmZmVjdCApIHtcblx0JC5XaWRnZXQucHJvdG90eXBlWyBcIl9cIiArIG1ldGhvZCBdID0gZnVuY3Rpb24oIGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBlZmZlY3Q6IG9wdGlvbnMgfTtcblx0XHR9XG5cdFx0dmFyIGhhc09wdGlvbnMsXG5cdFx0XHRlZmZlY3ROYW1lID0gIW9wdGlvbnMgP1xuXHRcdFx0XHRtZXRob2QgOlxuXHRcdFx0XHRvcHRpb25zID09PSB0cnVlIHx8IHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiID9cblx0XHRcdFx0XHRkZWZhdWx0RWZmZWN0IDpcblx0XHRcdFx0XHRvcHRpb25zLmVmZmVjdCB8fCBkZWZhdWx0RWZmZWN0O1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBkdXJhdGlvbjogb3B0aW9ucyB9O1xuXHRcdH1cblx0XHRoYXNPcHRpb25zID0gISQuaXNFbXB0eU9iamVjdCggb3B0aW9ucyApO1xuXHRcdG9wdGlvbnMuY29tcGxldGUgPSBjYWxsYmFjaztcblx0XHRpZiAoIG9wdGlvbnMuZGVsYXkgKSB7XG5cdFx0XHRlbGVtZW50LmRlbGF5KCBvcHRpb25zLmRlbGF5ICk7XG5cdFx0fVxuXHRcdGlmICggaGFzT3B0aW9ucyAmJiAkLmVmZmVjdHMgJiYgJC5lZmZlY3RzLmVmZmVjdFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgbWV0aG9kIF0oIG9wdGlvbnMgKTtcblx0XHR9IGVsc2UgaWYgKCBlZmZlY3ROYW1lICE9PSBtZXRob2QgJiYgZWxlbWVudFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgZWZmZWN0TmFtZSBdKCBvcHRpb25zLmR1cmF0aW9uLCBvcHRpb25zLmVhc2luZywgY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudC5xdWV1ZShmdW5jdGlvbiggbmV4dCApIHtcblx0XHRcdFx0JCggdGhpcyApWyBtZXRob2QgXSgpO1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGVsZW1lbnRbIDAgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5leHQoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn0pO1xuXG59KSggalF1ZXJ5ICk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgcmNhcGl0YWxzID0gL1tBLVpdL2csXG5cdHJlcGxhY2VGdW5jdGlvbiA9IGZ1bmN0aW9uKCBjICkge1xuXHRcdHJldHVybiBcIi1cIiArIGMudG9Mb3dlckNhc2UoKTtcblx0fTtcblxuJC5leHRlbmQoICQuV2lkZ2V0LnByb3RvdHlwZSwge1xuXHRfZ2V0Q3JlYXRlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdGlvbiwgdmFsdWUsXG5cdFx0XHRlbGVtID0gdGhpcy5lbGVtZW50WyAwIF0sXG5cdFx0XHRvcHRpb25zID0ge307XG5cblx0XHQvL1xuXHRcdGlmICggISQubW9iaWxlLmdldEF0dHJpYnV0ZSggZWxlbSwgXCJkZWZhdWx0c1wiICkgKSB7XG5cdFx0XHRmb3IgKCBvcHRpb24gaW4gdGhpcy5vcHRpb25zICkge1xuXHRcdFx0XHR2YWx1ZSA9ICQubW9iaWxlLmdldEF0dHJpYnV0ZSggZWxlbSwgb3B0aW9uLnJlcGxhY2UoIHJjYXBpdGFscywgcmVwbGFjZUZ1bmN0aW9uICkgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0b3B0aW9uc1sgb3B0aW9uIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG59KTtcblxuLy9UT0RPOiBSZW1vdmUgaW4gMS41IGZvciBiYWNrY29tcGF0IG9ubHlcbiQubW9iaWxlLndpZGdldCA9ICQuV2lkZ2V0O1xuXG59KSggalF1ZXJ5ICk7XG5cblxuKGZ1bmN0aW9uKCAkICkge1xuXHQvLyBUT0RPIG1vdmUgbG9hZGVyIGNsYXNzIGRvd24gaW50byB0aGUgd2lkZ2V0IHNldHRpbmdzXG5cdHZhciBsb2FkZXJDbGFzcyA9IFwidWktbG9hZGVyXCIsICRodG1sID0gJCggXCJodG1sXCIgKTtcblxuXHQkLndpZGdldCggXCJtb2JpbGUubG9hZGVyXCIsIHtcblx0XHQvLyBOT1RFIGlmIHRoZSBnbG9iYWwgY29uZmlnIHNldHRpbmdzIGFyZSBkZWZpbmVkIHRoZXkgd2lsbCBvdmVycmlkZSB0aGVzZVxuXHRcdC8vICAgICAgb3B0aW9uc1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdC8vIHRoZSB0aGVtZSBmb3IgdGhlIGxvYWRpbmcgbWVzc2FnZVxuXHRcdFx0dGhlbWU6IFwiYVwiLFxuXG5cdFx0XHQvLyB3aGV0aGVyIHRoZSB0ZXh0IGluIHRoZSBsb2FkaW5nIG1lc3NhZ2UgaXMgc2hvd25cblx0XHRcdHRleHRWaXNpYmxlOiBmYWxzZSxcblxuXHRcdFx0Ly8gY3VzdG9tIGh0bWwgZm9yIHRoZSBpbm5lciBjb250ZW50IG9mIHRoZSBsb2FkaW5nIG1lc3NhZ2Vcblx0XHRcdGh0bWw6IFwiXCIsXG5cblx0XHRcdC8vIHRoZSB0ZXh0IHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZSBwb3B1cCBpcyBzaG93blxuXHRcdFx0dGV4dDogXCJsb2FkaW5nXCJcblx0XHR9LFxuXG5cdFx0ZGVmYXVsdEh0bWw6IFwiPGRpdiBjbGFzcz0nXCIgKyBsb2FkZXJDbGFzcyArIFwiJz5cIiArXG5cdFx0XHRcIjxzcGFuIGNsYXNzPSd1aS1pY29uLWxvYWRpbmcnPjwvc3Bhbj5cIiArXG5cdFx0XHRcIjxoMT48L2gxPlwiICtcblx0XHRcdFwiPC9kaXY+XCIsXG5cblx0XHQvLyBGb3Igbm9uLWZpeGVkIHN1cHBvcnRpbiBicm93c2Vycy4gUG9zaXRpb24gYXQgeSBjZW50ZXIgKGlmIHNjcm9sbFRvcCBzdXBwb3J0ZWQpLCBhYm92ZSB0aGUgYWN0aXZlQnRuIChpZiBkZWZpbmVkKSwgb3IganVzdCAxMDBweCBmcm9tIHRvcFxuXHRcdGZha2VGaXhMb2FkZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFjdGl2ZUJ0biA9ICQoIFwiLlwiICsgJC5tb2JpbGUuYWN0aXZlQnRuQ2xhc3MgKS5maXJzdCgpO1xuXG5cdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0dG9wOiAkLnN1cHBvcnQuc2Nyb2xsVG9wICYmIHRoaXMud2luZG93LnNjcm9sbFRvcCgpICsgdGhpcy53aW5kb3cuaGVpZ2h0KCkgLyAyIHx8XG5cdFx0XHRcdFx0XHRhY3RpdmVCdG4ubGVuZ3RoICYmIGFjdGl2ZUJ0bi5vZmZzZXQoKS50b3AgfHwgMTAwXG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvLyBjaGVjayBwb3NpdGlvbiBvZiBsb2FkZXIgdG8gc2VlIGlmIGl0IGFwcGVhcnMgdG8gYmUgXCJmaXhlZFwiIHRvIGNlbnRlclxuXHRcdC8vIGlmIG5vdCwgdXNlIGFicyBwb3NpdGlvbmluZ1xuXHRcdGNoZWNrTG9hZGVyUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldCA9IHRoaXMuZWxlbWVudC5vZmZzZXQoKSxcblx0XHRcdFx0c2Nyb2xsVG9wID0gdGhpcy53aW5kb3cuc2Nyb2xsVG9wKCksXG5cdFx0XHRcdHNjcmVlbkhlaWdodCA9ICQubW9iaWxlLmdldFNjcmVlbkhlaWdodCgpO1xuXG5cdFx0XHRpZiAoIG9mZnNldC50b3AgPCBzY3JvbGxUb3AgfHwgKCBvZmZzZXQudG9wIC0gc2Nyb2xsVG9wICkgPiBzY3JlZW5IZWlnaHQgKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyggXCJ1aS1sb2FkZXItZmFrZWZpeFwiICk7XG5cdFx0XHRcdHRoaXMuZmFrZUZpeExvYWRlcigpO1xuXHRcdFx0XHR0aGlzLndpbmRvd1xuXHRcdFx0XHRcdC51bmJpbmQoIFwic2Nyb2xsXCIsIHRoaXMuY2hlY2tMb2FkZXJQb3NpdGlvbiApXG5cdFx0XHRcdFx0LmJpbmQoIFwic2Nyb2xsXCIsICQucHJveHkoIHRoaXMuZmFrZUZpeExvYWRlciwgdGhpcyApICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHJlc2V0SHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuaHRtbCggJCggdGhpcy5kZWZhdWx0SHRtbCApLmh0bWwoKSApO1xuXHRcdH0sXG5cblx0XHQvLyBUdXJuIG9uL29mZiBwYWdlIGxvYWRpbmcgbWVzc2FnZS4gVGhlbWUgZG91YmxlcyBhcyBhbiBvYmplY3QgYXJndW1lbnRcblx0XHQvLyB3aXRoIHRoZSBmb2xsb3dpbmcgc2hhcGU6IHsgdGhlbWU6ICcnLCB0ZXh0OiAnJywgaHRtbDogJycsIHRleHRWaXNpYmxlOiAnJyB9XG5cdFx0Ly8gTk9URSB0aGF0IHRoZSAkLm1vYmlsZS5sb2FkaW5nKiBzZXR0aW5ncyBhbmQgcGFyYW1zIHBhc3QgdGhlIGZpcnN0IGFyZSBkZXByZWNhdGVkXG5cdFx0Ly8gVE9ETyBzd2VldCBqZXN1cyB3ZSBuZWVkIHRvIGJyZWFrIHNvbWUgb2YgdGhpcyBvdXRcblx0XHRzaG93OiBmdW5jdGlvbiggdGhlbWUsIG1zZ1RleHQsIHRleHRvbmx5ICkge1xuXHRcdFx0dmFyIHRleHRWaXNpYmxlLCBtZXNzYWdlLCBsb2FkU2V0dGluZ3M7XG5cblx0XHRcdHRoaXMucmVzZXRIdG1sKCk7XG5cblx0XHRcdC8vIHVzZSB0aGUgcHJvdG90eXBlIG9wdGlvbnMgc28gdGhhdCBwZW9wbGUgY2FuIHNldCB0aGVtIGdsb2JhbGx5IGF0XG5cdFx0XHQvLyBtb2JpbGUgaW5pdC4gQ29uc2lzdGVuY3ksIGl0J3Mgd2hhdCdzIGZvciBkaW5uZXJcblx0XHRcdGlmICggJC50eXBlKCB0aGVtZSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0XHRsb2FkU2V0dGluZ3MgPSAkLmV4dGVuZCgge30sIHRoaXMub3B0aW9ucywgdGhlbWUgKTtcblxuXHRcdFx0XHR0aGVtZSA9IGxvYWRTZXR0aW5ncy50aGVtZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxvYWRTZXR0aW5ncyA9IHRoaXMub3B0aW9ucztcblxuXHRcdFx0XHQvLyBoZXJlIHdlIHByZWZlciB0aGUgdGhlbWUgdmFsdWUgcGFzc2VkIGFzIGEgc3RyaW5nIGFyZ3VtZW50LCB0aGVuXG5cdFx0XHRcdC8vIHdlIHByZWZlciB0aGUgZ2xvYmFsIG9wdGlvbiBiZWNhdXNlIHdlIGNhbid0IHVzZSB1bmRlZmluZWQgZGVmYXVsdFxuXHRcdFx0XHQvLyBwcm90b3R5cGUgb3B0aW9ucywgdGhlbiB0aGUgcHJvdG90eXBlIG9wdGlvblxuXHRcdFx0XHR0aGVtZSA9IHRoZW1lIHx8IGxvYWRTZXR0aW5ncy50aGVtZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc2V0IHRoZSBtZXNzYWdlIHRleHQsIHByZWZlciB0aGUgcGFyYW0sIHRoZW4gdGhlIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0Ly8gdGhlbiBsb2FkaW5nIG1lc3NhZ2Vcblx0XHRcdG1lc3NhZ2UgPSBtc2dUZXh0IHx8ICggbG9hZFNldHRpbmdzLnRleHQgPT09IGZhbHNlID8gXCJcIiA6IGxvYWRTZXR0aW5ncy50ZXh0ICk7XG5cblx0XHRcdC8vIHByZXBhcmUgdGhlIGRvbVxuXHRcdFx0JGh0bWwuYWRkQ2xhc3MoIFwidWktbG9hZGluZ1wiICk7XG5cblx0XHRcdHRleHRWaXNpYmxlID0gbG9hZFNldHRpbmdzLnRleHRWaXNpYmxlO1xuXG5cdFx0XHQvLyBhZGQgdGhlIHByb3BlciBjc3MgZ2l2ZW4gdGhlIG9wdGlvbnMgKHRoZW1lLCB0ZXh0LCBldGMpXG5cdFx0XHQvLyBGb3JjZSB0ZXh0IHZpc2liaWxpdHkgaWYgdGhlIHNlY29uZCBhcmd1bWVudCB3YXMgc3VwcGxpZWQsIG9yXG5cdFx0XHQvLyBpZiB0aGUgdGV4dCB3YXMgZXhwbGljaXRseSBzZXQgaW4gdGhlIG9iamVjdCBhcmdzXG5cdFx0XHR0aGlzLmVsZW1lbnQuYXR0cihcImNsYXNzXCIsIGxvYWRlckNsYXNzICtcblx0XHRcdFx0XCIgdWktY29ybmVyLWFsbCB1aS1ib2R5LVwiICsgdGhlbWUgK1xuXHRcdFx0XHRcIiB1aS1sb2FkZXItXCIgKyAoIHRleHRWaXNpYmxlIHx8IG1zZ1RleHQgfHwgdGhlbWUudGV4dCA/IFwidmVyYm9zZVwiIDogXCJkZWZhdWx0XCIgKSArXG5cdFx0XHRcdCggbG9hZFNldHRpbmdzLnRleHRvbmx5IHx8IHRleHRvbmx5ID8gXCIgdWktbG9hZGVyLXRleHRvbmx5XCIgOiBcIlwiICkgKTtcblxuXHRcdFx0Ly8gVE9ETyB2ZXJpZnkgdGhhdCBqcXVlcnkuZm4uaHRtbCBpcyBvayB0byB1c2UgaW4gYm90aCBjYXNlcyBoZXJlXG5cdFx0XHQvLyAgICAgIHRoaXMgbWlnaHQgYmUgb3Zlcmx5IGRlZmVuc2l2ZSBpbiBwcmV2ZW50aW5nIHVua25vd2luZyB4c3Ncblx0XHRcdC8vIGlmIHRoZSBodG1sIGF0dHJpYnV0ZSBpcyBkZWZpbmVkIG9uIHRoZSBsb2FkaW5nIHNldHRpbmdzLCB1c2UgdGhhdFxuXHRcdFx0Ly8gb3RoZXJ3aXNlIHVzZSB0aGUgZmFsbGJhY2tzIGZyb20gYWJvdmVcblx0XHRcdGlmICggbG9hZFNldHRpbmdzLmh0bWwgKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5odG1sKCBsb2FkU2V0dGluZ3MuaHRtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoIFwiaDFcIiApLnRleHQoIG1lc3NhZ2UgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXR0YWNoIHRoZSBsb2FkZXIgdG8gdGhlIERPTVxuXHRcdFx0dGhpcy5lbGVtZW50LmFwcGVuZFRvKCAkLm1vYmlsZS5wYWdlQ29udGFpbmVyICk7XG5cblx0XHRcdC8vIGNoZWNrIHRoYXQgdGhlIGxvYWRlciBpcyB2aXNpYmxlXG5cdFx0XHR0aGlzLmNoZWNrTG9hZGVyUG9zaXRpb24oKTtcblxuXHRcdFx0Ly8gb24gc2Nyb2xsIGNoZWNrIHRoZSBsb2FkZXIgcG9zaXRpb25cblx0XHRcdHRoaXMud2luZG93LmJpbmQoIFwic2Nyb2xsXCIsICQucHJveHkoIHRoaXMuY2hlY2tMb2FkZXJQb3NpdGlvbiwgdGhpcyApICk7XG5cdFx0fSxcblxuXHRcdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0JGh0bWwucmVtb3ZlQ2xhc3MoIFwidWktbG9hZGluZ1wiICk7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnRleHQgKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyggXCJ1aS1sb2FkZXItZmFrZWZpeFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdCQubW9iaWxlLndpbmRvdy51bmJpbmQoIFwic2Nyb2xsXCIsIHRoaXMuZmFrZUZpeExvYWRlciApO1xuXHRcdFx0JC5tb2JpbGUud2luZG93LnVuYmluZCggXCJzY3JvbGxcIiwgdGhpcy5jaGVja0xvYWRlclBvc2l0aW9uICk7XG5cdFx0fVxuXHR9KTtcblxufSkoalF1ZXJ5LCB0aGlzKTtcblxuXG4vKiFcbiAqIGpRdWVyeSBoYXNoY2hhbmdlIGV2ZW50IC0gdjEuMyAtIDcvMjEvMjAxMFxuICogaHR0cDovL2JlbmFsbWFuLmNvbS9wcm9qZWN0cy9qcXVlcnktaGFzaGNoYW5nZS1wbHVnaW4vXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxMCBcIkNvd2JveVwiIEJlbiBBbG1hblxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXMuXG4gKiBodHRwOi8vYmVuYWxtYW4uY29tL2Fib3V0L2xpY2Vuc2UvXG4gKi9cblxuLy8gU2NyaXB0OiBqUXVlcnkgaGFzaGNoYW5nZSBldmVudFxuLy9cbi8vICpWZXJzaW9uOiAxLjMsIExhc3QgdXBkYXRlZDogNy8yMS8yMDEwKlxuLy8gXG4vLyBQcm9qZWN0IEhvbWUgLSBodHRwOi8vYmVuYWxtYW4uY29tL3Byb2plY3RzL2pxdWVyeS1oYXNoY2hhbmdlLXBsdWdpbi9cbi8vIEdpdEh1YiAgICAgICAtIGh0dHA6Ly9naXRodWIuY29tL2Nvd2JveS9qcXVlcnktaGFzaGNoYW5nZS9cbi8vIFNvdXJjZSAgICAgICAtIGh0dHA6Ly9naXRodWIuY29tL2Nvd2JveS9qcXVlcnktaGFzaGNoYW5nZS9yYXcvbWFzdGVyL2pxdWVyeS5iYS1oYXNoY2hhbmdlLmpzXG4vLyAoTWluaWZpZWQpICAgLSBodHRwOi8vZ2l0aHViLmNvbS9jb3dib3kvanF1ZXJ5LWhhc2hjaGFuZ2UvcmF3L21hc3Rlci9qcXVlcnkuYmEtaGFzaGNoYW5nZS5taW4uanMgKDAuOGtiIGd6aXBwZWQpXG4vLyBcbi8vIEFib3V0OiBMaWNlbnNlXG4vLyBcbi8vIENvcHlyaWdodCAoYykgMjAxMCBcIkNvd2JveVwiIEJlbiBBbG1hbixcbi8vIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIGxpY2Vuc2VzLlxuLy8gaHR0cDovL2JlbmFsbWFuLmNvbS9hYm91dC9saWNlbnNlL1xuLy8gXG4vLyBBYm91dDogRXhhbXBsZXNcbi8vIFxuLy8gVGhlc2Ugd29ya2luZyBleGFtcGxlcywgY29tcGxldGUgd2l0aCBmdWxseSBjb21tZW50ZWQgY29kZSwgaWxsdXN0cmF0ZSBhIGZld1xuLy8gd2F5cyBpbiB3aGljaCB0aGlzIHBsdWdpbiBjYW4gYmUgdXNlZC5cbi8vIFxuLy8gaGFzaGNoYW5nZSBldmVudCAtIGh0dHA6Ly9iZW5hbG1hbi5jb20vY29kZS9wcm9qZWN0cy9qcXVlcnktaGFzaGNoYW5nZS9leGFtcGxlcy9oYXNoY2hhbmdlL1xuLy8gZG9jdW1lbnQuZG9tYWluIC0gaHR0cDovL2JlbmFsbWFuLmNvbS9jb2RlL3Byb2plY3RzL2pxdWVyeS1oYXNoY2hhbmdlL2V4YW1wbGVzL2RvY3VtZW50X2RvbWFpbi9cbi8vIFxuLy8gQWJvdXQ6IFN1cHBvcnQgYW5kIFRlc3Rpbmdcbi8vIFxuLy8gSW5mb3JtYXRpb24gYWJvdXQgd2hhdCB2ZXJzaW9uIG9yIHZlcnNpb25zIG9mIGpRdWVyeSB0aGlzIHBsdWdpbiBoYXMgYmVlblxuLy8gdGVzdGVkIHdpdGgsIHdoYXQgYnJvd3NlcnMgaXQgaGFzIGJlZW4gdGVzdGVkIGluLCBhbmQgd2hlcmUgdGhlIHVuaXQgdGVzdHNcbi8vIHJlc2lkZSAoc28geW91IGNhbiB0ZXN0IGl0IHlvdXJzZWxmKS5cbi8vIFxuLy8galF1ZXJ5IFZlcnNpb25zIC0gMS4yLjYsIDEuMy4yLCAxLjQuMSwgMS40LjJcbi8vIEJyb3dzZXJzIFRlc3RlZCAtIEludGVybmV0IEV4cGxvcmVyIDYtOCwgRmlyZWZveCAyLTQsIENocm9tZSA1LTYsIFNhZmFyaSAzLjItNSxcbi8vICAgICAgICAgICAgICAgICAgIE9wZXJhIDkuNi0xMC42MCwgaVBob25lIDMuMSwgQW5kcm9pZCAxLjYtMi4yLCBCbGFja0JlcnJ5IDQuNi01LlxuLy8gVW5pdCBUZXN0cyAgICAgIC0gaHR0cDovL2JlbmFsbWFuLmNvbS9jb2RlL3Byb2plY3RzL2pxdWVyeS1oYXNoY2hhbmdlL3VuaXQvXG4vLyBcbi8vIEFib3V0OiBLbm93biBpc3N1ZXNcbi8vIFxuLy8gV2hpbGUgdGhpcyBqUXVlcnkgaGFzaGNoYW5nZSBldmVudCBpbXBsZW1lbnRhdGlvbiBpcyBxdWl0ZSBzdGFibGUgYW5kXG4vLyByb2J1c3QsIHRoZXJlIGFyZSBhIGZldyB1bmZvcnR1bmF0ZSBicm93c2VyIGJ1Z3Mgc3Vycm91bmRpbmcgZXhwZWN0ZWRcbi8vIGhhc2hjaGFuZ2UgZXZlbnQtYmFzZWQgYmVoYXZpb3JzLCBpbmRlcGVuZGVudCBvZiBhbnkgSmF2YVNjcmlwdFxuLy8gd2luZG93Lm9uaGFzaGNoYW5nZSBhYnN0cmFjdGlvbi4gU2VlIHRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgZm9yIG1vcmVcbi8vIGluZm9ybWF0aW9uOlxuLy8gXG4vLyBDaHJvbWU6IEJhY2sgQnV0dG9uIC0gaHR0cDovL2JlbmFsbWFuLmNvbS9jb2RlL3Byb2plY3RzL2pxdWVyeS1oYXNoY2hhbmdlL2V4YW1wbGVzL2J1Zy1jaHJvbWUtYmFjay1idXR0b24vXG4vLyBGaXJlZm94OiBSZW1vdGUgWE1MSHR0cFJlcXVlc3QgLSBodHRwOi8vYmVuYWxtYW4uY29tL2NvZGUvcHJvamVjdHMvanF1ZXJ5LWhhc2hjaGFuZ2UvZXhhbXBsZXMvYnVnLWZpcmVmb3gtcmVtb3RlLXhoci9cbi8vIFdlYktpdDogQmFjayBCdXR0b24gaW4gYW4gSWZyYW1lIC0gaHR0cDovL2JlbmFsbWFuLmNvbS9jb2RlL3Byb2plY3RzL2pxdWVyeS1oYXNoY2hhbmdlL2V4YW1wbGVzL2J1Zy13ZWJraXQtaGFzaC1pZnJhbWUvXG4vLyBTYWZhcmk6IEJhY2sgQnV0dG9uIGZyb20gYSBkaWZmZXJlbnQgZG9tYWluIC0gaHR0cDovL2JlbmFsbWFuLmNvbS9jb2RlL3Byb2plY3RzL2pxdWVyeS1oYXNoY2hhbmdlL2V4YW1wbGVzL2J1Zy1zYWZhcmktYmFjay1mcm9tLWRpZmYtZG9tYWluL1xuLy8gXG4vLyBBbHNvIG5vdGUgdGhhdCBzaG91bGQgYSBicm93c2VyIG5hdGl2ZWx5IHN1cHBvcnQgdGhlIHdpbmRvdy5vbmhhc2hjaGFuZ2UgXG4vLyBldmVudCwgYnV0IG5vdCByZXBvcnQgdGhhdCBpdCBkb2VzLCB0aGUgZmFsbGJhY2sgcG9sbGluZyBsb29wIHdpbGwgYmUgdXNlZC5cbi8vIFxuLy8gQWJvdXQ6IFJlbGVhc2UgSGlzdG9yeVxuLy8gXG4vLyAxLjMgICAtICg3LzIxLzIwMTApIFJlb3JnYW5pemVkIElFNi83IElmcmFtZSBjb2RlIHRvIG1ha2UgaXQgbW9yZVxuLy8gICAgICAgICBcInJlbW92YWJsZVwiIGZvciBtb2JpbGUtb25seSBkZXZlbG9wbWVudC4gQWRkZWQgSUU2LzcgZG9jdW1lbnQudGl0bGVcbi8vICAgICAgICAgc3VwcG9ydC4gQXR0ZW1wdGVkIHRvIG1ha2UgSWZyYW1lIGFzIGhpZGRlbiBhcyBwb3NzaWJsZSBieSB1c2luZ1xuLy8gICAgICAgICB0ZWNobmlxdWVzIGZyb20gaHR0cDovL3d3dy5wYWNpZWxsb2dyb3VwLmNvbS9ibG9nLz9wPTYwNC4gQWRkZWQgXG4vLyAgICAgICAgIHN1cHBvcnQgZm9yIHRoZSBcInNob3J0Y3V0XCIgZm9ybWF0ICQod2luZG93KS5oYXNoY2hhbmdlKCBmbiApIGFuZFxuLy8gICAgICAgICAkKHdpbmRvdykuaGFzaGNoYW5nZSgpIGxpa2UgalF1ZXJ5IHByb3ZpZGVzIGZvciBidWlsdC1pbiBldmVudHMuXG4vLyAgICAgICAgIFJlbmFtZWQgalF1ZXJ5Lmhhc2hjaGFuZ2VEZWxheSB0byA8alF1ZXJ5LmZuLmhhc2hjaGFuZ2UuZGVsYXk+IGFuZFxuLy8gICAgICAgICBsb3dlcmVkIGl0cyBkZWZhdWx0IHZhbHVlIHRvIDUwLiBBZGRlZCA8alF1ZXJ5LmZuLmhhc2hjaGFuZ2UuZG9tYWluPlxuLy8gICAgICAgICBhbmQgPGpRdWVyeS5mbi5oYXNoY2hhbmdlLnNyYz4gcHJvcGVydGllcyBwbHVzIGRvY3VtZW50LWRvbWFpbi5odG1sXG4vLyAgICAgICAgIGZpbGUgdG8gYWRkcmVzcyBhY2Nlc3MgZGVuaWVkIGlzc3VlcyB3aGVuIHNldHRpbmcgZG9jdW1lbnQuZG9tYWluIGluXG4vLyAgICAgICAgIElFNi83LlxuLy8gMS4yICAgLSAoMi8xMS8yMDEwKSBGaXhlZCBhIGJ1ZyB3aGVyZSBjb21pbmcgYmFjayB0byBhIHBhZ2UgdXNpbmcgdGhpcyBwbHVnaW5cbi8vICAgICAgICAgZnJvbSBhIHBhZ2Ugb24gYW5vdGhlciBkb21haW4gd291bGQgY2F1c2UgYW4gZXJyb3IgaW4gU2FmYXJpIDQuIEFsc28sXG4vLyAgICAgICAgIElFNi83IElmcmFtZSBpcyBub3cgaW5zZXJ0ZWQgYWZ0ZXIgdGhlIGJvZHkgKHRoaXMgYWN0dWFsbHkgd29ya3MpLFxuLy8gICAgICAgICB3aGljaCBwcmV2ZW50cyB0aGUgcGFnZSBmcm9tIHNjcm9sbGluZyB3aGVuIHRoZSBldmVudCBpcyBmaXJzdCBib3VuZC5cbi8vICAgICAgICAgRXZlbnQgY2FuIGFsc28gbm93IGJlIGJvdW5kIGJlZm9yZSBET00gcmVhZHksIGJ1dCBpdCB3b24ndCBiZSB1c2FibGVcbi8vICAgICAgICAgYmVmb3JlIHRoZW4gaW4gSUU2LzcuXG4vLyAxLjEgICAtICgxLzIxLzIwMTApIEluY29ycG9yYXRlZCBkb2N1bWVudC5kb2N1bWVudE1vZGUgdGVzdCB0byBmaXggSUU4IGJ1Z1xuLy8gICAgICAgICB3aGVyZSBicm93c2VyIHZlcnNpb24gaXMgaW5jb3JyZWN0bHkgcmVwb3J0ZWQgYXMgOC4wLCBkZXNwaXRlXG4vLyAgICAgICAgIGluY2x1c2lvbiBvZiB0aGUgWC1VQS1Db21wYXRpYmxlIElFPUVtdWxhdGVJRTcgbWV0YSB0YWcuXG4vLyAxLjAgICAtICgxLzkvMjAxMCkgSW5pdGlhbCBSZWxlYXNlLiBCcm9rZSBvdXQgdGhlIGpRdWVyeSBCQlEgZXZlbnQuc3BlY2lhbFxuLy8gICAgICAgICB3aW5kb3cub25oYXNoY2hhbmdlIGZ1bmN0aW9uYWxpdHkgaW50byBhIHNlcGFyYXRlIHBsdWdpbiBmb3IgdXNlcnNcbi8vICAgICAgICAgd2hvIHdhbnQganVzdCB0aGUgYmFzaWMgZXZlbnQgJiBiYWNrIGJ1dHRvbiBzdXBwb3J0LCB3aXRob3V0IGFsbCB0aGVcbi8vICAgICAgICAgZXh0cmEgYXdlc29tZW5lc3MgdGhhdCBCQlEgcHJvdmlkZXMuIFRoaXMgcGx1Z2luIHdpbGwgYmUgaW5jbHVkZWQgYXNcbi8vICAgICAgICAgcGFydCBvZiBqUXVlcnkgQkJRLCBidXQgYWxzbyBiZSBhdmFpbGFibGUgc2VwYXJhdGVseS5cblxuKGZ1bmN0aW9uKCQsd2luZG93LHVuZGVmaW5lZCl7XG4gICckOm5vbXVuZ2UnOyAvLyBVc2VkIGJ5IFlVSSBjb21wcmVzc29yLlxuICBcbiAgLy8gUmV1c2VkIHN0cmluZy5cbiAgdmFyIHN0cl9oYXNoY2hhbmdlID0gJ2hhc2hjaGFuZ2UnLFxuICAgIFxuICAgIC8vIE1ldGhvZCAvIG9iamVjdCByZWZlcmVuY2VzLlxuICAgIGRvYyA9IGRvY3VtZW50LFxuICAgIGZha2Vfb25oYXNoY2hhbmdlLFxuICAgIHNwZWNpYWwgPSAkLmV2ZW50LnNwZWNpYWwsXG4gICAgXG4gICAgLy8gRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IHdpbmRvdy5vbmhhc2hjaGFuZ2U/IE5vdGUgdGhhdCBJRTggcnVubmluZyBpblxuICAgIC8vIElFNyBjb21wYXRpYmlsaXR5IG1vZGUgcmVwb3J0cyB0cnVlIGZvciAnb25oYXNoY2hhbmdlJyBpbiB3aW5kb3csIGV2ZW5cbiAgICAvLyB0aG91Z2ggdGhlIGV2ZW50IGlzbid0IHN1cHBvcnRlZCwgc28gYWxzbyB0ZXN0IGRvY3VtZW50LmRvY3VtZW50TW9kZS5cbiAgICBkb2NfbW9kZSA9IGRvYy5kb2N1bWVudE1vZGUsXG4gICAgc3VwcG9ydHNfb25oYXNoY2hhbmdlID0gJ29uJyArIHN0cl9oYXNoY2hhbmdlIGluIHdpbmRvdyAmJiAoIGRvY19tb2RlID09PSB1bmRlZmluZWQgfHwgZG9jX21vZGUgPiA3ICk7XG4gIFxuICAvLyBHZXQgbG9jYXRpb24uaGFzaCAob3Igd2hhdCB5b3UnZCBleHBlY3QgbG9jYXRpb24uaGFzaCB0byBiZSkgc2FucyBhbnlcbiAgLy8gbGVhZGluZyAjLiBUaGFua3MgZm9yIG1ha2luZyB0aGlzIG5lY2Vzc2FyeSwgRmlyZWZveCFcbiAgZnVuY3Rpb24gZ2V0X2ZyYWdtZW50KCB1cmwgKSB7XG4gICAgdXJsID0gdXJsIHx8IGxvY2F0aW9uLmhyZWY7XG4gICAgcmV0dXJuICcjJyArIHVybC5yZXBsYWNlKCAvXlteI10qIz8oLiopJC8sICckMScgKTtcbiAgfTtcbiAgXG4gIC8vIE1ldGhvZDogalF1ZXJ5LmZuLmhhc2hjaGFuZ2VcbiAgLy8gXG4gIC8vIEJpbmQgYSBoYW5kbGVyIHRvIHRoZSB3aW5kb3cub25oYXNoY2hhbmdlIGV2ZW50IG9yIHRyaWdnZXIgYWxsIGJvdW5kXG4gIC8vIHdpbmRvdy5vbmhhc2hjaGFuZ2UgZXZlbnQgaGFuZGxlcnMuIFRoaXMgYmVoYXZpb3IgaXMgY29uc2lzdGVudCB3aXRoXG4gIC8vIGpRdWVyeSdzIGJ1aWx0LWluIGV2ZW50IGhhbmRsZXJzLlxuICAvLyBcbiAgLy8gVXNhZ2U6XG4gIC8vIFxuICAvLyA+IGpRdWVyeSh3aW5kb3cpLmhhc2hjaGFuZ2UoIFsgaGFuZGxlciBdICk7XG4gIC8vIFxuICAvLyBBcmd1bWVudHM6XG4gIC8vIFxuICAvLyAgaGFuZGxlciAtIChGdW5jdGlvbikgT3B0aW9uYWwgaGFuZGxlciB0byBiZSBib3VuZCB0byB0aGUgaGFzaGNoYW5nZVxuICAvLyAgICBldmVudC4gVGhpcyBpcyBhIFwic2hvcnRjdXRcIiBmb3IgdGhlIG1vcmUgdmVyYm9zZSBmb3JtOlxuICAvLyAgICBqUXVlcnkod2luZG93KS5iaW5kKCAnaGFzaGNoYW5nZScsIGhhbmRsZXIgKS4gSWYgaGFuZGxlciBpcyBvbWl0dGVkLFxuICAvLyAgICBhbGwgYm91bmQgd2luZG93Lm9uaGFzaGNoYW5nZSBldmVudCBoYW5kbGVycyB3aWxsIGJlIHRyaWdnZXJlZC4gVGhpc1xuICAvLyAgICBpcyBhIHNob3J0Y3V0IGZvciB0aGUgbW9yZSB2ZXJib3NlXG4gIC8vICAgIGpRdWVyeSh3aW5kb3cpLnRyaWdnZXIoICdoYXNoY2hhbmdlJyApLiBUaGVzZSBmb3JtcyBhcmUgZGVzY3JpYmVkIGluXG4gIC8vICAgIHRoZSA8aGFzaGNoYW5nZSBldmVudD4gc2VjdGlvbi5cbiAgLy8gXG4gIC8vIFJldHVybnM6XG4gIC8vIFxuICAvLyAgKGpRdWVyeSkgVGhlIGluaXRpYWwgalF1ZXJ5IGNvbGxlY3Rpb24gb2YgZWxlbWVudHMuXG4gIFxuICAvLyBBbGxvdyB0aGUgXCJzaG9ydGN1dFwiIGZvcm1hdCAkKGVsZW0pLmhhc2hjaGFuZ2UoIGZuICkgZm9yIGJpbmRpbmcgYW5kXG4gIC8vICQoZWxlbSkuaGFzaGNoYW5nZSgpIGZvciB0cmlnZ2VyaW5nLCBsaWtlIGpRdWVyeSBkb2VzIGZvciBidWlsdC1pbiBldmVudHMuXG4gICQuZm5bIHN0cl9oYXNoY2hhbmdlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG4gICAgcmV0dXJuIGZuID8gdGhpcy5iaW5kKCBzdHJfaGFzaGNoYW5nZSwgZm4gKSA6IHRoaXMudHJpZ2dlciggc3RyX2hhc2hjaGFuZ2UgKTtcbiAgfTtcbiAgXG4gIC8vIFByb3BlcnR5OiBqUXVlcnkuZm4uaGFzaGNoYW5nZS5kZWxheVxuICAvLyBcbiAgLy8gVGhlIG51bWVyaWMgaW50ZXJ2YWwgKGluIG1pbGxpc2Vjb25kcykgYXQgd2hpY2ggdGhlIDxoYXNoY2hhbmdlIGV2ZW50PlxuICAvLyBwb2xsaW5nIGxvb3AgZXhlY3V0ZXMuIERlZmF1bHRzIHRvIDUwLlxuICBcbiAgLy8gUHJvcGVydHk6IGpRdWVyeS5mbi5oYXNoY2hhbmdlLmRvbWFpblxuICAvLyBcbiAgLy8gSWYgeW91J3JlIHNldHRpbmcgZG9jdW1lbnQuZG9tYWluIGluIHlvdXIgSmF2YVNjcmlwdCwgYW5kIHlvdSB3YW50IGhhc2hcbiAgLy8gaGlzdG9yeSB0byB3b3JrIGluIElFNi83LCBub3Qgb25seSBtdXN0IHRoaXMgcHJvcGVydHkgYmUgc2V0LCBidXQgeW91IG11c3RcbiAgLy8gYWxzbyBzZXQgZG9jdW1lbnQuZG9tYWluIEJFRk9SRSBqUXVlcnkgaXMgbG9hZGVkIGludG8gdGhlIHBhZ2UuIFRoaXNcbiAgLy8gcHJvcGVydHkgaXMgb25seSBhcHBsaWNhYmxlIGlmIHlvdSBhcmUgc3VwcG9ydGluZyBJRTYvNyAob3IgSUU4IG9wZXJhdGluZ1xuICAvLyBpbiBcIklFNyBjb21wYXRpYmlsaXR5XCIgbW9kZSkuXG4gIC8vIFxuICAvLyBJbiBhZGRpdGlvbiwgdGhlIDxqUXVlcnkuZm4uaGFzaGNoYW5nZS5zcmM+IHByb3BlcnR5IG11c3QgYmUgc2V0IHRvIHRoZVxuICAvLyBwYXRoIG9mIHRoZSBpbmNsdWRlZCBcImRvY3VtZW50LWRvbWFpbi5odG1sXCIgZmlsZSwgd2hpY2ggY2FuIGJlIHJlbmFtZWQgb3JcbiAgLy8gbW9kaWZpZWQgaWYgbmVjZXNzYXJ5IChub3RlIHRoYXQgdGhlIGRvY3VtZW50LmRvbWFpbiBzcGVjaWZpZWQgbXVzdCBiZSB0aGVcbiAgLy8gc2FtZSBpbiBib3RoIHlvdXIgbWFpbiBKYXZhU2NyaXB0IGFzIHdlbGwgYXMgaW4gdGhpcyBmaWxlKS5cbiAgLy8gXG4gIC8vIFVzYWdlOlxuICAvLyBcbiAgLy8galF1ZXJ5LmZuLmhhc2hjaGFuZ2UuZG9tYWluID0gZG9jdW1lbnQuZG9tYWluO1xuICBcbiAgLy8gUHJvcGVydHk6IGpRdWVyeS5mbi5oYXNoY2hhbmdlLnNyY1xuICAvLyBcbiAgLy8gSWYsIGZvciBzb21lIHJlYXNvbiwgeW91IG5lZWQgdG8gc3BlY2lmeSBhbiBJZnJhbWUgc3JjIGZpbGUgKGZvciBleGFtcGxlLFxuICAvLyB3aGVuIHNldHRpbmcgZG9jdW1lbnQuZG9tYWluIGFzIGluIDxqUXVlcnkuZm4uaGFzaGNoYW5nZS5kb21haW4+KSwgeW91IGNhblxuICAvLyBkbyBzbyB1c2luZyB0aGlzIHByb3BlcnR5LiBOb3RlIHRoYXQgd2hlbiB1c2luZyB0aGlzIHByb3BlcnR5LCBoaXN0b3J5XG4gIC8vIHdvbid0IGJlIHJlY29yZGVkIGluIElFNi83IHVudGlsIHRoZSBJZnJhbWUgc3JjIGZpbGUgbG9hZHMuIFRoaXMgcHJvcGVydHlcbiAgLy8gaXMgb25seSBhcHBsaWNhYmxlIGlmIHlvdSBhcmUgc3VwcG9ydGluZyBJRTYvNyAob3IgSUU4IG9wZXJhdGluZyBpbiBcIklFN1xuICAvLyBjb21wYXRpYmlsaXR5XCIgbW9kZSkuXG4gIC8vIFxuICAvLyBVc2FnZTpcbiAgLy8gXG4gIC8vIGpRdWVyeS5mbi5oYXNoY2hhbmdlLnNyYyA9ICdwYXRoL3RvL2ZpbGUuaHRtbCc7XG4gIFxuICAkLmZuWyBzdHJfaGFzaGNoYW5nZSBdLmRlbGF5ID0gNTA7XG4gIC8qXG4gICQuZm5bIHN0cl9oYXNoY2hhbmdlIF0uZG9tYWluID0gbnVsbDtcbiAgJC5mblsgc3RyX2hhc2hjaGFuZ2UgXS5zcmMgPSBudWxsO1xuICAqL1xuICBcbiAgLy8gRXZlbnQ6IGhhc2hjaGFuZ2UgZXZlbnRcbiAgLy8gXG4gIC8vIEZpcmVkIHdoZW4gbG9jYXRpb24uaGFzaCBjaGFuZ2VzLiBJbiBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQsIHRoZSBuYXRpdmVcbiAgLy8gSFRNTDUgd2luZG93Lm9uaGFzaGNoYW5nZSBldmVudCBpcyB1c2VkLCBvdGhlcndpc2UgYSBwb2xsaW5nIGxvb3AgaXNcbiAgLy8gaW5pdGlhbGl6ZWQsIHJ1bm5pbmcgZXZlcnkgPGpRdWVyeS5mbi5oYXNoY2hhbmdlLmRlbGF5PiBtaWxsaXNlY29uZHMgdG9cbiAgLy8gc2VlIGlmIHRoZSBoYXNoIGhhcyBjaGFuZ2VkLiBJbiBJRTYvNyAoYW5kIElFOCBvcGVyYXRpbmcgaW4gXCJJRTdcbiAgLy8gY29tcGF0aWJpbGl0eVwiIG1vZGUpLCBhIGhpZGRlbiBJZnJhbWUgaXMgY3JlYXRlZCB0byBhbGxvdyB0aGUgYmFjayBidXR0b25cbiAgLy8gYW5kIGhhc2gtYmFzZWQgaGlzdG9yeSB0byB3b3JrLlxuICAvLyBcbiAgLy8gVXNhZ2UgYXMgZGVzY3JpYmVkIGluIDxqUXVlcnkuZm4uaGFzaGNoYW5nZT46XG4gIC8vIFxuICAvLyA+IC8vIEJpbmQgYW4gZXZlbnQgaGFuZGxlci5cbiAgLy8gPiBqUXVlcnkod2luZG93KS5oYXNoY2hhbmdlKCBmdW5jdGlvbihlKSB7XG4gIC8vID4gICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gIC8vID4gICAuLi5cbiAgLy8gPiB9KTtcbiAgLy8gPiBcbiAgLy8gPiAvLyBNYW51YWxseSB0cmlnZ2VyIHRoZSBldmVudCBoYW5kbGVyLlxuICAvLyA+IGpRdWVyeSh3aW5kb3cpLmhhc2hjaGFuZ2UoKTtcbiAgLy8gXG4gIC8vIEEgbW9yZSB2ZXJib3NlIHVzYWdlIHRoYXQgYWxsb3dzIGZvciBldmVudCBuYW1lc3BhY2luZzpcbiAgLy8gXG4gIC8vID4gLy8gQmluZCBhbiBldmVudCBoYW5kbGVyLlxuICAvLyA+IGpRdWVyeSh3aW5kb3cpLmJpbmQoICdoYXNoY2hhbmdlJywgZnVuY3Rpb24oZSkge1xuICAvLyA+ICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuICAvLyA+ICAgLi4uXG4gIC8vID4gfSk7XG4gIC8vID4gXG4gIC8vID4gLy8gTWFudWFsbHkgdHJpZ2dlciB0aGUgZXZlbnQgaGFuZGxlci5cbiAgLy8gPiBqUXVlcnkod2luZG93KS50cmlnZ2VyKCAnaGFzaGNoYW5nZScgKTtcbiAgLy8gXG4gIC8vIEFkZGl0aW9uYWwgTm90ZXM6XG4gIC8vIFxuICAvLyAqIFRoZSBwb2xsaW5nIGxvb3AgYW5kIElmcmFtZSBhcmUgbm90IGNyZWF0ZWQgdW50aWwgYXQgbGVhc3Qgb25lIGhhbmRsZXJcbiAgLy8gICBpcyBhY3R1YWxseSBib3VuZCB0byB0aGUgJ2hhc2hjaGFuZ2UnIGV2ZW50LlxuICAvLyAqIElmIHlvdSBuZWVkIHRoZSBib3VuZCBoYW5kbGVyKHMpIHRvIGV4ZWN1dGUgaW1tZWRpYXRlbHksIGluIGNhc2VzIHdoZXJlXG4gIC8vICAgYSBsb2NhdGlvbi5oYXNoIGV4aXN0cyBvbiBwYWdlIGxvYWQsIHZpYSBib29rbWFyayBvciBwYWdlIHJlZnJlc2ggZm9yXG4gIC8vICAgZXhhbXBsZSwgdXNlIGpRdWVyeSh3aW5kb3cpLmhhc2hjaGFuZ2UoKSBvciB0aGUgbW9yZSB2ZXJib3NlIFxuICAvLyAgIGpRdWVyeSh3aW5kb3cpLnRyaWdnZXIoICdoYXNoY2hhbmdlJyApLlxuICAvLyAqIFRoZSBldmVudCBjYW4gYmUgYm91bmQgYmVmb3JlIERPTSByZWFkeSwgYnV0IHNpbmNlIGl0IHdvbid0IGJlIHVzYWJsZVxuICAvLyAgIGJlZm9yZSB0aGVuIGluIElFNi83IChkdWUgdG8gdGhlIG5lY2Vzc2FyeSBJZnJhbWUpLCByZWNvbW1lbmRlZCB1c2FnZSBpc1xuICAvLyAgIHRvIGJpbmQgaXQgaW5zaWRlIGEgRE9NIHJlYWR5IGhhbmRsZXIuXG4gIFxuICAvLyBPdmVycmlkZSBleGlzdGluZyAkLmV2ZW50LnNwZWNpYWwuaGFzaGNoYW5nZSBtZXRob2RzIChhbGxvd2luZyB0aGlzIHBsdWdpblxuICAvLyB0byBiZSBkZWZpbmVkIGFmdGVyIGpRdWVyeSBCQlEgaW4gQkJRJ3Mgc291cmNlIGNvZGUpLlxuICBzcGVjaWFsWyBzdHJfaGFzaGNoYW5nZSBdID0gJC5leHRlbmQoIHNwZWNpYWxbIHN0cl9oYXNoY2hhbmdlIF0sIHtcbiAgICBcbiAgICAvLyBDYWxsZWQgb25seSB3aGVuIHRoZSBmaXJzdCAnaGFzaGNoYW5nZScgZXZlbnQgaXMgYm91bmQgdG8gd2luZG93LlxuICAgIHNldHVwOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIElmIHdpbmRvdy5vbmhhc2hjaGFuZ2UgaXMgc3VwcG9ydGVkIG5hdGl2ZWx5LCB0aGVyZSdzIG5vdGhpbmcgdG8gZG8uLlxuICAgICAgaWYgKCBzdXBwb3J0c19vbmhhc2hjaGFuZ2UgKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgXG4gICAgICAvLyBPdGhlcndpc2UsIHdlIG5lZWQgdG8gY3JlYXRlIG91ciBvd24uIEFuZCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhpc1xuICAgICAgLy8gdW50aWwgdGhlIHVzZXIgYmluZHMgdG8gdGhlIGV2ZW50LCBqdXN0IGluIGNhc2UgdGhleSBuZXZlciBkbywgc2luY2UgaXRcbiAgICAgIC8vIHdpbGwgY3JlYXRlIGEgcG9sbGluZyBsb29wIGFuZCBwb3NzaWJseSBldmVuIGEgaGlkZGVuIElmcmFtZS5cbiAgICAgICQoIGZha2Vfb25oYXNoY2hhbmdlLnN0YXJ0ICk7XG4gICAgfSxcbiAgICBcbiAgICAvLyBDYWxsZWQgb25seSB3aGVuIHRoZSBsYXN0ICdoYXNoY2hhbmdlJyBldmVudCBpcyB1bmJvdW5kIGZyb20gd2luZG93LlxuICAgIHRlYXJkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIElmIHdpbmRvdy5vbmhhc2hjaGFuZ2UgaXMgc3VwcG9ydGVkIG5hdGl2ZWx5LCB0aGVyZSdzIG5vdGhpbmcgdG8gZG8uLlxuICAgICAgaWYgKCBzdXBwb3J0c19vbmhhc2hjaGFuZ2UgKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgXG4gICAgICAvLyBPdGhlcndpc2UsIHdlIG5lZWQgdG8gc3RvcCBvdXJzIChpZiBwb3NzaWJsZSkuXG4gICAgICAkKCBmYWtlX29uaGFzaGNoYW5nZS5zdG9wICk7XG4gICAgfVxuICAgIFxuICB9KTtcbiAgXG4gIC8vIGZha2Vfb25oYXNoY2hhbmdlIGRvZXMgYWxsIHRoZSB3b3JrIG9mIHRyaWdnZXJpbmcgdGhlIHdpbmRvdy5vbmhhc2hjaGFuZ2VcbiAgLy8gZXZlbnQgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdCwgaW5jbHVkaW5nIGNyZWF0aW5nIGFcbiAgLy8gcG9sbGluZyBsb29wIHRvIHdhdGNoIGZvciBoYXNoIGNoYW5nZXMgYW5kIGluIElFIDYvNyBjcmVhdGluZyBhIGhpZGRlblxuICAvLyBJZnJhbWUgdG8gZW5hYmxlIGJhY2sgYW5kIGZvcndhcmQuXG4gIGZha2Vfb25oYXNoY2hhbmdlID0gKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHNlbGYgPSB7fSxcbiAgICAgIHRpbWVvdXRfaWQsXG4gICAgICBcbiAgICAgIC8vIFJlbWVtYmVyIHRoZSBpbml0aWFsIGhhc2ggc28gaXQgZG9lc24ndCBnZXQgdHJpZ2dlcmVkIGltbWVkaWF0ZWx5LlxuICAgICAgbGFzdF9oYXNoID0gZ2V0X2ZyYWdtZW50KCksXG4gICAgICBcbiAgICAgIGZuX3JldHZhbCA9IGZ1bmN0aW9uKHZhbCl7IHJldHVybiB2YWw7IH0sXG4gICAgICBoaXN0b3J5X3NldCA9IGZuX3JldHZhbCxcbiAgICAgIGhpc3RvcnlfZ2V0ID0gZm5fcmV0dmFsO1xuICAgIFxuICAgIC8vIFN0YXJ0IHRoZSBwb2xsaW5nIGxvb3AuXG4gICAgc2VsZi5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGltZW91dF9pZCB8fCBwb2xsKCk7XG4gICAgfTtcbiAgICBcbiAgICAvLyBTdG9wIHRoZSBwb2xsaW5nIGxvb3AuXG4gICAgc2VsZi5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aW1lb3V0X2lkICYmIGNsZWFyVGltZW91dCggdGltZW91dF9pZCApO1xuICAgICAgdGltZW91dF9pZCA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFxuICAgIC8vIFRoaXMgcG9sbGluZyBsb29wIGNoZWNrcyBldmVyeSAkLmZuLmhhc2hjaGFuZ2UuZGVsYXkgbWlsbGlzZWNvbmRzIHRvIHNlZVxuICAgIC8vIGlmIGxvY2F0aW9uLmhhc2ggaGFzIGNoYW5nZWQsIGFuZCB0cmlnZ2VycyB0aGUgJ2hhc2hjaGFuZ2UnIGV2ZW50IG9uXG4gICAgLy8gd2luZG93IHdoZW4gbmVjZXNzYXJ5LlxuICAgIGZ1bmN0aW9uIHBvbGwoKSB7XG4gICAgICB2YXIgaGFzaCA9IGdldF9mcmFnbWVudCgpLFxuICAgICAgICBoaXN0b3J5X2hhc2ggPSBoaXN0b3J5X2dldCggbGFzdF9oYXNoICk7XG4gICAgICBcbiAgICAgIGlmICggaGFzaCAhPT0gbGFzdF9oYXNoICkge1xuICAgICAgICBoaXN0b3J5X3NldCggbGFzdF9oYXNoID0gaGFzaCwgaGlzdG9yeV9oYXNoICk7XG4gICAgICAgIFxuICAgICAgICAkKHdpbmRvdykudHJpZ2dlciggc3RyX2hhc2hjaGFuZ2UgKTtcbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYgKCBoaXN0b3J5X2hhc2ggIT09IGxhc3RfaGFzaCApIHtcbiAgICAgICAgbG9jYXRpb24uaHJlZiA9IGxvY2F0aW9uLmhyZWYucmVwbGFjZSggLyMuKi8sICcnICkgKyBoaXN0b3J5X2hhc2g7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRpbWVvdXRfaWQgPSBzZXRUaW1lb3V0KCBwb2xsLCAkLmZuWyBzdHJfaGFzaGNoYW5nZSBdLmRlbGF5ICk7XG4gICAgfTtcbiAgICBcbiAgICAvLyB2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZcbiAgICAvLyB2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2IFJFTU9WRSBJRiBOT1QgU1VQUE9SVElORyBJRTYvNy84IHZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZcbiAgICAvLyB2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZcbiAgICB3aW5kb3cuYXR0YWNoRXZlbnQgJiYgIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyICYmICFzdXBwb3J0c19vbmhhc2hjaGFuZ2UgJiYgKGZ1bmN0aW9uKCl7XG4gICAgICAvLyBOb3Qgb25seSBkbyBJRTYvNyBuZWVkIHRoZSBcIm1hZ2ljYWxcIiBJZnJhbWUgdHJlYXRtZW50LCBidXQgc28gZG9lcyBJRThcbiAgICAgIC8vIHdoZW4gcnVubmluZyBpbiBcIklFNyBjb21wYXRpYmlsaXR5XCIgbW9kZS5cbiAgICAgIFxuICAgICAgdmFyIGlmcmFtZSxcbiAgICAgICAgaWZyYW1lX3NyYztcbiAgICAgIFxuICAgICAgLy8gV2hlbiB0aGUgZXZlbnQgaXMgYm91bmQgYW5kIHBvbGxpbmcgc3RhcnRzIGluIElFIDYvNywgY3JlYXRlIGEgaGlkZGVuXG4gICAgICAvLyBJZnJhbWUgZm9yIGhpc3RvcnkgaGFuZGxpbmcuXG4gICAgICBzZWxmLnN0YXJ0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKCAhaWZyYW1lICkge1xuICAgICAgICAgIGlmcmFtZV9zcmMgPSAkLmZuWyBzdHJfaGFzaGNoYW5nZSBdLnNyYztcbiAgICAgICAgICBpZnJhbWVfc3JjID0gaWZyYW1lX3NyYyAmJiBpZnJhbWVfc3JjICsgZ2V0X2ZyYWdtZW50KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIGhpZGRlbiBJZnJhbWUuIEF0dGVtcHQgdG8gbWFrZSBJZnJhbWUgYXMgaGlkZGVuIGFzIHBvc3NpYmxlXG4gICAgICAgICAgLy8gYnkgdXNpbmcgdGVjaG5pcXVlcyBmcm9tIGh0dHA6Ly93d3cucGFjaWVsbG9ncm91cC5jb20vYmxvZy8/cD02MDQuXG4gICAgICAgICAgaWZyYW1lID0gJCgnPGlmcmFtZSB0YWJpbmRleD1cIi0xXCIgdGl0bGU9XCJlbXB0eVwiLz4nKS5oaWRlKClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gV2hlbiBJZnJhbWUgaGFzIGNvbXBsZXRlbHkgbG9hZGVkLCBpbml0aWFsaXplIHRoZSBoaXN0b3J5IGFuZFxuICAgICAgICAgICAgLy8gc3RhcnQgcG9sbGluZy5cbiAgICAgICAgICAgIC5vbmUoICdsb2FkJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgaWZyYW1lX3NyYyB8fCBoaXN0b3J5X3NldCggZ2V0X2ZyYWdtZW50KCkgKTtcbiAgICAgICAgICAgICAgcG9sbCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTG9hZCBJZnJhbWUgc3JjIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIG5vdGhpbmcuXG4gICAgICAgICAgICAuYXR0ciggJ3NyYycsIGlmcmFtZV9zcmMgfHwgJ2phdmFzY3JpcHQ6MCcgKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBcHBlbmQgSWZyYW1lIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGJvZHkgdG8gcHJldmVudCB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgLy8gaW5pdGlhbCBwYWdlIHNjcm9sbGluZyAoeWVzLCB0aGlzIHdvcmtzKS5cbiAgICAgICAgICAgIC5pbnNlcnRBZnRlciggJ2JvZHknIClbMF0uY29udGVudFdpbmRvdztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBXaGVuZXZlciBgZG9jdW1lbnQudGl0bGVgIGNoYW5nZXMsIHVwZGF0ZSB0aGUgSWZyYW1lJ3MgdGl0bGUgdG9cbiAgICAgICAgICAvLyBwcmV0dGlmeSB0aGUgYmFjay9uZXh0IGhpc3RvcnkgbWVudSBlbnRyaWVzLiBTaW5jZSBJRSBzb21ldGltZXNcbiAgICAgICAgICAvLyBlcnJvcnMgd2l0aCBcIlVuc3BlY2lmaWVkIGVycm9yXCIgdGhlIHZlcnkgZmlyc3QgdGltZSB0aGlzIGlzIHNldFxuICAgICAgICAgIC8vICh5ZXMsIHZlcnkgdXNlZnVsKSB3cmFwIHRoaXMgd2l0aCBhIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgICBkb2Mub25wcm9wZXJ0eWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIGV2ZW50LnByb3BlcnR5TmFtZSA9PT0gJ3RpdGxlJyApIHtcbiAgICAgICAgICAgICAgICBpZnJhbWUuZG9jdW1lbnQudGl0bGUgPSBkb2MudGl0bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBPdmVycmlkZSB0aGUgXCJzdG9wXCIgbWV0aG9kIHNpbmNlIGFuIElFNi83IElmcmFtZSB3YXMgY3JlYXRlZC4gRXZlblxuICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGxvbmdlciBhbnkgYm91bmQgZXZlbnQgaGFuZGxlcnMsIHRoZSBwb2xsaW5nIGxvb3BcbiAgICAgIC8vIGlzIHN0aWxsIG5lY2Vzc2FyeSBmb3IgYmFjay9uZXh0IHRvIHdvcmsgYXQgYWxsIVxuICAgICAgc2VsZi5zdG9wID0gZm5fcmV0dmFsO1xuICAgICAgXG4gICAgICAvLyBHZXQgaGlzdG9yeSBieSBsb29raW5nIGF0IHRoZSBoaWRkZW4gSWZyYW1lJ3MgbG9jYXRpb24uaGFzaC5cbiAgICAgIGhpc3RvcnlfZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRfZnJhZ21lbnQoIGlmcmFtZS5sb2NhdGlvbi5ocmVmICk7XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBTZXQgYSBuZXcgaGlzdG9yeSBpdGVtIGJ5IG9wZW5pbmcgYW5kIHRoZW4gY2xvc2luZyB0aGUgSWZyYW1lXG4gICAgICAvLyBkb2N1bWVudCwgKnRoZW4qIHNldHRpbmcgaXRzIGxvY2F0aW9uLmhhc2guIElmIGRvY3VtZW50LmRvbWFpbiBoYXNcbiAgICAgIC8vIGJlZW4gc2V0LCB1cGRhdGUgdGhhdCBhcyB3ZWxsLlxuICAgICAgaGlzdG9yeV9zZXQgPSBmdW5jdGlvbiggaGFzaCwgaGlzdG9yeV9oYXNoICkge1xuICAgICAgICB2YXIgaWZyYW1lX2RvYyA9IGlmcmFtZS5kb2N1bWVudCxcbiAgICAgICAgICBkb21haW4gPSAkLmZuWyBzdHJfaGFzaGNoYW5nZSBdLmRvbWFpbjtcbiAgICAgICAgXG4gICAgICAgIGlmICggaGFzaCAhPT0gaGlzdG9yeV9oYXNoICkge1xuICAgICAgICAgIC8vIFVwZGF0ZSBJZnJhbWUgd2l0aCBhbnkgaW5pdGlhbCBgZG9jdW1lbnQudGl0bGVgIHRoYXQgbWlnaHQgYmUgc2V0LlxuICAgICAgICAgIGlmcmFtZV9kb2MudGl0bGUgPSBkb2MudGl0bGU7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gT3BlbmluZyB0aGUgSWZyYW1lJ3MgZG9jdW1lbnQgYWZ0ZXIgaXQgaGFzIGJlZW4gY2xvc2VkIGlzIHdoYXRcbiAgICAgICAgICAvLyBhY3R1YWxseSBhZGRzIGEgaGlzdG9yeSBlbnRyeS5cbiAgICAgICAgICBpZnJhbWVfZG9jLm9wZW4oKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTZXQgZG9jdW1lbnQuZG9tYWluIGZvciB0aGUgSWZyYW1lIGRvY3VtZW50IGFzIHdlbGwsIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICBkb21haW4gJiYgaWZyYW1lX2RvYy53cml0ZSggJ1xceDNjc2NyaXB0PmRvY3VtZW50LmRvbWFpbj1cIicgKyBkb21haW4gKyAnXCJcXHgzYy9zY3JpcHQ+JyApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmcmFtZV9kb2MuY2xvc2UoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIElmcmFtZSdzIGhhc2gsIGZvciBncmVhdCBqdXN0aWNlLlxuICAgICAgICAgIGlmcmFtZS5sb2NhdGlvbi5oYXNoID0gaGFzaDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgIH0pKCk7XG4gICAgLy8gXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gXl5eXl5eXl5eXl5eXl5eXl5eXiBSRU1PVkUgSUYgTk9UIFNVUFBPUlRJTkcgSUU2LzcvOCBeXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgLy8gXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgXG4gICAgcmV0dXJuIHNlbGY7XG4gIH0pKCk7XG4gIFxufSkoalF1ZXJ5LHRoaXMpO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuXHQvKiEgbWF0Y2hNZWRpYSgpIHBvbHlmaWxsIC0gVGVzdCBhIENTUyBtZWRpYSB0eXBlL3F1ZXJ5IGluIEpTLiBBdXRob3JzICYgY29weXJpZ2h0IChjKSAyMDEyOiBTY290dCBKZWhsLCBQYXVsIElyaXNoLCBOaWNob2xhcyBaYWthcy4gRHVhbCBNSVQvQlNEIGxpY2Vuc2UgKi9cblx0d2luZG93Lm1hdGNoTWVkaWEgPSB3aW5kb3cubWF0Y2hNZWRpYSB8fCAoZnVuY3Rpb24oIGRvYywgdW5kZWZpbmVkICkge1xuXG5cdFx0dmFyIGJvb2wsXG5cdFx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudCxcblx0XHRcdHJlZk5vZGUgPSBkb2NFbGVtLmZpcnN0RWxlbWVudENoaWxkIHx8IGRvY0VsZW0uZmlyc3RDaGlsZCxcblx0XHRcdC8vIGZha2VCb2R5IHJlcXVpcmVkIGZvciA8RkY0IHdoZW4gZXhlY3V0ZWQgaW4gPGhlYWQ+XG5cdFx0XHRmYWtlQm9keSA9IGRvYy5jcmVhdGVFbGVtZW50KCBcImJvZHlcIiApLFxuXHRcdFx0ZGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHRcdGRpdi5pZCA9IFwibXEtdGVzdC0xXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO3RvcDotMTAwZW1cIjtcblx0XHRmYWtlQm9keS5zdHlsZS5iYWNrZ3JvdW5kID0gXCJub25lXCI7XG5cdFx0ZmFrZUJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcblxuXHRcdHJldHVybiBmdW5jdGlvbihxKXtcblxuXHRcdFx0ZGl2LmlubmVySFRNTCA9IFwiJnNoeTs8c3R5bGUgbWVkaWE9XFxcIlwiICsgcSArIFwiXFxcIj4gI21xLXRlc3QtMSB7IHdpZHRoOiA0MnB4OyB9PC9zdHlsZT5cIjtcblxuXHRcdFx0ZG9jRWxlbS5pbnNlcnRCZWZvcmUoIGZha2VCb2R5LCByZWZOb2RlICk7XG5cdFx0XHRib29sID0gZGl2Lm9mZnNldFdpZHRoID09PSA0Mjtcblx0XHRcdGRvY0VsZW0ucmVtb3ZlQ2hpbGQoIGZha2VCb2R5ICk7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG1hdGNoZXM6IGJvb2wsXG5cdFx0XHRcdG1lZGlhOiBxXG5cdFx0XHR9O1xuXG5cdFx0fTtcblxuXHR9KCBkb2N1bWVudCApKTtcblxuXHQvLyAkLm1vYmlsZS5tZWRpYSB1c2VzIG1hdGNoTWVkaWEgdG8gcmV0dXJuIGEgYm9vbGVhbi5cblx0JC5tb2JpbGUubWVkaWEgPSBmdW5jdGlvbiggcSApIHtcblx0XHRyZXR1cm4gd2luZG93Lm1hdGNoTWVkaWEoIHEgKS5tYXRjaGVzO1xuXHR9O1xuXG59KShqUXVlcnkpO1xuXG5cdChmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXHRcdHZhciBzdXBwb3J0ID0ge1xuXHRcdFx0dG91Y2g6IFwib250b3VjaGVuZFwiIGluIGRvY3VtZW50XG5cdFx0fTtcblxuXHRcdCQubW9iaWxlLnN1cHBvcnQgPSAkLm1vYmlsZS5zdXBwb3J0IHx8IHt9O1xuXHRcdCQuZXh0ZW5kKCAkLnN1cHBvcnQsIHN1cHBvcnQgKTtcblx0XHQkLmV4dGVuZCggJC5tb2JpbGUuc3VwcG9ydCwgc3VwcG9ydCApO1xuXHR9KCBqUXVlcnkgKSk7XG5cblx0KGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cdFx0JC5leHRlbmQoICQuc3VwcG9ydCwge1xuXHRcdFx0b3JpZW50YXRpb246IFwib3JpZW50YXRpb25cIiBpbiB3aW5kb3cgJiYgXCJvbm9yaWVudGF0aW9uY2hhbmdlXCIgaW4gd2luZG93XG5cdFx0fSk7XG5cdH0oIGpRdWVyeSApKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbi8vIHRoeCBNb2Rlcm5penJcbmZ1bmN0aW9uIHByb3BFeGlzdHMoIHByb3AgKSB7XG5cdHZhciB1Y19wcm9wID0gcHJvcC5jaGFyQXQoIDAgKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zdWJzdHIoIDEgKSxcblx0XHRwcm9wcyA9ICggcHJvcCArIFwiIFwiICsgdmVuZG9ycy5qb2luKCB1Y19wcm9wICsgXCIgXCIgKSArIHVjX3Byb3AgKS5zcGxpdCggXCIgXCIgKSxcblx0XHR2O1xuXG5cdGZvciAoIHYgaW4gcHJvcHMgKSB7XG5cdFx0aWYgKCBmYkNTU1sgcHJvcHNbIHYgXSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cbn1cblxudmFyIGZha2VCb2R5ID0gJCggXCI8Ym9keT5cIiApLnByZXBlbmRUbyggXCJodG1sXCIgKSxcblx0ZmJDU1MgPSBmYWtlQm9keVsgMCBdLnN0eWxlLFxuXHR2ZW5kb3JzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIk9cIiBdLFxuXHR3ZWJvcyA9IFwicGFsbUdldFJlc291cmNlXCIgaW4gd2luZG93LCAvL29ubHkgdXNlZCB0byBydWxlIG91dCBzY3JvbGxUb3Bcblx0b3BlcmFtaW5pID0gd2luZG93Lm9wZXJhbWluaSAmJiAoe30pLnRvU3RyaW5nLmNhbGwoIHdpbmRvdy5vcGVyYW1pbmkgKSA9PT0gXCJbb2JqZWN0IE9wZXJhTWluaV1cIixcblx0YmIgPSB3aW5kb3cuYmxhY2tiZXJyeSAmJiAhcHJvcEV4aXN0cyggXCItd2Via2l0LXRyYW5zZm9ybVwiICksIC8vb25seSB1c2VkIHRvIHJ1bGUgb3V0IGJveCBzaGFkb3csIGFzIGl0J3MgZmlsbGVkIG9wYXF1ZSBvbiBCQiA1IGFuZCBsb3dlclxuXHRub2tpYUxURTdfMztcblxuLy8gaW5saW5lIFNWRyBzdXBwb3J0IHRlc3RcbmZ1bmN0aW9uIGlubGluZVNWRygpIHtcblx0Ly8gVGhhbmtzIE1vZGVybml6ciAmIEVyaWsgRGFobHN0cm9tXG5cdHZhciB3ID0gd2luZG93LFxuXHRcdHN2ZyA9ICEhdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgISF3LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiICkuY3JlYXRlU1ZHUmVjdCAmJiAhKCB3Lm9wZXJhICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZiggXCJDaHJvbWVcIiApID09PSAtMSApLFxuXHRcdHN1cHBvcnQgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdGlmICggISggZGF0YSAmJiBzdmcgKSApIHtcblx0XHRcdFx0JCggXCJodG1sXCIgKS5hZGRDbGFzcyggXCJ1aS1ub3N2Z1wiICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRpbWcgPSBuZXcgdy5JbWFnZSgpO1xuXG5cdGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0c3VwcG9ydCggZmFsc2UgKTtcblx0fTtcblx0aW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHN1cHBvcnQoIGltZy53aWR0aCA9PT0gMSAmJiBpbWcuaGVpZ2h0ID09PSAxICk7XG5cdH07XG5cdGltZy5zcmMgPSBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veXdBQUFBQUFRQUJBQUFDQVV3QU93PT1cIjtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtM2RUZXN0KCkge1xuXHR2YXIgbXFQcm9wID0gXCJ0cmFuc2Zvcm0tM2RcIixcblx0XHQvLyBCZWNhdXNlIHRoZSBgdHJhbnNsYXRlM2RgIHRlc3QgYmVsb3cgdGhyb3dzIGZhbHNlIHBvc2l0aXZlcyBpbiBBbmRyb2lkOlxuXHRcdHJldCA9ICQubW9iaWxlLm1lZGlhKCBcIigtXCIgKyB2ZW5kb3JzLmpvaW4oIFwiLVwiICsgbXFQcm9wICsgXCIpLCgtXCIgKSArIFwiLVwiICsgbXFQcm9wICsgXCIpLChcIiArIG1xUHJvcCArIFwiKVwiICksXG5cdFx0ZWwsIHRyYW5zZm9ybXMsIHQ7XG5cblx0aWYgKCByZXQgKSB7XG5cdFx0cmV0dXJuICEhcmV0O1xuXHR9XG5cblx0ZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cdHRyYW5zZm9ybXMgPSB7XG5cdFx0Ly8gV2XigJlyZSBvbWl0dGluZyBPcGVyYSBmb3IgdGhlIHRpbWUgYmVpbmc7IE1TIHVzZXMgdW5wcmVmaXhlZC5cblx0XHRcIk1velRyYW5zZm9ybVwiOiBcIi1tb3otdHJhbnNmb3JtXCIsXG5cdFx0XCJ0cmFuc2Zvcm1cIjogXCJ0cmFuc2Zvcm1cIlxuXHR9O1xuXG5cdGZha2VCb2R5LmFwcGVuZCggZWwgKTtcblxuXHRmb3IgKCB0IGluIHRyYW5zZm9ybXMgKSB7XG5cdFx0aWYgKCBlbC5zdHlsZVsgdCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRlbC5zdHlsZVsgdCBdID0gXCJ0cmFuc2xhdGUzZCggMTAwcHgsIDFweCwgMXB4IClcIjtcblx0XHRcdHJldCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBlbCApLmdldFByb3BlcnR5VmFsdWUoIHRyYW5zZm9ybXNbIHQgXSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gKCAhIXJldCAmJiByZXQgIT09IFwibm9uZVwiICk7XG59XG5cbi8vIFRlc3QgZm9yIGR5bmFtaWMtdXBkYXRpbmcgYmFzZSB0YWcgc3VwcG9ydCAoIGFsbG93cyB1cyB0byBhdm9pZCBocmVmLHNyYyBhdHRyIHJld3JpdGluZyApXG5mdW5jdGlvbiBiYXNlVGFnVGVzdCgpIHtcblx0dmFyIGZhdXhCYXNlID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0ICsgbG9jYXRpb24ucGF0aG5hbWUgKyBcInVpLWRpci9cIixcblx0XHRiYXNlID0gJCggXCJoZWFkIGJhc2VcIiApLFxuXHRcdGZhdXhFbGUgPSBudWxsLFxuXHRcdGhyZWYgPSBcIlwiLFxuXHRcdGxpbmssIHJlYmFzZTtcblxuXHRpZiAoICFiYXNlLmxlbmd0aCApIHtcblx0XHRiYXNlID0gZmF1eEVsZSA9ICQoIFwiPGJhc2U+XCIsIHsgXCJocmVmXCI6IGZhdXhCYXNlIH0pLmFwcGVuZFRvKCBcImhlYWRcIiApO1xuXHR9IGVsc2Uge1xuXHRcdGhyZWYgPSBiYXNlLmF0dHIoIFwiaHJlZlwiICk7XG5cdH1cblxuXHRsaW5rID0gJCggXCI8YSBocmVmPSd0ZXN0dXJsJyAvPlwiICkucHJlcGVuZFRvKCBmYWtlQm9keSApO1xuXHRyZWJhc2UgPSBsaW5rWyAwIF0uaHJlZjtcblx0YmFzZVsgMCBdLmhyZWYgPSBocmVmIHx8IGxvY2F0aW9uLnBhdGhuYW1lO1xuXG5cdGlmICggZmF1eEVsZSApIHtcblx0XHRmYXV4RWxlLnJlbW92ZSgpO1xuXHR9XG5cdHJldHVybiByZWJhc2UuaW5kZXhPZiggZmF1eEJhc2UgKSA9PT0gMDtcbn1cblxuLy8gVGhhbmtzIE1vZGVybml6clxuZnVuY3Rpb24gY3NzUG9pbnRlckV2ZW50c1Rlc3QoKSB7XG5cdHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJ4XCIgKSxcblx0XHRkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cdFx0Z2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlLFxuXHRcdHN1cHBvcnRzO1xuXG5cdGlmICggISggXCJwb2ludGVyRXZlbnRzXCIgaW4gZWxlbWVudC5zdHlsZSApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuXHRlbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcInhcIjtcblx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBlbGVtZW50ICk7XG5cdHN1cHBvcnRzID0gZ2V0Q29tcHV0ZWRTdHlsZSAmJlxuXHRnZXRDb21wdXRlZFN0eWxlKCBlbGVtZW50LCBcIlwiICkucG9pbnRlckV2ZW50cyA9PT0gXCJhdXRvXCI7XG5cdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggZWxlbWVudCApO1xuXHRyZXR1cm4gISFzdXBwb3J0cztcbn1cblxuZnVuY3Rpb24gYm91bmRpbmdSZWN0KCkge1xuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXHRyZXR1cm4gdHlwZW9mIGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09IFwidW5kZWZpbmVkXCI7XG59XG5cbi8vIG5vbi1VQS1iYXNlZCBJRSB2ZXJzaW9uIGNoZWNrIGJ5IEphbWVzIFBhZG9sc2V5LCBtb2RpZmllZCBieSBqZGFsdG9uIC0gZnJvbSBodHRwOi8vZ2lzdC5naXRodWIuY29tLzUyNzY4M1xuLy8gYWxsb3dzIGZvciBpbmNsdXNpb24gb2YgSUUgNissIGluY2x1ZGluZyBXaW5kb3dzIE1vYmlsZSA3XG4kLmV4dGVuZCggJC5tb2JpbGUsIHsgYnJvd3Nlcjoge30gfSApO1xuJC5tb2JpbGUuYnJvd3Nlci5vbGRJRSA9IChmdW5jdGlvbigpIHtcblx0dmFyIHYgPSAzLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRhID0gZGl2LmFsbCB8fCBbXTtcblxuXHRkbyB7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiPCEtLVtpZiBndCBJRSBcIiArICggKyt2ICkgKyBcIl0+PGJyPjwhW2VuZGlmXS0tPlwiO1xuXHR9IHdoaWxlKCBhWzBdICk7XG5cblx0cmV0dXJuIHYgPiA0ID8gdiA6ICF2O1xufSkoKTtcblxuZnVuY3Rpb24gZml4ZWRQb3NpdGlvbigpIHtcblx0dmFyIHcgPSB3aW5kb3csXG5cdFx0dWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuXHRcdHBsYXRmb3JtID0gbmF2aWdhdG9yLnBsYXRmb3JtLFxuXHRcdC8vIFJlbmRlcmluZyBlbmdpbmUgaXMgV2Via2l0LCBhbmQgY2FwdHVyZSBtYWpvciB2ZXJzaW9uXG5cdFx0d2ttYXRjaCA9IHVhLm1hdGNoKCAvQXBwbGVXZWJLaXRcXC8oWzAtOV0rKS8gKSxcblx0XHR3a3ZlcnNpb24gPSAhIXdrbWF0Y2ggJiYgd2ttYXRjaFsgMSBdLFxuXHRcdGZmbWF0Y2ggPSB1YS5tYXRjaCggL0Zlbm5lY1xcLyhbMC05XSspLyApLFxuXHRcdGZmdmVyc2lvbiA9ICEhZmZtYXRjaCAmJiBmZm1hdGNoWyAxIF0sXG5cdFx0b3BlcmFtbW9iaWxlbWF0Y2ggPSB1YS5tYXRjaCggL09wZXJhIE1vYmlcXC8oWzAtOV0rKS8gKSxcblx0XHRvbXZlcnNpb24gPSAhIW9wZXJhbW1vYmlsZW1hdGNoICYmIG9wZXJhbW1vYmlsZW1hdGNoWyAxIF07XG5cblx0aWYgKFxuXHRcdC8vIGlPUyA0LjMgYW5kIG9sZGVyIDogUGxhdGZvcm0gaXMgaVBob25lL1BhZC9Ub3VjaCBhbmQgV2Via2l0IHZlcnNpb24gaXMgbGVzcyB0aGFuIDUzNCAoaW9zNSlcblx0XHQoICggcGxhdGZvcm0uaW5kZXhPZiggXCJpUGhvbmVcIiApID4gLTEgfHwgcGxhdGZvcm0uaW5kZXhPZiggXCJpUGFkXCIgKSA+IC0xICB8fCBwbGF0Zm9ybS5pbmRleE9mKCBcImlQb2RcIiApID4gLTEgKSAmJiB3a3ZlcnNpb24gJiYgd2t2ZXJzaW9uIDwgNTM0ICkgfHxcblx0XHQvLyBPcGVyYSBNaW5pXG5cdFx0KCB3Lm9wZXJhbWluaSAmJiAoe30pLnRvU3RyaW5nLmNhbGwoIHcub3BlcmFtaW5pICkgPT09IFwiW29iamVjdCBPcGVyYU1pbmldXCIgKSB8fFxuXHRcdCggb3BlcmFtbW9iaWxlbWF0Y2ggJiYgb212ZXJzaW9uIDwgNzQ1OCApXHR8fFxuXHRcdC8vQW5kcm9pZCBsdGUgMi4xOiBQbGF0Zm9ybSBpcyBBbmRyb2lkIGFuZCBXZWJraXQgdmVyc2lvbiBpcyBsZXNzIHRoYW4gNTMzIChBbmRyb2lkIDIuMilcblx0XHQoIHVhLmluZGV4T2YoIFwiQW5kcm9pZFwiICkgPiAtMSAmJiB3a3ZlcnNpb24gJiYgd2t2ZXJzaW9uIDwgNTMzICkgfHxcblx0XHQvLyBGaXJlZm94IE1vYmlsZSBiZWZvcmUgNi4wIC1cblx0XHQoIGZmdmVyc2lvbiAmJiBmZnZlcnNpb24gPCA2ICkgfHxcblx0XHQvLyBXZWJPUyBsZXNzIHRoYW4gM1xuXHRcdCggXCJwYWxtR2V0UmVzb3VyY2VcIiBpbiB3aW5kb3cgJiYgd2t2ZXJzaW9uICYmIHdrdmVyc2lvbiA8IDUzNCApXHR8fFxuXHRcdC8vIE1lZUdvXG5cdFx0KCB1YS5pbmRleE9mKCBcIk1lZUdvXCIgKSA+IC0xICYmIHVhLmluZGV4T2YoIFwiTm9raWFCcm93c2VyLzguNS4wXCIgKSA+IC0xICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59XG5cbiQuZXh0ZW5kKCAkLnN1cHBvcnQsIHtcblx0Ly8gTm90ZSwgQ2hyb21lIGZvciBpT1MgaGFzIGFuIGV4dHJlbWVseSBxdWlya3kgaW1wbGVtZW50YXRpb24gb2YgcG9wc3RhdGUuXG5cdC8vIFdlJ3ZlIGNob3NlbiB0byB0YWtlIHRoZSBzaG9ydGVzdCBwYXRoIHRvIGEgYnVnIGZpeCBoZXJlIGZvciBpc3N1ZSAjNTQyNlxuXHQvLyBTZWUgdGhlIGZvbGxvd2luZyBsaW5rIGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVnZXggY2hvc2VuXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2Nocm9tZS9tb2JpbGUvZG9jcy91c2VyLWFnZW50I2Nocm9tZV9mb3JfaW9zX3VzZXItYWdlbnRcblx0cHVzaFN0YXRlOiBcInB1c2hTdGF0ZVwiIGluIGhpc3RvcnkgJiZcblx0XHRcInJlcGxhY2VTdGF0ZVwiIGluIGhpc3RvcnkgJiZcblx0XHQvLyBXaGVuIHJ1bm5pbmcgaW5zaWRlIGEgRkYgaWZyYW1lLCBjYWxsaW5nIHJlcGxhY2VTdGF0ZSBjYXVzZXMgYW4gZXJyb3Jcblx0XHQhKCB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCBcIkZpcmVmb3hcIiApID49IDAgJiYgd2luZG93LnRvcCAhPT0gd2luZG93ICkgJiZcblx0XHQoIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnNlYXJjaCgvQ3JpT1MvKSA9PT0gLTEgKSxcblxuXHRtZWRpYXF1ZXJ5OiAkLm1vYmlsZS5tZWRpYSggXCJvbmx5IGFsbFwiICksXG5cdGNzc1BzZXVkb0VsZW1lbnQ6ICEhcHJvcEV4aXN0cyggXCJjb250ZW50XCIgKSxcblx0dG91Y2hPdmVyZmxvdzogISFwcm9wRXhpc3RzKCBcIm92ZXJmbG93U2Nyb2xsaW5nXCIgKSxcblx0Y3NzVHJhbnNmb3JtM2Q6IHRyYW5zZm9ybTNkVGVzdCgpLFxuXHRib3hTaGFkb3c6ICEhcHJvcEV4aXN0cyggXCJib3hTaGFkb3dcIiApICYmICFiYixcblx0Zml4ZWRQb3NpdGlvbjogZml4ZWRQb3NpdGlvbigpLFxuXHRzY3JvbGxUb3A6IChcInBhZ2VYT2Zmc2V0XCIgaW4gd2luZG93IHx8XG5cdFx0XCJzY3JvbGxUb3BcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHxcblx0XHRcInNjcm9sbFRvcFwiIGluIGZha2VCb2R5WyAwIF0pICYmICF3ZWJvcyAmJiAhb3BlcmFtaW5pLFxuXG5cdGR5bmFtaWNCYXNlVGFnOiBiYXNlVGFnVGVzdCgpLFxuXHRjc3NQb2ludGVyRXZlbnRzOiBjc3NQb2ludGVyRXZlbnRzVGVzdCgpLFxuXHRib3VuZGluZ1JlY3Q6IGJvdW5kaW5nUmVjdCgpLFxuXHRpbmxpbmVTVkc6IGlubGluZVNWR1xufSk7XG5cbmZha2VCb2R5LnJlbW92ZSgpO1xuXG4vLyAkLm1vYmlsZS5hamF4QmxhY2tsaXN0IGlzIHVzZWQgdG8gb3ZlcnJpZGUgYWpheEVuYWJsZWQgb24gcGxhdGZvcm1zIHRoYXQgaGF2ZSBrbm93biBjb25mbGljdHMgd2l0aCBoYXNoIGhpc3RvcnkgdXBkYXRlcyAoQkI1LCBTeW1iaWFuKVxuLy8gb3IgdGhhdCBnZW5lcmFsbHkgd29yayBiZXR0ZXIgYnJvd3NpbmcgaW4gcmVndWxhciBodHRwIGZvciBmdWxsIHBhZ2UgcmVmcmVzaGVzIChPcGVyYSBNaW5pKVxuLy8gTm90ZTogVGhpcyBkZXRlY3Rpb24gYmVsb3cgaXMgdXNlZCBhcyBhIGxhc3QgcmVzb3J0LlxuLy8gV2UgcmVjb21tZW5kIG9ubHkgdXNpbmcgdGhlc2UgZGV0ZWN0aW9uIG1ldGhvZHMgd2hlbiBhbGwgb3RoZXIgbW9yZSByZWxpYWJsZS9mb3J3YXJkLWxvb2tpbmcgYXBwcm9hY2hlcyBhcmUgbm90IHBvc3NpYmxlXG5ub2tpYUxURTdfMyA9IChmdW5jdGlvbigpIHtcblxuXHR2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuXHQvL1RoZSBmb2xsb3dpbmcgaXMgYW4gYXR0ZW1wdCB0byBtYXRjaCBOb2tpYSBicm93c2VycyB0aGF0IGFyZSBydW5uaW5nIFN5bWJpYW4vczYwLCB3aXRoIHdlYmtpdCwgdmVyc2lvbiA3LjMgb3Igb2xkZXJcblx0cmV0dXJuIHVhLmluZGV4T2YoIFwiTm9raWFcIiApID4gLTEgJiZcblx0XHRcdCggdWEuaW5kZXhPZiggXCJTeW1iaWFuLzNcIiApID4gLTEgfHwgdWEuaW5kZXhPZiggXCJTZXJpZXM2MC81XCIgKSA+IC0xICkgJiZcblx0XHRcdHVhLmluZGV4T2YoIFwiQXBwbGVXZWJLaXRcIiApID4gLTEgJiZcblx0XHRcdHVhLm1hdGNoKCAvKEJyb3dzZXJOR3xOb2tpYUJyb3dzZXIpXFwvN1xcLlswLTNdLyApO1xufSkoKTtcblxuLy8gU3VwcG9ydCBjb25kaXRpb25zIHRoYXQgbXVzdCBiZSBtZXQgaW4gb3JkZXIgdG8gcHJvY2VlZFxuLy8gZGVmYXVsdCBlbmhhbmNlZCBxdWFsaWZpY2F0aW9ucyBhcmUgbWVkaWEgcXVlcnkgc3VwcG9ydCBPUiBJRSA3K1xuXG4kLm1vYmlsZS5ncmFkZUEgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuICggKCAkLnN1cHBvcnQubWVkaWFxdWVyeSAmJiAkLnN1cHBvcnQuY3NzUHNldWRvRWxlbWVudCApIHx8ICQubW9iaWxlLmJyb3dzZXIub2xkSUUgJiYgJC5tb2JpbGUuYnJvd3Nlci5vbGRJRSA+PSA4ICkgJiYgKCAkLnN1cHBvcnQuYm91bmRpbmdSZWN0IHx8ICQuZm4uanF1ZXJ5Lm1hdGNoKC8xXFwuWzAtNytdXFwuWzAtOStdPy8pICE9PSBudWxsICk7XG59O1xuXG4kLm1vYmlsZS5hamF4QmxhY2tsaXN0ID1cblx0XHRcdC8vIEJsYWNrQmVycnkgYnJvd3NlcnMsIHByZS13ZWJraXRcblx0XHRcdHdpbmRvdy5ibGFja2JlcnJ5ICYmICF3aW5kb3cuV2ViS2l0UG9pbnQgfHxcblx0XHRcdC8vIE9wZXJhIE1pbmlcblx0XHRcdG9wZXJhbWluaSB8fFxuXHRcdFx0Ly8gU3ltYmlhbiB3ZWJraXRzIHByZSA3LjNcblx0XHRcdG5va2lhTFRFN18zO1xuXG4vLyBMYXN0bHksIHRoaXMgd29ya2Fyb3VuZCBpcyB0aGUgb25seSB3YXkgd2UndmUgZm91bmQgc28gZmFyIHRvIGdldCBwcmUgNy4zIFN5bWJpYW4gd2Via2l0IGRldmljZXNcbi8vIHRvIHJlbmRlciB0aGUgc3R5bGVzaGVldHMgd2hlbiB0aGV5J3JlIHJlZmVyZW5jZWQgYmVmb3JlIHRoaXMgc2NyaXB0LCBhcyB3ZSdkIHJlY29tbWVuZCBkb2luZy5cbi8vIFRoaXMgc2ltcGx5IHJlYXBwZW5kcyB0aGUgQ1NTIGluIHBsYWNlLCB3aGljaCBmb3Igc29tZSByZWFzb24gbWFrZXMgaXQgYXBwbHlcbmlmICggbm9raWFMVEU3XzMgKSB7XG5cdCQoZnVuY3Rpb24oKSB7XG5cdFx0JCggXCJoZWFkIGxpbmtbcmVsPSdzdHlsZXNoZWV0J11cIiApLmF0dHIoIFwicmVsXCIsIFwiYWx0ZXJuYXRlIHN0eWxlc2hlZXRcIiApLmF0dHIoIFwicmVsXCIsIFwic3R5bGVzaGVldFwiICk7XG5cdH0pO1xufVxuXG4vLyBGb3IgcnVsaW5nIG91dCBzaGFkb3dzIHZpYSBjc3NcbmlmICggISQuc3VwcG9ydC5ib3hTaGFkb3cgKSB7XG5cdCQoIFwiaHRtbFwiICkuYWRkQ2xhc3MoIFwidWktbm9ib3hzaGFkb3dcIiApO1xufVxuXG59KSggalF1ZXJ5ICk7XG5cblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cdHZhciAkd2luID0gJC5tb2JpbGUud2luZG93LCBzZWxmLFxuXHRcdGR1bW15Rm5Ub0luaXROYXZpZ2F0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdH07XG5cblx0JC5ldmVudC5zcGVjaWFsLmJlZm9yZW5hdmlnYXRlID0ge1xuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdCR3aW4ub24oIFwibmF2aWdhdGVcIiwgZHVtbXlGblRvSW5pdE5hdmlnYXRlICk7XG5cdFx0fSxcblxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdCR3aW4ub2ZmKCBcIm5hdmlnYXRlXCIsIGR1bW15Rm5Ub0luaXROYXZpZ2F0ZSApO1xuXHRcdH1cblx0fTtcblxuXHQkLmV2ZW50LnNwZWNpYWwubmF2aWdhdGUgPSBzZWxmID0ge1xuXHRcdGJvdW5kOiBmYWxzZSxcblxuXHRcdHB1c2hTdGF0ZUVuYWJsZWQ6IHRydWUsXG5cblx0XHRvcmlnaW5hbEV2ZW50TmFtZTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gSWYgcHVzaHN0YXRlIHN1cHBvcnQgaXMgcHJlc2VudCBhbmQgcHVzaCBzdGF0ZSBzdXBwb3J0IGlzIGRlZmluZWQgdG9cblx0XHQvLyBiZSB0cnVlIG9uIHRoZSBtb2JpbGUgbmFtZXNwYWNlLlxuXHRcdGlzUHVzaFN0YXRlRW5hYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gJC5zdXBwb3J0LnB1c2hTdGF0ZSAmJlxuXHRcdFx0XHQkLm1vYmlsZS5wdXNoU3RhdGVFbmFibGVkID09PSB0cnVlICYmXG5cdFx0XHRcdHRoaXMuaXNIYXNoQ2hhbmdlRW5hYmxlZCgpO1xuXHRcdH0sXG5cblx0XHQvLyAhISBhc3N1bWVzIG1vYmlsZSBuYW1lc3BhY2UgaXMgcHJlc2VudFxuXHRcdGlzSGFzaENoYW5nZUVuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICQubW9iaWxlLmhhc2hMaXN0ZW5pbmdFbmFibGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBUT0RPIGEgbG90IG9mIGR1cGxpY2F0aW9uIGJldHdlZW4gcG9wc3RhdGUgYW5kIGhhc2hjaGFuZ2Vcblx0XHRwb3BzdGF0ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIG5ld0V2ZW50ID0gbmV3ICQuRXZlbnQoIFwibmF2aWdhdGVcIiApLFxuXHRcdFx0XHRiZWZvcmVOYXZpZ2F0ZSA9IG5ldyAkLkV2ZW50KCBcImJlZm9yZW5hdmlnYXRlXCIgKSxcblx0XHRcdFx0c3RhdGUgPSBldmVudC5vcmlnaW5hbEV2ZW50LnN0YXRlIHx8IHt9O1xuXG5cdFx0XHRiZWZvcmVOYXZpZ2F0ZS5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XG5cdFx0XHQkd2luLnRyaWdnZXIoIGJlZm9yZU5hdmlnYXRlICk7XG5cblx0XHRcdGlmICggYmVmb3JlTmF2aWdhdGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBldmVudC5oaXN0b3J5U3RhdGUgKSB7XG5cdFx0XHRcdCQuZXh0ZW5kKHN0YXRlLCBldmVudC5oaXN0b3J5U3RhdGUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhlIG9yaWdpbmFsIGV2ZW50IGlzIHRyYWNrZWQgZm9yIHRoZSBlbmRcblx0XHRcdC8vIHVzZXIgdG8gaW5zcGVjdCBpbmNhc2UgdGhleSB3YW50IHRvIGRvIHNvbWV0aGluZyBzcGVjaWFsXG5cdFx0XHRuZXdFdmVudC5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XG5cblx0XHRcdC8vIE5PVEUgd2UgbGV0IHRoZSBjdXJyZW50IHN0YWNrIHVud2luZCBiZWNhdXNlIGFueSBhc3NpZ25tZW50IHRvXG5cdFx0XHQvLyAgICAgIGxvY2F0aW9uLmhhc2ggd2lsbCBzdG9wIHRoZSB3b3JsZCBhbmQgcnVuIHRoaXMgZXZlbnQgaGFuZGxlci4gQnlcblx0XHRcdC8vICAgICAgZG9pbmcgdGhpcyB3ZSBjcmVhdGUgYSBzaW1pbGFyIGJlaGF2aW9yIHRvIGhhc2hjaGFuZ2Ugb24gaGFzaFxuXHRcdFx0Ly8gICAgICBhc3NpZ25tZW50XG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkd2luLnRyaWdnZXIoIG5ld0V2ZW50LCB7XG5cdFx0XHRcdFx0c3RhdGU6IHN0YXRlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSwgMCk7XG5cdFx0fSxcblxuXHRcdGhhc2hjaGFuZ2U6IGZ1bmN0aW9uKCBldmVudCAvKiwgZGF0YSAqLyApIHtcblx0XHRcdHZhciBuZXdFdmVudCA9IG5ldyAkLkV2ZW50KCBcIm5hdmlnYXRlXCIgKSxcblx0XHRcdFx0YmVmb3JlTmF2aWdhdGUgPSBuZXcgJC5FdmVudCggXCJiZWZvcmVuYXZpZ2F0ZVwiICk7XG5cblx0XHRcdGJlZm9yZU5hdmlnYXRlLm9yaWdpbmFsRXZlbnQgPSBldmVudDtcblx0XHRcdCR3aW4udHJpZ2dlciggYmVmb3JlTmF2aWdhdGUgKTtcblxuXHRcdFx0aWYgKCBiZWZvcmVOYXZpZ2F0ZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhlIG9yaWdpbmFsIGV2ZW50IGlzIHRyYWNrZWQgZm9yIHRoZSBlbmRcblx0XHRcdC8vIHVzZXIgdG8gaW5zcGVjdCBpbmNhc2UgdGhleSB3YW50IHRvIGRvIHNvbWV0aGluZyBzcGVjaWFsXG5cdFx0XHRuZXdFdmVudC5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XG5cblx0XHRcdC8vIFRyaWdnZXIgdGhlIGhhc2hjaGFuZ2Ugd2l0aCBzdGF0ZSBwcm92aWRlZCBieSB0aGUgdXNlclxuXHRcdFx0Ly8gdGhhdCBhbHRlcmVkIHRoZSBoYXNoXG5cdFx0XHQkd2luLnRyaWdnZXIoIG5ld0V2ZW50LCB7XG5cdFx0XHRcdC8vIFVzZXJzIHRoYXQgd2FudCB0byBmdWxseSBub3JtYWxpemUgdGhlIHR3byBldmVudHNcblx0XHRcdFx0Ly8gd2lsbCBuZWVkIHRvIGRvIGhpc3RvcnkgbWFuYWdlbWVudCBkb3duIHRoZSBzdGFjayBhbmRcblx0XHRcdFx0Ly8gYWRkIHRoZSBzdGF0ZSB0byB0aGUgZXZlbnQgYmVmb3JlIHRoaXMgYmluZGluZyBpcyBmaXJlZFxuXHRcdFx0XHQvLyBUT0RPIGNvbnNpZGVyIGFsbG93aW5nIGZvciB0aGUgZXhwbGljaXQgYWRkaXRpb24gb2YgY2FsbGJhY2tzXG5cdFx0XHRcdC8vICAgICAgdG8gYmUgZmlyZWQgYmVmb3JlIHRoaXMgdmFsdWUgaXMgc2V0IHRvIGF2b2lkIGV2ZW50IHRpbWluZyBpc3N1ZXNcblx0XHRcdFx0c3RhdGU6IGV2ZW50Lmhhc2hjaGFuZ2VTdGF0ZSB8fCB7fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8vIFRPRE8gV2UgcmVhbGx5IG9ubHkgd2FudCB0byBzZXQgdGhpcyB1cCBvbmNlXG5cdFx0Ly8gICAgICBidXQgSSdtIG5vdCBjbGVhciBpZiB0aGVyZSdzIGEgYmV0ZXIgd2F5IHRvIGFjaGlldmVcblx0XHQvLyAgICAgIHRoaXMgd2l0aCB0aGUgalF1ZXJ5IHNwZWNpYWwgZXZlbnQgc3RydWN0dXJlXG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCAvKiBkYXRhLCBuYW1lc3BhY2VzICovICkge1xuXHRcdFx0aWYgKCBzZWxmLmJvdW5kICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHNlbGYuYm91bmQgPSB0cnVlO1xuXG5cdFx0XHRpZiAoIHNlbGYuaXNQdXNoU3RhdGVFbmFibGVkKCkgKSB7XG5cdFx0XHRcdHNlbGYub3JpZ2luYWxFdmVudE5hbWUgPSBcInBvcHN0YXRlXCI7XG5cdFx0XHRcdCR3aW4uYmluZCggXCJwb3BzdGF0ZS5uYXZpZ2F0ZVwiLCBzZWxmLnBvcHN0YXRlICk7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWxmLmlzSGFzaENoYW5nZUVuYWJsZWQoKSApIHtcblx0XHRcdFx0c2VsZi5vcmlnaW5hbEV2ZW50TmFtZSA9IFwiaGFzaGNoYW5nZVwiO1xuXHRcdFx0XHQkd2luLmJpbmQoIFwiaGFzaGNoYW5nZS5uYXZpZ2F0ZVwiLCBzZWxmLmhhc2hjaGFuZ2UgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59KSggalF1ZXJ5ICk7XG5cblxuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblx0XHR2YXIgcGF0aCwgJGJhc2UsIGRpYWxvZ0hhc2hLZXkgPSBcIiZ1aS1zdGF0ZT1kaWFsb2dcIjtcblxuXHRcdCQubW9iaWxlLnBhdGggPSBwYXRoID0ge1xuXHRcdFx0dWlTdGF0ZUtleTogXCImdWktc3RhdGVcIixcblxuXHRcdFx0Ly8gVGhpcyBzY2FyeSBsb29raW5nIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXJzZXMgYW4gYWJzb2x1dGUgVVJMIG9yIGl0cyByZWxhdGl2ZVxuXHRcdFx0Ly8gdmFyaWFudHMgKHByb3RvY29sLCBzaXRlLCBkb2N1bWVudCwgcXVlcnksIGFuZCBoYXNoKSwgaW50byB0aGUgdmFyaW91c1xuXHRcdFx0Ly8gY29tcG9uZW50cyAocHJvdG9jb2wsIGhvc3QsIHBhdGgsIHF1ZXJ5LCBmcmFnbWVudCwgZXRjIHRoYXQgbWFrZSB1cCB0aGVcblx0XHRcdC8vIFVSTCBhcyB3ZWxsIGFzIHNvbWUgb3RoZXIgY29tbW9ubHkgdXNlZCBzdWItcGFydHMuIFdoZW4gdXNlZCB3aXRoIFJlZ0V4cC5leGVjKClcblx0XHRcdC8vIG9yIFN0cmluZy5tYXRjaCwgaXQgcGFyc2VzIHRoZSBVUkwgaW50byBhIHJlc3VsdHMgYXJyYXkgdGhhdCBsb29rcyBsaWtlIHRoaXM6XG5cdFx0XHQvL1xuXHRcdFx0Ly8gICAgIFswXTogaHR0cDovL2pibGFzOnBhc3N3b3JkQG15Y29tcGFueS5jb206ODA4MC9tYWlsL2luYm94P21zZz0xMjM0JnR5cGU9dW5yZWFkI21zZy1jb250ZW50XG5cdFx0XHQvLyAgICAgWzFdOiBodHRwOi8vamJsYXM6cGFzc3dvcmRAbXljb21wYW55LmNvbTo4MDgwL21haWwvaW5ib3g/bXNnPTEyMzQmdHlwZT11bnJlYWRcblx0XHRcdC8vICAgICBbMl06IGh0dHA6Ly9qYmxhczpwYXNzd29yZEBteWNvbXBhbnkuY29tOjgwODAvbWFpbC9pbmJveFxuXHRcdFx0Ly8gICAgIFszXTogaHR0cDovL2pibGFzOnBhc3N3b3JkQG15Y29tcGFueS5jb206ODA4MFxuXHRcdFx0Ly8gICAgIFs0XTogaHR0cDpcblx0XHRcdC8vICAgICBbNV06IC8vXG5cdFx0XHQvLyAgICAgWzZdOiBqYmxhczpwYXNzd29yZEBteWNvbXBhbnkuY29tOjgwODBcblx0XHRcdC8vICAgICBbN106IGpibGFzOnBhc3N3b3JkXG5cdFx0XHQvLyAgICAgWzhdOiBqYmxhc1xuXHRcdFx0Ly8gICAgIFs5XTogcGFzc3dvcmRcblx0XHRcdC8vICAgIFsxMF06IG15Y29tcGFueS5jb206ODA4MFxuXHRcdFx0Ly8gICAgWzExXTogbXljb21wYW55LmNvbVxuXHRcdFx0Ly8gICAgWzEyXTogODA4MFxuXHRcdFx0Ly8gICAgWzEzXTogL21haWwvaW5ib3hcblx0XHRcdC8vICAgIFsxNF06IC9tYWlsL1xuXHRcdFx0Ly8gICAgWzE1XTogaW5ib3hcblx0XHRcdC8vICAgIFsxNl06ID9tc2c9MTIzNCZ0eXBlPXVucmVhZFxuXHRcdFx0Ly8gICAgWzE3XTogI21zZy1jb250ZW50XG5cdFx0XHQvL1xuXHRcdFx0dXJsUGFyc2VSRTogL15cXHMqKCgoKFteOlxcLyNcXD9dKzopPyg/OihcXC9cXC8pKCg/OigoW146QFxcLyNcXD9dKykoPzpcXDooW146QFxcLyNcXD9dKykpPylAKT8oKFteOlxcLyNcXD9cXF1cXFtdK3xcXFtbXlxcL1xcXUAjP10rXFxdKSg/OlxcOihbMC05XSspKT8pKT8pPyk/KChcXC8/KD86W15cXC9cXD8jXStcXC8rKSopKFteXFw/I10qKSkpPyhcXD9bXiNdKyk/KSgjLiopPy8sXG5cblx0XHRcdC8vIEFic3RyYWN0aW9uIHRvIGFkZHJlc3MgeHNzIChJc3N1ZSAjNDc4NykgYnkgcmVtb3ZpbmcgdGhlIGF1dGhvcml0eSBpblxuXHRcdFx0Ly8gYnJvd3NlcnMgdGhhdCBhdXRvLWRlY29kZSBpdC4gQWxsIHJlZmVyZW5jZXMgdG8gbG9jYXRpb24uaHJlZiBzaG91bGQgYmVcblx0XHRcdC8vIHJlcGxhY2VkIHdpdGggYSBjYWxsIHRvIHRoaXMgbWV0aG9kIHNvIHRoYXQgaXQgY2FuIGJlIGRlYWx0IHdpdGggcHJvcGVybHkgaGVyZVxuXHRcdFx0Z2V0TG9jYXRpb246IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdFx0XHRcdHZhciBwYXJzZWRVcmwgPSB0aGlzLnBhcnNlVXJsKCB1cmwgfHwgbG9jYXRpb24uaHJlZiApLFxuXHRcdFx0XHRcdHVyaSA9IHVybCA/IHBhcnNlZFVybCA6IGxvY2F0aW9uLFxuXG5cdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRvIHBhcnNlIHRoZSB1cmwgb3IgdGhlIGxvY2F0aW9uIG9iamVjdCBmb3IgdGhlIGhhc2ggYmVjYXVzZSB1c2luZ1xuXHRcdFx0XHRcdC8vIGxvY2F0aW9uLmhhc2ggaXMgYXV0b2RlY29kZWQgaW4gZmlyZWZveCwgdGhlIHJlc3Qgb2YgdGhlIHVybCBzaG91bGQgYmUgZnJvbVxuXHRcdFx0XHRcdC8vIHRoZSBvYmplY3QgKGxvY2F0aW9uIHVubGVzcyB3ZSdyZSB0ZXN0aW5nKSB0byBhdm9pZCB0aGUgaW5jbHVzaW9uIG9mIHRoZVxuXHRcdFx0XHRcdC8vIGF1dGhvcml0eVxuXHRcdFx0XHRcdGhhc2ggPSBwYXJzZWRVcmwuaGFzaDtcblxuXHRcdFx0XHQvLyBtaW1pYyB0aGUgYnJvd3NlciB3aXRoIGFuIGVtcHR5IHN0cmluZyB3aGVuIHRoZSBoYXNoIGlzIGVtcHR5XG5cdFx0XHRcdGhhc2ggPSBoYXNoID09PSBcIiNcIiA/IFwiXCIgOiBoYXNoO1xuXG5cdFx0XHRcdHJldHVybiB1cmkucHJvdG9jb2wgK1xuXHRcdFx0XHRcdHBhcnNlZFVybC5kb3VibGVTbGFzaCArXG5cdFx0XHRcdFx0dXJpLmhvc3QgK1xuXG5cdFx0XHRcdFx0Ly8gVGhlIHBhdGhuYW1lIG11c3Qgc3RhcnQgd2l0aCBhIHNsYXNoIGlmIHRoZXJlJ3MgYSBwcm90b2NvbCwgYmVjYXVzZSB5b3Vcblx0XHRcdFx0XHQvLyBjYW4ndCBoYXZlIGEgcHJvdG9jb2wgZm9sbG93ZWQgYnkgYSByZWxhdGl2ZSBwYXRoLiBBbHNvLCBpdCdzIGltcG9zc2libGUgdG9cblx0XHRcdFx0XHQvLyBjYWxjdWxhdGUgYWJzb2x1dGUgVVJMcyBmcm9tIHJlbGF0aXZlIG9uZXMgaWYgdGhlIGFic29sdXRlIG9uZSBkb2Vzbid0IGhhdmVcblx0XHRcdFx0XHQvLyBhIGxlYWRpbmcgXCIvXCIuXG5cdFx0XHRcdFx0KCAoIHVyaS5wcm90b2NvbCAhPT0gXCJcIiAmJiB1cmkucGF0aG5hbWUuc3Vic3RyaW5nKCAwLCAxICkgIT09IFwiL1wiICkgP1xuXHRcdFx0XHRcdFx0XCIvXCIgOiBcIlwiICkgK1xuXHRcdFx0XHRcdHVyaS5wYXRobmFtZSArXG5cdFx0XHRcdFx0dXJpLnNlYXJjaCArXG5cdFx0XHRcdFx0aGFzaDtcblx0XHRcdH0sXG5cblx0XHRcdC8vcmV0dXJuIHRoZSBvcmlnaW5hbCBkb2N1bWVudCB1cmxcblx0XHRcdGdldERvY3VtZW50VXJsOiBmdW5jdGlvbiggYXNQYXJzZWRPYmplY3QgKSB7XG5cdFx0XHRcdHJldHVybiBhc1BhcnNlZE9iamVjdCA/ICQuZXh0ZW5kKCB7fSwgcGF0aC5kb2N1bWVudFVybCApIDogcGF0aC5kb2N1bWVudFVybC5ocmVmO1xuXHRcdFx0fSxcblxuXHRcdFx0cGFyc2VMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnBhcnNlVXJsKCB0aGlzLmdldExvY2F0aW9uKCkgKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vUGFyc2UgYSBVUkwgaW50byBhIHN0cnVjdHVyZSB0aGF0IGFsbG93cyBlYXN5IGFjY2VzcyB0b1xuXHRcdFx0Ly9hbGwgb2YgdGhlIFVSTCBjb21wb25lbnRzIGJ5IG5hbWUuXG5cdFx0XHRwYXJzZVVybDogZnVuY3Rpb24oIHVybCApIHtcblx0XHRcdFx0Ly8gSWYgd2UncmUgcGFzc2VkIGFuIG9iamVjdCwgd2UnbGwgYXNzdW1lIHRoYXQgaXQgaXNcblx0XHRcdFx0Ly8gYSBwYXJzZWQgdXJsIG9iamVjdCBhbmQganVzdCByZXR1cm4gaXQgYmFjayB0byB0aGUgY2FsbGVyLlxuXHRcdFx0XHRpZiAoICQudHlwZSggdXJsICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHVybDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtYXRjaGVzID0gcGF0aC51cmxQYXJzZVJFLmV4ZWMoIHVybCB8fCBcIlwiICkgfHwgW107XG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgYW4gb2JqZWN0IHRoYXQgYWxsb3dzIHRoZSBjYWxsZXIgdG8gYWNjZXNzIHRoZSBzdWItbWF0Y2hlc1xuXHRcdFx0XHRcdC8vIGJ5IG5hbWUuIE5vdGUgdGhhdCBJRSByZXR1cm5zIGFuIGVtcHR5IHN0cmluZyBpbnN0ZWFkIG9mIHVuZGVmaW5lZCxcblx0XHRcdFx0XHQvLyBsaWtlIGFsbCBvdGhlciBicm93c2VycyBkbywgc28gd2Ugbm9ybWFsaXplIGV2ZXJ5dGhpbmcgc28gaXRzIGNvbnNpc3RlbnRcblx0XHRcdFx0XHQvLyBubyBtYXR0ZXIgd2hhdCBicm93c2VyIHdlJ3JlIHJ1bm5pbmcgb24uXG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGhyZWY6ICAgICAgICAgbWF0Y2hlc1sgIDAgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdFx0aHJlZk5vSGFzaDogICBtYXRjaGVzWyAgMSBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0XHRocmVmTm9TZWFyY2g6IG1hdGNoZXNbICAyIF0gfHwgXCJcIixcblx0XHRcdFx0XHRcdGRvbWFpbjogICAgICAgbWF0Y2hlc1sgIDMgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdFx0cHJvdG9jb2w6ICAgICBtYXRjaGVzWyAgNCBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0XHRkb3VibGVTbGFzaDogIG1hdGNoZXNbICA1IF0gfHwgXCJcIixcblx0XHRcdFx0XHRcdGF1dGhvcml0eTogICAgbWF0Y2hlc1sgIDYgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdFx0dXNlcm5hbWU6ICAgICBtYXRjaGVzWyAgOCBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0XHRwYXNzd29yZDogICAgIG1hdGNoZXNbICA5IF0gfHwgXCJcIixcblx0XHRcdFx0XHRcdGhvc3Q6ICAgICAgICAgbWF0Y2hlc1sgMTAgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdFx0aG9zdG5hbWU6ICAgICBtYXRjaGVzWyAxMSBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0XHRwb3J0OiAgICAgICAgIG1hdGNoZXNbIDEyIF0gfHwgXCJcIixcblx0XHRcdFx0XHRcdHBhdGhuYW1lOiAgICAgbWF0Y2hlc1sgMTMgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdFx0ZGlyZWN0b3J5OiAgICBtYXRjaGVzWyAxNCBdIHx8IFwiXCIsXG5cdFx0XHRcdFx0XHRmaWxlbmFtZTogICAgIG1hdGNoZXNbIDE1IF0gfHwgXCJcIixcblx0XHRcdFx0XHRcdHNlYXJjaDogICAgICAgbWF0Y2hlc1sgMTYgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdFx0aGFzaDogICAgICAgICBtYXRjaGVzWyAxNyBdIHx8IFwiXCJcblx0XHRcdFx0XHR9O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly9UdXJuIHJlbFBhdGggaW50byBhbiBhc2JvbHV0ZSBwYXRoLiBhYnNQYXRoIGlzXG5cdFx0XHQvL2FuIG9wdGlvbmFsIGFic29sdXRlIHBhdGggd2hpY2ggZGVzY3JpYmVzIHdoYXRcblx0XHRcdC8vcmVsUGF0aCBpcyByZWxhdGl2ZSB0by5cblx0XHRcdG1ha2VQYXRoQWJzb2x1dGU6IGZ1bmN0aW9uKCByZWxQYXRoLCBhYnNQYXRoICkge1xuXHRcdFx0XHR2YXIgYWJzU3RhY2ssXG5cdFx0XHRcdFx0cmVsU3RhY2ssXG5cdFx0XHRcdFx0aSwgZDtcblxuXHRcdFx0XHRpZiAoIHJlbFBhdGggJiYgcmVsUGF0aC5jaGFyQXQoIDAgKSA9PT0gXCIvXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlbFBhdGg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZWxQYXRoID0gcmVsUGF0aCB8fCBcIlwiO1xuXHRcdFx0XHRhYnNQYXRoID0gYWJzUGF0aCA/IGFic1BhdGgucmVwbGFjZSggL15cXC98KFxcL1teXFwvXSp8W15cXC9dKykkL2csIFwiXCIgKSA6IFwiXCI7XG5cblx0XHRcdFx0YWJzU3RhY2sgPSBhYnNQYXRoID8gYWJzUGF0aC5zcGxpdCggXCIvXCIgKSA6IFtdO1xuXHRcdFx0XHRyZWxTdGFjayA9IHJlbFBhdGguc3BsaXQoIFwiL1wiICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCByZWxTdGFjay5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHRkID0gcmVsU3RhY2tbIGkgXTtcblx0XHRcdFx0XHRzd2l0Y2ggKCBkICkge1xuXHRcdFx0XHRcdFx0Y2FzZSBcIi5cIjpcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiLi5cIjpcblx0XHRcdFx0XHRcdFx0aWYgKCBhYnNTdGFjay5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0YWJzU3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRhYnNTdGFjay5wdXNoKCBkICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gXCIvXCIgKyBhYnNTdGFjay5qb2luKCBcIi9cIiApO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly9SZXR1cm5zIHRydWUgaWYgYm90aCB1cmxzIGhhdmUgdGhlIHNhbWUgZG9tYWluLlxuXHRcdFx0aXNTYW1lRG9tYWluOiBmdW5jdGlvbiggYWJzVXJsMSwgYWJzVXJsMiApIHtcblx0XHRcdFx0cmV0dXJuIHBhdGgucGFyc2VVcmwoIGFic1VybDEgKS5kb21haW4gPT09IHBhdGgucGFyc2VVcmwoIGFic1VybDIgKS5kb21haW47XG5cdFx0XHR9LFxuXG5cdFx0XHQvL1JldHVybnMgdHJ1ZSBmb3IgYW55IHJlbGF0aXZlIHZhcmlhbnQuXG5cdFx0XHRpc1JlbGF0aXZlVXJsOiBmdW5jdGlvbiggdXJsICkge1xuXHRcdFx0XHQvLyBBbGwgcmVsYXRpdmUgVXJsIHZhcmlhbnRzIGhhdmUgb25lIHRoaW5nIGluIGNvbW1vbiwgbm8gcHJvdG9jb2wuXG5cdFx0XHRcdHJldHVybiBwYXRoLnBhcnNlVXJsKCB1cmwgKS5wcm90b2NvbCA9PT0gXCJcIjtcblx0XHRcdH0sXG5cblx0XHRcdC8vUmV0dXJucyB0cnVlIGZvciBhbiBhYnNvbHV0ZSB1cmwuXG5cdFx0XHRpc0Fic29sdXRlVXJsOiBmdW5jdGlvbiggdXJsICkge1xuXHRcdFx0XHRyZXR1cm4gcGF0aC5wYXJzZVVybCggdXJsICkucHJvdG9jb2wgIT09IFwiXCI7XG5cdFx0XHR9LFxuXG5cdFx0XHQvL1R1cm4gdGhlIHNwZWNpZmllZCByZWFsdGl2ZSBVUkwgaW50byBhbiBhYnNvbHV0ZSBvbmUuIFRoaXMgZnVuY3Rpb25cblx0XHRcdC8vY2FuIGhhbmRsZSBhbGwgcmVsYXRpdmUgdmFyaWFudHMgKHByb3RvY29sLCBzaXRlLCBkb2N1bWVudCwgcXVlcnksIGZyYWdtZW50KS5cblx0XHRcdG1ha2VVcmxBYnNvbHV0ZTogZnVuY3Rpb24oIHJlbFVybCwgYWJzVXJsICkge1xuXHRcdFx0XHRpZiAoICFwYXRoLmlzUmVsYXRpdmVVcmwoIHJlbFVybCApICkge1xuXHRcdFx0XHRcdHJldHVybiByZWxVcmw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGFic1VybCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGFic1VybCA9IHRoaXMuZG9jdW1lbnRCYXNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHJlbE9iaiA9IHBhdGgucGFyc2VVcmwoIHJlbFVybCApLFxuXHRcdFx0XHRcdGFic09iaiA9IHBhdGgucGFyc2VVcmwoIGFic1VybCApLFxuXHRcdFx0XHRcdHByb3RvY29sID0gcmVsT2JqLnByb3RvY29sIHx8IGFic09iai5wcm90b2NvbCxcblx0XHRcdFx0XHRkb3VibGVTbGFzaCA9IHJlbE9iai5wcm90b2NvbCA/IHJlbE9iai5kb3VibGVTbGFzaCA6ICggcmVsT2JqLmRvdWJsZVNsYXNoIHx8IGFic09iai5kb3VibGVTbGFzaCApLFxuXHRcdFx0XHRcdGF1dGhvcml0eSA9IHJlbE9iai5hdXRob3JpdHkgfHwgYWJzT2JqLmF1dGhvcml0eSxcblx0XHRcdFx0XHRoYXNQYXRoID0gcmVsT2JqLnBhdGhuYW1lICE9PSBcIlwiLFxuXHRcdFx0XHRcdHBhdGhuYW1lID0gcGF0aC5tYWtlUGF0aEFic29sdXRlKCByZWxPYmoucGF0aG5hbWUgfHwgYWJzT2JqLmZpbGVuYW1lLCBhYnNPYmoucGF0aG5hbWUgKSxcblx0XHRcdFx0XHRzZWFyY2ggPSByZWxPYmouc2VhcmNoIHx8ICggIWhhc1BhdGggJiYgYWJzT2JqLnNlYXJjaCApIHx8IFwiXCIsXG5cdFx0XHRcdFx0aGFzaCA9IHJlbE9iai5oYXNoO1xuXG5cdFx0XHRcdHJldHVybiBwcm90b2NvbCArIGRvdWJsZVNsYXNoICsgYXV0aG9yaXR5ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly9BZGQgc2VhcmNoIChha2EgcXVlcnkpIHBhcmFtcyB0byB0aGUgc3BlY2lmaWVkIHVybC5cblx0XHRcdGFkZFNlYXJjaFBhcmFtczogZnVuY3Rpb24oIHVybCwgcGFyYW1zICkge1xuXHRcdFx0XHR2YXIgdSA9IHBhdGgucGFyc2VVcmwoIHVybCApLFxuXHRcdFx0XHRcdHAgPSAoIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSA/ICQucGFyYW0oIHBhcmFtcyApIDogcGFyYW1zLFxuXHRcdFx0XHRcdHMgPSB1LnNlYXJjaCB8fCBcIj9cIjtcblx0XHRcdFx0cmV0dXJuIHUuaHJlZk5vU2VhcmNoICsgcyArICggcy5jaGFyQXQoIHMubGVuZ3RoIC0gMSApICE9PSBcIj9cIiA/IFwiJlwiIDogXCJcIiApICsgcCArICggdS5oYXNoIHx8IFwiXCIgKTtcblx0XHRcdH0sXG5cblx0XHRcdGNvbnZlcnRVcmxUb0RhdGFVcmw6IGZ1bmN0aW9uKCBhYnNVcmwgKSB7XG5cdFx0XHRcdHZhciB1ID0gcGF0aC5wYXJzZVVybCggYWJzVXJsICk7XG5cdFx0XHRcdGlmICggcGF0aC5pc0VtYmVkZGVkUGFnZSggdSApICkge1xuXHRcdFx0XHRcdC8vIEZvciBlbWJlZGRlZCBwYWdlcywgcmVtb3ZlIHRoZSBkaWFsb2cgaGFzaCBrZXkgYXMgaW4gZ2V0RmlsZVBhdGgoKSxcblx0XHRcdFx0XHQvLyBhbmQgcmVtb3ZlIG90aGVyd2lzZSB0aGUgRGF0YSBVcmwgd29uJ3QgbWF0Y2ggdGhlIGlkIG9mIHRoZSBlbWJlZGRlZCBQYWdlLlxuXHRcdFx0XHRcdHJldHVybiB1Lmhhc2hcblx0XHRcdFx0XHRcdC5zcGxpdCggZGlhbG9nSGFzaEtleSApWzBdXG5cdFx0XHRcdFx0XHQucmVwbGFjZSggL14jLywgXCJcIiApXG5cdFx0XHRcdFx0XHQucmVwbGFjZSggL1xcPy4qJC8sIFwiXCIgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggcGF0aC5pc1NhbWVEb21haW4oIHUsIHRoaXMuZG9jdW1lbnRCYXNlICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHUuaHJlZk5vSGFzaC5yZXBsYWNlKCB0aGlzLmRvY3VtZW50QmFzZS5kb21haW4sIFwiXCIgKS5zcGxpdCggZGlhbG9nSGFzaEtleSApWzBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHdpbmRvdy5kZWNvZGVVUklDb21wb25lbnQoYWJzVXJsKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vZ2V0IHBhdGggZnJvbSBjdXJyZW50IGhhc2gsIG9yIGZyb20gYSBmaWxlIHBhdGhcblx0XHRcdGdldDogZnVuY3Rpb24oIG5ld1BhdGggKSB7XG5cdFx0XHRcdGlmICggbmV3UGF0aCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdG5ld1BhdGggPSBwYXRoLnBhcnNlTG9jYXRpb24oKS5oYXNoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwYXRoLnN0cmlwSGFzaCggbmV3UGF0aCApLnJlcGxhY2UoIC9bXlxcL10qXFwuW15cXC8qXSskLywgXCJcIiApO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly9zZXQgbG9jYXRpb24gaGFzaCB0byBwYXRoXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBwYXRoICkge1xuXHRcdFx0XHRsb2NhdGlvbi5oYXNoID0gcGF0aDtcblx0XHRcdH0sXG5cblx0XHRcdC8vdGVzdCBpZiBhIGdpdmVuIHVybCAoc3RyaW5nKSBpcyBhIHBhdGhcblx0XHRcdC8vTk9URSBtaWdodCBiZSBleGNlcHRpb25hbGx5IG5haXZlXG5cdFx0XHRpc1BhdGg6IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdFx0XHRcdHJldHVybiAoIC9cXC8vICkudGVzdCggdXJsICk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvL3JldHVybiBhIHVybCBwYXRoIHdpdGggdGhlIHdpbmRvdydzIGxvY2F0aW9uIHByb3RvY29sL2hvc3RuYW1lL3BhdGhuYW1lIHJlbW92ZWRcblx0XHRcdGNsZWFuOiBmdW5jdGlvbiggdXJsICkge1xuXHRcdFx0XHRyZXR1cm4gdXJsLnJlcGxhY2UoIHRoaXMuZG9jdW1lbnRCYXNlLmRvbWFpbiwgXCJcIiApO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly9qdXN0IHJldHVybiB0aGUgdXJsIHdpdGhvdXQgYW4gaW5pdGlhbCAjXG5cdFx0XHRzdHJpcEhhc2g6IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdFx0XHRcdHJldHVybiB1cmwucmVwbGFjZSggL14jLywgXCJcIiApO1xuXHRcdFx0fSxcblxuXHRcdFx0c3RyaXBRdWVyeVBhcmFtczogZnVuY3Rpb24oIHVybCApIHtcblx0XHRcdFx0cmV0dXJuIHVybC5yZXBsYWNlKCAvXFw/LiokLywgXCJcIiApO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly9yZW1vdmUgdGhlIHByZWNlZGluZyBoYXNoLCBhbnkgcXVlcnkgcGFyYW1zLCBhbmQgZGlhbG9nIG5vdGF0aW9uc1xuXHRcdFx0Y2xlYW5IYXNoOiBmdW5jdGlvbiggaGFzaCApIHtcblx0XHRcdFx0cmV0dXJuIHBhdGguc3RyaXBIYXNoKCBoYXNoLnJlcGxhY2UoIC9cXD8uKiQvLCBcIlwiICkucmVwbGFjZSggZGlhbG9nSGFzaEtleSwgXCJcIiApICk7XG5cdFx0XHR9LFxuXG5cdFx0XHRpc0hhc2hWYWxpZDogZnVuY3Rpb24oIGhhc2ggKSB7XG5cdFx0XHRcdHJldHVybiAoIC9eI1teI10rJC8gKS50ZXN0KCBoYXNoICk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvL2NoZWNrIHdoZXRoZXIgYSB1cmwgaXMgcmVmZXJlbmNpbmcgdGhlIHNhbWUgZG9tYWluLCBvciBhbiBleHRlcm5hbCBkb21haW4gb3IgZGlmZmVyZW50IHByb3RvY29sXG5cdFx0XHQvL2NvdWxkIGJlIG1haWx0bywgZXRjXG5cdFx0XHRpc0V4dGVybmFsOiBmdW5jdGlvbiggdXJsICkge1xuXHRcdFx0XHR2YXIgdSA9IHBhdGgucGFyc2VVcmwoIHVybCApO1xuXHRcdFx0XHRyZXR1cm4gdS5wcm90b2NvbCAmJiB1LmRvbWFpbiAhPT0gdGhpcy5kb2N1bWVudFVybC5kb21haW4gPyB0cnVlIDogZmFsc2U7XG5cdFx0XHR9LFxuXG5cdFx0XHRoYXNQcm90b2NvbDogZnVuY3Rpb24oIHVybCApIHtcblx0XHRcdFx0cmV0dXJuICggL14oOj9cXHcrOikvICkudGVzdCggdXJsICk7XG5cdFx0XHR9LFxuXG5cdFx0XHRpc0VtYmVkZGVkUGFnZTogZnVuY3Rpb24oIHVybCApIHtcblx0XHRcdFx0dmFyIHUgPSBwYXRoLnBhcnNlVXJsKCB1cmwgKTtcblxuXHRcdFx0XHQvL2lmIHRoZSBwYXRoIGlzIGFic29sdXRlLCB0aGVuIHdlIG5lZWQgdG8gY29tcGFyZSB0aGUgdXJsIGFnYWluc3Rcblx0XHRcdFx0Ly9ib3RoIHRoZSB0aGlzLmRvY3VtZW50VXJsIGFuZCB0aGUgZG9jdW1lbnRCYXNlLiBUaGUgbWFpbiByZWFzb24gZm9yIHRoaXNcblx0XHRcdFx0Ly9pcyB0aGF0IGxpbmtzIGVtYmVkZGVkIHdpdGhpbiBleHRlcm5hbCBkb2N1bWVudHMgd2lsbCByZWZlciB0byB0aGVcblx0XHRcdFx0Ly9hcHBsaWNhdGlvbiBkb2N1bWVudCwgd2hlcmVhcyBsaW5rcyBlbWJlZGRlZCB3aXRoaW4gdGhlIGFwcGxpY2F0aW9uXG5cdFx0XHRcdC8vZG9jdW1lbnQgd2lsbCBiZSByZXNvbHZlZCBhZ2FpbnN0IHRoZSBkb2N1bWVudCBiYXNlLlxuXHRcdFx0XHRpZiAoIHUucHJvdG9jb2wgIT09IFwiXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICggIXRoaXMuaXNQYXRoKHUuaGFzaCkgJiYgdS5oYXNoICYmICggdS5ocmVmTm9IYXNoID09PSB0aGlzLmRvY3VtZW50VXJsLmhyZWZOb0hhc2ggfHwgKCB0aGlzLmRvY3VtZW50QmFzZURpZmZlcnMgJiYgdS5ocmVmTm9IYXNoID09PSB0aGlzLmRvY3VtZW50QmFzZS5ocmVmTm9IYXNoICkgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAoIC9eIy8gKS50ZXN0KCB1LmhyZWYgKTtcblx0XHRcdH0sXG5cblx0XHRcdHNxdWFzaDogZnVuY3Rpb24oIHVybCwgcmVzb2x1dGlvblVybCApIHtcblx0XHRcdFx0dmFyIGhyZWYsIGNsZWFuZWRVcmwsIHNlYXJjaCwgc3RhdGVJbmRleCxcblx0XHRcdFx0XHRpc1BhdGggPSB0aGlzLmlzUGF0aCggdXJsICksXG5cdFx0XHRcdFx0dXJpID0gdGhpcy5wYXJzZVVybCggdXJsICksXG5cdFx0XHRcdFx0cHJlc2VydmVkSGFzaCA9IHVyaS5oYXNoLFxuXHRcdFx0XHRcdHVpU3RhdGUgPSBcIlwiO1xuXG5cdFx0XHRcdC8vIHByb2R1Y2UgYSB1cmwgYWdhaW5zdCB3aGljaCB3ZSBjYW4gcmVzb2xlIHRoZSBwcm92aWRlZCBwYXRoXG5cdFx0XHRcdHJlc29sdXRpb25VcmwgPSByZXNvbHV0aW9uVXJsIHx8IChwYXRoLmlzUGF0aCh1cmwpID8gcGF0aC5nZXRMb2NhdGlvbigpIDogcGF0aC5nZXREb2N1bWVudFVybCgpKTtcblxuXHRcdFx0XHQvLyBJZiB0aGUgdXJsIGlzIGFueXRoaW5nIGJ1dCBhIHNpbXBsZSBzdHJpbmcsIHJlbW92ZSBhbnkgcHJlY2VkaW5nIGhhc2hcblx0XHRcdFx0Ly8gZWcgI2Zvby9iYXIgLT4gZm9vL2JhclxuXHRcdFx0XHQvLyAgICAjZm9vIC0+ICNmb29cblx0XHRcdFx0Y2xlYW5lZFVybCA9IGlzUGF0aCA/IHBhdGguc3RyaXBIYXNoKCB1cmwgKSA6IHVybDtcblxuXHRcdFx0XHQvLyBJZiB0aGUgdXJsIGlzIGEgZnVsbCB1cmwgd2l0aCBhIGhhc2ggY2hlY2sgaWYgdGhlIHBhcnNlZCBoYXNoIGlzIGEgcGF0aFxuXHRcdFx0XHQvLyBpZiBpdCBpcywgc3RyaXAgdGhlICMsIGFuZCB1c2UgaXQgb3RoZXJ3aXNlIGNvbnRpbnVlIHdpdGhvdXQgY2hhbmdlXG5cdFx0XHRcdGNsZWFuZWRVcmwgPSBwYXRoLmlzUGF0aCggdXJpLmhhc2ggKSA/IHBhdGguc3RyaXBIYXNoKCB1cmkuaGFzaCApIDogY2xlYW5lZFVybDtcblxuXHRcdFx0XHQvLyBTcGxpdCB0aGUgVUkgU3RhdGUga2V5cyBvZmYgdGhlIGhyZWZcblx0XHRcdFx0c3RhdGVJbmRleCA9IGNsZWFuZWRVcmwuaW5kZXhPZiggdGhpcy51aVN0YXRlS2V5ICk7XG5cblx0XHRcdFx0Ly8gc3RvcmUgdGhlIHVpIHN0YXRlIGtleXMgZm9yIHVzZVxuXHRcdFx0XHRpZiAoIHN0YXRlSW5kZXggPiAtMSApIHtcblx0XHRcdFx0XHR1aVN0YXRlID0gY2xlYW5lZFVybC5zbGljZSggc3RhdGVJbmRleCApO1xuXHRcdFx0XHRcdGNsZWFuZWRVcmwgPSBjbGVhbmVkVXJsLnNsaWNlKCAwLCBzdGF0ZUluZGV4ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBtYWtlIHRoZSBjbGVhbmVkVXJsIGFic29sdXRlIHJlbGF0aXZlIHRvIHRoZSByZXNvbHV0aW9uIHVybFxuXHRcdFx0XHRocmVmID0gcGF0aC5tYWtlVXJsQWJzb2x1dGUoIGNsZWFuZWRVcmwsIHJlc29sdXRpb25VcmwgKTtcblxuXHRcdFx0XHQvLyBncmFiIHRoZSBzZWFyY2ggZnJvbSB0aGUgcmVzb2x2ZWQgdXJsIHNpbmNlIHBhcnNpbmcgZnJvbVxuXHRcdFx0XHQvLyB0aGUgcGFzc2VkIHVybCBtYXkgbm90IHlpZWxkIHRoZSBjb3JyZWN0IHJlc3VsdFxuXHRcdFx0XHRzZWFyY2ggPSB0aGlzLnBhcnNlVXJsKCBocmVmICkuc2VhcmNoO1xuXG5cdFx0XHRcdC8vIFRPRE8gYWxsIHRoaXMgY3JhcCBpcyB0ZXJyaWJsZSwgY2xlYW4gaXQgdXBcblx0XHRcdFx0aWYgKCBpc1BhdGggKSB7XG5cdFx0XHRcdFx0Ly8gcmVqZWN0IHRoZSBoYXNoIGlmIGl0J3MgYSBwYXRoIG9yIGl0J3MganVzdCBhIGRpYWxvZyBrZXlcblx0XHRcdFx0XHRpZiAoIHBhdGguaXNQYXRoKCBwcmVzZXJ2ZWRIYXNoICkgfHwgcHJlc2VydmVkSGFzaC5yZXBsYWNlKFwiI1wiLCBcIlwiKS5pbmRleE9mKCB0aGlzLnVpU3RhdGVLZXkgKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0cHJlc2VydmVkSGFzaCA9IFwiXCI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQXBwZW5kIHRoZSBVSSBTdGF0ZSBrZXlzIHdoZXJlIGl0IGV4aXN0cyBhbmQgaXQncyBiZWVuIHJlbW92ZWRcblx0XHRcdFx0XHQvLyBmcm9tIHRoZSB1cmxcblx0XHRcdFx0XHRpZiAoIHVpU3RhdGUgJiYgcHJlc2VydmVkSGFzaC5pbmRleE9mKCB0aGlzLnVpU3RhdGVLZXkgKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdHByZXNlcnZlZEhhc2ggKz0gdWlTdGF0ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBtYWtlIHN1cmUgdGhhdCBwb3VuZCBpcyBvbiB0aGUgZnJvbnQgb2YgdGhlIGhhc2hcblx0XHRcdFx0XHRpZiAoIHByZXNlcnZlZEhhc2guaW5kZXhPZiggXCIjXCIgKSA9PT0gLTEgJiYgcHJlc2VydmVkSGFzaCAhPT0gXCJcIiApIHtcblx0XHRcdFx0XHRcdHByZXNlcnZlZEhhc2ggPSBcIiNcIiArIHByZXNlcnZlZEhhc2g7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gcmVjb25zdHJ1Y3QgZWFjaCBvZiB0aGUgcGllY2VzIHdpdGggdGhlIG5ldyBzZWFyY2ggc3RyaW5nIGFuZCBoYXNoXG5cdFx0XHRcdFx0aHJlZiA9IHBhdGgucGFyc2VVcmwoIGhyZWYgKTtcblx0XHRcdFx0XHRocmVmID0gaHJlZi5wcm90b2NvbCArIGhyZWYuZG91YmxlU2xhc2ggKyBocmVmLmhvc3QgKyBocmVmLnBhdGhuYW1lICsgc2VhcmNoICtcblx0XHRcdFx0XHRcdHByZXNlcnZlZEhhc2g7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aHJlZiArPSBocmVmLmluZGV4T2YoIFwiI1wiICkgPiAtMSA/IHVpU3RhdGUgOiBcIiNcIiArIHVpU3RhdGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gaHJlZjtcblx0XHRcdH0sXG5cblx0XHRcdGlzUHJlc2VydmFibGVIYXNoOiBmdW5jdGlvbiggaGFzaCApIHtcblx0XHRcdFx0cmV0dXJuIGhhc2gucmVwbGFjZSggXCIjXCIsIFwiXCIgKS5pbmRleE9mKCB0aGlzLnVpU3RhdGVLZXkgKSA9PT0gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEVzY2FwZSB3ZWlyZCBjaGFyYWN0ZXJzIGluIHRoZSBoYXNoIGlmIGl0IGlzIHRvIGJlIHVzZWQgYXMgYSBzZWxlY3RvclxuXHRcdFx0aGFzaFRvU2VsZWN0b3I6IGZ1bmN0aW9uKCBoYXNoICkge1xuXHRcdFx0XHR2YXIgaGFzSGFzaCA9ICggaGFzaC5zdWJzdHJpbmcoIDAsIDEgKSA9PT0gXCIjXCIgKTtcblx0XHRcdFx0aWYgKCBoYXNIYXNoICkge1xuXHRcdFx0XHRcdGhhc2ggPSBoYXNoLnN1YnN0cmluZyggMSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAoIGhhc0hhc2ggPyBcIiNcIiA6IFwiXCIgKSArIGhhc2gucmVwbGFjZSggLyhbIVwiIyQlJicoKSorLC4vOjs8PT4/QFtcXF1eYHt8fX5dKS9nLCBcIlxcXFwkMVwiICk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyByZXR1cm4gdGhlIHN1YnN0cmluZyBvZiBhIGZpbGVwYXRoIGJlZm9yZSB0aGUgc3ViLXBhZ2Uga2V5LCBmb3IgbWFraW5nXG5cdFx0XHQvLyBhIHNlcnZlciByZXF1ZXN0XG5cdFx0XHRnZXRGaWxlUGF0aDogZnVuY3Rpb24oIHBhdGggKSB7XG5cdFx0XHRcdHZhciBzcGxpdGtleSA9IFwiJlwiICsgJC5tb2JpbGUuc3ViUGFnZVVybEtleTtcblx0XHRcdFx0cmV0dXJuIHBhdGggJiYgcGF0aC5zcGxpdCggc3BsaXRrZXkgKVswXS5zcGxpdCggZGlhbG9nSGFzaEtleSApWzBdO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHNwZWNpZmllZCB1cmwgcmVmZXJzIHRvIHRoZSBmaXJzdCBwYWdlIGluIHRoZSBtYWluXG5cdFx0XHQvLyBhcHBsaWNhdGlvbiBkb2N1bWVudC5cblx0XHRcdGlzRmlyc3RQYWdlVXJsOiBmdW5jdGlvbiggdXJsICkge1xuXHRcdFx0XHQvLyBXZSBvbmx5IGRlYWwgd2l0aCBhYnNvbHV0ZSBwYXRocy5cblx0XHRcdFx0dmFyIHUgPSBwYXRoLnBhcnNlVXJsKCBwYXRoLm1ha2VVcmxBYnNvbHV0ZSggdXJsLCB0aGlzLmRvY3VtZW50QmFzZSApICksXG5cblx0XHRcdFx0XHQvLyBEb2VzIHRoZSB1cmwgaGF2ZSB0aGUgc2FtZSBwYXRoIGFzIHRoZSBkb2N1bWVudD9cblx0XHRcdFx0XHRzYW1lUGF0aCA9IHUuaHJlZk5vSGFzaCA9PT0gdGhpcy5kb2N1bWVudFVybC5ocmVmTm9IYXNoIHx8XG5cdFx0XHRcdFx0XHQoIHRoaXMuZG9jdW1lbnRCYXNlRGlmZmVycyAmJlxuXHRcdFx0XHRcdFx0XHR1LmhyZWZOb0hhc2ggPT09IHRoaXMuZG9jdW1lbnRCYXNlLmhyZWZOb0hhc2ggKSxcblxuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmlyc3QgcGFnZSBlbGVtZW50LlxuXHRcdFx0XHRcdGZwID0gJC5tb2JpbGUuZmlyc3RQYWdlLFxuXG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBpZCBvZiB0aGUgZmlyc3QgcGFnZSBlbGVtZW50IGlmIGl0IGhhcyBvbmUuXG5cdFx0XHRcdFx0ZnBJZCA9IGZwICYmIGZwWzBdID8gZnBbMF0uaWQgOiB1bmRlZmluZWQ7XG5cblx0XHRcdFx0Ly8gVGhlIHVybCByZWZlcnMgdG8gdGhlIGZpcnN0IHBhZ2UgaWYgdGhlIHBhdGggbWF0Y2hlcyB0aGUgZG9jdW1lbnQgYW5kXG5cdFx0XHRcdC8vIGl0IGVpdGhlciBoYXMgbm8gaGFzaCB2YWx1ZSwgb3IgdGhlIGhhc2ggaXMgZXhhY3RseSBlcXVhbCB0byB0aGUgaWRcblx0XHRcdFx0Ly8gb2YgdGhlIGZpcnN0IHBhZ2UgZWxlbWVudC5cblx0XHRcdFx0cmV0dXJuIHNhbWVQYXRoICYmXG5cdFx0XHRcdFx0KCAhdS5oYXNoIHx8XG5cdFx0XHRcdFx0XHR1Lmhhc2ggPT09IFwiI1wiIHx8XG5cdFx0XHRcdFx0XHQoIGZwSWQgJiYgdS5oYXNoLnJlcGxhY2UoIC9eIy8sIFwiXCIgKSA9PT0gZnBJZCApICk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBTb21lIGVtYmVkZGVkIGJyb3dzZXJzLCBsaWtlIHRoZSB3ZWIgdmlldyBpbiBQaG9uZSBHYXAsIGFsbG93XG5cdFx0XHQvLyBjcm9zcy1kb21haW4gWEhSIHJlcXVlc3RzIGlmIHRoZSBkb2N1bWVudCBkb2luZyB0aGUgcmVxdWVzdCB3YXMgbG9hZGVkXG5cdFx0XHQvLyB2aWEgdGhlIGZpbGU6Ly8gcHJvdG9jb2wuIFRoaXMgaXMgdXN1YWxseSB0byBhbGxvdyB0aGUgYXBwbGljYXRpb24gdG9cblx0XHRcdC8vIFwicGhvbmUgaG9tZVwiIGFuZCBmZXRjaCBhcHAgc3BlY2lmaWMgZGF0YS4gV2Ugbm9ybWFsbHkgbGV0IHRoZSBicm93c2VyXG5cdFx0XHQvLyBoYW5kbGUgZXh0ZXJuYWwvY3Jvc3MtZG9tYWluIHVybHMsIGJ1dCBpZiB0aGUgYWxsb3dDcm9zc0RvbWFpblBhZ2VzXG5cdFx0XHQvLyBvcHRpb24gaXMgdHJ1ZSwgd2Ugd2lsbCBhbGxvdyBjcm9zcy1kb21haW4gaHR0cC9odHRwcyByZXF1ZXN0cyB0byBnb1xuXHRcdFx0Ly8gdGhyb3VnaCBvdXIgcGFnZSBsb2FkaW5nIGxvZ2ljLlxuXHRcdFx0aXNQZXJtaXR0ZWRDcm9zc0RvbWFpblJlcXVlc3Q6IGZ1bmN0aW9uKCBkb2NVcmwsIHJlcVVybCApIHtcblx0XHRcdFx0cmV0dXJuICQubW9iaWxlLmFsbG93Q3Jvc3NEb21haW5QYWdlcyAmJlxuXHRcdFx0XHRcdChkb2NVcmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIiB8fCBkb2NVcmwucHJvdG9jb2wgPT09IFwiY29udGVudDpcIikgJiZcblx0XHRcdFx0XHRyZXFVcmwuc2VhcmNoKCAvXmh0dHBzPzovICkgIT09IC0xO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwYXRoLmRvY3VtZW50VXJsID0gcGF0aC5wYXJzZUxvY2F0aW9uKCk7XG5cblx0XHQkYmFzZSA9ICQoIFwiaGVhZFwiICkuZmluZCggXCJiYXNlXCIgKTtcblxuXHRcdHBhdGguZG9jdW1lbnRCYXNlID0gJGJhc2UubGVuZ3RoID9cblx0XHRcdHBhdGgucGFyc2VVcmwoIHBhdGgubWFrZVVybEFic29sdXRlKCAkYmFzZS5hdHRyKCBcImhyZWZcIiApLCBwYXRoLmRvY3VtZW50VXJsLmhyZWYgKSApIDpcblx0XHRcdHBhdGguZG9jdW1lbnRVcmw7XG5cblx0XHRwYXRoLmRvY3VtZW50QmFzZURpZmZlcnMgPSAocGF0aC5kb2N1bWVudFVybC5ocmVmTm9IYXNoICE9PSBwYXRoLmRvY3VtZW50QmFzZS5ocmVmTm9IYXNoKTtcblxuXHRcdC8vcmV0dXJuIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBiYXNlIHVybFxuXHRcdHBhdGguZ2V0RG9jdW1lbnRCYXNlID0gZnVuY3Rpb24oIGFzUGFyc2VkT2JqZWN0ICkge1xuXHRcdFx0cmV0dXJuIGFzUGFyc2VkT2JqZWN0ID8gJC5leHRlbmQoIHt9LCBwYXRoLmRvY3VtZW50QmFzZSApIDogcGF0aC5kb2N1bWVudEJhc2UuaHJlZjtcblx0XHR9O1xuXG5cdFx0Ly8gREVQUkVDQVRFRCBhcyBvZiAxLjQuMCAtIHJlbW92ZSBpbiAxLjUuMFxuXHRcdCQuZXh0ZW5kKCAkLm1vYmlsZSwge1xuXG5cdFx0XHQvL3JldHVybiB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgdXJsXG5cdFx0XHRnZXREb2N1bWVudFVybDogcGF0aC5nZXREb2N1bWVudFVybCxcblxuXHRcdFx0Ly9yZXR1cm4gdGhlIG9yaWdpbmFsIGRvY3VtZW50IGJhc2UgdXJsXG5cdFx0XHRnZXREb2N1bWVudEJhc2U6IHBhdGguZ2V0RG9jdW1lbnRCYXNlXG5cdFx0fSk7XG59KSggalF1ZXJ5ICk7XG5cblxuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblx0JC5tb2JpbGUuSGlzdG9yeSA9IGZ1bmN0aW9uKCBzdGFjaywgaW5kZXggKSB7XG5cdFx0dGhpcy5zdGFjayA9IHN0YWNrIHx8IFtdO1xuXHRcdHRoaXMuYWN0aXZlSW5kZXggPSBpbmRleCB8fCAwO1xuXHR9O1xuXG5cdCQuZXh0ZW5kKCQubW9iaWxlLkhpc3RvcnkucHJvdG90eXBlLCB7XG5cdFx0Z2V0QWN0aXZlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnN0YWNrWyB0aGlzLmFjdGl2ZUluZGV4IF07XG5cdFx0fSxcblxuXHRcdGdldExhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhY2tbIHRoaXMucHJldmlvdXNJbmRleCBdO1xuXHRcdH0sXG5cblx0XHRnZXROZXh0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnN0YWNrWyB0aGlzLmFjdGl2ZUluZGV4ICsgMSBdO1xuXHRcdH0sXG5cblx0XHRnZXRQcmV2OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnN0YWNrWyB0aGlzLmFjdGl2ZUluZGV4IC0gMSBdO1xuXHRcdH0sXG5cblx0XHQvLyBhZGROZXcgaXMgdXNlZCB3aGVuZXZlciBhIG5ldyBwYWdlIGlzIGFkZGVkXG5cdFx0YWRkOiBmdW5jdGlvbiggdXJsLCBkYXRhICkge1xuXHRcdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cblx0XHRcdC8vaWYgdGhlcmUncyBmb3J3YXJkIGhpc3RvcnksIHdpcGUgaXRcblx0XHRcdGlmICggdGhpcy5nZXROZXh0KCkgKSB7XG5cdFx0XHRcdHRoaXMuY2xlYXJGb3J3YXJkKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHRoZSBoYXNoIGlzIGluY2x1ZGVkIGluIHRoZSBkYXRhIG1ha2Ugc3VyZSB0aGUgc2hhcGVcblx0XHRcdC8vIGlzIGNvbnNpc3RlbnQgZm9yIGNvbXBhcmlzb25cblx0XHRcdGlmICggZGF0YS5oYXNoICYmIGRhdGEuaGFzaC5pbmRleE9mKCBcIiNcIiApID09PSAtMSkge1xuXHRcdFx0XHRkYXRhLmhhc2ggPSBcIiNcIiArIGRhdGEuaGFzaDtcblx0XHRcdH1cblxuXHRcdFx0ZGF0YS51cmwgPSB1cmw7XG5cdFx0XHR0aGlzLnN0YWNrLnB1c2goIGRhdGEgKTtcblx0XHRcdHRoaXMuYWN0aXZlSW5kZXggPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG5cdFx0fSxcblxuXHRcdC8vd2lwZSB1cmxzIGFoZWFkIG9mIGFjdGl2ZSBpbmRleFxuXHRcdGNsZWFyRm9yd2FyZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnN0YWNrID0gdGhpcy5zdGFjay5zbGljZSggMCwgdGhpcy5hY3RpdmVJbmRleCArIDEgKTtcblx0XHR9LFxuXG5cdFx0ZmluZDogZnVuY3Rpb24oIHVybCwgc3RhY2ssIGVhcmx5UmV0dXJuICkge1xuXHRcdFx0c3RhY2sgPSBzdGFjayB8fCB0aGlzLnN0YWNrO1xuXG5cdFx0XHR2YXIgZW50cnksIGksIGxlbmd0aCA9IHN0YWNrLmxlbmd0aCwgaW5kZXg7XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGVudHJ5ID0gc3RhY2tbaV07XG5cblx0XHRcdFx0aWYgKCBkZWNvZGVVUklDb21wb25lbnQodXJsKSA9PT0gZGVjb2RlVVJJQ29tcG9uZW50KGVudHJ5LnVybCkgfHxcblx0XHRcdFx0XHRkZWNvZGVVUklDb21wb25lbnQodXJsKSA9PT0gZGVjb2RlVVJJQ29tcG9uZW50KGVudHJ5Lmhhc2gpICkge1xuXHRcdFx0XHRcdGluZGV4ID0gaTtcblxuXHRcdFx0XHRcdGlmICggZWFybHlSZXR1cm4gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaW5kZXg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbmRleDtcblx0XHR9LFxuXG5cdFx0Y2xvc2VzdDogZnVuY3Rpb24oIHVybCApIHtcblx0XHRcdHZhciBjbG9zZXN0LCBhID0gdGhpcy5hY3RpdmVJbmRleDtcblxuXHRcdFx0Ly8gRmlyc3QsIHRha2UgdGhlIHNsaWNlIG9mIHRoZSBoaXN0b3J5IHN0YWNrIGJlZm9yZSB0aGUgY3VycmVudCBpbmRleCBhbmQgc2VhcmNoXG5cdFx0XHQvLyBmb3IgYSB1cmwgbWF0Y2guIElmIG9uZSBpcyBmb3VuZCwgd2UnbGwgYXZvaWQgYXZvaWQgbG9va2luZyB0aHJvdWdoIGZvcndhcmQgaGlzdG9yeVxuXHRcdFx0Ly8gTk9URSB0aGUgcHJlZmVyZW5jZSBmb3IgYmFja3dhcmQgaGlzdG9yeSBtb3ZlbWVudCBpcyBkcml2ZW4gYnkgdGhlIGZhY3QgdGhhdFxuXHRcdFx0Ly8gICAgICBtb3N0IG1vYmlsZSBicm93c2VycyBvbmx5IGhhdmUgYSBkZWRpY2F0ZWQgYmFjayBidXR0b24sIGFuZCB1c2VycyByYXJlbHkgdXNlXG5cdFx0XHQvLyAgICAgIHRoZSBmb3J3YXJkIGJ1dHRvbiBpbiBkZXNrdG9wIGJyb3dzZXIgYW55aG93XG5cdFx0XHRjbG9zZXN0ID0gdGhpcy5maW5kKCB1cmwsIHRoaXMuc3RhY2suc2xpY2UoMCwgYSkgKTtcblxuXHRcdFx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW4gYmFja3dhcmQgaGlzdG9yeSBjaGVjayBmb3J3YXJkLiBUaGUgYHRydWVgXG5cdFx0XHQvLyB2YWx1ZSBwYXNzZWQgYXMgdGhlIHRoaXJkIHBhcmFtZXRlciBjYXVzZXMgdGhlIGZpbmQgbWV0aG9kIHRvIGJyZWFrXG5cdFx0XHQvLyBvbiB0aGUgZmlyc3QgbWF0Y2ggaW4gdGhlIGZvcndhcmQgaGlzdG9yeSBzbGljZS4gVGhlIHN0YXJ0aW5nIGluZGV4XG5cdFx0XHQvLyBvZiB0aGUgc2xpY2UgbXVzdCB0aGVuIGJlIGFkZGVkIHRvIHRoZSByZXN1bHQgdG8gZ2V0IHRoZSBlbGVtZW50IGluZGV4XG5cdFx0XHQvLyBpbiB0aGUgb3JpZ2luYWwgaGlzdG9yeSBzdGFjayA6KCA6KFxuXHRcdFx0Ly9cblx0XHRcdC8vIFRPRE8gdGhpcyBpcyBoeXBlciBjb25mdXNpbmcgYW5kIHNob3VsZCBiZSBjbGVhbmVkIHVwICh1Z2ggc28gYmFkKVxuXHRcdFx0aWYgKCBjbG9zZXN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGNsb3Nlc3QgPSB0aGlzLmZpbmQoIHVybCwgdGhpcy5zdGFjay5zbGljZShhKSwgdHJ1ZSApO1xuXHRcdFx0XHRjbG9zZXN0ID0gY2xvc2VzdCA9PT0gdW5kZWZpbmVkID8gY2xvc2VzdCA6IGNsb3Nlc3QgKyBhO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2xvc2VzdDtcblx0XHR9LFxuXG5cdFx0ZGlyZWN0OiBmdW5jdGlvbiggb3B0cyApIHtcblx0XHRcdHZhciBuZXdBY3RpdmVJbmRleCA9IHRoaXMuY2xvc2VzdCggb3B0cy51cmwgKSwgYSA9IHRoaXMuYWN0aXZlSW5kZXg7XG5cblx0XHRcdC8vIHNhdmUgbmV3IHBhZ2UgaW5kZXgsIG51bGwgY2hlY2sgdG8gcHJldmVudCBmYWxzZXkgMCByZXN1bHRcblx0XHRcdC8vIHJlY29yZCB0aGUgcHJldmlvdXMgaW5kZXggZm9yIHJlZmVyZW5jZVxuXHRcdFx0aWYgKCBuZXdBY3RpdmVJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLmFjdGl2ZUluZGV4ID0gbmV3QWN0aXZlSW5kZXg7XG5cdFx0XHRcdHRoaXMucHJldmlvdXNJbmRleCA9IGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGludm9rZSBjYWxsYmFja3Mgd2hlcmUgYXBwcm9wcmlhdGVcblx0XHRcdC8vXG5cdFx0XHQvLyBUT0RPIHRoaXMgaXMgYWxzbyBjb252b2x1dGVkIGFuZCBjb25mdXNpbmdcblx0XHRcdGlmICggbmV3QWN0aXZlSW5kZXggPCBhICkge1xuXHRcdFx0XHQoIG9wdHMucHJlc2VudCB8fCBvcHRzLmJhY2sgfHwgJC5ub29wICkoIHRoaXMuZ2V0QWN0aXZlKCksIFwiYmFja1wiICk7XG5cdFx0XHR9IGVsc2UgaWYgKCBuZXdBY3RpdmVJbmRleCA+IGEgKSB7XG5cdFx0XHRcdCggb3B0cy5wcmVzZW50IHx8IG9wdHMuZm9yd2FyZCB8fCAkLm5vb3AgKSggdGhpcy5nZXRBY3RpdmUoKSwgXCJmb3J3YXJkXCIgKTtcblx0XHRcdH0gZWxzZSBpZiAoIG5ld0FjdGl2ZUluZGV4ID09PSB1bmRlZmluZWQgJiYgb3B0cy5taXNzaW5nICkge1xuXHRcdFx0XHRvcHRzLm1pc3NpbmcoIHRoaXMuZ2V0QWN0aXZlKCkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSkoIGpRdWVyeSApO1xuXG5cblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cdHZhciBwYXRoID0gJC5tb2JpbGUucGF0aCxcblx0XHRpbml0aWFsSHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cblx0JC5tb2JpbGUuTmF2aWdhdG9yID0gZnVuY3Rpb24oIGhpc3RvcnkgKSB7XG5cdFx0dGhpcy5oaXN0b3J5ID0gaGlzdG9yeTtcblx0XHR0aGlzLmlnbm9yZUluaXRpYWxIYXNoQ2hhbmdlID0gdHJ1ZTtcblxuXHRcdCQubW9iaWxlLndpbmRvdy5iaW5kKHtcblx0XHRcdFwicG9wc3RhdGUuaGlzdG9yeVwiOiAkLnByb3h5KCB0aGlzLnBvcHN0YXRlLCB0aGlzICksXG5cdFx0XHRcImhhc2hjaGFuZ2UuaGlzdG9yeVwiOiAkLnByb3h5KCB0aGlzLmhhc2hjaGFuZ2UsIHRoaXMgKVxuXHRcdH0pO1xuXHR9O1xuXG5cdCQuZXh0ZW5kKCQubW9iaWxlLk5hdmlnYXRvci5wcm90b3R5cGUsIHtcblx0XHRzcXVhc2g6IGZ1bmN0aW9uKCB1cmwsIGRhdGEgKSB7XG5cdFx0XHR2YXIgc3RhdGUsIGhyZWYsIGhhc2ggPSBwYXRoLmlzUGF0aCh1cmwpID8gcGF0aC5zdHJpcEhhc2godXJsKSA6IHVybDtcblxuXHRcdFx0aHJlZiA9IHBhdGguc3F1YXNoKCB1cmwgKTtcblxuXHRcdFx0Ly8gbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhpcyBpbmZvcm1hdGlvbiB3aGVuIGl0IGlzbid0IGV4cGxpY2l0bHkgc2V0IGluIHRoZVxuXHRcdFx0Ly8gZGF0YSBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSBzcXVhc2ggbWV0aG9kXG5cdFx0XHRzdGF0ZSA9ICQuZXh0ZW5kKHtcblx0XHRcdFx0aGFzaDogaGFzaCxcblx0XHRcdFx0dXJsOiBocmVmXG5cdFx0XHR9LCBkYXRhKTtcblxuXHRcdFx0Ly8gcmVwbGFjZSB0aGUgY3VycmVudCB1cmwgd2l0aCB0aGUgbmV3IGhyZWYgYW5kIHN0b3JlIHRoZSBzdGF0ZVxuXHRcdFx0Ly8gTm90ZSB0aGF0IGluIHNvbWUgY2FzZXMgd2UgbWlnaHQgYmUgcmVwbGFjaW5nIGFuIHVybCB3aXRoIHRoZVxuXHRcdFx0Ly8gc2FtZSB1cmwuIFdlIGRvIHRoaXMgYW55d2F5cyBiZWNhdXNlIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXRcblx0XHRcdC8vIGFsbCBvZiBvdXIgaGlzdG9yeSBlbnRyaWVzIGhhdmUgYSBzdGF0ZSBvYmplY3QgYXNzb2NpYXRlZCB3aXRoXG5cdFx0XHQvLyB0aGVtLiBUaGlzIGFsbG93cyB1cyB0byB3b3JrIGFyb3VuZCB0aGUgY2FzZSB3aGVyZSAkLm1vYmlsZS5iYWNrKClcblx0XHRcdC8vIGlzIGNhbGxlZCB0byB0cmFuc2l0aW9uIGZyb20gYW4gZXh0ZXJuYWwgcGFnZSB0byBhbiBlbWJlZGRlZCBwYWdlLlxuXHRcdFx0Ly8gSW4gdGhhdCBwYXJ0aWN1bGFyIGNhc2UsIGEgaGFzaGNoYW5nZSBldmVudCBpcyAqTk9UKiBnZW5lcmF0ZWQgYnkgdGhlIGJyb3dzZXIuXG5cdFx0XHQvLyBFbnN1cmluZyBlYWNoIGhpc3RvcnkgZW50cnkgaGFzIGEgc3RhdGUgb2JqZWN0IG1lYW5zIHRoYXQgb25Qb3BTdGF0ZSgpXG5cdFx0XHQvLyB3aWxsIGFsd2F5cyB0cmlnZ2VyIG91ciBoYXNoY2hhbmdlIGNhbGxiYWNrIGV2ZW4gd2hlbiBhIGhhc2hjaGFuZ2UgZXZlbnRcblx0XHRcdC8vIGlzIG5vdCBmaXJlZC5cblx0XHRcdHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSggc3RhdGUsIHN0YXRlLnRpdGxlIHx8IGRvY3VtZW50LnRpdGxlLCBocmVmICk7XG5cblx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHR9LFxuXG5cdFx0aGFzaDogZnVuY3Rpb24oIHVybCwgaHJlZiApIHtcblx0XHRcdHZhciBwYXJzZWQsIGxvYywgaGFzaCwgcmVzb2x2ZWQ7XG5cblx0XHRcdC8vIEdyYWIgdGhlIGhhc2ggZm9yIHJlY29yZGluZy4gSWYgdGhlIHBhc3NlZCB1cmwgaXMgYSBwYXRoXG5cdFx0XHQvLyB3ZSB1c2VkIHRoZSBwYXJzZWQgdmVyc2lvbiBvZiB0aGUgc3F1YXNoZWQgdXJsIHRvIHJlY29uc3RydWN0LFxuXHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIGFzc3VtZSBpdCdzIGEgaGFzaCBhbmQgc3RvcmUgaXQgZGlyZWN0bHlcblx0XHRcdHBhcnNlZCA9IHBhdGgucGFyc2VVcmwoIHVybCApO1xuXHRcdFx0bG9jID0gcGF0aC5wYXJzZUxvY2F0aW9uKCk7XG5cblx0XHRcdGlmICggbG9jLnBhdGhuYW1lICsgbG9jLnNlYXJjaCA9PT0gcGFyc2VkLnBhdGhuYW1lICsgcGFyc2VkLnNlYXJjaCApIHtcblx0XHRcdFx0Ly8gSWYgdGhlIHBhdGhuYW1lIGFuZCBzZWFyY2ggb2YgdGhlIHBhc3NlZCB1cmwgaXMgaWRlbnRpY2FsIHRvIHRoZSBjdXJyZW50IGxvY1xuXHRcdFx0XHQvLyB0aGVuIHdlIG11c3QgdXNlIHRoZSBoYXNoLiBPdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBubyBldmVudFxuXHRcdFx0XHQvLyBlZywgdXJsID0gXCIvZm9vL2Jhcj9iYXojYmFuZ1wiLCBsb2NhdGlvbi5ocmVmID0gXCJodHRwOi8vZXhhbXBsZS5jb20vZm9vL2Jhcj9iYXpcIlxuXHRcdFx0XHRoYXNoID0gcGFyc2VkLmhhc2ggPyBwYXJzZWQuaGFzaCA6IHBhcnNlZC5wYXRobmFtZSArIHBhcnNlZC5zZWFyY2g7XG5cdFx0XHR9IGVsc2UgaWYgKCBwYXRoLmlzUGF0aCh1cmwpICkge1xuXHRcdFx0XHRyZXNvbHZlZCA9IHBhdGgucGFyc2VVcmwoIGhyZWYgKTtcblx0XHRcdFx0Ly8gSWYgdGhlIHBhc3NlZCB1cmwgaXMgYSBwYXRoLCBtYWtlIGl0IGRvbWFpbiByZWxhdGl2ZSBhbmQgcmVtb3ZlIGFueSB0cmFpbGluZyBoYXNoXG5cdFx0XHRcdGhhc2ggPSByZXNvbHZlZC5wYXRobmFtZSArIHJlc29sdmVkLnNlYXJjaCArIChwYXRoLmlzUHJlc2VydmFibGVIYXNoKCByZXNvbHZlZC5oYXNoICk/IHJlc29sdmVkLmhhc2gucmVwbGFjZSggXCIjXCIsIFwiXCIgKSA6IFwiXCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFzaCA9IHVybDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fSxcblxuXHRcdC8vIFRPRE8gcmVjb25zaWRlciBuYW1lXG5cdFx0Z286IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIG5vRXZlbnRzICkge1xuXHRcdFx0dmFyIHN0YXRlLCBocmVmLCBoYXNoLCBwb3BzdGF0ZUV2ZW50LFxuXHRcdFx0XHRpc1BvcFN0YXRlRXZlbnQgPSAkLmV2ZW50LnNwZWNpYWwubmF2aWdhdGUuaXNQdXNoU3RhdGVFbmFibGVkKCk7XG5cblx0XHRcdC8vIEdldCB0aGUgdXJsIGFzIGl0IHdvdWxkIGxvb2sgc3F1YXNoZWQgb24gdG8gdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiB1cmxcblx0XHRcdGhyZWYgPSBwYXRoLnNxdWFzaCggdXJsICk7XG5cblx0XHRcdC8vIHNvcnQgb3V0IHdoYXQgdGhlIGhhc2ggc291bGQgYmUgZnJvbSB0aGUgdXJsXG5cdFx0XHRoYXNoID0gdGhpcy5oYXNoKCB1cmwsIGhyZWYgKTtcblxuXHRcdFx0Ly8gSGVyZSB3ZSBwcmV2ZW50IHRoZSBuZXh0IGhhc2ggY2hhbmdlIG9yIHBvcHN0YXRlIGV2ZW50IGZyb20gZG9pbmcgYW55XG5cdFx0XHQvLyBoaXN0b3J5IG1hbmFnZW1lbnQuIEluIHRoZSBjYXNlIG9mIGhhc2hjaGFuZ2Ugd2UgZG9uJ3Qgc3dhbGxvdyBpdFxuXHRcdFx0Ly8gaWYgdGhlcmUgd2lsbCBiZSBubyBoYXNoY2hhbmdlIGZpcmVkIChzaW5jZSB0aGF0IHdvbid0IHJlc2V0IHRoZSB2YWx1ZSlcblx0XHRcdC8vIGFuZCB3aWxsIHN3YWxsb3cgdGhlIGZvbGxvd2luZyBoYXNoY2hhbmdlXG5cdFx0XHRpZiAoIG5vRXZlbnRzICYmIGhhc2ggIT09IHBhdGguc3RyaXBIYXNoKHBhdGgucGFyc2VMb2NhdGlvbigpLmhhc2gpICkge1xuXHRcdFx0XHR0aGlzLnByZXZlbnROZXh0SGFzaENoYW5nZSA9IG5vRXZlbnRzO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJTVBPUlRBTlQgaW4gdGhlIGNhc2Ugd2hlcmUgcG9wc3RhdGUgaXMgc3VwcG9ydGVkIHRoZSBldmVudCB3aWxsIGJlIHRyaWdnZXJlZFxuXHRcdFx0Ly8gICAgICBkaXJlY3RseSwgc3RvcHBpbmcgZnVydGhlciBleGVjdXRpb24gLSBpZSwgaW50ZXJ1cHRpbmcgdGhlIGZsb3cgb2YgdGhpc1xuXHRcdFx0Ly8gICAgICBtZXRob2QgY2FsbCB0byBmaXJlIGJpbmRpbmdzIGF0IHRoaXMgZXhwcmVzc2lvbi4gQmVsb3cgdGhlIG5hdmlnYXRlIG1ldGhvZFxuXHRcdFx0Ly8gICAgICB0aGVyZSBpcyBhIGJpbmRpbmcgdG8gY2F0Y2ggdGhpcyBldmVudCBhbmQgc3RvcCBpdHMgcHJvcGFnYXRpb24uXG5cdFx0XHQvL1xuXHRcdFx0Ly8gICAgICBXZSB0aGVuIHRyaWdnZXIgYSBuZXcgcG9wc3RhdGUgZXZlbnQgb24gdGhlIHdpbmRvdyB3aXRoIGEgbnVsbCBzdGF0ZVxuXHRcdFx0Ly8gICAgICBzbyB0aGF0IHRoZSBuYXZpZ2F0ZSBldmVudHMgY2FuIGNvbmNsdWRlIHRoZWlyIHdvcmsgcHJvcGVybHlcblx0XHRcdC8vXG5cdFx0XHQvLyBpZiB0aGUgdXJsIGlzIGEgcGF0aCB3ZSB3YW50IHRvIHByZXNlcnZlIHRoZSBxdWVyeSBwYXJhbXMgdGhhdCBhcmUgYXZhaWxhYmxlIG9uXG5cdFx0XHQvLyB0aGUgY3VycmVudCB1cmwuXG5cdFx0XHR0aGlzLnByZXZlbnRIYXNoQXNzaWduUG9wU3RhdGUgPSB0cnVlO1xuXHRcdFx0d2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoO1xuXG5cdFx0XHQvLyBJZiBwb3BzdGF0ZSBpcyBlbmFibGVkIGFuZCB0aGUgYnJvd3NlciB0cmlnZ2VycyBgcG9wc3RhdGVgIGV2ZW50cyB3aGVuIHRoZSBoYXNoXG5cdFx0XHQvLyBpcyBzZXQgKHRoaXMgb2Z0ZW4gaGFwcGVucyBpbW1lZGlhdGVseSBpbiBicm93c2VycyBsaWtlIENocm9tZSksIHRoZW4gdGhlXG5cdFx0XHQvLyB0aGlzIGZsYWcgd2lsbCBiZSBzZXQgdG8gZmFsc2UgYWxyZWFkeS4gSWYgaXQncyBhIGJyb3dzZXIgdGhhdCBkb2VzIG5vdCB0cmlnZ2VyXG5cdFx0XHQvLyBhIGBwb3BzdGF0ZWAgb24gaGFzaCBhc3NpZ25lbWVudCBvciBgcmVwbGFjZVN0YXRlYCB0aGVuIHdlIG5lZWQgYXZvaWQgdGhlIGJyYW5jaFxuXHRcdFx0Ly8gdGhhdCBzd2FsbG93cyB0aGUgZXZlbnQgY3JlYXRlZCBieSB0aGUgcG9wc3RhdGUgZ2VuZXJhdGVkIGJ5IHRoZSBoYXNoIGFzc2lnbm1lbnRcblx0XHRcdC8vIEF0IHRoZSB0aW1lIG9mIHRoaXMgd3JpdGluZyB0aGlzIGhhcHBlbnMgd2l0aCBPcGVyYSAxMiBhbmQgc29tZSB2ZXJzaW9uIG9mIElFXG5cdFx0XHR0aGlzLnByZXZlbnRIYXNoQXNzaWduUG9wU3RhdGUgPSBmYWxzZTtcblxuXHRcdFx0c3RhdGUgPSAkLmV4dGVuZCh7XG5cdFx0XHRcdHVybDogaHJlZixcblx0XHRcdFx0aGFzaDogaGFzaCxcblx0XHRcdFx0dGl0bGU6IGRvY3VtZW50LnRpdGxlXG5cdFx0XHR9LCBkYXRhKTtcblxuXHRcdFx0aWYgKCBpc1BvcFN0YXRlRXZlbnQgKSB7XG5cdFx0XHRcdHBvcHN0YXRlRXZlbnQgPSBuZXcgJC5FdmVudCggXCJwb3BzdGF0ZVwiICk7XG5cdFx0XHRcdHBvcHN0YXRlRXZlbnQub3JpZ2luYWxFdmVudCA9IHtcblx0XHRcdFx0XHR0eXBlOiBcInBvcHN0YXRlXCIsXG5cdFx0XHRcdFx0c3RhdGU6IG51bGxcblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLnNxdWFzaCggdXJsLCBzdGF0ZSApO1xuXG5cdFx0XHRcdC8vIFRyaWdnZXIgYSBuZXcgZmF1eCBwb3BzdGF0ZSBldmVudCB0byByZXBsYWNlIHRoZSBvbmUgdGhhdCB3ZVxuXHRcdFx0XHQvLyBjYXVnaHQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSBoYXNoIHNldHRpbmcgYWJvdmUuXG5cdFx0XHRcdGlmICggIW5vRXZlbnRzICkge1xuXHRcdFx0XHRcdHRoaXMuaWdub3JlUG9wU3RhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdCQubW9iaWxlLndpbmRvdy50cmlnZ2VyKCBwb3BzdGF0ZUV2ZW50ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVjb3JkIHRoZSBoaXN0b3J5IGVudHJ5IHNvIHRoYXQgdGhlIGluZm9ybWF0aW9uIGNhbiBiZSBpbmNsdWRlZFxuXHRcdFx0Ly8gaW4gaGFzaGNoYW5nZSBldmVudCBkcml2ZW4gbmF2aWdhdGUgZXZlbnRzIGluIGEgc2ltaWxhciBmYXNoaW9uIHRvXG5cdFx0XHQvLyB0aGUgc3RhdGUgdGhhdCdzIHByb3ZpZGVkIGJ5IHBvcHN0YXRlXG5cdFx0XHR0aGlzLmhpc3RvcnkuYWRkKCBzdGF0ZS51cmwsIHN0YXRlICk7XG5cdFx0fSxcblxuXHRcdC8vIFRoaXMgYmluZGluZyBpcyBpbnRlbmRlZCB0byBjYXRjaCB0aGUgcG9wc3RhdGUgZXZlbnRzIHRoYXQgYXJlIGZpcmVkXG5cdFx0Ly8gd2hlbiBleGVjdXRpb24gb2YgdGhlIGAkLm5hdmlnYXRlYCBtZXRob2Qgc3RvcHMgYXQgd2luZG93LmxvY2F0aW9uLmhhc2ggPSB1cmw7XG5cdFx0Ly8gYW5kIGNvbXBsZXRlbHkgcHJldmVudCB0aGVtIGZyb20gcHJvcGFnYXRpbmcuIFRoZSBwb3BzdGF0ZSBldmVudCB3aWxsIHRoZW4gYmVcblx0XHQvLyByZXRyaWdnZXJlZCBhZnRlciBleGVjdXRpb24gcmVzdW1lc1xuXHRcdC8vXG5cdFx0Ly8gVE9ETyBncmFiIHRoZSBvcmlnaW5hbCBldmVudCBoZXJlIGFuZCB1c2UgaXQgZm9yIHRoZSBzeW50aGV0aWMgZXZlbnQgaW4gdGhlXG5cdFx0Ly8gICAgICBzZWNvbmQgaGFsZiBvZiB0aGUgbmF2aWdhdGUgZXhlY3V0aW9uIHRoYXQgd2lsbCBmb2xsb3cgdGhpcyBiaW5kaW5nXG5cdFx0cG9wc3RhdGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBoYXNoLCBzdGF0ZTtcblxuXHRcdFx0Ly8gUGFydGx5IHRvIHN1cHBvcnQgb3VyIHRlc3Qgc3VpdGUgd2hpY2ggbWFudWFsbHkgYWx0ZXJzIHRoZSBzdXBwb3J0XG5cdFx0XHQvLyB2YWx1ZSB0byB0ZXN0IGhhc2hjaGFuZ2UuIFBhcnRseSB0byBwcmV2ZW50IGFsbCBhcm91bmQgd2VpcmRuZXNzXG5cdFx0XHRpZiAoICEkLmV2ZW50LnNwZWNpYWwubmF2aWdhdGUuaXNQdXNoU3RhdGVFbmFibGVkKCkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyB0aGUgcG9wc3RhdGUgdHJpZ2dlcmVkIGJ5IHRoZSBhY3R1YWwgYWx0ZXJhdGlvbiBvZiB0aGUgaGFzaFxuXHRcdFx0Ly8gcHJldmVudCBpdCBjb21wbGV0ZWx5LiBIaXN0b3J5IGlzIHRyYWNrZWQgbWFudWFsbHlcblx0XHRcdGlmICggdGhpcy5wcmV2ZW50SGFzaEFzc2lnblBvcFN0YXRlICkge1xuXHRcdFx0XHR0aGlzLnByZXZlbnRIYXNoQXNzaWduUG9wU3RhdGUgPSBmYWxzZTtcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgdGhpcyBpcyB0aGUgcG9wc3RhdGUgdHJpZ2dlcmVkIGFmdGVyIHRoZSBgcmVwbGFjZVN0YXRlYCBjYWxsIGluIHRoZSBnb1xuXHRcdFx0Ly8gbWV0aG9kLCB0aGVuIHNpbXBseSBpZ25vcmUgaXQuIFRoZSBoaXN0b3J5IGVudHJ5IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWRcblx0XHRcdGlmICggdGhpcy5pZ25vcmVQb3BTdGF0ZSApIHtcblx0XHRcdFx0dGhpcy5pZ25vcmVQb3BTdGF0ZSA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZXJlIGlzIG5vIHN0YXRlLCBhbmQgdGhlIGhpc3Rvcnkgc3RhY2sgbGVuZ3RoIGlzIG9uZSB3ZXJlXG5cdFx0XHQvLyBwcm9iYWJseSBnZXR0aW5nIHRoZSBwYWdlIGxvYWQgcG9wc3RhdGUgZmlyZWQgYnkgYnJvd3NlcnMgbGlrZSBjaHJvbWVcblx0XHRcdC8vIGF2b2lkIGl0IGFuZCBzZXQgdGhlIG9uZSB0aW1lIGZsYWcgdG8gZmFsc2UuXG5cdFx0XHQvLyBUT0RPOiBEbyB3ZSByZWFsbHkgbmVlZCBhbGwgdGhlc2UgY29uZGl0aW9ucz8gQ29tcGFyaW5nIGxvY2F0aW9uIGhyZWZzXG5cdFx0XHQvLyBzaG91bGQgYmUgc3VmZmljaWVudC5cblx0XHRcdGlmICggIWV2ZW50Lm9yaWdpbmFsRXZlbnQuc3RhdGUgJiZcblx0XHRcdFx0dGhpcy5oaXN0b3J5LnN0YWNrLmxlbmd0aCA9PT0gMSAmJlxuXHRcdFx0XHR0aGlzLmlnbm9yZUluaXRpYWxIYXNoQ2hhbmdlICkge1xuXHRcdFx0XHR0aGlzLmlnbm9yZUluaXRpYWxIYXNoQ2hhbmdlID0gZmFsc2U7XG5cblx0XHRcdFx0aWYgKCBsb2NhdGlvbi5ocmVmID09PSBpbml0aWFsSHJlZiApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhY2NvdW50IGZvciBkaXJlY3QgbWFuaXB1bGF0aW9uIG9mIHRoZSBoYXNoLiBUaGF0IGlzLCB3ZSB3aWxsIHJlY2VpdmUgYSBwb3BzdGF0ZVxuXHRcdFx0Ly8gd2hlbiB0aGUgaGFzaCBpcyBjaGFuZ2VkIGJ5IGFzc2lnbm1lbnQsIGFuZCBpdCB3b24ndCBoYXZlIGEgc3RhdGUgYXNzb2NpYXRlZC4gV2Vcblx0XHRcdC8vIHRoZW4gbmVlZCB0byBzcXVhc2ggdGhlIGhhc2guIFNlZSBiZWxvdyBmb3IgaGFuZGxpbmcgb2YgaGFzaCBhc3NpZ25tZW50IHRoYXRcblx0XHRcdC8vIG1hdGNoZXMgYW4gZXhpc3RpbmcgaGlzdG9yeSBlbnRyeVxuXHRcdFx0Ly8gVE9ETyBpdCBtaWdodCBiZSBiZXR0ZXIgdG8gb25seSBhZGQgdG8gdGhlIGhpc3Rvcnkgc3RhY2tcblx0XHRcdC8vICAgICAgd2hlbiB0aGUgaGFzaCBpcyBhZGphY2VudCB0byB0aGUgYWN0aXZlIGhpc3RvcnkgZW50cnlcblx0XHRcdGhhc2ggPSBwYXRoLnBhcnNlTG9jYXRpb24oKS5oYXNoO1xuXHRcdFx0aWYgKCAhZXZlbnQub3JpZ2luYWxFdmVudC5zdGF0ZSAmJiBoYXNoICkge1xuXHRcdFx0XHQvLyBzcXVhc2ggdGhlIGhhc2ggdGhhdCdzIGJlZW4gYXNzaWduZWQgb24gdGhlIFVSTCB3aXRoIHJlcGxhY2VTdGF0ZVxuXHRcdFx0XHQvLyBhbHNvIGdyYWIgdGhlIHJlc3VsdGluZyBzdGF0ZSBvYmplY3QgZm9yIHN0b3JhZ2Vcblx0XHRcdFx0c3RhdGUgPSB0aGlzLnNxdWFzaCggaGFzaCApO1xuXG5cdFx0XHRcdC8vIHJlY29yZCB0aGUgbmV3IGhhc2ggYXMgYW4gYWRkaXRpb25hbCBoaXN0b3J5IGVudHJ5XG5cdFx0XHRcdC8vIHRvIG1hdGNoIHRoZSBicm93c2VyJ3MgdHJlYXRtZW50IG9mIGhhc2ggYXNzaWdubWVudFxuXHRcdFx0XHR0aGlzLmhpc3RvcnkuYWRkKCBzdGF0ZS51cmwsIHN0YXRlICk7XG5cblx0XHRcdFx0Ly8gcGFzcyB0aGUgbmV3bHkgY3JlYXRlZCBzdGF0ZSBpbmZvcm1hdGlvblxuXHRcdFx0XHQvLyBhbG9uZyB3aXRoIHRoZSBldmVudFxuXHRcdFx0XHRldmVudC5oaXN0b3J5U3RhdGUgPSBzdGF0ZTtcblxuXHRcdFx0XHQvLyBkbyBub3QgYWx0ZXIgaGlzdG9yeSwgd2UndmUgYWRkZWQgYSBuZXcgaGlzdG9yeSBlbnRyeVxuXHRcdFx0XHQvLyBzbyB3ZSBrbm93IHdoZXJlIHdlIGFyZVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGFsbCBlbHNlIGZhaWxzIHRoaXMgaXMgYSBwb3BzdGF0ZSB0aGF0IGNvbWVzIGZyb20gdGhlIGJhY2sgb3IgZm9yd2FyZCBidXR0b25zXG5cdFx0XHQvLyBtYWtlIHN1cmUgdG8gc2V0IHRoZSBzdGF0ZSBvZiBvdXIgaGlzdG9yeSBzdGFjayBwcm9wZXJseSwgYW5kIHJlY29yZCB0aGUgZGlyZWN0aW9uYWxpdHlcblx0XHRcdHRoaXMuaGlzdG9yeS5kaXJlY3Qoe1xuXHRcdFx0XHR1cmw6IChldmVudC5vcmlnaW5hbEV2ZW50LnN0YXRlIHx8IHt9KS51cmwgfHwgaGFzaCxcblxuXHRcdFx0XHQvLyBXaGVuIHRoZSB1cmwgaXMgZWl0aGVyIGZvcndhcmQgb3IgYmFja3dhcmQgaW4gaGlzdG9yeSBpbmNsdWRlIHRoZSBlbnRyeVxuXHRcdFx0XHQvLyBhcyBkYXRhIG9uIHRoZSBldmVudCBvYmplY3QgZm9yIG1lcmdpbmcgYXMgZGF0YSBpbiB0aGUgbmF2aWdhdGUgZXZlbnRcblx0XHRcdFx0cHJlc2VudDogZnVuY3Rpb24oIGhpc3RvcnlFbnRyeSwgZGlyZWN0aW9uICkge1xuXHRcdFx0XHRcdC8vIG1ha2Ugc3VyZSB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IHRvIHBhc3MgZG93biBhcyB0aGUgbmF2aWdhdGUgZXZlbnQgZGF0YVxuXHRcdFx0XHRcdGV2ZW50Lmhpc3RvcnlTdGF0ZSA9ICQuZXh0ZW5kKHt9LCBoaXN0b3J5RW50cnkpO1xuXHRcdFx0XHRcdGV2ZW50Lmhpc3RvcnlTdGF0ZS5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvLyBOT1RFIG11c3QgYmluZCBiZWZvcmUgYG5hdmlnYXRlYCBzcGVjaWFsIGV2ZW50IGhhc2hjaGFuZ2UgYmluZGluZyBvdGhlcndpc2UgdGhlXG5cdFx0Ly8gICAgICBuYXZpZ2F0aW9uIGRhdGEgd29uJ3QgYmUgYXR0YWNoZWQgdG8gdGhlIGhhc2hjaGFuZ2UgZXZlbnQgaW4gdGltZSBmb3IgdGhvc2Vcblx0XHQvLyAgICAgIGJpbmRpbmdzIHRvIGF0dGFjaCBpdCB0byB0aGUgYG5hdmlnYXRlYCBzcGVjaWFsIGV2ZW50XG5cdFx0Ly8gVE9ETyBhZGQgYSBjaGVjayBoZXJlIHRoYXQgYGhhc2hjaGFuZ2UubmF2aWdhdGVgIGlzIGJvdW5kIGFscmVhZHkgb3RoZXJ3aXNlIGl0J3Ncblx0XHQvLyAgICAgIGJyb2tlbiAoZXhjZXB0aW9uPylcblx0XHRoYXNoY2hhbmdlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgaGlzdG9yeSwgaGFzaDtcblxuXHRcdFx0Ly8gSWYgaGFzaGNoYW5nZSBsaXN0ZW5pbmcgaXMgZXhwbGljaXRseSBkaXNhYmxlZCBvciBwdXNoc3RhdGUgaXMgc3VwcG9ydGVkXG5cdFx0XHQvLyBhdm9pZCBtYWtpbmcgdXNlIG9mIHRoZSBoYXNoY2hhbmdlIGhhbmRsZXIuXG5cdFx0XHRpZiAoISQuZXZlbnQuc3BlY2lhbC5uYXZpZ2F0ZS5pc0hhc2hDaGFuZ2VFbmFibGVkKCkgfHxcblx0XHRcdFx0JC5ldmVudC5zcGVjaWFsLm5hdmlnYXRlLmlzUHVzaFN0YXRlRW5hYmxlZCgpICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9uIG9jY2FzaW9uIGV4cGxpY2l0bHkgd2FudCB0byBwcmV2ZW50IHRoZSBuZXh0IGhhc2ggZnJvbSBwcm9wb2dhdGluZyBiZWNhdXNlIHdlIG9ubHlcblx0XHRcdC8vIHdpdGggdG8gYWx0ZXIgdGhlIHVybCB0byByZXByZXNlbnQgdGhlIG5ldyBzdGF0ZSBkbyBzbyBoZXJlXG5cdFx0XHRpZiAoIHRoaXMucHJldmVudE5leHRIYXNoQ2hhbmdlICkge1xuXHRcdFx0XHR0aGlzLnByZXZlbnROZXh0SGFzaENoYW5nZSA9IGZhbHNlO1xuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRoaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuXHRcdFx0aGFzaCA9IHBhdGgucGFyc2VMb2NhdGlvbigpLmhhc2g7XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBoYXNoY2hhbmdlIGNhdXNlZCBieSB0aGUgYmFjayBvciBmb3J3YXJkIGJ1dHRvblxuXHRcdFx0Ly8gbWFrZSBzdXJlIHRvIHNldCB0aGUgc3RhdGUgb2Ygb3VyIGhpc3Rvcnkgc3RhY2sgcHJvcGVybHlcblx0XHRcdHRoaXMuaGlzdG9yeS5kaXJlY3Qoe1xuXHRcdFx0XHR1cmw6IGhhc2gsXG5cblx0XHRcdFx0Ly8gV2hlbiB0aGUgdXJsIGlzIGVpdGhlciBmb3J3YXJkIG9yIGJhY2t3YXJkIGluIGhpc3RvcnkgaW5jbHVkZSB0aGUgZW50cnlcblx0XHRcdFx0Ly8gYXMgZGF0YSBvbiB0aGUgZXZlbnQgb2JqZWN0IGZvciBtZXJnaW5nIGFzIGRhdGEgaW4gdGhlIG5hdmlnYXRlIGV2ZW50XG5cdFx0XHRcdHByZXNlbnQ6IGZ1bmN0aW9uKCBoaXN0b3J5RW50cnksIGRpcmVjdGlvbiApIHtcblx0XHRcdFx0XHQvLyBtYWtlIHN1cmUgdG8gY3JlYXRlIGEgbmV3IG9iamVjdCB0byBwYXNzIGRvd24gYXMgdGhlIG5hdmlnYXRlIGV2ZW50IGRhdGFcblx0XHRcdFx0XHRldmVudC5oYXNoY2hhbmdlU3RhdGUgPSAkLmV4dGVuZCh7fSwgaGlzdG9yeUVudHJ5KTtcblx0XHRcdFx0XHRldmVudC5oYXNoY2hhbmdlU3RhdGUuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFdoZW4gd2UgZG9uJ3QgZmluZCBhIGhhc2ggaW4gb3VyIGhpc3RvcnkgY2xlYXJseSB3ZSdyZSBhaW1pbmcgdG8gZ28gdGhlcmVcblx0XHRcdFx0Ly8gcmVjb3JkIHRoZSBlbnRyeSBhcyBuZXcgZm9yIGZ1dHVyZSB0cmF2ZXJzYWxcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gTk9URSBpdCdzIG5vdCBlbnRpcmVseSBjbGVhciB0aGF0IHRoaXMgaXMgdGhlIHJpZ2h0IHRoaW5nIHRvIGRvIGdpdmVuIHRoYXQgd2Vcblx0XHRcdFx0Ly8gICAgICBjYW4ndCBrbm93IHRoZSB1c2VycyBpbnRlbnRpb24uIEl0IG1pZ2h0IGJlIGJldHRlciB0byBleHBsaWNpdGx5IF9ub3RfXG5cdFx0XHRcdC8vICAgICAgc3VwcG9ydCBsb2NhdGlvbi5oYXNoIGFzc2lnbm1lbnQgaW4gcHJlZmVyZW5jZSB0byAkLm5hdmlnYXRlIGNhbGxzXG5cdFx0XHRcdC8vIFRPRE8gZmlyc3QgYXJnIHRvIGFkZCBzaG91bGQgYmUgdGhlIGhyZWYsIGJ1dCBpdCBjYXVzZXMgaXNzdWVzIGluIGlkZW50aWZ5aW5nXG5cdFx0XHRcdC8vICAgICAgZW1iZWRlZCBwYWdlc1xuXHRcdFx0XHRtaXNzaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRoaXN0b3J5LmFkZCggaGFzaCwge1xuXHRcdFx0XHRcdFx0aGFzaDogaGFzaCxcblx0XHRcdFx0XHRcdHRpdGxlOiBkb2N1bWVudC50aXRsZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xufSkoIGpRdWVyeSApO1xuXG5cblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cdC8vIFRPRE8gY29uc2lkZXIgcXVldWVpbmcgbmF2aWdhdGlvbiBhY3Rpdml0eSB1bnRpbCBwcmV2aW91cyBhY3Rpdml0aWVzIGhhdmUgY29tcGxldGVkXG5cdC8vICAgICAgc28gdGhhdCBlbmQgdXNlcnMgZG9uJ3QgaGF2ZSB0byB0aGluayBhYm91dCBpdC4gUHVudGluZyBmb3Igbm93XG5cdC8vIFRPRE8gISEgbW92ZSB0aGUgZXZlbnQgYmluZGluZ3MgaW50byBjYWxsYmFja3Mgb24gdGhlIG5hdmlnYXRlIGV2ZW50XG5cdCQubW9iaWxlLm5hdmlnYXRlID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgbm9FdmVudHMgKSB7XG5cdFx0JC5tb2JpbGUubmF2aWdhdGUubmF2aWdhdG9yLmdvKCB1cmwsIGRhdGEsIG5vRXZlbnRzICk7XG5cdH07XG5cblx0Ly8gZXhwb3NlIHRoZSBoaXN0b3J5IG9uIHRoZSBuYXZpZ2F0ZSBtZXRob2QgaW4gYW50aWNpcGF0aW9uIG9mIGZ1bGwgaW50ZWdyYXRpb24gd2l0aFxuXHQvLyBleGlzdGluZyBuYXZpZ2F0aW9uIGZ1bmN0aW9uYWx0eSB0aGF0IGlzIHRpZ2h0bHkgY291cGxlZCB0byB0aGUgaGlzdG9yeSBpbmZvcm1hdGlvblxuXHQkLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5ID0gbmV3ICQubW9iaWxlLkhpc3RvcnkoKTtcblxuXHQvLyBpbnN0YW50aWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgbmF2aWdhdG9yIGZvciB1c2Ugd2l0aGluIHRoZSAkLm5hdmlnYXRlIG1ldGhvZFxuXHQkLm1vYmlsZS5uYXZpZ2F0ZS5uYXZpZ2F0b3IgPSBuZXcgJC5tb2JpbGUuTmF2aWdhdG9yKCAkLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5ICk7XG5cblx0dmFyIGxvYyA9ICQubW9iaWxlLnBhdGgucGFyc2VMb2NhdGlvbigpO1xuXHQkLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5LmFkZCggbG9jLmhyZWYsIHtoYXNoOiBsb2MuaGFzaH0gKTtcbn0pKCBqUXVlcnkgKTtcblxuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblx0dmFyIHByb3BzID0ge1xuXHRcdFx0XCJhbmltYXRpb25cIjoge30sXG5cdFx0XHRcInRyYW5zaXRpb25cIjoge31cblx0XHR9LFxuXHRcdHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKSxcblx0XHR2ZW5kb3JQcmVmaXhlcyA9IFsgXCJcIiwgXCJ3ZWJraXQtXCIsIFwibW96LVwiLCBcIm8tXCIgXTtcblxuXHQkLmVhY2goIFsgXCJhbmltYXRpb25cIiwgXCJ0cmFuc2l0aW9uXCIgXSwgZnVuY3Rpb24oIGksIHRlc3QgKSB7XG5cblx0XHQvLyBHZXQgY29ycmVjdCBuYW1lIGZvciB0ZXN0XG5cdFx0dmFyIHRlc3ROYW1lID0gKCBpID09PSAwICkgPyB0ZXN0ICsgXCItXCIgKyBcIm5hbWVcIiA6IHRlc3Q7XG5cblx0XHQkLmVhY2goIHZlbmRvclByZWZpeGVzLCBmdW5jdGlvbiggaiwgcHJlZml4ICkge1xuXHRcdFx0aWYgKCB0ZXN0RWxlbWVudC5zdHlsZVsgJC5jYW1lbENhc2UoIHByZWZpeCArIHRlc3ROYW1lICkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQgcHJvcHNbIHRlc3QgXVsgXCJwcmVmaXhcIiBdID0gcHJlZml4O1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBTZXQgZXZlbnQgYW5kIGR1cmF0aW9uIG5hbWVzIGZvciBsYXRlciB1c2Vcblx0XHRwcm9wc1sgdGVzdCBdWyBcImR1cmF0aW9uXCIgXSA9XG5cdFx0XHQkLmNhbWVsQ2FzZSggcHJvcHNbIHRlc3QgXVsgXCJwcmVmaXhcIiBdICsgdGVzdCArIFwiLVwiICsgXCJkdXJhdGlvblwiICk7XG5cdFx0cHJvcHNbIHRlc3QgXVsgXCJldmVudFwiIF0gPVxuXHRcdFx0JC5jYW1lbENhc2UoIHByb3BzWyB0ZXN0IF1bIFwicHJlZml4XCIgXSArIHRlc3QgKyBcIi1cIiArIFwiZW5kXCIgKTtcblxuXHRcdC8vIEFsbCBsb3dlciBjYXNlIGlmIG5vdCBhIHZlbmRvciBwcm9wXG5cdFx0aWYgKCBwcm9wc1sgdGVzdCBdWyBcInByZWZpeFwiIF0gPT09IFwiXCIgKSB7XG5cdFx0XHRwcm9wc1sgdGVzdCBdWyBcImV2ZW50XCIgXSA9IHByb3BzWyB0ZXN0IF1bIFwiZXZlbnRcIiBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBJZiBhIHZhbGlkIHByZWZpeCB3YXMgZm91bmQgdGhlbiB0aGUgaXQgaXMgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyXG5cdCQuc3VwcG9ydC5jc3NUcmFuc2l0aW9ucyA9ICggcHJvcHNbIFwidHJhbnNpdGlvblwiIF1bIFwicHJlZml4XCIgXSAhPT0gdW5kZWZpbmVkICk7XG5cdCQuc3VwcG9ydC5jc3NBbmltYXRpb25zID0gKCBwcm9wc1sgXCJhbmltYXRpb25cIiBdWyBcInByZWZpeFwiIF0gIT09IHVuZGVmaW5lZCApO1xuXG5cdC8vIFJlbW92ZSB0aGUgdGVzdEVsZW1lbnRcblx0JCggdGVzdEVsZW1lbnQgKS5yZW1vdmUoKTtcblxuXHQvLyBBbmltYXRpb24gY29tcGxldGUgY2FsbGJhY2tcblx0JC5mbi5hbmltYXRpb25Db21wbGV0ZSA9IGZ1bmN0aW9uKCBjYWxsYmFjaywgdHlwZSwgZmFsbGJhY2tUaW1lICkge1xuXHRcdHZhciB0aW1lciwgZHVyYXRpb24sXG5cdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdGV2ZW50QmluZGluZyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIENsZWFyIHRoZSB0aW1lciBzbyB3ZSBkb24ndCBjYWxsIGNhbGxiYWNrIHR3aWNlXG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGltZXIgKTtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fSxcblx0XHRcdGFuaW1hdGlvblR5cGUgPSAoICF0eXBlIHx8IHR5cGUgPT09IFwiYW5pbWF0aW9uXCIgKSA/IFwiYW5pbWF0aW9uXCIgOiBcInRyYW5zaXRpb25cIjtcblxuXHRcdC8vIE1ha2Ugc3VyZSBzZWxlY3RlZCB0eXBlIGlzIHN1cHBvcnRlZCBieSBicm93c2VyXG5cdFx0aWYgKCAoICQuc3VwcG9ydC5jc3NUcmFuc2l0aW9ucyAmJiBhbmltYXRpb25UeXBlID09PSBcInRyYW5zaXRpb25cIiApIHx8XG5cdFx0XHQoICQuc3VwcG9ydC5jc3NBbmltYXRpb25zICYmIGFuaW1hdGlvblR5cGUgPT09IFwiYW5pbWF0aW9uXCIgKSApIHtcblxuXHRcdFx0Ly8gSWYgYSBmYWxsYmFjayB0aW1lIHdhcyBub3QgcGFzc2VkIHNldCBvbmVcblx0XHRcdGlmICggZmFsbGJhY2tUaW1lID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoZSB3YXMgbm90IGJvdW5kIHRvIGRvY3VtZW50IGJlZm9yZSBjaGVja2luZyAuY3NzXG5cdFx0XHRcdGlmICggJCggdGhpcyApLmNvbnRleHQgIT09IGRvY3VtZW50ICkge1xuXG5cdFx0XHRcdFx0Ly8gUGFyc2UgdGhlIGR1cnJhdGlvbiBzaW5jZSBpdHMgaW4gc2Vjb25kIG11bHRpcGxlIGJ5IDEwMDAgZm9yIG1pbGxpc2Vjb25kc1xuXHRcdFx0XHRcdC8vIE11bHRpcGx5IGJ5IDMgdG8gbWFrZSBzdXJlIHdlIGdpdmUgdGhlIGFuaW1hdGlvbiBwbGVudHkgb2YgdGltZS5cblx0XHRcdFx0XHRkdXJhdGlvbiA9IHBhcnNlRmxvYXQoXG5cdFx0XHRcdFx0XHQkKCB0aGlzICkuY3NzKCBwcm9wc1sgYW5pbWF0aW9uVHlwZSBdLmR1cmF0aW9uIClcblx0XHRcdFx0XHQpICogMzAwMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHdlIGNvdWxkIG5vdCByZWFkIGEgZHVyYXRpb24gdXNlIHRoZSBkZWZhdWx0XG5cdFx0XHRcdGlmICggZHVyYXRpb24gPT09IDAgfHwgZHVyYXRpb24gPT09IHVuZGVmaW5lZCB8fCBpc05hTiggZHVyYXRpb24gKSApIHtcblx0XHRcdFx0XHRkdXJhdGlvbiA9ICQuZm4uYW5pbWF0aW9uQ29tcGxldGUuZGVmYXVsdER1cmF0aW9uO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldHMgdXAgdGhlIGZhbGxiYWNrIGlmIGV2ZW50IG5ldmVyIGNvbWVzXG5cdFx0XHR0aW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkKCB0aGF0ICkub2ZmKCBwcm9wc1sgYW5pbWF0aW9uVHlwZSBdLmV2ZW50LCBldmVudEJpbmRpbmcgKTtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoYXQgKTtcblx0XHRcdH0sIGR1cmF0aW9uICk7XG5cblx0XHRcdC8vIEJpbmQgdGhlIGV2ZW50XG5cdFx0XHRyZXR1cm4gJCggdGhpcyApLm9uZSggcHJvcHNbIGFuaW1hdGlvblR5cGUgXS5ldmVudCwgZXZlbnRCaW5kaW5nICk7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ1NTIGFuaW1hdGlvbiAvIHRyYW5zaXRpb25zIG5vdCBzdXBwb3J0ZWRcblx0XHRcdC8vIERlZmVyIGV4ZWN1dGlvbiBmb3IgY29uc2lzdGVuY3kgYmV0d2VlbiB3ZWJraXQvbm9uIHdlYmtpdFxuXHRcdFx0c2V0VGltZW91dCggJC5wcm94eSggY2FsbGJhY2ssIHRoaXMgKSwgMCApO1xuXHRcdFx0cmV0dXJuICQoIHRoaXMgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gQWxsb3cgZGVmYXVsdCBjYWxsYmFjayB0byBiZSBjb25maWd1cmVkIG9uIG1vYmlsZUluaXRcblx0JC5mbi5hbmltYXRpb25Db21wbGV0ZS5kZWZhdWx0RHVyYXRpb24gPSAxMDAwO1xufSkoIGpRdWVyeSApO1xuXG4vLyBUaGlzIHBsdWdpbiBpcyBhbiBleHBlcmltZW50IGZvciBhYnN0cmFjdGluZyBhd2F5IHRoZSB0b3VjaCBhbmQgbW91c2Vcbi8vIGV2ZW50cyBzbyB0aGF0IGRldmVsb3BlcnMgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCB3aGljaCBtZXRob2Qgb2YgaW5wdXRcbi8vIHRoZSBkZXZpY2UgdGhlaXIgZG9jdW1lbnQgaXMgbG9hZGVkIG9uIHN1cHBvcnRzLlxuLy9cbi8vIFRoZSBpZGVhIGhlcmUgaXMgdG8gYWxsb3cgdGhlIGRldmVsb3BlciB0byByZWdpc3RlciBsaXN0ZW5lcnMgZm9yIHRoZVxuLy8gYmFzaWMgbW91c2UgZXZlbnRzLCBzdWNoIGFzIG1vdXNlZG93biwgbW91c2Vtb3ZlLCBtb3VzZXVwLCBhbmQgY2xpY2ssXG4vLyBhbmQgdGhlIHBsdWdpbiB3aWxsIHRha2UgY2FyZSBvZiByZWdpc3RlcmluZyB0aGUgY29ycmVjdCBsaXN0ZW5lcnNcbi8vIGJlaGluZCB0aGUgc2NlbmVzIHRvIGludm9rZSB0aGUgbGlzdGVuZXIgYXQgdGhlIGZhc3Rlc3QgcG9zc2libGUgdGltZVxuLy8gZm9yIHRoYXQgZGV2aWNlLCB3aGlsZSBzdGlsbCByZXRhaW5pbmcgdGhlIG9yZGVyIG9mIGV2ZW50IGZpcmluZyBpblxuLy8gdGhlIHRyYWRpdGlvbmFsIG1vdXNlIGVudmlyb25tZW50LCBzaG91bGQgbXVsdGlwbGUgaGFuZGxlcnMgYmUgcmVnaXN0ZXJlZFxuLy8gb24gdGhlIHNhbWUgZWxlbWVudCBmb3IgZGlmZmVyZW50IGV2ZW50cy5cbi8vXG4vLyBUaGUgY3VycmVudCB2ZXJzaW9uIGV4cG9zZXMgdGhlIGZvbGxvd2luZyB2aXJ0dWFsIGV2ZW50cyB0byBqUXVlcnkgYmluZCBtZXRob2RzOlxuLy8gXCJ2bW91c2VvdmVyIHZtb3VzZWRvd24gdm1vdXNlbW92ZSB2bW91c2V1cCB2Y2xpY2sgdm1vdXNlb3V0IHZtb3VzZWNhbmNlbFwiXG5cbihmdW5jdGlvbiggJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkICkge1xuXG52YXIgZGF0YVByb3BlcnR5TmFtZSA9IFwidmlydHVhbE1vdXNlQmluZGluZ3NcIixcblx0dG91Y2hUYXJnZXRQcm9wZXJ0eU5hbWUgPSBcInZpcnR1YWxUb3VjaElEXCIsXG5cdHZpcnR1YWxFdmVudE5hbWVzID0gXCJ2bW91c2VvdmVyIHZtb3VzZWRvd24gdm1vdXNlbW92ZSB2bW91c2V1cCB2Y2xpY2sgdm1vdXNlb3V0IHZtb3VzZWNhbmNlbFwiLnNwbGl0KCBcIiBcIiApLFxuXHR0b3VjaEV2ZW50UHJvcHMgPSBcImNsaWVudFggY2xpZW50WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlbllcIi5zcGxpdCggXCIgXCIgKSxcblx0bW91c2VIb29rUHJvcHMgPSAkLmV2ZW50Lm1vdXNlSG9va3MgPyAkLmV2ZW50Lm1vdXNlSG9va3MucHJvcHMgOiBbXSxcblx0bW91c2VFdmVudFByb3BzID0gJC5ldmVudC5wcm9wcy5jb25jYXQoIG1vdXNlSG9va1Byb3BzICksXG5cdGFjdGl2ZURvY0hhbmRsZXJzID0ge30sXG5cdHJlc2V0VGltZXJJRCA9IDAsXG5cdHN0YXJ0WCA9IDAsXG5cdHN0YXJ0WSA9IDAsXG5cdGRpZFNjcm9sbCA9IGZhbHNlLFxuXHRjbGlja0Jsb2NrTGlzdCA9IFtdLFxuXHRibG9ja01vdXNlVHJpZ2dlcnMgPSBmYWxzZSxcblx0YmxvY2tUb3VjaFRyaWdnZXJzID0gZmFsc2UsXG5cdGV2ZW50Q2FwdHVyZVN1cHBvcnRlZCA9IFwiYWRkRXZlbnRMaXN0ZW5lclwiIGluIGRvY3VtZW50LFxuXHQkZG9jdW1lbnQgPSAkKCBkb2N1bWVudCApLFxuXHRuZXh0VG91Y2hJRCA9IDEsXG5cdGxhc3RUb3VjaElEID0gMCwgdGhyZXNob2xkLFxuXHRpO1xuXG4kLnZtb3VzZSA9IHtcblx0bW92ZURpc3RhbmNlVGhyZXNob2xkOiAxMCxcblx0Y2xpY2tEaXN0YW5jZVRocmVzaG9sZDogMTAsXG5cdHJlc2V0VGltZXJEdXJhdGlvbjogMTUwMFxufTtcblxuZnVuY3Rpb24gZ2V0TmF0aXZlRXZlbnQoIGV2ZW50ICkge1xuXG5cdHdoaWxlICggZXZlbnQgJiYgdHlwZW9mIGV2ZW50Lm9yaWdpbmFsRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0ZXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50O1xuXHR9XG5cdHJldHVybiBldmVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVmlydHVhbEV2ZW50KCBldmVudCwgZXZlbnRUeXBlICkge1xuXG5cdHZhciB0ID0gZXZlbnQudHlwZSxcblx0XHRvZSwgcHJvcHMsIG5lLCBwcm9wLCBjdCwgdG91Y2gsIGksIGosIGxlbjtcblxuXHRldmVudCA9ICQuRXZlbnQoIGV2ZW50ICk7XG5cdGV2ZW50LnR5cGUgPSBldmVudFR5cGU7XG5cblx0b2UgPSBldmVudC5vcmlnaW5hbEV2ZW50O1xuXHRwcm9wcyA9ICQuZXZlbnQucHJvcHM7XG5cblx0Ly8gYWRkcmVzc2VzIHNlcGFyYXRpb24gb2YgJC5ldmVudC5wcm9wcyBpbiB0byAkLmV2ZW50Lm1vdXNlSG9vay5wcm9wcyBhbmQgSXNzdWUgMzI4MFxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS1tb2JpbGUvaXNzdWVzLzMyODBcblx0aWYgKCB0LnNlYXJjaCggL14obW91c2V8Y2xpY2spLyApID4gLTEgKSB7XG5cdFx0cHJvcHMgPSBtb3VzZUV2ZW50UHJvcHM7XG5cdH1cblxuXHQvLyBjb3B5IG9yaWdpbmFsIGV2ZW50IHByb3BlcnRpZXMgb3ZlciB0byB0aGUgbmV3IGV2ZW50XG5cdC8vIHRoaXMgd291bGQgaGFwcGVuIGlmIHdlIGNvdWxkIGNhbGwgJC5ldmVudC5maXggaW5zdGVhZCBvZiAkLkV2ZW50XG5cdC8vIGJ1dCB3ZSBkb24ndCBoYXZlIGEgd2F5IHRvIGZvcmNlIGFuIGV2ZW50IHRvIGJlIGZpeGVkIG11bHRpcGxlIHRpbWVzXG5cdGlmICggb2UgKSB7XG5cdFx0Zm9yICggaSA9IHByb3BzLmxlbmd0aCwgcHJvcDsgaTsgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIC0taSBdO1xuXHRcdFx0ZXZlbnRbIHByb3AgXSA9IG9lWyBwcm9wIF07XG5cdFx0fVxuXHR9XG5cblx0Ly8gbWFrZSBzdXJlIHRoYXQgaWYgdGhlIG1vdXNlIGFuZCBjbGljayB2aXJ0dWFsIGV2ZW50cyBhcmUgZ2VuZXJhdGVkXG5cdC8vIHdpdGhvdXQgYSAud2hpY2ggb25lIGlzIGRlZmluZWRcblx0aWYgKCB0LnNlYXJjaCgvbW91c2UoZG93bnx1cCl8Y2xpY2svKSA+IC0xICYmICFldmVudC53aGljaCApIHtcblx0XHRldmVudC53aGljaCA9IDE7XG5cdH1cblxuXHRpZiAoIHQuc2VhcmNoKC9edG91Y2gvKSAhPT0gLTEgKSB7XG5cdFx0bmUgPSBnZXROYXRpdmVFdmVudCggb2UgKTtcblx0XHR0ID0gbmUudG91Y2hlcztcblx0XHRjdCA9IG5lLmNoYW5nZWRUb3VjaGVzO1xuXHRcdHRvdWNoID0gKCB0ICYmIHQubGVuZ3RoICkgPyB0WzBdIDogKCAoIGN0ICYmIGN0Lmxlbmd0aCApID8gY3RbIDAgXSA6IHVuZGVmaW5lZCApO1xuXG5cdFx0aWYgKCB0b3VjaCApIHtcblx0XHRcdGZvciAoIGogPSAwLCBsZW4gPSB0b3VjaEV2ZW50UHJvcHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcblx0XHRcdFx0cHJvcCA9IHRvdWNoRXZlbnRQcm9wc1sgaiBdO1xuXHRcdFx0XHRldmVudFsgcHJvcCBdID0gdG91Y2hbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGdldFZpcnR1YWxCaW5kaW5nRmxhZ3MoIGVsZW1lbnQgKSB7XG5cblx0dmFyIGZsYWdzID0ge30sXG5cdFx0YiwgaztcblxuXHR3aGlsZSAoIGVsZW1lbnQgKSB7XG5cblx0XHRiID0gJC5kYXRhKCBlbGVtZW50LCBkYXRhUHJvcGVydHlOYW1lICk7XG5cblx0XHRmb3IgKCAgayBpbiBiICkge1xuXHRcdFx0aWYgKCBiWyBrIF0gKSB7XG5cdFx0XHRcdGZsYWdzWyBrIF0gPSBmbGFncy5oYXNWaXJ0dWFsQmluZGluZyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cdH1cblx0cmV0dXJuIGZsYWdzO1xufVxuXG5mdW5jdGlvbiBnZXRDbG9zZXN0RWxlbWVudFdpdGhWaXJ0dWFsQmluZGluZyggZWxlbWVudCwgZXZlbnRUeXBlICkge1xuXHR2YXIgYjtcblx0d2hpbGUgKCBlbGVtZW50ICkge1xuXG5cdFx0YiA9ICQuZGF0YSggZWxlbWVudCwgZGF0YVByb3BlcnR5TmFtZSApO1xuXG5cdFx0aWYgKCBiICYmICggIWV2ZW50VHlwZSB8fCBiWyBldmVudFR5cGUgXSApICkge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0fVxuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGVuYWJsZVRvdWNoQmluZGluZ3MoKSB7XG5cdGJsb2NrVG91Y2hUcmlnZ2VycyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBkaXNhYmxlVG91Y2hCaW5kaW5ncygpIHtcblx0YmxvY2tUb3VjaFRyaWdnZXJzID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlTW91c2VCaW5kaW5ncygpIHtcblx0bGFzdFRvdWNoSUQgPSAwO1xuXHRjbGlja0Jsb2NrTGlzdC5sZW5ndGggPSAwO1xuXHRibG9ja01vdXNlVHJpZ2dlcnMgPSBmYWxzZTtcblxuXHQvLyBXaGVuIG1vdXNlIGJpbmRpbmdzIGFyZSBlbmFibGVkLCBvdXJcblx0Ly8gdG91Y2ggYmluZGluZ3MgYXJlIGRpc2FibGVkLlxuXHRkaXNhYmxlVG91Y2hCaW5kaW5ncygpO1xufVxuXG5mdW5jdGlvbiBkaXNhYmxlTW91c2VCaW5kaW5ncygpIHtcblx0Ly8gV2hlbiBtb3VzZSBiaW5kaW5ncyBhcmUgZGlzYWJsZWQsIG91clxuXHQvLyB0b3VjaCBiaW5kaW5ncyBhcmUgZW5hYmxlZC5cblx0ZW5hYmxlVG91Y2hCaW5kaW5ncygpO1xufVxuXG5mdW5jdGlvbiBzdGFydFJlc2V0VGltZXIoKSB7XG5cdGNsZWFyUmVzZXRUaW1lcigpO1xuXHRyZXNldFRpbWVySUQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRyZXNldFRpbWVySUQgPSAwO1xuXHRcdGVuYWJsZU1vdXNlQmluZGluZ3MoKTtcblx0fSwgJC52bW91c2UucmVzZXRUaW1lckR1cmF0aW9uICk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyUmVzZXRUaW1lcigpIHtcblx0aWYgKCByZXNldFRpbWVySUQgKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KCByZXNldFRpbWVySUQgKTtcblx0XHRyZXNldFRpbWVySUQgPSAwO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJWaXJ0dWFsRXZlbnQoIGV2ZW50VHlwZSwgZXZlbnQsIGZsYWdzICkge1xuXHR2YXIgdmU7XG5cblx0aWYgKCAoIGZsYWdzICYmIGZsYWdzWyBldmVudFR5cGUgXSApIHx8XG5cdFx0XHRcdCggIWZsYWdzICYmIGdldENsb3Nlc3RFbGVtZW50V2l0aFZpcnR1YWxCaW5kaW5nKCBldmVudC50YXJnZXQsIGV2ZW50VHlwZSApICkgKSB7XG5cblx0XHR2ZSA9IGNyZWF0ZVZpcnR1YWxFdmVudCggZXZlbnQsIGV2ZW50VHlwZSApO1xuXG5cdFx0JCggZXZlbnQudGFyZ2V0KS50cmlnZ2VyKCB2ZSApO1xuXHR9XG5cblx0cmV0dXJuIHZlO1xufVxuXG5mdW5jdGlvbiBtb3VzZUV2ZW50Q2FsbGJhY2soIGV2ZW50ICkge1xuXHR2YXIgdG91Y2hJRCA9ICQuZGF0YSggZXZlbnQudGFyZ2V0LCB0b3VjaFRhcmdldFByb3BlcnR5TmFtZSApLFxuXHRcdHZlO1xuXG5cdGlmICggIWJsb2NrTW91c2VUcmlnZ2VycyAmJiAoICFsYXN0VG91Y2hJRCB8fCBsYXN0VG91Y2hJRCAhPT0gdG91Y2hJRCApICkge1xuXHRcdHZlID0gdHJpZ2dlclZpcnR1YWxFdmVudCggXCJ2XCIgKyBldmVudC50eXBlLCBldmVudCApO1xuXHRcdGlmICggdmUgKSB7XG5cdFx0XHRpZiAoIHZlLmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2ZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdGlmICggdmUuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnQoIGV2ZW50ICkge1xuXG5cdHZhciB0b3VjaGVzID0gZ2V0TmF0aXZlRXZlbnQoIGV2ZW50ICkudG91Y2hlcyxcblx0XHR0YXJnZXQsIGZsYWdzLCB0O1xuXG5cdGlmICggdG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0XHRmbGFncyA9IGdldFZpcnR1YWxCaW5kaW5nRmxhZ3MoIHRhcmdldCApO1xuXG5cdFx0aWYgKCBmbGFncy5oYXNWaXJ0dWFsQmluZGluZyApIHtcblxuXHRcdFx0bGFzdFRvdWNoSUQgPSBuZXh0VG91Y2hJRCsrO1xuXHRcdFx0JC5kYXRhKCB0YXJnZXQsIHRvdWNoVGFyZ2V0UHJvcGVydHlOYW1lLCBsYXN0VG91Y2hJRCApO1xuXG5cdFx0XHRjbGVhclJlc2V0VGltZXIoKTtcblxuXHRcdFx0ZGlzYWJsZU1vdXNlQmluZGluZ3MoKTtcblx0XHRcdGRpZFNjcm9sbCA9IGZhbHNlO1xuXG5cdFx0XHR0ID0gZ2V0TmF0aXZlRXZlbnQoIGV2ZW50ICkudG91Y2hlc1sgMCBdO1xuXHRcdFx0c3RhcnRYID0gdC5wYWdlWDtcblx0XHRcdHN0YXJ0WSA9IHQucGFnZVk7XG5cblx0XHRcdHRyaWdnZXJWaXJ0dWFsRXZlbnQoIFwidm1vdXNlb3ZlclwiLCBldmVudCwgZmxhZ3MgKTtcblx0XHRcdHRyaWdnZXJWaXJ0dWFsRXZlbnQoIFwidm1vdXNlZG93blwiLCBldmVudCwgZmxhZ3MgKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlU2Nyb2xsKCBldmVudCApIHtcblx0aWYgKCBibG9ja1RvdWNoVHJpZ2dlcnMgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCAhZGlkU2Nyb2xsICkge1xuXHRcdHRyaWdnZXJWaXJ0dWFsRXZlbnQoIFwidm1vdXNlY2FuY2VsXCIsIGV2ZW50LCBnZXRWaXJ0dWFsQmluZGluZ0ZsYWdzKCBldmVudC50YXJnZXQgKSApO1xuXHR9XG5cblx0ZGlkU2Nyb2xsID0gdHJ1ZTtcblx0c3RhcnRSZXNldFRpbWVyKCk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZSggZXZlbnQgKSB7XG5cdGlmICggYmxvY2tUb3VjaFRyaWdnZXJzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciB0ID0gZ2V0TmF0aXZlRXZlbnQoIGV2ZW50ICkudG91Y2hlc1sgMCBdLFxuXHRcdGRpZENhbmNlbCA9IGRpZFNjcm9sbCxcblx0XHRtb3ZlVGhyZXNob2xkID0gJC52bW91c2UubW92ZURpc3RhbmNlVGhyZXNob2xkLFxuXHRcdGZsYWdzID0gZ2V0VmlydHVhbEJpbmRpbmdGbGFncyggZXZlbnQudGFyZ2V0ICk7XG5cblx0XHRkaWRTY3JvbGwgPSBkaWRTY3JvbGwgfHxcblx0XHRcdCggTWF0aC5hYnMoIHQucGFnZVggLSBzdGFydFggKSA+IG1vdmVUaHJlc2hvbGQgfHxcblx0XHRcdFx0TWF0aC5hYnMoIHQucGFnZVkgLSBzdGFydFkgKSA+IG1vdmVUaHJlc2hvbGQgKTtcblxuXHRpZiAoIGRpZFNjcm9sbCAmJiAhZGlkQ2FuY2VsICkge1xuXHRcdHRyaWdnZXJWaXJ0dWFsRXZlbnQoIFwidm1vdXNlY2FuY2VsXCIsIGV2ZW50LCBmbGFncyApO1xuXHR9XG5cblx0dHJpZ2dlclZpcnR1YWxFdmVudCggXCJ2bW91c2Vtb3ZlXCIsIGV2ZW50LCBmbGFncyApO1xuXHRzdGFydFJlc2V0VGltZXIoKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlVG91Y2hFbmQoIGV2ZW50ICkge1xuXHRpZiAoIGJsb2NrVG91Y2hUcmlnZ2VycyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRkaXNhYmxlVG91Y2hCaW5kaW5ncygpO1xuXG5cdHZhciBmbGFncyA9IGdldFZpcnR1YWxCaW5kaW5nRmxhZ3MoIGV2ZW50LnRhcmdldCApLFxuXHRcdHZlLCB0O1xuXHR0cmlnZ2VyVmlydHVhbEV2ZW50KCBcInZtb3VzZXVwXCIsIGV2ZW50LCBmbGFncyApO1xuXG5cdGlmICggIWRpZFNjcm9sbCApIHtcblx0XHR2ZSA9IHRyaWdnZXJWaXJ0dWFsRXZlbnQoIFwidmNsaWNrXCIsIGV2ZW50LCBmbGFncyApO1xuXHRcdGlmICggdmUgJiYgdmUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHQvLyBUaGUgdGFyZ2V0IG9mIHRoZSBtb3VzZSBldmVudHMgdGhhdCBmb2xsb3cgdGhlIHRvdWNoZW5kXG5cdFx0XHQvLyBldmVudCBkb24ndCBuZWNlc3NhcmlseSBtYXRjaCB0aGUgdGFyZ2V0IHVzZWQgZHVyaW5nIHRoZVxuXHRcdFx0Ly8gdG91Y2guIFRoaXMgbWVhbnMgd2UgbmVlZCB0byByZWx5IG9uIGNvb3JkaW5hdGVzIGZvciBibG9ja2luZ1xuXHRcdFx0Ly8gYW55IGNsaWNrIHRoYXQgaXMgZ2VuZXJhdGVkLlxuXHRcdFx0dCA9IGdldE5hdGl2ZUV2ZW50KCBldmVudCApLmNoYW5nZWRUb3VjaGVzWyAwIF07XG5cdFx0XHRjbGlja0Jsb2NrTGlzdC5wdXNoKHtcblx0XHRcdFx0dG91Y2hJRDogbGFzdFRvdWNoSUQsXG5cdFx0XHRcdHg6IHQuY2xpZW50WCxcblx0XHRcdFx0eTogdC5jbGllbnRZXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gUHJldmVudCBhbnkgbW91c2UgZXZlbnRzIHRoYXQgZm9sbG93IGZyb20gdHJpZ2dlcmluZ1xuXHRcdFx0Ly8gdmlydHVhbCBldmVudCBub3RpZmljYXRpb25zLlxuXHRcdFx0YmxvY2tNb3VzZVRyaWdnZXJzID0gdHJ1ZTtcblx0XHR9XG5cdH1cblx0dHJpZ2dlclZpcnR1YWxFdmVudCggXCJ2bW91c2VvdXRcIiwgZXZlbnQsIGZsYWdzKTtcblx0ZGlkU2Nyb2xsID0gZmFsc2U7XG5cblx0c3RhcnRSZXNldFRpbWVyKCk7XG59XG5cbmZ1bmN0aW9uIGhhc1ZpcnR1YWxCaW5kaW5ncyggZWxlICkge1xuXHR2YXIgYmluZGluZ3MgPSAkLmRhdGEoIGVsZSwgZGF0YVByb3BlcnR5TmFtZSApLFxuXHRcdGs7XG5cblx0aWYgKCBiaW5kaW5ncyApIHtcblx0XHRmb3IgKCBrIGluIGJpbmRpbmdzICkge1xuXHRcdFx0aWYgKCBiaW5kaW5nc1sgayBdICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBkdW1teU1vdXNlSGFuZGxlcigpIHt9XG5cbmZ1bmN0aW9uIGdldFNwZWNpYWxFdmVudE9iamVjdCggZXZlbnRUeXBlICkge1xuXHR2YXIgcmVhbFR5cGUgPSBldmVudFR5cGUuc3Vic3RyKCAxICk7XG5cblx0cmV0dXJuIHtcblx0XHRzZXR1cDogZnVuY3Rpb24oLyogZGF0YSwgbmFtZXNwYWNlICovKSB7XG5cdFx0XHQvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCB2aXJ0dWFsIG1vdXNlIGJpbmRpbmcgZm9yIHRoaXMgZWxlbWVudCxcblx0XHRcdC8vIGFkZCBhIGJpbmRpbmdzIG9iamVjdCB0byBpdHMgZGF0YS5cblxuXHRcdFx0aWYgKCAhaGFzVmlydHVhbEJpbmRpbmdzKCB0aGlzICkgKSB7XG5cdFx0XHRcdCQuZGF0YSggdGhpcywgZGF0YVByb3BlcnR5TmFtZSwge30gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgc2V0dXAgaXMgY2FsbGVkLCB3ZSBrbm93IGl0IGlzIHRoZSBmaXJzdCBiaW5kaW5nIGZvciB0aGlzXG5cdFx0XHQvLyBldmVudFR5cGUsIHNvIGluaXRpYWxpemUgdGhlIGNvdW50IGZvciB0aGUgZXZlbnRUeXBlIHRvIHplcm8uXG5cdFx0XHR2YXIgYmluZGluZ3MgPSAkLmRhdGEoIHRoaXMsIGRhdGFQcm9wZXJ0eU5hbWUgKTtcblx0XHRcdGJpbmRpbmdzWyBldmVudFR5cGUgXSA9IHRydWU7XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHZpcnR1YWwgbW91c2UgZXZlbnQgZm9yIHRoaXMgdHlwZSxcblx0XHRcdC8vIHJlZ2lzdGVyIGEgZ2xvYmFsIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50LlxuXG5cdFx0XHRhY3RpdmVEb2NIYW5kbGVyc1sgZXZlbnRUeXBlIF0gPSAoIGFjdGl2ZURvY0hhbmRsZXJzWyBldmVudFR5cGUgXSB8fCAwICkgKyAxO1xuXG5cdFx0XHRpZiAoIGFjdGl2ZURvY0hhbmRsZXJzWyBldmVudFR5cGUgXSA9PT0gMSApIHtcblx0XHRcdFx0JGRvY3VtZW50LmJpbmQoIHJlYWxUeXBlLCBtb3VzZUV2ZW50Q2FsbGJhY2sgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU29tZSBicm93c2VycywgbGlrZSBPcGVyYSBNaW5pLCB3b24ndCBkaXNwYXRjaCBtb3VzZS9jbGljayBldmVudHNcblx0XHRcdC8vIGZvciBlbGVtZW50cyB1bmxlc3MgdGhleSBhY3R1YWxseSBoYXZlIGhhbmRsZXJzIHJlZ2lzdGVyZWQgb24gdGhlbS5cblx0XHRcdC8vIFRvIGdldCBhcm91bmQgdGhpcywgd2UgcmVnaXN0ZXIgZHVtbXkgaGFuZGxlcnMgb24gdGhlIGVsZW1lbnRzLlxuXG5cdFx0XHQkKCB0aGlzICkuYmluZCggcmVhbFR5cGUsIGR1bW15TW91c2VIYW5kbGVyICk7XG5cblx0XHRcdC8vIEZvciBub3csIGlmIGV2ZW50IGNhcHR1cmUgaXMgbm90IHN1cHBvcnRlZCwgd2UgcmVseSBvbiBtb3VzZSBoYW5kbGVycy5cblx0XHRcdGlmICggZXZlbnRDYXB0dXJlU3VwcG9ydGVkICkge1xuXHRcdFx0XHQvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCB2aXJ0dWFsIG1vdXNlIGJpbmRpbmcgZm9yIHRoZSBkb2N1bWVudCxcblx0XHRcdFx0Ly8gcmVnaXN0ZXIgb3VyIHRvdWNoc3RhcnQgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQuXG5cblx0XHRcdFx0YWN0aXZlRG9jSGFuZGxlcnNbIFwidG91Y2hzdGFydFwiIF0gPSAoIGFjdGl2ZURvY0hhbmRsZXJzWyBcInRvdWNoc3RhcnRcIiBdIHx8IDApICsgMTtcblxuXHRcdFx0XHRpZiAoIGFjdGl2ZURvY0hhbmRsZXJzWyBcInRvdWNoc3RhcnRcIiBdID09PSAxICkge1xuXHRcdFx0XHRcdCRkb2N1bWVudC5iaW5kKCBcInRvdWNoc3RhcnRcIiwgaGFuZGxlVG91Y2hTdGFydCApXG5cdFx0XHRcdFx0XHQuYmluZCggXCJ0b3VjaGVuZFwiLCBoYW5kbGVUb3VjaEVuZCApXG5cblx0XHRcdFx0XHRcdC8vIE9uIHRvdWNoIHBsYXRmb3JtcywgdG91Y2hpbmcgdGhlIHNjcmVlbiBhbmQgdGhlbiBkcmFnZ2luZyB5b3VyIGZpbmdlclxuXHRcdFx0XHRcdFx0Ly8gY2F1c2VzIHRoZSB3aW5kb3cgY29udGVudCB0byBzY3JvbGwgYWZ0ZXIgc29tZSBkaXN0YW5jZSB0aHJlc2hvbGQgaXNcblx0XHRcdFx0XHRcdC8vIGV4Y2VlZGVkLiBPbiB0aGVzZSBwbGF0Zm9ybXMsIGEgc2Nyb2xsIHByZXZlbnRzIGEgY2xpY2sgZXZlbnQgZnJvbSBiZWluZ1xuXHRcdFx0XHRcdFx0Ly8gZGlzcGF0Y2hlZCwgYW5kIG9uIHNvbWUgcGxhdGZvcm1zLCBldmVuIHRoZSB0b3VjaGVuZCBpcyBzdXBwcmVzc2VkLiBUb1xuXHRcdFx0XHRcdFx0Ly8gbWltaWMgdGhlIHN1cHByZXNzaW9uIG9mIHRoZSBjbGljayBldmVudCwgd2UgbmVlZCB0byB3YXRjaCBmb3IgYSBzY3JvbGxcblx0XHRcdFx0XHRcdC8vIGV2ZW50LiBVbmZvcnR1bmF0ZWx5LCBzb21lIHBsYXRmb3JtcyBsaWtlIGlPUyBkb24ndCBkaXNwYXRjaCBzY3JvbGxcblx0XHRcdFx0XHRcdC8vIGV2ZW50cyB1bnRpbCAqQUZURVIqIHRoZSB1c2VyIGxpZnRzIHRoZWlyIGZpbmdlciAodG91Y2hlbmQpLiBUaGlzIG1lYW5zXG5cdFx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIHdhdGNoIGJvdGggc2Nyb2xsIGFuZCB0b3VjaG1vdmUgZXZlbnRzIHRvIGZpZ3VyZSBvdXQgd2hldGhlclxuXHRcdFx0XHRcdFx0Ly8gb3Igbm90IGEgc2Nyb2xsIGhhcHBlbmVucyBiZWZvcmUgdGhlIHRvdWNoZW5kIGV2ZW50IGlzIGZpcmVkLlxuXG5cdFx0XHRcdFx0XHQuYmluZCggXCJ0b3VjaG1vdmVcIiwgaGFuZGxlVG91Y2hNb3ZlIClcblx0XHRcdFx0XHRcdC5iaW5kKCBcInNjcm9sbFwiLCBoYW5kbGVTY3JvbGwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oLyogZGF0YSwgbmFtZXNwYWNlICovKSB7XG5cdFx0XHQvLyBJZiB0aGlzIGlzIHRoZSBsYXN0IHZpcnR1YWwgYmluZGluZyBmb3IgdGhpcyBldmVudFR5cGUsXG5cdFx0XHQvLyByZW1vdmUgaXRzIGdsb2JhbCBoYW5kbGVyIGZyb20gdGhlIGRvY3VtZW50LlxuXG5cdFx0XHQtLWFjdGl2ZURvY0hhbmRsZXJzWyBldmVudFR5cGUgXTtcblxuXHRcdFx0aWYgKCAhYWN0aXZlRG9jSGFuZGxlcnNbIGV2ZW50VHlwZSBdICkge1xuXHRcdFx0XHQkZG9jdW1lbnQudW5iaW5kKCByZWFsVHlwZSwgbW91c2VFdmVudENhbGxiYWNrICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZXZlbnRDYXB0dXJlU3VwcG9ydGVkICkge1xuXHRcdFx0XHQvLyBJZiB0aGlzIGlzIHRoZSBsYXN0IHZpcnR1YWwgbW91c2UgYmluZGluZyBpbiBleGlzdGVuY2UsXG5cdFx0XHRcdC8vIHJlbW92ZSBvdXIgZG9jdW1lbnQgdG91Y2hzdGFydCBsaXN0ZW5lci5cblxuXHRcdFx0XHQtLWFjdGl2ZURvY0hhbmRsZXJzWyBcInRvdWNoc3RhcnRcIiBdO1xuXG5cdFx0XHRcdGlmICggIWFjdGl2ZURvY0hhbmRsZXJzWyBcInRvdWNoc3RhcnRcIiBdICkge1xuXHRcdFx0XHRcdCRkb2N1bWVudC51bmJpbmQoIFwidG91Y2hzdGFydFwiLCBoYW5kbGVUb3VjaFN0YXJ0IClcblx0XHRcdFx0XHRcdC51bmJpbmQoIFwidG91Y2htb3ZlXCIsIGhhbmRsZVRvdWNoTW92ZSApXG5cdFx0XHRcdFx0XHQudW5iaW5kKCBcInRvdWNoZW5kXCIsIGhhbmRsZVRvdWNoRW5kIClcblx0XHRcdFx0XHRcdC51bmJpbmQoIFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciAkdGhpcyA9ICQoIHRoaXMgKSxcblx0XHRcdFx0YmluZGluZ3MgPSAkLmRhdGEoIHRoaXMsIGRhdGFQcm9wZXJ0eU5hbWUgKTtcblxuXHRcdFx0Ly8gdGVhcmRvd24gbWF5IGJlIGNhbGxlZCB3aGVuIGFuIGVsZW1lbnQgd2FzXG5cdFx0XHQvLyByZW1vdmVkIGZyb20gdGhlIERPTS4gSWYgdGhpcyBpcyB0aGUgY2FzZSxcblx0XHRcdC8vIGpRdWVyeSBjb3JlIG1heSBoYXZlIGFscmVhZHkgc3RyaXBwZWQgdGhlIGVsZW1lbnRcblx0XHRcdC8vIG9mIGFueSBkYXRhIGJpbmRpbmdzIHNvIHdlIG5lZWQgdG8gY2hlY2sgaXQgYmVmb3JlXG5cdFx0XHQvLyB1c2luZyBpdC5cblx0XHRcdGlmICggYmluZGluZ3MgKSB7XG5cdFx0XHRcdGJpbmRpbmdzWyBldmVudFR5cGUgXSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVbnJlZ2lzdGVyIHRoZSBkdW1teSBldmVudCBoYW5kbGVyLlxuXG5cdFx0XHQkdGhpcy51bmJpbmQoIHJlYWxUeXBlLCBkdW1teU1vdXNlSGFuZGxlciApO1xuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIHRoZSBsYXN0IHZpcnR1YWwgbW91c2UgYmluZGluZyBvbiB0aGVcblx0XHRcdC8vIGVsZW1lbnQsIHJlbW92ZSB0aGUgYmluZGluZyBkYXRhIGZyb20gdGhlIGVsZW1lbnQuXG5cblx0XHRcdGlmICggIWhhc1ZpcnR1YWxCaW5kaW5ncyggdGhpcyApICkge1xuXHRcdFx0XHQkdGhpcy5yZW1vdmVEYXRhKCBkYXRhUHJvcGVydHlOYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBFeHBvc2Ugb3VyIGN1c3RvbSBldmVudHMgdG8gdGhlIGpRdWVyeSBiaW5kL3VuYmluZCBtZWNoYW5pc20uXG5cbmZvciAoIGkgPSAwOyBpIDwgdmlydHVhbEV2ZW50TmFtZXMubGVuZ3RoOyBpKysgKSB7XG5cdCQuZXZlbnQuc3BlY2lhbFsgdmlydHVhbEV2ZW50TmFtZXNbIGkgXSBdID0gZ2V0U3BlY2lhbEV2ZW50T2JqZWN0KCB2aXJ0dWFsRXZlbnROYW1lc1sgaSBdICk7XG59XG5cbi8vIEFkZCBhIGNhcHR1cmUgY2xpY2sgaGFuZGxlciB0byBibG9jayBjbGlja3MuXG4vLyBOb3RlIHRoYXQgd2UgcmVxdWlyZSBldmVudCBjYXB0dXJlIHN1cHBvcnQgZm9yIHRoaXMgc28gaWYgdGhlIGRldmljZVxuLy8gZG9lc24ndCBzdXBwb3J0IGl0LCB3ZSBwdW50IGZvciBub3cgYW5kIHJlbHkgc29sZWx5IG9uIG1vdXNlIGV2ZW50cy5cbmlmICggZXZlbnRDYXB0dXJlU3VwcG9ydGVkICkge1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcImNsaWNrXCIsIGZ1bmN0aW9uKCBlICkge1xuXHRcdHZhciBjbnQgPSBjbGlja0Jsb2NrTGlzdC5sZW5ndGgsXG5cdFx0XHR0YXJnZXQgPSBlLnRhcmdldCxcblx0XHRcdHgsIHksIGVsZSwgaSwgbywgdG91Y2hJRDtcblxuXHRcdGlmICggY250ICkge1xuXHRcdFx0eCA9IGUuY2xpZW50WDtcblx0XHRcdHkgPSBlLmNsaWVudFk7XG5cdFx0XHR0aHJlc2hvbGQgPSAkLnZtb3VzZS5jbGlja0Rpc3RhbmNlVGhyZXNob2xkO1xuXG5cdFx0XHQvLyBUaGUgaWRlYSBoZXJlIGlzIHRvIHJ1biB0aHJvdWdoIHRoZSBjbGlja0Jsb2NrTGlzdCB0byBzZWUgaWZcblx0XHRcdC8vIHRoZSBjdXJyZW50IGNsaWNrIGV2ZW50IGlzIGluIHRoZSBwcm94aW1pdHkgb2Ygb25lIG9mIG91clxuXHRcdFx0Ly8gdmNsaWNrIGV2ZW50cyB0aGF0IGhhZCBwcmV2ZW50RGVmYXVsdCgpIGNhbGxlZCBvbiBpdC4gSWYgd2UgZmluZFxuXHRcdFx0Ly8gb25lLCB0aGVuIHdlIGJsb2NrIHRoZSBjbGljay5cblx0XHRcdC8vXG5cdFx0XHQvLyBXaHkgZG8gd2UgaGF2ZSB0byByZWx5IG9uIHByb3hpbWl0eT9cblx0XHRcdC8vXG5cdFx0XHQvLyBCZWNhdXNlIHRoZSB0YXJnZXQgb2YgdGhlIHRvdWNoIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSB2Y2xpY2tcblx0XHRcdC8vIGNhbiBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgdGFyZ2V0IG9mIHRoZSBjbGljayBldmVudCBzeW50aGVzaXplZFxuXHRcdFx0Ly8gYnkgdGhlIGJyb3dzZXIuIFRoZSB0YXJnZXQgb2YgYSBtb3VzZS9jbGljayBldmVudCB0aGF0IGlzIHN5bnRoZXNpemVkXG5cdFx0XHQvLyBmcm9tIGEgdG91Y2ggZXZlbnQgc2VlbXMgdG8gYmUgaW1wbGVtZW50YXRpb24gc3BlY2lmaWMuIEZvciBleGFtcGxlLFxuXHRcdFx0Ly8gc29tZSBicm93c2VycyB3aWxsIGZpcmUgbW91c2UvY2xpY2sgZXZlbnRzIGZvciBhIGxpbmsgdGhhdCBpcyBuZWFyXG5cdFx0XHQvLyBhIHRvdWNoIGV2ZW50LCBldmVuIHRob3VnaCB0aGUgdGFyZ2V0IG9mIHRoZSB0b3VjaHN0YXJ0L3RvdWNoZW5kIGV2ZW50XG5cdFx0XHQvLyBzYXlzIHRoZSB1c2VyIHRvdWNoZWQgb3V0c2lkZSB0aGUgbGluay4gQWxzbywgaXQgc2VlbXMgdGhhdCB3aXRoIG1vc3Rcblx0XHRcdC8vIGJyb3dzZXJzLCB0aGUgdGFyZ2V0IG9mIHRoZSBtb3VzZS9jbGljayBldmVudCBpcyBub3QgY2FsY3VsYXRlZCB1bnRpbCB0aGVcblx0XHRcdC8vIHRpbWUgaXQgaXMgZGlzcGF0Y2hlZCwgc28gaWYgeW91IHJlcGxhY2UgYW4gZWxlbWVudCB0aGF0IHlvdSB0b3VjaGVkXG5cdFx0XHQvLyB3aXRoIGFub3RoZXIgZWxlbWVudCwgdGhlIHRhcmdldCBvZiB0aGUgbW91c2UvY2xpY2sgd2lsbCBiZSB0aGUgbmV3XG5cdFx0XHQvLyBlbGVtZW50IHVuZGVybmVhdGggdGhhdCBwb2ludC5cblx0XHRcdC8vXG5cdFx0XHQvLyBBc2lkZSBmcm9tIHByb3hpbWl0eSwgd2UgYWxzbyBjaGVjayB0byBzZWUgaWYgdGhlIHRhcmdldCBhbmQgYW55XG5cdFx0XHQvLyBvZiBpdHMgYW5jZXN0b3JzIHdlcmUgdGhlIG9uZXMgdGhhdCBibG9ja2VkIGEgY2xpY2suIFRoaXMgaXMgbmVjZXNzYXJ5XG5cdFx0XHQvLyBiZWNhdXNlIG9mIHRoZSBzdHJhbmdlIG1vdXNlL2NsaWNrIHRhcmdldCBjYWxjdWxhdGlvbiBkb25lIGluIHRoZVxuXHRcdFx0Ly8gQW5kcm9pZCAyLjEgYnJvd3Nlciwgd2hlcmUgaWYgeW91IGNsaWNrIG9uIGFuIGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBhXG5cdFx0XHQvLyBtb3VzZS9jbGljayBoYW5kbGVyIG9uIG9uZSBvZiBpdHMgYW5jZXN0b3JzLCB0aGUgdGFyZ2V0IHdpbGwgYmUgdGhlXG5cdFx0XHQvLyBpbm5lcm1vc3QgY2hpbGQgb2YgdGhlIHRvdWNoZWQgZWxlbWVudCwgZXZlbiBpZiB0aGF0IGNoaWxkIGlzIG5vIHdoZXJlXG5cdFx0XHQvLyBuZWFyIHRoZSBwb2ludCBvZiB0b3VjaC5cblxuXHRcdFx0ZWxlID0gdGFyZ2V0O1xuXG5cdFx0XHR3aGlsZSAoIGVsZSApIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjbnQ7IGkrKyApIHtcblx0XHRcdFx0XHRvID0gY2xpY2tCbG9ja0xpc3RbIGkgXTtcblx0XHRcdFx0XHR0b3VjaElEID0gMDtcblxuXHRcdFx0XHRcdGlmICggKCBlbGUgPT09IHRhcmdldCAmJiBNYXRoLmFicyggby54IC0geCApIDwgdGhyZXNob2xkICYmIE1hdGguYWJzKCBvLnkgLSB5ICkgPCB0aHJlc2hvbGQgKSB8fFxuXHRcdFx0XHRcdFx0XHRcdCQuZGF0YSggZWxlLCB0b3VjaFRhcmdldFByb3BlcnR5TmFtZSApID09PSBvLnRvdWNoSUQgKSB7XG5cdFx0XHRcdFx0XHQvLyBYWFg6IFdlIG1heSB3YW50IHRvIGNvbnNpZGVyIHJlbW92aW5nIG1hdGNoZXMgZnJvbSB0aGUgYmxvY2sgbGlzdFxuXHRcdFx0XHRcdFx0Ly8gICAgICBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIHRoZSByZXNldCB0aW1lciB0byBmaXJlLlxuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxlID0gZWxlLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCB0cnVlKTtcbn1cbn0pKCBqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQgKTtcblxuXG4oZnVuY3Rpb24oICQsIHdpbmRvdywgdW5kZWZpbmVkICkge1xuXHR2YXIgJGRvY3VtZW50ID0gJCggZG9jdW1lbnQgKSxcblx0XHRzdXBwb3J0VG91Y2ggPSAkLm1vYmlsZS5zdXBwb3J0LnRvdWNoLFxuXHRcdHNjcm9sbEV2ZW50ID0gXCJ0b3VjaG1vdmUgc2Nyb2xsXCIsXG5cdFx0dG91Y2hTdGFydEV2ZW50ID0gc3VwcG9ydFRvdWNoID8gXCJ0b3VjaHN0YXJ0XCIgOiBcIm1vdXNlZG93blwiLFxuXHRcdHRvdWNoU3RvcEV2ZW50ID0gc3VwcG9ydFRvdWNoID8gXCJ0b3VjaGVuZFwiIDogXCJtb3VzZXVwXCIsXG5cdFx0dG91Y2hNb3ZlRXZlbnQgPSBzdXBwb3J0VG91Y2ggPyBcInRvdWNobW92ZVwiIDogXCJtb3VzZW1vdmVcIjtcblxuXHQvLyBzZXR1cCBuZXcgZXZlbnQgc2hvcnRjdXRzXG5cdCQuZWFjaCggKCBcInRvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIFwiICtcblx0XHRcInRhcCB0YXBob2xkIFwiICtcblx0XHRcInN3aXBlIHN3aXBlbGVmdCBzd2lwZXJpZ2h0IFwiICtcblx0XHRcInNjcm9sbHN0YXJ0IHNjcm9sbHN0b3BcIiApLnNwbGl0KCBcIiBcIiApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHRcdCQuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdHJldHVybiBmbiA/IHRoaXMuYmluZCggbmFtZSwgZm4gKSA6IHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHRcdH07XG5cblx0XHQvLyBqUXVlcnkgPCAxLjhcblx0XHRpZiAoICQuYXR0ckZuICkge1xuXHRcdFx0JC5hdHRyRm5bIG5hbWUgXSA9IHRydWU7XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiB0cmlnZ2VyQ3VzdG9tRXZlbnQoIG9iaiwgZXZlbnRUeXBlLCBldmVudCwgYnViYmxlICkge1xuXHRcdHZhciBvcmlnaW5hbFR5cGUgPSBldmVudC50eXBlO1xuXHRcdGV2ZW50LnR5cGUgPSBldmVudFR5cGU7XG5cdFx0aWYgKCBidWJibGUgKSB7XG5cdFx0XHQkLmV2ZW50LnRyaWdnZXIoIGV2ZW50LCB1bmRlZmluZWQsIG9iaiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkLmV2ZW50LmRpc3BhdGNoLmNhbGwoIG9iaiwgZXZlbnQgKTtcblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IG9yaWdpbmFsVHlwZTtcblx0fVxuXG5cdC8vIGFsc28gaGFuZGxlcyBzY3JvbGxzdG9wXG5cdCQuZXZlbnQuc3BlY2lhbC5zY3JvbGxzdGFydCA9IHtcblxuXHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHR2YXIgdGhpc09iamVjdCA9IHRoaXMsXG5cdFx0XHRcdCR0aGlzID0gJCggdGhpc09iamVjdCApLFxuXHRcdFx0XHRzY3JvbGxpbmcsXG5cdFx0XHRcdHRpbWVyO1xuXG5cdFx0XHRmdW5jdGlvbiB0cmlnZ2VyKCBldmVudCwgc3RhdGUgKSB7XG5cdFx0XHRcdHNjcm9sbGluZyA9IHN0YXRlO1xuXHRcdFx0XHR0cmlnZ2VyQ3VzdG9tRXZlbnQoIHRoaXNPYmplY3QsIHNjcm9sbGluZyA/IFwic2Nyb2xsc3RhcnRcIiA6IFwic2Nyb2xsc3RvcFwiLCBldmVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpUGhvbmUgdHJpZ2dlcnMgc2Nyb2xsIGFmdGVyIGEgc21hbGwgZGVsYXk7IHVzZSB0b3VjaG1vdmUgaW5zdGVhZFxuXHRcdFx0JHRoaXMuYmluZCggc2Nyb2xsRXZlbnQsIGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHRpZiAoICEkLmV2ZW50LnNwZWNpYWwuc2Nyb2xsc3RhcnQuZW5hYmxlZCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoICFzY3JvbGxpbmcgKSB7XG5cdFx0XHRcdFx0dHJpZ2dlciggZXZlbnQsIHRydWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGltZXIgKTtcblx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0cmlnZ2VyKCBldmVudCwgZmFsc2UgKTtcblx0XHRcdFx0fSwgNTAgKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0JCggdGhpcyApLnVuYmluZCggc2Nyb2xsRXZlbnQgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gYWxzbyBoYW5kbGVzIHRhcGhvbGRcblx0JC5ldmVudC5zcGVjaWFsLnRhcCA9IHtcblx0XHR0YXBob2xkVGhyZXNob2xkOiA3NTAsXG5cdFx0ZW1pdFRhcE9uVGFwaG9sZDogdHJ1ZSxcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGhpc09iamVjdCA9IHRoaXMsXG5cdFx0XHRcdCR0aGlzID0gJCggdGhpc09iamVjdCApLFxuXHRcdFx0XHRpc1RhcGhvbGQgPSBmYWxzZTtcblxuXHRcdFx0JHRoaXMuYmluZCggXCJ2bW91c2Vkb3duXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0aXNUYXBob2xkID0gZmFsc2U7XG5cdFx0XHRcdGlmICggZXZlbnQud2hpY2ggJiYgZXZlbnQud2hpY2ggIT09IDEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG9yaWdUYXJnZXQgPSBldmVudC50YXJnZXQsXG5cdFx0XHRcdFx0dGltZXI7XG5cblx0XHRcdFx0ZnVuY3Rpb24gY2xlYXJUYXBUaW1lcigpIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVyICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmdW5jdGlvbiBjbGVhclRhcEhhbmRsZXJzKCkge1xuXHRcdFx0XHRcdGNsZWFyVGFwVGltZXIoKTtcblxuXHRcdFx0XHRcdCR0aGlzLnVuYmluZCggXCJ2Y2xpY2tcIiwgY2xpY2tIYW5kbGVyIClcblx0XHRcdFx0XHRcdC51bmJpbmQoIFwidm1vdXNldXBcIiwgY2xlYXJUYXBUaW1lciApO1xuXHRcdFx0XHRcdCRkb2N1bWVudC51bmJpbmQoIFwidm1vdXNlY2FuY2VsXCIsIGNsZWFyVGFwSGFuZGxlcnMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZ1bmN0aW9uIGNsaWNrSGFuZGxlciggZXZlbnQgKSB7XG5cdFx0XHRcdFx0Y2xlYXJUYXBIYW5kbGVycygpO1xuXG5cdFx0XHRcdFx0Ly8gT05MWSB0cmlnZ2VyIGEgJ3RhcCcgZXZlbnQgaWYgdGhlIHN0YXJ0IHRhcmdldCBpc1xuXHRcdFx0XHRcdC8vIHRoZSBzYW1lIGFzIHRoZSBzdG9wIHRhcmdldC5cblx0XHRcdFx0XHRpZiAoICFpc1RhcGhvbGQgJiYgb3JpZ1RhcmdldCA9PT0gZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0XHRcdFx0dHJpZ2dlckN1c3RvbUV2ZW50KCB0aGlzT2JqZWN0LCBcInRhcFwiLCBldmVudCApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGlzVGFwaG9sZCApIHtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0JHRoaXMuYmluZCggXCJ2bW91c2V1cFwiLCBjbGVhclRhcFRpbWVyIClcblx0XHRcdFx0XHQuYmluZCggXCJ2Y2xpY2tcIiwgY2xpY2tIYW5kbGVyICk7XG5cdFx0XHRcdCRkb2N1bWVudC5iaW5kKCBcInZtb3VzZWNhbmNlbFwiLCBjbGVhclRhcEhhbmRsZXJzICk7XG5cblx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoICEkLmV2ZW50LnNwZWNpYWwudGFwLmVtaXRUYXBPblRhcGhvbGQgKSB7XG5cdFx0XHRcdFx0XHRpc1RhcGhvbGQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0cmlnZ2VyQ3VzdG9tRXZlbnQoIHRoaXNPYmplY3QsIFwidGFwaG9sZFwiLCAkLkV2ZW50KCBcInRhcGhvbGRcIiwgeyB0YXJnZXQ6IG9yaWdUYXJnZXQgfSApICk7XG5cdFx0XHRcdH0sICQuZXZlbnQuc3BlY2lhbC50YXAudGFwaG9sZFRocmVzaG9sZCApO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHQkKCB0aGlzICkudW5iaW5kKCBcInZtb3VzZWRvd25cIiApLnVuYmluZCggXCJ2Y2xpY2tcIiApLnVuYmluZCggXCJ2bW91c2V1cFwiICk7XG5cdFx0XHQkZG9jdW1lbnQudW5iaW5kKCBcInZtb3VzZWNhbmNlbFwiICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEFsc28gaGFuZGxlcyBzd2lwZWxlZnQsIHN3aXBlcmlnaHRcblx0JC5ldmVudC5zcGVjaWFsLnN3aXBlID0ge1xuXG5cdFx0Ly8gTW9yZSB0aGFuIHRoaXMgaG9yaXpvbnRhbCBkaXNwbGFjZW1lbnQsIGFuZCB3ZSB3aWxsIHN1cHByZXNzIHNjcm9sbGluZy5cblx0XHRzY3JvbGxTdXByZXNzaW9uVGhyZXNob2xkOiAzMCxcblxuXHRcdC8vIE1vcmUgdGltZSB0aGFuIHRoaXMsIGFuZCBpdCBpc24ndCBhIHN3aXBlLlxuXHRcdGR1cmF0aW9uVGhyZXNob2xkOiAxMDAwLFxuXG5cdFx0Ly8gU3dpcGUgaG9yaXpvbnRhbCBkaXNwbGFjZW1lbnQgbXVzdCBiZSBtb3JlIHRoYW4gdGhpcy5cblx0XHRob3Jpem9udGFsRGlzdGFuY2VUaHJlc2hvbGQ6IDMwLFxuXG5cdFx0Ly8gU3dpcGUgdmVydGljYWwgZGlzcGxhY2VtZW50IG11c3QgYmUgbGVzcyB0aGFuIHRoaXMuXG5cdFx0dmVydGljYWxEaXN0YW5jZVRocmVzaG9sZDogMzAsXG5cblx0XHRnZXRMb2NhdGlvbjogZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHRcdHZhciB3aW5QYWdlWCA9IHdpbmRvdy5wYWdlWE9mZnNldCxcblx0XHRcdFx0d2luUGFnZVkgPSB3aW5kb3cucGFnZVlPZmZzZXQsXG5cdFx0XHRcdHggPSBldmVudC5jbGllbnRYLFxuXHRcdFx0XHR5ID0gZXZlbnQuY2xpZW50WTtcblxuXHRcdFx0aWYgKCBldmVudC5wYWdlWSA9PT0gMCAmJiBNYXRoLmZsb29yKCB5ICkgPiBNYXRoLmZsb29yKCBldmVudC5wYWdlWSApIHx8XG5cdFx0XHRcdGV2ZW50LnBhZ2VYID09PSAwICYmIE1hdGguZmxvb3IoIHggKSA+IE1hdGguZmxvb3IoIGV2ZW50LnBhZ2VYICkgKSB7XG5cblx0XHRcdFx0Ly8gaU9TNCBjbGllbnRYL2NsaWVudFkgaGF2ZSB0aGUgdmFsdWUgdGhhdCBzaG91bGQgaGF2ZSBiZWVuXG5cdFx0XHRcdC8vIGluIHBhZ2VYL3BhZ2VZLiBXaGlsZSBwYWdlWC9wYWdlLyBoYXZlIHRoZSB2YWx1ZSAwXG5cdFx0XHRcdHggPSB4IC0gd2luUGFnZVg7XG5cdFx0XHRcdHkgPSB5IC0gd2luUGFnZVk7XG5cdFx0XHR9IGVsc2UgaWYgKCB5IDwgKCBldmVudC5wYWdlWSAtIHdpblBhZ2VZKSB8fCB4IDwgKCBldmVudC5wYWdlWCAtIHdpblBhZ2VYICkgKSB7XG5cblx0XHRcdFx0Ly8gU29tZSBBbmRyb2lkIGJyb3dzZXJzIGhhdmUgdG90YWxseSBib2d1cyB2YWx1ZXMgZm9yIGNsaWVudFgvWVxuXHRcdFx0XHQvLyB3aGVuIHNjcm9sbGluZy96b29taW5nIGEgcGFnZS4gRGV0ZWN0YWJsZSBzaW5jZSBjbGllbnRYL2NsaWVudFlcblx0XHRcdFx0Ly8gc2hvdWxkIG5ldmVyIGJlIHNtYWxsZXIgdGhhbiBwYWdlWC9wYWdlWSBtaW51cyBwYWdlIHNjcm9sbFxuXHRcdFx0XHR4ID0gZXZlbnQucGFnZVggLSB3aW5QYWdlWDtcblx0XHRcdFx0eSA9IGV2ZW50LnBhZ2VZIC0gd2luUGFnZVk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IHgsXG5cdFx0XHRcdHk6IHlcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdHN0YXJ0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgZGF0YSA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyA/XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzWyAwIF0gOiBldmVudCxcblx0XHRcdFx0bG9jYXRpb24gPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZ2V0TG9jYXRpb24oIGRhdGEgKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0aW1lOiAoIG5ldyBEYXRlKCkgKS5nZXRUaW1lKCksXG5cdFx0XHRcdFx0XHRjb29yZHM6IFsgbG9jYXRpb24ueCwgbG9jYXRpb24ueSBdLFxuXHRcdFx0XHRcdFx0b3JpZ2luOiAkKCBldmVudC50YXJnZXQgKVxuXHRcdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdHN0b3A6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBkYXRhID0gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzID9cblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbIDAgXSA6IGV2ZW50LFxuXHRcdFx0XHRsb2NhdGlvbiA9ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5nZXRMb2NhdGlvbiggZGF0YSApO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHRpbWU6ICggbmV3IERhdGUoKSApLmdldFRpbWUoKSxcblx0XHRcdFx0XHRcdGNvb3JkczogWyBsb2NhdGlvbi54LCBsb2NhdGlvbi55IF1cblx0XHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRoYW5kbGVTd2lwZTogZnVuY3Rpb24oIHN0YXJ0LCBzdG9wLCB0aGlzT2JqZWN0LCBvcmlnVGFyZ2V0ICkge1xuXHRcdFx0aWYgKCBzdG9wLnRpbWUgLSBzdGFydC50aW1lIDwgJC5ldmVudC5zcGVjaWFsLnN3aXBlLmR1cmF0aW9uVGhyZXNob2xkICYmXG5cdFx0XHRcdE1hdGguYWJzKCBzdGFydC5jb29yZHNbIDAgXSAtIHN0b3AuY29vcmRzWyAwIF0gKSA+ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5ob3Jpem9udGFsRGlzdGFuY2VUaHJlc2hvbGQgJiZcblx0XHRcdFx0TWF0aC5hYnMoIHN0YXJ0LmNvb3Jkc1sgMSBdIC0gc3RvcC5jb29yZHNbIDEgXSApIDwgJC5ldmVudC5zcGVjaWFsLnN3aXBlLnZlcnRpY2FsRGlzdGFuY2VUaHJlc2hvbGQgKSB7XG5cdFx0XHRcdHZhciBkaXJlY3Rpb24gPSBzdGFydC5jb29yZHNbMF0gPiBzdG9wLmNvb3Jkc1sgMCBdID8gXCJzd2lwZWxlZnRcIiA6IFwic3dpcGVyaWdodFwiO1xuXG5cdFx0XHRcdHRyaWdnZXJDdXN0b21FdmVudCggdGhpc09iamVjdCwgXCJzd2lwZVwiLCAkLkV2ZW50KCBcInN3aXBlXCIsIHsgdGFyZ2V0OiBvcmlnVGFyZ2V0LCBzd2lwZXN0YXJ0OiBzdGFydCwgc3dpcGVzdG9wOiBzdG9wIH0pLCB0cnVlICk7XG5cdFx0XHRcdHRyaWdnZXJDdXN0b21FdmVudCggdGhpc09iamVjdCwgZGlyZWN0aW9uLCQuRXZlbnQoIGRpcmVjdGlvbiwgeyB0YXJnZXQ6IG9yaWdUYXJnZXQsIHN3aXBlc3RhcnQ6IHN0YXJ0LCBzd2lwZXN0b3A6IHN0b3AgfSApLCB0cnVlICk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fSxcblxuXHRcdC8vIFRoaXMgc2VydmVzIGFzIGEgZmxhZyB0byBlbnN1cmUgdGhhdCBhdCBtb3N0IG9uZSBzd2lwZSBldmVudCBldmVudCBpc1xuXHRcdC8vIGluIHdvcmsgYXQgYW55IGdpdmVuIHRpbWVcblx0XHRldmVudEluUHJvZ3Jlc3M6IGZhbHNlLFxuXG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGV2ZW50cyxcblx0XHRcdFx0dGhpc09iamVjdCA9IHRoaXMsXG5cdFx0XHRcdCR0aGlzID0gJCggdGhpc09iamVjdCApLFxuXHRcdFx0XHRjb250ZXh0ID0ge307XG5cblx0XHRcdC8vIFJldHJpZXZlIHRoZSBldmVudHMgZGF0YSBmb3IgdGhpcyBlbGVtZW50IGFuZCBhZGQgdGhlIHN3aXBlIGNvbnRleHRcblx0XHRcdGV2ZW50cyA9ICQuZGF0YSggdGhpcywgXCJtb2JpbGUtZXZlbnRzXCIgKTtcblx0XHRcdGlmICggIWV2ZW50cyApIHtcblx0XHRcdFx0ZXZlbnRzID0geyBsZW5ndGg6IDAgfTtcblx0XHRcdFx0JC5kYXRhKCB0aGlzLCBcIm1vYmlsZS1ldmVudHNcIiwgZXZlbnRzICk7XG5cdFx0XHR9XG5cdFx0XHRldmVudHMubGVuZ3RoKys7XG5cdFx0XHRldmVudHMuc3dpcGUgPSBjb250ZXh0O1xuXG5cdFx0XHRjb250ZXh0LnN0YXJ0ID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIEJhaWwgaWYgd2UncmUgYWxyZWFkeSB3b3JraW5nIG9uIGEgc3dpcGUgZXZlbnRcblx0XHRcdFx0aWYgKCAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZXZlbnRJblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZXZlbnRJblByb2dyZXNzID0gdHJ1ZTtcblxuXHRcdFx0XHR2YXIgc3RvcCxcblx0XHRcdFx0XHRzdGFydCA9ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5zdGFydCggZXZlbnQgKSxcblx0XHRcdFx0XHRvcmlnVGFyZ2V0ID0gZXZlbnQudGFyZ2V0LFxuXHRcdFx0XHRcdGVtaXR0ZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRjb250ZXh0Lm1vdmUgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhc3RhcnQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3RvcCA9ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5zdG9wKCBldmVudCApO1xuXHRcdFx0XHRcdGlmICggIWVtaXR0ZWQgKSB7XG5cdFx0XHRcdFx0XHRlbWl0dGVkID0gJC5ldmVudC5zcGVjaWFsLnN3aXBlLmhhbmRsZVN3aXBlKCBzdGFydCwgc3RvcCwgdGhpc09iamVjdCwgb3JpZ1RhcmdldCApO1xuXHRcdFx0XHRcdFx0aWYgKCBlbWl0dGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlc2V0IHRoZSBjb250ZXh0IHRvIG1ha2Ugd2F5IGZvciB0aGUgbmV4dCBzd2lwZSBldmVudFxuXHRcdFx0XHRcdFx0XHQkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZXZlbnRJblByb2dyZXNzID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHByZXZlbnQgc2Nyb2xsaW5nXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggc3RhcnQuY29vcmRzWyAwIF0gLSBzdG9wLmNvb3Jkc1sgMCBdICkgPiAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuc2Nyb2xsU3VwcmVzc2lvblRocmVzaG9sZCApIHtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGNvbnRleHQuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0ZW1pdHRlZCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdC8vIFJlc2V0IHRoZSBjb250ZXh0IHRvIG1ha2Ugd2F5IGZvciB0aGUgbmV4dCBzd2lwZSBldmVudFxuXHRcdFx0XHRcdFx0JC5ldmVudC5zcGVjaWFsLnN3aXBlLmV2ZW50SW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0JGRvY3VtZW50Lm9mZiggdG91Y2hNb3ZlRXZlbnQsIGNvbnRleHQubW92ZSApO1xuXHRcdFx0XHRcdFx0Y29udGV4dC5tb3ZlID0gbnVsbDtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQkZG9jdW1lbnQub24oIHRvdWNoTW92ZUV2ZW50LCBjb250ZXh0Lm1vdmUgKVxuXHRcdFx0XHRcdC5vbmUoIHRvdWNoU3RvcEV2ZW50LCBjb250ZXh0LnN0b3AgKTtcblx0XHRcdH07XG5cdFx0XHQkdGhpcy5vbiggdG91Y2hTdGFydEV2ZW50LCBjb250ZXh0LnN0YXJ0ICk7XG5cdFx0fSxcblxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBldmVudHMsIGNvbnRleHQ7XG5cblx0XHRcdGV2ZW50cyA9ICQuZGF0YSggdGhpcywgXCJtb2JpbGUtZXZlbnRzXCIgKTtcblx0XHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0XHRjb250ZXh0ID0gZXZlbnRzLnN3aXBlO1xuXHRcdFx0XHRkZWxldGUgZXZlbnRzLnN3aXBlO1xuXHRcdFx0XHRldmVudHMubGVuZ3RoLS07XG5cdFx0XHRcdGlmICggZXZlbnRzLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdFx0XHQkLnJlbW92ZURhdGEoIHRoaXMsIFwibW9iaWxlLWV2ZW50c1wiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjb250ZXh0ICkge1xuXHRcdFx0XHRpZiAoIGNvbnRleHQuc3RhcnQgKSB7XG5cdFx0XHRcdFx0JCggdGhpcyApLm9mZiggdG91Y2hTdGFydEV2ZW50LCBjb250ZXh0LnN0YXJ0ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBjb250ZXh0Lm1vdmUgKSB7XG5cdFx0XHRcdFx0JGRvY3VtZW50Lm9mZiggdG91Y2hNb3ZlRXZlbnQsIGNvbnRleHQubW92ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggY29udGV4dC5zdG9wICkge1xuXHRcdFx0XHRcdCRkb2N1bWVudC5vZmYoIHRvdWNoU3RvcEV2ZW50LCBjb250ZXh0LnN0b3AgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0JC5lYWNoKHtcblx0XHRzY3JvbGxzdG9wOiBcInNjcm9sbHN0YXJ0XCIsXG5cdFx0dGFwaG9sZDogXCJ0YXBcIixcblx0XHRzd2lwZWxlZnQ6IFwic3dpcGUubGVmdFwiLFxuXHRcdHN3aXBlcmlnaHQ6IFwic3dpcGUucmlnaHRcIlxuXHR9LCBmdW5jdGlvbiggZXZlbnQsIHNvdXJjZUV2ZW50ICkge1xuXG5cdFx0JC5ldmVudC5zcGVjaWFsWyBldmVudCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkKCB0aGlzICkuYmluZCggc291cmNlRXZlbnQsICQubm9vcCApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLnVuYmluZCggc291cmNlRXZlbnQgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcblxufSkoIGpRdWVyeSwgdGhpcyApO1xuXG5cblx0Ly8gdGhyb3R0bGVkIHJlc2l6ZSBldmVudFxuXHQoZnVuY3Rpb24oICQgKSB7XG5cdFx0JC5ldmVudC5zcGVjaWFsLnRocm90dGxlZHJlc2l6ZSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLmJpbmQoIFwicmVzaXplXCIsIGhhbmRsZXIgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS51bmJpbmQoIFwicmVzaXplXCIsIGhhbmRsZXIgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIHRocm90dGxlID0gMjUwLFxuXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjdXJyID0gKCBuZXcgRGF0ZSgpICkuZ2V0VGltZSgpO1xuXHRcdFx0XHRkaWZmID0gY3VyciAtIGxhc3RDYWxsO1xuXG5cdFx0XHRcdGlmICggZGlmZiA+PSB0aHJvdHRsZSApIHtcblxuXHRcdFx0XHRcdGxhc3RDYWxsID0gY3Vycjtcblx0XHRcdFx0XHQkKCB0aGlzICkudHJpZ2dlciggXCJ0aHJvdHRsZWRyZXNpemVcIiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIGhlbGRDYWxsICkge1xuXHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KCBoZWxkQ2FsbCApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByb21pc2UgYSBoZWxkIGNhbGwgd2lsbCBzdGlsbCBleGVjdXRlXG5cdFx0XHRcdFx0aGVsZENhbGwgPSBzZXRUaW1lb3V0KCBoYW5kbGVyLCB0aHJvdHRsZSAtIGRpZmYgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGxhc3RDYWxsID0gMCxcblx0XHRcdGhlbGRDYWxsLFxuXHRcdFx0Y3Vycixcblx0XHRcdGRpZmY7XG5cdH0pKCBqUXVlcnkgKTtcblxuXG4oZnVuY3Rpb24oICQsIHdpbmRvdyApIHtcblx0dmFyIHdpbiA9ICQoIHdpbmRvdyApLFxuXHRcdGV2ZW50X25hbWUgPSBcIm9yaWVudGF0aW9uY2hhbmdlXCIsXG5cdFx0Z2V0X29yaWVudGF0aW9uLFxuXHRcdGxhc3Rfb3JpZW50YXRpb24sXG5cdFx0aW5pdGlhbF9vcmllbnRhdGlvbl9pc19sYW5kc2NhcGUsXG5cdFx0aW5pdGlhbF9vcmllbnRhdGlvbl9pc19kZWZhdWx0LFxuXHRcdHBvcnRyYWl0X21hcCA9IHsgXCIwXCI6IHRydWUsIFwiMTgwXCI6IHRydWUgfSxcblx0XHR3dywgd2gsIGxhbmRzY2FwZV90aHJlc2hvbGQ7XG5cblx0Ly8gSXQgc2VlbXMgdGhhdCBzb21lIGRldmljZS9icm93c2VyIHZlbmRvcnMgdXNlIHdpbmRvdy5vcmllbnRhdGlvbiB2YWx1ZXMgMCBhbmQgMTgwIHRvXG5cdC8vIGRlbm90ZSB0aGUgXCJkZWZhdWx0XCIgb3JpZW50YXRpb24uIEZvciBpT1MgZGV2aWNlcywgYW5kIG1vc3Qgb3RoZXIgc21hcnQtcGhvbmVzIHRlc3RlZCxcblx0Ly8gdGhlIGRlZmF1bHQgb3JpZW50YXRpb24gaXMgYWx3YXlzIFwicG9ydHJhaXRcIiwgYnV0IGluIHNvbWUgQW5kcm9pZCBhbmQgUklNIGJhc2VkIHRhYmxldHMsXG5cdC8vIHRoZSBkZWZhdWx0IG9yaWVudGF0aW9uIGlzIFwibGFuZHNjYXBlXCIuIFRoZSBmb2xsb3dpbmcgY29kZSBhdHRlbXB0cyB0byB1c2UgdGhlIHdpbmRvd1xuXHQvLyBkaW1lbnNpb25zIHRvIGZpZ3VyZSBvdXQgd2hhdCB0aGUgY3VycmVudCBvcmllbnRhdGlvbiBpcywgYW5kIHRoZW4gbWFrZXMgYWRqdXN0bWVudHNcblx0Ly8gdG8gdGhlIHRvIHRoZSBwb3J0cmFpdF9tYXAgaWYgbmVjZXNzYXJ5LCBzbyB0aGF0IHdlIGNhbiBwcm9wZXJseSBkZWNvZGUgdGhlXG5cdC8vIHdpbmRvdy5vcmllbnRhdGlvbiB2YWx1ZSB3aGVuZXZlciBnZXRfb3JpZW50YXRpb24oKSBpcyBjYWxsZWQuXG5cdC8vXG5cdC8vIE5vdGUgdGhhdCB3ZSB1c2VkIHRvIHVzZSBhIG1lZGlhIHF1ZXJ5IHRvIGZpZ3VyZSBvdXQgd2hhdCB0aGUgb3JpZW50YXRpb24gdGhlIGJyb3dzZXJcblx0Ly8gdGhpbmtzIGl0IGlzIGluOlxuXHQvL1xuXHQvLyAgICAgaW5pdGlhbF9vcmllbnRhdGlvbl9pc19sYW5kc2NhcGUgPSAkLm1vYmlsZS5tZWRpYShcImFsbCBhbmQgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpXCIpO1xuXHQvL1xuXHQvLyBidXQgdGhlcmUgd2FzIGFuIGlQaG9uZS9pUG9kIFRvdWNoIGJ1ZyBiZWdpbm5pbmcgd2l0aCBpT1MgNC4yLCB1cCB0aHJvdWdoIGlPUyA1LjEsXG5cdC8vIHdoZXJlIHRoZSBicm93c2VyICpBTFdBWVMqIGFwcGxpZWQgdGhlIGxhbmRzY2FwZSBtZWRpYSBxdWVyeS4gVGhpcyBidWcgZG9lcyBub3Rcblx0Ly8gaGFwcGVuIG9uIGlQYWQuXG5cblx0aWYgKCAkLnN1cHBvcnQub3JpZW50YXRpb24gKSB7XG5cblx0XHQvLyBDaGVjayB0aGUgd2luZG93IHdpZHRoIGFuZCBoZWlnaHQgdG8gZmlndXJlIG91dCB3aGF0IHRoZSBjdXJyZW50IG9yaWVudGF0aW9uXG5cdFx0Ly8gb2YgdGhlIGRldmljZSBpcyBhdCB0aGlzIG1vbWVudC4gTm90ZSB0aGF0IHdlJ3ZlIGluaXRpYWxpemVkIHRoZSBwb3J0cmFpdCBtYXBcblx0XHQvLyB2YWx1ZXMgdG8gMCBhbmQgMTgwLCAqQU5EKiB3ZSBwdXJwb3NlbHkgY2hlY2sgZm9yIGxhbmRzY2FwZSBzbyB0aGF0IGlmIHdlIGd1ZXNzXG5cdFx0Ly8gd3JvbmcsICwgd2UgZGVmYXVsdCB0byB0aGUgYXNzdW1wdGlvbiB0aGF0IHBvcnRyYWl0IGlzIHRoZSBkZWZhdWx0IG9yaWVudGF0aW9uLlxuXHRcdC8vIFdlIHVzZSBhIHRocmVzaG9sZCBjaGVjayBiZWxvdyBiZWNhdXNlIG9uIHNvbWUgcGxhdGZvcm1zIGxpa2UgaU9TLCB0aGUgaVBob25lXG5cdFx0Ly8gZm9ybS1mYWN0b3IgY2FuIHJlcG9ydCBhIGxhcmdlciB3aWR0aCB0aGFuIGhlaWdodCBpZiB0aGUgdXNlciB0dXJucyBvbiB0aGVcblx0XHQvLyBkZXZlbG9wZXIgY29uc29sZS4gVGhlIGFjdHVhbCB0aHJlc2hvbGQgdmFsdWUgaXMgc29tZXdoYXQgYXJiaXRyYXJ5LCB3ZSBqdXN0XG5cdFx0Ly8gbmVlZCB0byBtYWtlIHN1cmUgaXQgaXMgbGFyZ2UgZW5vdWdoIHRvIGV4Y2x1ZGUgdGhlIGRldmVsb3BlciBjb25zb2xlIGNhc2UuXG5cblx0XHR3dyA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IHdpbi53aWR0aCgpO1xuXHRcdHdoID0gd2luZG93LmlubmVySGVpZ2h0IHx8IHdpbi5oZWlnaHQoKTtcblx0XHRsYW5kc2NhcGVfdGhyZXNob2xkID0gNTA7XG5cblx0XHRpbml0aWFsX29yaWVudGF0aW9uX2lzX2xhbmRzY2FwZSA9IHd3ID4gd2ggJiYgKCB3dyAtIHdoICkgPiBsYW5kc2NhcGVfdGhyZXNob2xkO1xuXG5cdFx0Ly8gTm93IGNoZWNrIHRvIHNlZSBpZiB0aGUgY3VycmVudCB3aW5kb3cub3JpZW50YXRpb24gaXMgMCBvciAxODAuXG5cdFx0aW5pdGlhbF9vcmllbnRhdGlvbl9pc19kZWZhdWx0ID0gcG9ydHJhaXRfbWFwWyB3aW5kb3cub3JpZW50YXRpb24gXTtcblxuXHRcdC8vIElmIHRoZSBpbml0aWFsIG9yaWVudGF0aW9uIGlzIGxhbmRzY2FwZSwgYnV0IHdpbmRvdy5vcmllbnRhdGlvbiByZXBvcnRzIDAgb3IgMTgwLCAqT1IqXG5cdFx0Ly8gaWYgdGhlIGluaXRpYWwgb3JpZW50YXRpb24gaXMgcG9ydHJhaXQsIGJ1dCB3aW5kb3cub3JpZW50YXRpb24gcmVwb3J0cyA5MCBvciAtOTAsIHdlXG5cdFx0Ly8gbmVlZCB0byBmbGlwIG91ciBwb3J0cmFpdF9tYXAgdmFsdWVzIGJlY2F1c2UgbGFuZHNjYXBlIGlzIHRoZSBkZWZhdWx0IG9yaWVudGF0aW9uIGZvclxuXHRcdC8vIHRoaXMgZGV2aWNlL2Jyb3dzZXIuXG5cdFx0aWYgKCAoIGluaXRpYWxfb3JpZW50YXRpb25faXNfbGFuZHNjYXBlICYmIGluaXRpYWxfb3JpZW50YXRpb25faXNfZGVmYXVsdCApIHx8ICggIWluaXRpYWxfb3JpZW50YXRpb25faXNfbGFuZHNjYXBlICYmICFpbml0aWFsX29yaWVudGF0aW9uX2lzX2RlZmF1bHQgKSApIHtcblx0XHRcdHBvcnRyYWl0X21hcCA9IHsgXCItOTBcIjogdHJ1ZSwgXCI5MFwiOiB0cnVlIH07XG5cdFx0fVxuXHR9XG5cblx0JC5ldmVudC5zcGVjaWFsLm9yaWVudGF0aW9uY2hhbmdlID0gJC5leHRlbmQoIHt9LCAkLmV2ZW50LnNwZWNpYWwub3JpZW50YXRpb25jaGFuZ2UsIHtcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBJZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkIG5hdGl2ZWx5LCByZXR1cm4gZmFsc2Ugc28gdGhhdCBqUXVlcnlcblx0XHRcdC8vIHdpbGwgYmluZCB0byB0aGUgZXZlbnQgdXNpbmcgRE9NIG1ldGhvZHMuXG5cdFx0XHRpZiAoICQuc3VwcG9ydC5vcmllbnRhdGlvbiAmJiAhJC5ldmVudC5zcGVjaWFsLm9yaWVudGF0aW9uY2hhbmdlLmRpc2FibGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEdldCB0aGUgY3VycmVudCBvcmllbnRhdGlvbiB0byBhdm9pZCBpbml0aWFsIGRvdWJsZS10cmlnZ2VyaW5nLlxuXHRcdFx0bGFzdF9vcmllbnRhdGlvbiA9IGdldF9vcmllbnRhdGlvbigpO1xuXG5cdFx0XHQvLyBCZWNhdXNlIHRoZSBvcmllbnRhdGlvbmNoYW5nZSBldmVudCBkb2Vzbid0IGV4aXN0LCBzaW11bGF0ZSB0aGVcblx0XHRcdC8vIGV2ZW50IGJ5IHRlc3Rpbmcgd2luZG93IGRpbWVuc2lvbnMgb24gcmVzaXplLlxuXHRcdFx0d2luLmJpbmQoIFwidGhyb3R0bGVkcmVzaXplXCIsIGhhbmRsZXIgKTtcblx0XHR9LFxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIElmIHRoZSBldmVudCBpcyBub3Qgc3VwcG9ydGVkIG5hdGl2ZWx5LCByZXR1cm4gZmFsc2Ugc28gdGhhdFxuXHRcdFx0Ly8galF1ZXJ5IHdpbGwgdW5iaW5kIHRoZSBldmVudCB1c2luZyBET00gbWV0aG9kcy5cblx0XHRcdGlmICggJC5zdXBwb3J0Lm9yaWVudGF0aW9uICYmICEkLmV2ZW50LnNwZWNpYWwub3JpZW50YXRpb25jaGFuZ2UuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQmVjYXVzZSB0aGUgb3JpZW50YXRpb25jaGFuZ2UgZXZlbnQgZG9lc24ndCBleGlzdCwgdW5iaW5kIHRoZVxuXHRcdFx0Ly8gcmVzaXplIGV2ZW50IGhhbmRsZXIuXG5cdFx0XHR3aW4udW5iaW5kKCBcInRocm90dGxlZHJlc2l6ZVwiLCBoYW5kbGVyICk7XG5cdFx0fSxcblx0XHRhZGQ6IGZ1bmN0aW9uKCBoYW5kbGVPYmogKSB7XG5cdFx0XHQvLyBTYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBib3VuZCBldmVudCBoYW5kbGVyLlxuXHRcdFx0dmFyIG9sZF9oYW5kbGVyID0gaGFuZGxlT2JqLmhhbmRsZXI7XG5cblx0XHRcdGhhbmRsZU9iai5oYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQvLyBNb2RpZnkgZXZlbnQgb2JqZWN0LCBhZGRpbmcgdGhlIC5vcmllbnRhdGlvbiBwcm9wZXJ0eS5cblx0XHRcdFx0ZXZlbnQub3JpZW50YXRpb24gPSBnZXRfb3JpZW50YXRpb24oKTtcblxuXHRcdFx0XHQvLyBDYWxsIHRoZSBvcmlnaW5hbGx5LWJvdW5kIGV2ZW50IGhhbmRsZXIgYW5kIHJldHVybiBpdHMgcmVzdWx0LlxuXHRcdFx0XHRyZXR1cm4gb2xkX2hhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIElmIHRoZSBldmVudCBpcyBub3Qgc3VwcG9ydGVkIG5hdGl2ZWx5LCB0aGlzIGhhbmRsZXIgd2lsbCBiZSBib3VuZCB0b1xuXHQvLyB0aGUgd2luZG93IHJlc2l6ZSBldmVudCB0byBzaW11bGF0ZSB0aGUgb3JpZW50YXRpb25jaGFuZ2UgZXZlbnQuXG5cdGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG5cdFx0Ly8gR2V0IHRoZSBjdXJyZW50IG9yaWVudGF0aW9uLlxuXHRcdHZhciBvcmllbnRhdGlvbiA9IGdldF9vcmllbnRhdGlvbigpO1xuXG5cdFx0aWYgKCBvcmllbnRhdGlvbiAhPT0gbGFzdF9vcmllbnRhdGlvbiApIHtcblx0XHRcdC8vIFRoZSBvcmllbnRhdGlvbiBoYXMgY2hhbmdlZCwgc28gdHJpZ2dlciB0aGUgb3JpZW50YXRpb25jaGFuZ2UgZXZlbnQuXG5cdFx0XHRsYXN0X29yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG5cdFx0XHR3aW4udHJpZ2dlciggZXZlbnRfbmFtZSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEdldCB0aGUgY3VycmVudCBwYWdlIG9yaWVudGF0aW9uLiBUaGlzIG1ldGhvZCBpcyBleHBvc2VkIHB1YmxpY2x5LCBzaG91bGQgaXRcblx0Ly8gYmUgbmVlZGVkLCBhcyBqUXVlcnkuZXZlbnQuc3BlY2lhbC5vcmllbnRhdGlvbmNoYW5nZS5vcmllbnRhdGlvbigpXG5cdCQuZXZlbnQuc3BlY2lhbC5vcmllbnRhdGlvbmNoYW5nZS5vcmllbnRhdGlvbiA9IGdldF9vcmllbnRhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpc1BvcnRyYWl0ID0gdHJ1ZSwgZWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXHRcdC8vIHByZWZlciB3aW5kb3cgb3JpZW50YXRpb24gdG8gdGhlIGNhbGN1bGF0aW9uIGJhc2VkIG9uIHNjcmVlbnNpemUgYXNcblx0XHQvLyB0aGUgYWN0dWFsIHNjcmVlbiByZXNpemUgdGFrZXMgcGxhY2UgYmVmb3JlIG9yIGFmdGVyIHRoZSBvcmllbnRhdGlvbiBjaGFuZ2UgZXZlbnRcblx0XHQvLyBoYXMgYmVlbiBmaXJlZCBkZXBlbmRpbmcgb24gaW1wbGVtZW50YXRpb24gKGVnIGFuZHJvaWQgMi4zIGlzIGJlZm9yZSwgaXBob25lIGFmdGVyKS5cblx0XHQvLyBNb3JlIHRlc3RpbmcgaXMgcmVxdWlyZWQgdG8gZGV0ZXJtaW5lIGlmIGEgbW9yZSByZWxpYWJsZSBtZXRob2Qgb2YgZGV0ZXJtaW5pbmcgdGhlIG5ldyBzY3JlZW5zaXplXG5cdFx0Ly8gaXMgcG9zc2libGUgd2hlbiBvcmllbnRhdGlvbmNoYW5nZSBpcyBmaXJlZC4gKGVnLCB1c2UgbWVkaWEgcXVlcmllcyArIGVsZW1lbnQgKyBvcGFjaXR5KVxuXHRcdGlmICggJC5zdXBwb3J0Lm9yaWVudGF0aW9uICkge1xuXHRcdFx0Ly8gaWYgdGhlIHdpbmRvdyBvcmllbnRhdGlvbiByZWdpc3RlcnMgYXMgMCBvciAxODAgZGVncmVlcyByZXBvcnRcblx0XHRcdC8vIHBvcnRyYWl0LCBvdGhlcndpc2UgbGFuZHNjYXBlXG5cdFx0XHRpc1BvcnRyYWl0ID0gcG9ydHJhaXRfbWFwWyB3aW5kb3cub3JpZW50YXRpb24gXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aXNQb3J0cmFpdCA9IGVsZW0gJiYgZWxlbS5jbGllbnRXaWR0aCAvIGVsZW0uY2xpZW50SGVpZ2h0IDwgMS4xO1xuXHRcdH1cblxuXHRcdHJldHVybiBpc1BvcnRyYWl0ID8gXCJwb3J0cmFpdFwiIDogXCJsYW5kc2NhcGVcIjtcblx0fTtcblxuXHQkLmZuWyBldmVudF9uYW1lIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGZuID8gdGhpcy5iaW5kKCBldmVudF9uYW1lLCBmbiApIDogdGhpcy50cmlnZ2VyKCBldmVudF9uYW1lICk7XG5cdH07XG5cblx0Ly8galF1ZXJ5IDwgMS44XG5cdGlmICggJC5hdHRyRm4gKSB7XG5cdFx0JC5hdHRyRm5bIGV2ZW50X25hbWUgXSA9IHRydWU7XG5cdH1cblxufSggalF1ZXJ5LCB0aGlzICkpO1xuXG5cblxuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuXHQvLyBleGlzdGluZyBiYXNlIHRhZz9cblx0dmFyIGJhc2VFbGVtZW50ID0gJCggXCJoZWFkXCIgKS5jaGlsZHJlbiggXCJiYXNlXCIgKSxcblxuXHQvLyBiYXNlIGVsZW1lbnQgbWFuYWdlbWVudCwgZGVmaW5lZCBkZXBlbmRpbmcgb24gZHluYW1pYyBiYXNlIHRhZyBzdXBwb3J0XG5cdC8vIFRPRE8gbW92ZSB0byBleHRlcm5hbCB3aWRnZXRcblx0YmFzZSA9IHtcblxuXHRcdC8vIGRlZmluZSBiYXNlIGVsZW1lbnQsIGZvciB1c2UgaW4gcm91dGluZyBhc3NldCB1cmxzIHRoYXQgYXJlIHJlZmVyZW5jZWRcblx0XHQvLyBpbiBBamF4LXJlcXVlc3RlZCBtYXJrdXBcblx0XHRlbGVtZW50OiAoIGJhc2VFbGVtZW50Lmxlbmd0aCA/IGJhc2VFbGVtZW50IDpcblx0XHRcdCQoIFwiPGJhc2U+XCIsIHsgaHJlZjogJC5tb2JpbGUucGF0aC5kb2N1bWVudEJhc2UuaHJlZk5vSGFzaCB9ICkucHJlcGVuZFRvKCAkKCBcImhlYWRcIiApICkgKSxcblxuXHRcdGxpbmtTZWxlY3RvcjogXCJbc3JjXSwgbGlua1tocmVmXSwgYVtyZWw9J2V4dGVybmFsJ10sIDpqcW1EYXRhKGFqYXg9J2ZhbHNlJyksIGFbdGFyZ2V0XVwiLFxuXG5cdFx0Ly8gc2V0IHRoZSBnZW5lcmF0ZWQgQkFTRSBlbGVtZW50J3MgaHJlZiB0byBhIG5ldyBwYWdlJ3MgYmFzZSBwYXRoXG5cdFx0c2V0OiBmdW5jdGlvbiggaHJlZiApIHtcblxuXHRcdFx0Ly8gd2Ugc2hvdWxkIGRvIG5vdGhpbmcgaWYgdGhlIHVzZXIgd2FudHMgdG8gbWFuYWdlIHRoZWlyIHVybCBiYXNlXG5cdFx0XHQvLyBtYW51YWxseVxuXHRcdFx0aWYgKCAhJC5tb2JpbGUuZHluYW1pY0Jhc2VFbmFibGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIHdlIHNob3VsZCB1c2UgdGhlIGJhc2UgdGFnIGlmIHdlIGNhbiBtYW5pcHVsYXRlIGl0IGR5bmFtaWNhbGx5XG5cdFx0XHRpZiAoICQuc3VwcG9ydC5keW5hbWljQmFzZVRhZyApIHtcblx0XHRcdFx0YmFzZS5lbGVtZW50LmF0dHIoIFwiaHJlZlwiLFxuXHRcdFx0XHRcdCQubW9iaWxlLnBhdGgubWFrZVVybEFic29sdXRlKCBocmVmLCAkLm1vYmlsZS5wYXRoLmRvY3VtZW50QmFzZSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHJld3JpdGU6IGZ1bmN0aW9uKCBocmVmLCBwYWdlICkge1xuXHRcdFx0dmFyIG5ld1BhdGggPSAkLm1vYmlsZS5wYXRoLmdldCggaHJlZiApO1xuXG5cdFx0XHRwYWdlLmZpbmQoIGJhc2UubGlua1NlbGVjdG9yICkuZWFjaChmdW5jdGlvbiggaSwgbGluayApIHtcblx0XHRcdFx0dmFyIHRoaXNBdHRyID0gJCggbGluayApLmlzKCBcIltocmVmXVwiICkgPyBcImhyZWZcIiA6XG5cdFx0XHRcdFx0JCggbGluayApLmlzKCBcIltzcmNdXCIgKSA/IFwic3JjXCIgOiBcImFjdGlvblwiLFxuXHRcdFx0XHR0aGVMb2NhdGlvbiA9ICQubW9iaWxlLnBhdGgucGFyc2VMb2NhdGlvbigpLFxuXHRcdFx0XHR0aGlzVXJsID0gJCggbGluayApLmF0dHIoIHRoaXNBdHRyICk7XG5cblx0XHRcdFx0Ly8gWFhYX2pibGFzOiBXZSBuZWVkIHRvIGZpeCB0aGlzIHNvIHRoYXQgaXQgcmVtb3ZlcyB0aGUgZG9jdW1lbnRcblx0XHRcdFx0Ly8gICAgICAgICAgICBiYXNlIFVSTCwgYW5kIHRoZW4gcHJlcGVuZHMgd2l0aCB0aGUgbmV3IHBhZ2UgVVJMLlxuXHRcdFx0XHQvLyBpZiBmdWxsIHBhdGggZXhpc3RzIGFuZCBpcyBzYW1lLCBjaG9wIGl0IC0gaGVscHMgSUUgb3V0XG5cdFx0XHRcdHRoaXNVcmwgPSB0aGlzVXJsLnJlcGxhY2UoIHRoZUxvY2F0aW9uLnByb3RvY29sICsgdGhlTG9jYXRpb24uZG91YmxlU2xhc2ggK1xuXHRcdFx0XHRcdHRoZUxvY2F0aW9uLmhvc3QgKyB0aGVMb2NhdGlvbi5wYXRobmFtZSwgXCJcIiApO1xuXG5cdFx0XHRcdGlmICggIS9eKFxcdys6fCN8XFwvKS8udGVzdCggdGhpc1VybCApICkge1xuXHRcdFx0XHRcdCQoIGxpbmsgKS5hdHRyKCB0aGlzQXR0ciwgbmV3UGF0aCArIHRoaXNVcmwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8vIHNldCB0aGUgZ2VuZXJhdGVkIEJBU0UgZWxlbWVudCdzIGhyZWYgdG8gYSBuZXcgcGFnZSdzIGJhc2UgcGF0aFxuXHRcdHJlc2V0OiBmdW5jdGlvbigvKiBocmVmICovKSB7XG5cdFx0XHRiYXNlLmVsZW1lbnQuYXR0ciggXCJocmVmXCIsICQubW9iaWxlLnBhdGguZG9jdW1lbnRCYXNlLmhyZWZOb1NlYXJjaCApO1xuXHRcdH1cblx0fTtcblxuXHQkLm1vYmlsZS5iYXNlID0gYmFzZTtcblxufSkoIGpRdWVyeSApO1xuXG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuJC5tb2JpbGUud2lkZ2V0cyA9IHt9O1xuXG52YXIgb3JpZ2luYWxXaWRnZXQgPSAkLndpZGdldCxcblxuXHQvLyBSZWNvcmQgdGhlIG9yaWdpbmFsLCBub24tbW9iaWxlaW5pdC1tb2RpZmllZCB2ZXJzaW9uIG9mICQubW9iaWxlLmtlZXBOYXRpdmVcblx0Ly8gc28gd2UgY2FuIGxhdGVyIGRldGVybWluZSB3aGV0aGVyIHNvbWVvbmUgaGFzIG1vZGlmaWVkICQubW9iaWxlLmtlZXBOYXRpdmVcblx0a2VlcE5hdGl2ZUZhY3RvcnlEZWZhdWx0ID0gJC5tb2JpbGUua2VlcE5hdGl2ZTtcblxuJC53aWRnZXQgPSAoZnVuY3Rpb24oIG9yaWcgKSB7XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29uc3RydWN0b3IgPSBvcmlnLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSxcblx0XHRcdG5hbWUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGUud2lkZ2V0TmFtZTtcblxuXHRcdGNvbnN0cnVjdG9yLmluaXRTZWxlY3RvciA9ICggKCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuaW5pdFNlbGVjdG9yICE9PSB1bmRlZmluZWQgKSA/XG5cdFx0XHRjb25zdHJ1Y3Rvci5wcm90b3R5cGUuaW5pdFNlbGVjdG9yIDogXCI6anFtRGF0YShyb2xlPSdcIiArIG5hbWUgKyBcIicpXCIgKTtcblxuXHRcdCQubW9iaWxlLndpZGdldHNbIG5hbWUgXSA9IGNvbnN0cnVjdG9yO1xuXG5cdFx0cmV0dXJuIGNvbnN0cnVjdG9yO1xuXHR9O1xufSkoICQud2lkZ2V0ICk7XG5cbi8vIE1ha2Ugc3VyZSAkLndpZGdldCBzdGlsbCBoYXMgYnJpZGdlIGFuZCBleHRlbmQgbWV0aG9kc1xuJC5leHRlbmQoICQud2lkZ2V0LCBvcmlnaW5hbFdpZGdldCApO1xuXG4vLyBGb3IgYmFja2NvbXBhdCByZW1vdmUgaW4gMS41XG4kLm1vYmlsZS5kb2N1bWVudC5vbiggXCJjcmVhdGVcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHQkKCBldmVudC50YXJnZXQgKS5lbmhhbmNlV2l0aGluKCk7XG59KTtcblxuJC53aWRnZXQoIFwibW9iaWxlLnBhZ2VcIiwge1xuXHRvcHRpb25zOiB7XG5cdFx0dGhlbWU6IFwiYVwiLFxuXHRcdGRvbUNhY2hlOiBmYWxzZSxcblxuXHRcdC8vIERlcHJlY2F0ZWQgaW4gMS40IHJlbW92ZSBpbiAxLjVcblx0XHRrZWVwTmF0aXZlRGVmYXVsdDogJC5tb2JpbGUua2VlcE5hdGl2ZSxcblxuXHRcdC8vIERlcHJlY2F0ZWQgaW4gMS40IHJlbW92ZSBpbiAxLjVcblx0XHRjb250ZW50VGhlbWU6IG51bGwsXG5cdFx0ZW5oYW5jZWQ6IGZhbHNlXG5cdH0sXG5cblx0Ly8gREVQUkVDQVRFRCBmb3IgPiAxLjRcblx0Ly8gVE9ETyByZW1vdmUgYXQgMS41XG5cdF9jcmVhdGVXaWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdCQuV2lkZ2V0LnByb3RvdHlwZS5fY3JlYXRlV2lkZ2V0LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR0aGlzLl90cmlnZ2VyKCBcImluaXRcIiApO1xuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIElmIGZhbHNlIGlzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja3MgZG8gbm90IGNyZWF0ZSB0aGUgcGFnZVxuXHRcdGlmICggdGhpcy5fdHJpZ2dlciggXCJiZWZvcmVjcmVhdGVcIiApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZW5oYW5jZWQgKSB7XG5cdFx0XHR0aGlzLl9lbmhhbmNlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fb24oIHRoaXMuZWxlbWVudCwge1xuXHRcdFx0cGFnZWJlZm9yZWhpZGU6IFwicmVtb3ZlQ29udGFpbmVyQmFja2dyb3VuZFwiLFxuXHRcdFx0cGFnZWJlZm9yZXNob3c6IFwiX2hhbmRsZVBhZ2VCZWZvcmVTaG93XCJcblx0XHR9KTtcblxuXHRcdHRoaXMuZWxlbWVudC5lbmhhbmNlV2l0aGluKCk7XG5cdFx0Ly8gRGlhbG9nIHdpZGdldCBpcyBkZXByZWNhdGVkIGluIDEuNCByZW1vdmUgdGhpcyBpbiAxLjVcblx0XHRpZiAoICQubW9iaWxlLmdldEF0dHJpYnV0ZSggdGhpcy5lbGVtZW50WzBdLCBcInJvbGVcIiApID09PSBcImRpYWxvZ1wiICYmICQubW9iaWxlLmRpYWxvZyApIHtcblx0XHRcdHRoaXMuZWxlbWVudC5kaWFsb2coKTtcblx0XHR9XG5cdH0sXG5cblx0X2VuaGFuY2U6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXR0clByZWZpeCA9IFwiZGF0YS1cIiArICQubW9iaWxlLm5zLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5yb2xlICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LmF0dHIoIFwiZGF0YS1cIiArICQubW9iaWxlLm5zICsgXCJyb2xlXCIsIHRoaXMub3B0aW9ucy5yb2xlICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQuYXR0ciggXCJ0YWJpbmRleFwiLCBcIjBcIiApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktcGFnZSB1aS1wYWdlLXRoZW1lLVwiICsgdGhpcy5vcHRpb25zLnRoZW1lICk7XG5cblx0XHQvLyBNYW5pcHVsYXRpb24gb2YgY29udGVudCBvcyBEZXByZWNhdGVkIGFzIG9mIDEuNCByZW1vdmUgaW4gMS41XG5cdFx0dGhpcy5lbGVtZW50LmZpbmQoIFwiW1wiICsgYXR0clByZWZpeCArIFwicm9sZT0nY29udGVudCddXCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciAkdGhpcyA9ICQoIHRoaXMgKSxcblx0XHRcdFx0dGhlbWUgPSB0aGlzLmdldEF0dHJpYnV0ZSggYXR0clByZWZpeCArIFwidGhlbWVcIiApIHx8IHVuZGVmaW5lZDtcblx0XHRcdFx0c2VsZi5vcHRpb25zLmNvbnRlbnRUaGVtZSA9IHRoZW1lIHx8IHNlbGYub3B0aW9ucy5jb250ZW50VGhlbWUgfHwgKCBzZWxmLm9wdGlvbnMuZGlhbG9nICYmIHNlbGYub3B0aW9ucy50aGVtZSApIHx8ICggc2VsZi5lbGVtZW50LmpxbURhdGEoXCJyb2xlXCIpID09PSBcImRpYWxvZ1wiICYmICBzZWxmLm9wdGlvbnMudGhlbWUgKTtcblx0XHRcdFx0JHRoaXMuYWRkQ2xhc3MoIFwidWktY29udGVudFwiICk7XG5cdFx0XHRcdGlmICggc2VsZi5vcHRpb25zLmNvbnRlbnRUaGVtZSApIHtcblx0XHRcdFx0XHQkdGhpcy5hZGRDbGFzcyggXCJ1aS1ib2R5LVwiICsgKCBzZWxmLm9wdGlvbnMuY29udGVudFRoZW1lICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBBZGQgQVJJQSByb2xlXG5cdFx0XHRcdCR0aGlzLmF0dHIoIFwicm9sZVwiLCBcIm1haW5cIiApLmFkZENsYXNzKCBcInVpLWNvbnRlbnRcIiApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGJpbmRSZW1vdmU6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHR2YXIgcGFnZSA9IHRoaXMuZWxlbWVudDtcblxuXHRcdC8vIHdoZW4gZG9tIGNhY2hpbmcgaXMgbm90IGVuYWJsZWQgb3IgdGhlIHBhZ2UgaXMgZW1iZWRkZWQgYmluZCB0byByZW1vdmUgdGhlIHBhZ2Ugb24gaGlkZVxuXHRcdGlmICggIXBhZ2UuZGF0YSggXCJtb2JpbGUtcGFnZVwiICkub3B0aW9ucy5kb21DYWNoZSAmJlxuXHRcdFx0cGFnZS5pcyggXCI6anFtRGF0YShleHRlcm5hbC1wYWdlPSd0cnVlJylcIiApICkge1xuXG5cdFx0XHQvLyBUT0RPIHVzZSBfb24gLSB0aGF0IGlzLCBzb3J0IG91dCB3aHkgaXQgZG9lc24ndCB3b3JrIGluIHRoaXMgY2FzZVxuXHRcdFx0cGFnZS5iaW5kKCBcInBhZ2VoaWRlLnJlbW92ZVwiLCBjYWxsYmFjayB8fCBmdW5jdGlvbiggZSwgZGF0YSApIHtcblxuXHRcdFx0XHQvL2NoZWNrIGlmIHRoaXMgaXMgYSBzYW1lIHBhZ2UgdHJhbnNpdGlvbiBhbmQgaWYgc28gZG9uJ3QgcmVtb3ZlIHRoZSBwYWdlXG5cdFx0XHRcdGlmKCAhZGF0YS5zYW1lUGFnZSApe1xuXHRcdFx0XHRcdHZhciAkdGhpcyA9ICQoIHRoaXMgKSxcblx0XHRcdFx0XHRcdHByRXZlbnQgPSBuZXcgJC5FdmVudCggXCJwYWdlcmVtb3ZlXCIgKTtcblxuXHRcdFx0XHRcdCR0aGlzLnRyaWdnZXIoIHByRXZlbnQgKTtcblxuXHRcdFx0XHRcdGlmICggIXByRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRcdFx0XHQkdGhpcy5yZW1vdmVXaXRoRGVwZW5kZW50cygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggbyApIHtcblx0XHRpZiAoIG8udGhlbWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyggXCJ1aS1wYWdlLXRoZW1lLVwiICsgdGhpcy5vcHRpb25zLnRoZW1lICkuYWRkQ2xhc3MoIFwidWktcGFnZS10aGVtZS1cIiArIG8udGhlbWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIG8uY29udGVudFRoZW1lICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCggXCJbZGF0YS1cIiArICQubW9iaWxlLm5zICsgXCI9J2NvbnRlbnQnXVwiICkucmVtb3ZlQ2xhc3MoIFwidWktYm9keS1cIiArIHRoaXMub3B0aW9ucy5jb250ZW50VGhlbWUgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktYm9keS1cIiArIG8uY29udGVudFRoZW1lICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVQYWdlQmVmb3JlU2hvdzogZnVuY3Rpb24oLyogZSAqLykge1xuXHRcdHRoaXMuc2V0Q29udGFpbmVyQmFja2dyb3VuZCgpO1xuXHR9LFxuXHQvLyBEZXByZWNhdGVkIGluIDEuNCByZW1vdmUgaW4gMS41XG5cdHJlbW92ZUNvbnRhaW5lckJhY2tncm91bmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudC5jbG9zZXN0KCBcIjptb2JpbGUtcGFnZWNvbnRhaW5lclwiICkucGFnZWNvbnRhaW5lcih7IFwidGhlbWVcIjogXCJub25lXCIgfSk7XG5cdH0sXG5cdC8vIERlcHJlY2F0ZWQgaW4gMS40IHJlbW92ZSBpbiAxLjVcblx0Ly8gc2V0IHRoZSBwYWdlIGNvbnRhaW5lciBiYWNrZ3JvdW5kIHRvIHRoZSBwYWdlIHRoZW1lXG5cdHNldENvbnRhaW5lckJhY2tncm91bmQ6IGZ1bmN0aW9uKCB0aGVtZSApIHtcblx0XHR0aGlzLmVsZW1lbnQucGFyZW50KCkucGFnZWNvbnRhaW5lciggeyBcInRoZW1lXCI6IHRoZW1lIHx8IHRoaXMub3B0aW9ucy50aGVtZSB9ICk7XG5cdH0sXG5cdC8vIERlcHJlY2F0ZWQgaW4gMS40IHJlbW92ZSBpbiAxLjVcblx0a2VlcE5hdGl2ZVNlbGVjdG9yOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGtlZXBOYXRpdmUgPSAkLnRyaW0oIG9wdGlvbnMua2VlcE5hdGl2ZSB8fCBcIlwiICksXG5cdFx0XHRnbG9iYWxWYWx1ZSA9ICQudHJpbSggJC5tb2JpbGUua2VlcE5hdGl2ZSApLFxuXHRcdFx0b3B0aW9uVmFsdWUgPSAkLnRyaW0oIG9wdGlvbnMua2VlcE5hdGl2ZURlZmF1bHQgKSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgJC5tb2JpbGUua2VlcE5hdGl2ZSBoYXMgY2hhbmdlZCBmcm9tIHRoZSBmYWN0b3J5IGRlZmF1bHRcblx0XHRcdG5ld0RlZmF1bHQgPSAoIGtlZXBOYXRpdmVGYWN0b3J5RGVmYXVsdCA9PT0gZ2xvYmFsVmFsdWUgP1xuXHRcdFx0XHRcIlwiIDogZ2xvYmFsVmFsdWUgKSxcblxuXHRcdFx0Ly8gSWYgJC5tb2JpbGUua2VlcE5hdGl2ZSBoYXMgbm90IGNoYW5nZWQsIHVzZSBvcHRpb25zLmtlZXBOYXRpdmVEZWZhdWx0XG5cdFx0XHRvbGREZWZhdWx0ID0gKCBuZXdEZWZhdWx0ID09PSBcIlwiID8gb3B0aW9uVmFsdWUgOiBcIlwiICk7XG5cblx0XHQvLyBDb25jYXRlbmF0ZSBrZWVwTmF0aXZlIHNlbGVjdG9ycyBmcm9tIGFsbCBzb3VyY2VzIHdoZXJlIHRoZSB2YWx1ZSBoYXNcblx0XHQvLyBjaGFuZ2VkIG9yLCBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCByZXR1cm4gdGhlIGRlZmF1bHRcblx0XHRyZXR1cm4gKCAoIGtlZXBOYXRpdmUgPyBbIGtlZXBOYXRpdmUgXSA6IFtdIClcblx0XHRcdC5jb25jYXQoIG5ld0RlZmF1bHQgPyBbIG5ld0RlZmF1bHQgXSA6IFtdIClcblx0XHRcdC5jb25jYXQoIG9sZERlZmF1bHQgPyBbIG9sZERlZmF1bHQgXSA6IFtdIClcblx0XHRcdC5qb2luKCBcIiwgXCIgKSApO1xuXHR9XG59KTtcbn0pKCBqUXVlcnkgKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cblx0JC53aWRnZXQoIFwibW9iaWxlLnBhZ2Vjb250YWluZXJcIiwge1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdHRoZW1lOiBcImFcIlxuXHRcdH0sXG5cblx0XHRpbml0U2VsZWN0b3I6IGZhbHNlLFxuXG5cdFx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCBcImJlZm9yZWNyZWF0ZVwiICk7XG5cdFx0XHR0aGlzLnNldExhc3RTY3JvbGxFbmFibGVkID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy5fb24oIHRoaXMud2luZG93LCB7XG5cdFx0XHRcdC8vIGRpc2FibGUgYW4gc2Nyb2xsIHNldHRpbmcgd2hlbiBhIGhhc2hjaGFuZ2UgaGFzIGJlZW4gZmlyZWQsXG5cdFx0XHRcdC8vIHRoaXMgb25seSB3b3JrcyBiZWNhdXNlIHRoZSByZWNvcmRpbmcgb2YgdGhlIHNjcm9sbCBwb3NpdGlvblxuXHRcdFx0XHQvLyBpcyBkZWxheWVkIGZvciAxMDBtcyBhZnRlciB0aGUgYnJvd3NlciBtaWdodCBoYXZlIGNoYW5nZWQgdGhlXG5cdFx0XHRcdC8vIHBvc2l0aW9uIGJlY2F1c2Ugb2YgdGhlIGhhc2hjaGFuZ2Vcblx0XHRcdFx0bmF2aWdhdGU6IFwiX2Rpc2FibGVSZWNvcmRTY3JvbGxcIixcblxuXHRcdFx0XHQvLyBiaW5kIHRvIHNjcm9sbHN0b3AgZm9yIHRoZSBmaXJzdCBwYWdlLCBcInBhZ2VjaGFuZ2VcIiB3b24ndCBiZVxuXHRcdFx0XHQvLyBmaXJlZCBpbiB0aGF0IGNhc2Vcblx0XHRcdFx0c2Nyb2xsc3RvcDogXCJfZGVsYXllZFJlY29yZFNjcm9sbFwiXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gVE9ETyBjb25zaWRlciBtb3ZpbmcgdGhlIG5hdmlnYXRpb24gaGFuZGxlciBPVVQgb2Ygd2lkZ2V0IGludG9cblx0XHRcdC8vICAgICAgc29tZSBvdGhlciBvYmplY3QgYXMgZ2x1ZSBiZXR3ZWVuIHRoZSBuYXZpZ2F0ZSBldmVudCBhbmQgdGhlXG5cdFx0XHQvLyAgICAgIGNvbnRlbnQgd2lkZ2V0IGxvYWQgYW5kIGNoYW5nZSBtZXRob2RzXG5cdFx0XHR0aGlzLl9vbiggdGhpcy53aW5kb3csIHsgbmF2aWdhdGU6IFwiX2ZpbHRlck5hdmlnYXRlRXZlbnRzXCIgfSk7XG5cblx0XHRcdC8vIFRPRE8gbW92ZSBmcm9tIHBhZ2UqIGV2ZW50cyB0byBjb250ZW50KiBldmVudHNcblx0XHRcdHRoaXMuX29uKHsgcGFnZWNoYW5nZTogXCJfYWZ0ZXJDb250ZW50Q2hhbmdlXCIgfSk7XG5cblx0XHRcdC8vIGhhbmRsZSBpbml0aWFsIGhhc2hjaGFuZ2UgZnJvbSBjaHJvbWUgOihcblx0XHRcdHRoaXMud2luZG93Lm9uZSggXCJuYXZpZ2F0ZVwiLCAkLnByb3h5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnNldExhc3RTY3JvbGxFbmFibGVkID0gdHJ1ZTtcblx0XHRcdH0sIHRoaXMpKTtcblx0XHR9LFxuXG5cdFx0X3NldE9wdGlvbnM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0aWYgKCBvcHRpb25zLnRoZW1lICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50aGVtZSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyggXCJ1aS1vdmVybGF5LVwiICsgdGhpcy5vcHRpb25zLnRoZW1lIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktb3ZlcmxheS1cIiArIG9wdGlvbnMudGhlbWUgKTtcblx0XHRcdH0gZWxzZSBpZiAoIG9wdGlvbnMudGhlbWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCBcInVpLW92ZXJsYXktXCIgKyB0aGlzLm9wdGlvbnMudGhlbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc3VwZXIoIG9wdGlvbnMgKTtcblx0XHR9LFxuXG5cdFx0X2Rpc2FibGVSZWNvcmRTY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zZXRMYXN0U2Nyb2xsRW5hYmxlZCA9IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRfZW5hYmxlUmVjb3JkU2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuc2V0TGFzdFNjcm9sbEVuYWJsZWQgPSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBUT0RPIGNvbnNpZGVyIHRoZSBuYW1lIGhlcmUsIHNpbmNlIGl0J3MgcHVycG9zZSBzcGVjaWZpY1xuXHRcdF9hZnRlckNvbnRlbnRDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gb25jZSB0aGUgcGFnZSBoYXMgY2hhbmdlZCwgcmUtZW5hYmxlIHRoZSBzY3JvbGwgcmVjb3JkaW5nXG5cdFx0XHR0aGlzLnNldExhc3RTY3JvbGxFbmFibGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gcmVtb3ZlIGFueSBiaW5kaW5nIHRoYXQgcHJldmlvdXNseSBleGlzdGVkIG9uIHRoZSBnZXQgc2Nyb2xsXG5cdFx0XHQvLyB3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSBkaWZmZXJlbnQgdGhhbiB0aGUgc2Nyb2xsIGVsZW1lbnRcblx0XHRcdC8vIGRldGVybWluZWQgZm9yIHRoaXMgcGFnZSBwcmV2aW91c2x5XG5cdFx0XHR0aGlzLl9vZmYoIHRoaXMud2luZG93LCBcInNjcm9sbHN0b3BcIiApO1xuXG5cdFx0XHQvLyBkZXRlcm1pbmUgYW5kIGJpbmQgdG8gdGhlIGN1cnJlbnQgc2NvbGwgZWxlbWVudCB3aGljaCBtYXkgYmUgdGhlXG5cdFx0XHQvLyB3aW5kb3cgb3IgaW4gdGhlIGNhc2Ugb2YgdG91Y2ggb3ZlcmZsb3cgdGhlIGVsZW1lbnQgdG91Y2ggb3ZlcmZsb3dcblx0XHRcdHRoaXMuX29uKCB0aGlzLndpbmRvdywgeyBzY3JvbGxzdG9wOiBcIl9kZWxheWVkUmVjb3JkU2Nyb2xsXCIgfSk7XG5cdFx0fSxcblxuXHRcdF9yZWNvcmRTY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gdGhpcyBiYXJyaWVyIHByZXZlbnRzIHNldHRpbmcgdGhlIHNjcm9sbCB2YWx1ZSBiYXNlZCBvblxuXHRcdFx0Ly8gdGhlIGJyb3dzZXIgc2Nyb2xsaW5nIHRoZSB3aW5kb3cgYmFzZWQgb24gYSBoYXNoY2hhbmdlXG5cdFx0XHRpZiAoICF0aGlzLnNldExhc3RTY3JvbGxFbmFibGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVIaXN0b3J5KCksXG5cdFx0XHRcdGN1cnJlbnRTY3JvbGwsIG1pblNjcm9sbCwgZGVmYXVsdFNjcm9sbDtcblxuXHRcdFx0aWYgKCBhY3RpdmUgKSB7XG5cdFx0XHRcdGN1cnJlbnRTY3JvbGwgPSB0aGlzLl9nZXRTY3JvbGwoKTtcblx0XHRcdFx0bWluU2Nyb2xsID0gdGhpcy5fZ2V0TWluU2Nyb2xsKCk7XG5cdFx0XHRcdGRlZmF1bHRTY3JvbGwgPSB0aGlzLl9nZXREZWZhdWx0U2Nyb2xsKCk7XG5cblx0XHRcdFx0Ly8gU2V0IGFjdGl2ZSBwYWdlJ3MgbGFzdFNjcm9sbCBwcm9wLiBJZiB0aGUgbG9jYXRpb24gd2UncmVcblx0XHRcdFx0Ly8gc2Nyb2xsaW5nIHRvIGlzIGxlc3MgdGhhbiBtaW5TY3JvbGxCYWNrLCBsZXQgaXQgZ28uXG5cdFx0XHRcdGFjdGl2ZS5sYXN0U2Nyb2xsID0gY3VycmVudFNjcm9sbCA8IG1pblNjcm9sbCA/IGRlZmF1bHRTY3JvbGwgOiBjdXJyZW50U2Nyb2xsO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfZGVsYXllZFJlY29yZFNjcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRUaW1lb3V0KCAkLnByb3h5KHRoaXMsIFwiX3JlY29yZFNjcm9sbFwiKSwgMTAwICk7XG5cdFx0fSxcblxuXHRcdF9nZXRTY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMud2luZG93LnNjcm9sbFRvcCgpO1xuXHRcdH0sXG5cblx0XHRfZ2V0TWluU2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAkLm1vYmlsZS5taW5TY3JvbGxCYWNrO1xuXHRcdH0sXG5cblx0XHRfZ2V0RGVmYXVsdFNjcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gJC5tb2JpbGUuZGVmYXVsdEhvbWVTY3JvbGw7XG5cdFx0fSxcblxuXHRcdF9maWx0ZXJOYXZpZ2F0ZUV2ZW50czogZnVuY3Rpb24oIGUsIGRhdGEgKSB7XG5cdFx0XHR2YXIgdXJsO1xuXG5cdFx0XHRpZiAoIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXJsID0gZS5vcmlnaW5hbEV2ZW50LnR5cGUuaW5kZXhPZiggXCJoYXNoY2hhbmdlXCIgKSA+IC0xID8gZGF0YS5zdGF0ZS5oYXNoIDogZGF0YS5zdGF0ZS51cmw7XG5cblx0XHRcdGlmICggIXVybCApIHtcblx0XHRcdFx0dXJsID0gdGhpcy5fZ2V0SGFzaCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICF1cmwgfHwgdXJsID09PSBcIiNcIiB8fCB1cmwuaW5kZXhPZiggXCIjXCIgKyAkLm1vYmlsZS5wYXRoLnVpU3RhdGVLZXkgKSA9PT0gMCApIHtcblx0XHRcdFx0dXJsID0gbG9jYXRpb24uaHJlZjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5faGFuZGxlTmF2aWdhdGUoIHVybCwgZGF0YS5zdGF0ZSApO1xuXHRcdH0sXG5cblx0XHRfZ2V0SGFzaDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gJC5tb2JpbGUucGF0aC5wYXJzZUxvY2F0aW9uKCkuaGFzaDtcblx0XHR9LFxuXG5cdFx0Ly8gVE9ETyBhY3RpdmUgcGFnZSBzaG91bGQgYmUgbWFuYWdlZCBieSB0aGUgY29udGFpbmVyIChpZSwgaXQgc2hvdWxkIGJlIGEgcHJvcGVydHkpXG5cdFx0Z2V0QWN0aXZlUGFnZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hY3RpdmVQYWdlO1xuXHRcdH0sXG5cblx0XHQvLyBUT0RPIHRoZSBmaXJzdCBwYWdlIHNob3VsZCBiZSBhIHByb3BlcnR5IHNldCBkdXJpbmcgX2NyZWF0ZSB1c2luZyB0aGUgbG9naWNcblx0XHQvLyAgICAgIHRoYXQgY3VycmVudGx5IHJlc2lkZXMgaW4gaW5pdFxuXHRcdF9nZXRJbml0aWFsQ29udGVudDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gJC5tb2JpbGUuZmlyc3RQYWdlO1xuXHRcdH0sXG5cblx0XHQvLyBUT0RPIGVhY2ggY29udGVudCBjb250YWluZXIgc2hvdWxkIGhhdmUgYSBoaXN0b3J5IG9iamVjdFxuXHRcdF9nZXRIaXN0b3J5OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAkLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5O1xuXHRcdH0sXG5cblx0XHQvLyBUT0RPIHVzZSBfZ2V0SGlzdG9yeVxuXHRcdF9nZXRBY3RpdmVIaXN0b3J5OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAkLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5LmdldEFjdGl2ZSgpO1xuXHRcdH0sXG5cblx0XHQvLyBUT0RPIHRoZSBkb2N1bWVudCBiYXNlIHNob3VsZCBiZSBkZXRlcm1pbmVkIGF0IGNyZWF0aW9uXG5cdFx0X2dldERvY3VtZW50QmFzZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gJC5tb2JpbGUucGF0aC5kb2N1bWVudEJhc2U7XG5cdFx0fSxcblxuXHRcdGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5nbyggLTEgKTtcblx0XHR9LFxuXG5cdFx0Zm9yd2FyZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmdvKCAxICk7XG5cdFx0fSxcblxuXHRcdGdvOiBmdW5jdGlvbiggc3RlcHMgKSB7XG5cblx0XHRcdC8vaWYgaGFzaGxpc3RlbmluZyBpcyBlbmFibGVkIHVzZSBuYXRpdmUgaGlzdG9yeSBtZXRob2Rcblx0XHRcdGlmICggJC5tb2JpbGUuaGFzaExpc3RlbmluZ0VuYWJsZWQgKSB7XG5cdFx0XHRcdHdpbmRvdy5oaXN0b3J5LmdvKCBzdGVwcyApO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvL3dlIGFyZSBub3QgbGlzdGVuaW5nIHRvIHRoZSBoYXNoIHNvIGhhbmRsZSBoaXN0b3J5IGludGVybmFsbHlcblx0XHRcdFx0dmFyIGFjdGl2ZUluZGV4ID0gJC5tb2JpbGUubmF2aWdhdGUuaGlzdG9yeS5hY3RpdmVJbmRleCxcblx0XHRcdFx0XHRpbmRleCA9IGFjdGl2ZUluZGV4ICsgcGFyc2VJbnQoIHN0ZXBzLCAxMCApLFxuXHRcdFx0XHRcdHVybCA9ICQubW9iaWxlLm5hdmlnYXRlLmhpc3Rvcnkuc3RhY2tbIGluZGV4IF0udXJsLFxuXHRcdFx0XHRcdGRpcmVjdGlvbiA9ICggc3RlcHMgPj0gMSApPyBcImZvcndhcmRcIiA6IFwiYmFja1wiO1xuXG5cdFx0XHRcdC8vdXBkYXRlIHRoZSBoaXN0b3J5IG9iamVjdFxuXHRcdFx0XHQkLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5LmFjdGl2ZUluZGV4ID0gaW5kZXg7XG5cdFx0XHRcdCQubW9iaWxlLm5hdmlnYXRlLmhpc3RvcnkucHJldmlvdXNJbmRleCA9IGFjdGl2ZUluZGV4O1xuXG5cdFx0XHRcdC8vY2hhbmdlIHRvIHRoZSBuZXcgcGFnZVxuXHRcdFx0XHR0aGlzLmNoYW5nZSggdXJsLCB7IGRpcmVjdGlvbjogZGlyZWN0aW9uLCBjaGFuZ2VIYXNoOiBmYWxzZSwgZnJvbUhhc2hDaGFuZ2U6IHRydWUgfSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBUT0RPIHJlbmFtZSBfaGFuZGxlRGVzdGluYXRpb25cblx0XHRfaGFuZGxlRGVzdGluYXRpb246IGZ1bmN0aW9uKCB0byApIHtcblx0XHRcdHZhciBoaXN0b3J5O1xuXG5cdFx0XHQvLyBjbGVhbiB0aGUgaGFzaCBmb3IgY29tcGFyaXNvbiBpZiBpdCdzIGEgdXJsXG5cdFx0XHRpZiAoICQudHlwZSh0bykgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHRvID0gJC5tb2JpbGUucGF0aC5zdHJpcEhhc2goIHRvICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdG8gKSB7XG5cdFx0XHRcdGhpc3RvcnkgPSB0aGlzLl9nZXRIaXN0b3J5KCk7XG5cblx0XHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgJ3RvJyBjYW4gYmUgb25lIG9mIDMgdGhpbmdzLCBhIGNhY2hlZCBwYWdlXG5cdFx0XHRcdC8vIGVsZW1lbnQgZnJvbSBhIGhpc3Rvcnkgc3RhY2sgZW50cnksIGFuIGlkLCBvciBzaXRlLXJlbGF0aXZlIC9cblx0XHRcdFx0Ly8gYWJzb2x1dGUgVVJMLiBJZiAndG8nIGlzIGFuIGlkLCB3ZSBuZWVkIHRvIHJlc29sdmUgaXQgYWdhaW5zdFxuXHRcdFx0XHQvLyB0aGUgZG9jdW1lbnRCYXNlLCBub3QgdGhlIGxvY2F0aW9uLmhyZWYsIHNpbmNlIHRoZSBoYXNoY2hhbmdlXG5cdFx0XHRcdC8vIGNvdWxkJ3ZlIGJlZW4gdGhlIHJlc3VsdCBvZiBhIGZvcndhcmQvYmFja3dhcmQgbmF2aWdhdGlvblxuXHRcdFx0XHQvLyB0aGF0IGNyb3NzZXMgZnJvbSBhbiBleHRlcm5hbCBwYWdlL2RpYWxvZyB0byBhbiBpbnRlcm5hbFxuXHRcdFx0XHQvLyBwYWdlL2RpYWxvZy5cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gVE9ETyBtb3ZlIGNoZWNrIHRvIGhpc3Rvcnkgb2JqZWN0IG9yIHBhdGggb2JqZWN0P1xuXHRcdFx0XHR0byA9ICEkLm1vYmlsZS5wYXRoLmlzUGF0aCggdG8gKSA/ICggJC5tb2JpbGUucGF0aC5tYWtlVXJsQWJzb2x1dGUoIFwiI1wiICsgdG8sIHRoaXMuX2dldERvY3VtZW50QmFzZSgpICkgKSA6IHRvO1xuXG5cdFx0XHRcdC8vIElmIHdlJ3JlIGFib3V0IHRvIGdvIHRvIGFuIGluaXRpYWwgVVJMIHRoYXQgY29udGFpbnMgYVxuXHRcdFx0XHQvLyByZWZlcmVuY2UgdG8gYSBub24tZXhpc3RlbnQgaW50ZXJuYWwgcGFnZSwgZ28gdG8gdGhlIGZpcnN0XG5cdFx0XHRcdC8vIHBhZ2UgaW5zdGVhZC4gV2Uga25vdyB0aGF0IHRoZSBpbml0aWFsIGhhc2ggcmVmZXJzIHRvIGFcblx0XHRcdFx0Ly8gbm9uLWV4aXN0ZW50IHBhZ2UsIGJlY2F1c2UgdGhlIGluaXRpYWwgaGFzaCBkaWQgbm90IGVuZFxuXHRcdFx0XHQvLyB1cCBpbiB0aGUgaW5pdGlhbCBoaXN0b3J5IGVudHJ5XG5cdFx0XHRcdC8vIFRPRE8gbW92ZSBjaGVjayB0byBoaXN0b3J5IG9iamVjdD9cblx0XHRcdFx0aWYgKCB0byA9PT0gJC5tb2JpbGUucGF0aC5tYWtlVXJsQWJzb2x1dGUoIFwiI1wiICsgaGlzdG9yeS5pbml0aWFsRHN0LCB0aGlzLl9nZXREb2N1bWVudEJhc2UoKSApICYmXG5cdFx0XHRcdFx0aGlzdG9yeS5zdGFjay5sZW5ndGggJiZcblx0XHRcdFx0XHRoaXN0b3J5LnN0YWNrWzBdLnVybCAhPT0gaGlzdG9yeS5pbml0aWFsRHN0LnJlcGxhY2UoICQubW9iaWxlLmRpYWxvZ0hhc2hLZXksIFwiXCIgKSApIHtcblx0XHRcdFx0XHR0byA9IHRoaXMuX2dldEluaXRpYWxDb250ZW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0byB8fCB0aGlzLl9nZXRJbml0aWFsQ29udGVudCgpO1xuXHRcdH0sXG5cblx0XHRfaGFuZGxlRGlhbG9nOiBmdW5jdGlvbiggY2hhbmdlUGFnZU9wdGlvbnMsIGRhdGEgKSB7XG5cdFx0XHR2YXIgdG8sIGFjdGl2ZSwgYWN0aXZlQ29udGVudCA9IHRoaXMuZ2V0QWN0aXZlUGFnZSgpO1xuXG5cdFx0XHQvLyBJZiBjdXJyZW50IGFjdGl2ZSBwYWdlIGlzIG5vdCBhIGRpYWxvZyBza2lwIHRoZSBkaWFsb2cgYW5kIGNvbnRpbnVlXG5cdFx0XHQvLyBpbiB0aGUgc2FtZSBkaXJlY3Rpb25cblx0XHRcdGlmICggYWN0aXZlQ29udGVudCAmJiAhYWN0aXZlQ29udGVudC5oYXNDbGFzcyggXCJ1aS1kaWFsb2dcIiApICkge1xuXHRcdFx0XHQvLyBkZXRlcm1pbmUgaWYgd2UncmUgaGVhZGluZyBmb3J3YXJkIG9yIGJhY2t3YXJkIGFuZCBjb250aW51ZVxuXHRcdFx0XHQvLyBhY2NvcmRpbmdseSBwYXN0IHRoZSBjdXJyZW50IGRpYWxvZ1xuXHRcdFx0XHRpZiAoIGRhdGEuZGlyZWN0aW9uID09PSBcImJhY2tcIiApIHtcblx0XHRcdFx0XHR0aGlzLmJhY2soKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmZvcndhcmQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHByZXZlbnQgY2hhbmdlUGFnZSBjYWxsXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGlmIHRoZSBjdXJyZW50IGFjdGl2ZSBwYWdlIGlzIGEgZGlhbG9nIGFuZCB3ZSdyZSBuYXZpZ2F0aW5nXG5cdFx0XHRcdC8vIHRvIGEgZGlhbG9nIHVzZSB0aGUgZGlhbG9nIG9iamVjdGVkIHNhdmVkIGluIHRoZSBzdGFja1xuXHRcdFx0XHR0byA9IGRhdGEucGFnZVVybDtcblx0XHRcdFx0YWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlSGlzdG9yeSgpO1xuXG5cdFx0XHRcdC8vIG1ha2Ugc3VyZSB0byBzZXQgdGhlIHJvbGUsIHRyYW5zaXRpb24gYW5kIHJldmVyc2FsXG5cdFx0XHRcdC8vIGFzIG1vc3Qgb2YgdGhpcyBpcyBsb3N0IGJ5IHRoZSBkb21DYWNoZSBjbGVhbmluZ1xuXHRcdFx0XHQkLmV4dGVuZCggY2hhbmdlUGFnZU9wdGlvbnMsIHtcblx0XHRcdFx0XHRyb2xlOiBhY3RpdmUucm9sZSxcblx0XHRcdFx0XHR0cmFuc2l0aW9uOiBhY3RpdmUudHJhbnNpdGlvbixcblx0XHRcdFx0XHRyZXZlcnNlOiBkYXRhLmRpcmVjdGlvbiA9PT0gXCJiYWNrXCJcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0bztcblx0XHR9LFxuXG5cdFx0X2hhbmRsZU5hdmlnYXRlOiBmdW5jdGlvbiggdXJsLCBkYXRhICkge1xuXHRcdFx0Ly9maW5kIGZpcnN0IHBhZ2UgdmlhIGhhc2hcblx0XHRcdC8vIFRPRE8gc3RyaXBwaW5nIHRoZSBoYXNoIHR3aWNlIHdpdGggaGFuZGxlVXJsXG5cdFx0XHR2YXIgdG8gPSAkLm1vYmlsZS5wYXRoLnN0cmlwSGFzaCggdXJsICksIGhpc3RvcnkgPSB0aGlzLl9nZXRIaXN0b3J5KCksXG5cblx0XHRcdFx0Ly8gdHJhbnNpdGlvbiBpcyBmYWxzZSBpZiBpdCdzIHRoZSBmaXJzdCBwYWdlLCB1bmRlZmluZWRcblx0XHRcdFx0Ly8gb3RoZXJ3aXNlIChhbmQgbWF5IGJlIG92ZXJyaWRkZW4gYnkgZGVmYXVsdClcblx0XHRcdFx0dHJhbnNpdGlvbiA9IGhpc3Rvcnkuc3RhY2subGVuZ3RoID09PSAwID8gXCJub25lXCIgOiB1bmRlZmluZWQsXG5cblx0XHRcdFx0Ly8gZGVmYXVsdCBvcHRpb25zIGZvciB0aGUgY2hhbmdQYWdlIGNhbGxzIG1hZGUgYWZ0ZXIgZXhhbWluaW5nXG5cdFx0XHRcdC8vIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBwYWdlIGFuZCB0aGUgaGFzaCwgTk9URSB0aGF0IHRoZVxuXHRcdFx0XHQvLyB0cmFuc2l0aW9uIGlzIGRlcml2ZWQgZnJvbSB0aGUgcHJldmlvdXMgaGlzdG9yeSBlbnRyeVxuXHRcdFx0XHRjaGFuZ2VQYWdlT3B0aW9ucyA9IHtcblx0XHRcdFx0XHRjaGFuZ2VIYXNoOiBmYWxzZSxcblx0XHRcdFx0XHRmcm9tSGFzaENoYW5nZTogdHJ1ZSxcblx0XHRcdFx0XHRyZXZlcnNlOiBkYXRhLmRpcmVjdGlvbiA9PT0gXCJiYWNrXCJcblx0XHRcdFx0fTtcblxuXHRcdFx0JC5leHRlbmQoIGNoYW5nZVBhZ2VPcHRpb25zLCBkYXRhLCB7XG5cdFx0XHRcdHRyYW5zaXRpb246ICggaGlzdG9yeS5nZXRMYXN0KCkgfHwge30gKS50cmFuc2l0aW9uIHx8IHRyYW5zaXRpb25cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBUT0RPIG1vdmUgdG8gX2hhbmRsZURlc3RpbmF0aW9uID9cblx0XHRcdC8vIElmIHRoaXMgaXNuJ3QgdGhlIGZpcnN0IHBhZ2UsIGlmIHRoZSBjdXJyZW50IHVybCBpcyBhIGRpYWxvZyBoYXNoXG5cdFx0XHQvLyBrZXksIGFuZCB0aGUgaW5pdGlhbCBkZXN0aW5hdGlvbiBpc24ndCBlcXVhbCB0byB0aGUgY3VycmVudCB0YXJnZXRcblx0XHRcdC8vIHBhZ2UsIHVzZSB0aGUgc3BlY2lhbCBkaWFsb2cgaGFuZGxpbmdcblx0XHRcdGlmICggaGlzdG9yeS5hY3RpdmVJbmRleCA+IDAgJiZcblx0XHRcdFx0dG8uaW5kZXhPZiggJC5tb2JpbGUuZGlhbG9nSGFzaEtleSApID4gLTEgJiZcblx0XHRcdFx0aGlzdG9yeS5pbml0aWFsRHN0ICE9PSB0byApIHtcblxuXHRcdFx0XHR0byA9IHRoaXMuX2hhbmRsZURpYWxvZyggY2hhbmdlUGFnZU9wdGlvbnMsIGRhdGEgKTtcblxuXHRcdFx0XHRpZiAoIHRvID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fY2hhbmdlQ29udGVudCggdGhpcy5faGFuZGxlRGVzdGluYXRpb24oIHRvICksIGNoYW5nZVBhZ2VPcHRpb25zICk7XG5cdFx0fSxcblxuXHRcdF9jaGFuZ2VDb250ZW50OiBmdW5jdGlvbiggdG8sIG9wdHMgKSB7XG5cdFx0XHQkLm1vYmlsZS5jaGFuZ2VQYWdlKCB0bywgb3B0cyApO1xuXHRcdH0sXG5cblx0XHRfZ2V0QmFzZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gJC5tb2JpbGUuYmFzZTtcblx0XHR9LFxuXG5cdFx0X2dldE5zOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAkLm1vYmlsZS5ucztcblx0XHR9LFxuXG5cdFx0X2VuaGFuY2U6IGZ1bmN0aW9uKCBjb250ZW50LCByb2xlICkge1xuXHRcdFx0Ly8gVE9ETyBjb25zaWRlciBzdXBwb3J0aW5nIGEgY3VzdG9tIGNhbGxiYWNrLCBhbmQgcGFzc2luZyBpblxuXHRcdFx0Ly8gdGhlIHNldHRpbmdzIHdoaWNoIGluY2x1ZGVzIHRoZSByb2xlXG5cdFx0XHRyZXR1cm4gY29udGVudC5wYWdlKHsgcm9sZTogcm9sZSB9KTtcblx0XHR9LFxuXG5cdFx0X2luY2x1ZGU6IGZ1bmN0aW9uKCBwYWdlLCBzZXR0aW5ncyApIHtcblx0XHRcdC8vIGFwcGVuZCB0byBwYWdlIGFuZCBlbmhhbmNlXG5cdFx0XHRwYWdlLmFwcGVuZFRvKCB0aGlzLmVsZW1lbnQgKTtcblxuXHRcdFx0Ly8gdXNlIHRoZSBwYWdlIHdpZGdldCB0byBlbmhhbmNlXG5cdFx0XHR0aGlzLl9lbmhhbmNlKCBwYWdlLCBzZXR0aW5ncy5yb2xlICk7XG5cblx0XHRcdC8vIHJlbW92ZSBwYWdlIG9uIGhpZGVcblx0XHRcdHBhZ2UucGFnZSggXCJiaW5kUmVtb3ZlXCIgKTtcblx0XHR9LFxuXG5cdFx0X2ZpbmQ6IGZ1bmN0aW9uKCBhYnNVcmwgKSB7XG5cdFx0XHQvLyBUT0RPIGNvbnNpZGVyIHN1cHBvcnRpbmcgYSBjdXN0b20gY2FsbGJhY2tcblx0XHRcdHZhciBmaWxlVXJsID0gdGhpcy5fY3JlYXRlRmlsZVVybCggYWJzVXJsICksXG5cdFx0XHRcdGRhdGFVcmwgPSB0aGlzLl9jcmVhdGVEYXRhVXJsKCBhYnNVcmwgKSxcblx0XHRcdFx0cGFnZSwgaW5pdGlhbENvbnRlbnQgPSB0aGlzLl9nZXRJbml0aWFsQ29udGVudCgpO1xuXG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgdGhlIHBhZ2UgYWxyZWFkeSBleGlzdHMgaW4gdGhlIERPTS5cblx0XHRcdC8vIE5PVEUgZG8gX25vdF8gdXNlIHRoZSA6anFtRGF0YSBwc2V1ZG8gc2VsZWN0b3IgYmVjYXVzZSBwYXJlbnRoZXNpc1xuXHRcdFx0Ly8gICAgICBhcmUgYSB2YWxpZCB1cmwgY2hhciBhbmQgaXQgYnJlYWtzIG9uIHRoZSBmaXJzdCBvY2N1cmVuY2Vcblx0XHRcdHBhZ2UgPSB0aGlzLmVsZW1lbnRcblx0XHRcdFx0LmNoaWxkcmVuKCBcIltkYXRhLVwiICsgdGhpcy5fZ2V0TnMoKSArXCJ1cmw9J1wiICsgZGF0YVVybCArIFwiJ11cIiApO1xuXG5cdFx0XHQvLyBJZiB3ZSBmYWlsZWQgdG8gZmluZCB0aGUgcGFnZSwgY2hlY2sgdG8gc2VlIGlmIHRoZSB1cmwgaXMgYVxuXHRcdFx0Ly8gcmVmZXJlbmNlIHRvIGFuIGVtYmVkZGVkIHBhZ2UuIElmIHNvLCBpdCBtYXkgaGF2ZSBiZWVuIGR5bmFtaWNhbGx5XG5cdFx0XHQvLyBpbmplY3RlZCBieSBhIGRldmVsb3BlciwgaW4gd2hpY2ggY2FzZSBpdCB3b3VsZCBiZSBsYWNraW5nIGFcblx0XHRcdC8vIGRhdGEtdXJsIGF0dHJpYnV0ZSBhbmQgaW4gbmVlZCBvZiBlbmhhbmNlbWVudC5cblx0XHRcdGlmICggcGFnZS5sZW5ndGggPT09IDAgJiYgZGF0YVVybCAmJiAhJC5tb2JpbGUucGF0aC5pc1BhdGgoIGRhdGFVcmwgKSApIHtcblx0XHRcdFx0cGFnZSA9IHRoaXMuZWxlbWVudC5jaGlsZHJlbiggJC5tb2JpbGUucGF0aC5oYXNoVG9TZWxlY3RvcihcIiNcIiArIGRhdGFVcmwpIClcblx0XHRcdFx0XHQuYXR0ciggXCJkYXRhLVwiICsgdGhpcy5fZ2V0TnMoKSArIFwidXJsXCIsIGRhdGFVcmwgKVxuXHRcdFx0XHRcdC5qcW1EYXRhKCBcInVybFwiLCBkYXRhVXJsICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHdlIGZhaWxlZCB0byBmaW5kIGEgcGFnZSBpbiB0aGUgRE9NLCBjaGVjayB0aGUgVVJMIHRvIHNlZSBpZiBpdFxuXHRcdFx0Ly8gcmVmZXJzIHRvIHRoZSBmaXJzdCBwYWdlIGluIHRoZSBhcHBsaWNhdGlvbi4gQWxzbyBjaGVjayB0byBtYWtlIHN1cmVcblx0XHRcdC8vIG91ciBjYWNoZWQtZmlyc3QtcGFnZSBpcyBhY3R1YWxseSBpbiB0aGUgRE9NLiBTb21lIHVzZXIgZGVwbG95ZWRcblx0XHRcdC8vIGFwcHMgYXJlIHBydW5pbmcgdGhlIGZpcnN0IHBhZ2UgZnJvbSB0aGUgRE9NIGZvciB2YXJpb3VzIHJlYXNvbnMuXG5cdFx0XHQvLyBXZSBjaGVjayBmb3IgdGhpcyBjYXNlIGhlcmUgYmVjYXVzZSB3ZSBkb24ndCB3YW50IGEgZmlyc3QtcGFnZSB3aXRoXG5cdFx0XHQvLyBhbiBpZCBmYWxsaW5nIHRocm91Z2ggdG8gdGhlIG5vbi1leGlzdGVudCBlbWJlZGRlZCBwYWdlIGVycm9yIGNhc2UuXG5cdFx0XHRpZiAoIHBhZ2UubGVuZ3RoID09PSAwICYmXG5cdFx0XHRcdCQubW9iaWxlLnBhdGguaXNGaXJzdFBhZ2VVcmwoIGZpbGVVcmwgKSAmJlxuXHRcdFx0XHRpbml0aWFsQ29udGVudCAmJlxuXHRcdFx0XHRpbml0aWFsQ29udGVudC5wYXJlbnQoKS5sZW5ndGggKSB7XG5cdFx0XHRcdHBhZ2UgPSAkKCBpbml0aWFsQ29udGVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcGFnZTtcblx0XHR9LFxuXG5cdFx0X2dldExvYWRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gJC5tb2JpbGUubG9hZGluZygpO1xuXHRcdH0sXG5cblx0XHRfc2hvd0xvYWRpbmc6IGZ1bmN0aW9uKCBkZWxheSwgdGhlbWUsIG1zZywgdGV4dG9ubHkgKSB7XG5cdFx0XHQvLyBUaGlzIGNvbmZpZ3VyYWJsZSB0aW1lb3V0IGFsbG93cyBjYWNoZWQgcGFnZXMgYSBicmllZlxuXHRcdFx0Ly8gZGVsYXkgdG8gbG9hZCB3aXRob3V0IHNob3dpbmcgYSBtZXNzYWdlXG5cdFx0XHRpZiAoIHRoaXMuX2xvYWRNc2cgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbG9hZE1zZyA9IHNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5fZ2V0TG9hZGVyKCkubG9hZGVyKCBcInNob3dcIiwgdGhlbWUsIG1zZywgdGV4dG9ubHkgKTtcblx0XHRcdFx0dGhpcy5fbG9hZE1zZyA9IDA7XG5cdFx0XHR9LCB0aGlzKSwgZGVsYXkgKTtcblx0XHR9LFxuXG5cdFx0X2hpZGVMb2FkaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIFN0b3AgbWVzc2FnZSBzaG93IHRpbWVyXG5cdFx0XHRjbGVhclRpbWVvdXQoIHRoaXMuX2xvYWRNc2cgKTtcblx0XHRcdHRoaXMuX2xvYWRNc2cgPSAwO1xuXG5cdFx0XHQvLyBIaWRlIGxvYWRpbmcgbWVzc2FnZVxuXHRcdFx0dGhpcy5fZ2V0TG9hZGVyKCkubG9hZGVyKCBcImhpZGVcIiApO1xuXHRcdH0sXG5cblx0XHRfc2hvd0Vycm9yOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIG1ha2Ugc3VyZSB0byByZW1vdmUgdGhlIGN1cnJlbnQgbG9hZGluZyBtZXNzYWdlXG5cdFx0XHR0aGlzLl9oaWRlTG9hZGluZygpO1xuXG5cdFx0XHQvLyBzaG93IHRoZSBlcnJvciBtZXNzYWdlXG5cdFx0XHR0aGlzLl9zaG93TG9hZGluZyggMCwgJC5tb2JpbGUucGFnZUxvYWRFcnJvck1lc3NhZ2VUaGVtZSwgJC5tb2JpbGUucGFnZUxvYWRFcnJvck1lc3NhZ2UsIHRydWUgKTtcblxuXHRcdFx0Ly8gaGlkZSB0aGUgZXJyb3IgbWVzc2FnZSBhZnRlciBhIGRlbGF5XG5cdFx0XHQvLyBUT0RPIGNvbmZpZ3VyYXRpb25cblx0XHRcdHNldFRpbWVvdXQoICQucHJveHkodGhpcywgXCJfaGlkZUxvYWRpbmdcIiksIDE1MDAgKTtcblx0XHR9LFxuXG5cdFx0X3BhcnNlOiBmdW5jdGlvbiggaHRtbCwgZmlsZVVybCApIHtcblx0XHRcdC8vIFRPRE8gY29uc2lkZXIgYWxsb3dpbmcgY3VzdG9taXphdGlvbiBvZiB0aGlzIG1ldGhvZC4gSXQncyB2ZXJ5IEpRTSBzcGVjaWZpY1xuXHRcdFx0dmFyIHBhZ2UsIGFsbCA9ICQoIFwiPGRpdj48L2Rpdj5cIiApO1xuXG5cdFx0XHQvL3dvcmthcm91bmQgdG8gYWxsb3cgc2NyaXB0cyB0byBleGVjdXRlIHdoZW4gaW5jbHVkZWQgaW4gcGFnZSBkaXZzXG5cdFx0XHRhbGwuZ2V0KCAwICkuaW5uZXJIVE1MID0gaHRtbDtcblxuXHRcdFx0cGFnZSA9IGFsbC5maW5kKCBcIjpqcW1EYXRhKHJvbGU9J3BhZ2UnKSwgOmpxbURhdGEocm9sZT0nZGlhbG9nJylcIiApLmZpcnN0KCk7XG5cblx0XHRcdC8vaWYgcGFnZSBlbGVtIGNvdWxkbid0IGJlIGZvdW5kLCBjcmVhdGUgb25lIGFuZCBpbnNlcnQgdGhlIGJvZHkgZWxlbWVudCdzIGNvbnRlbnRzXG5cdFx0XHRpZiAoICFwYWdlLmxlbmd0aCApIHtcblx0XHRcdFx0cGFnZSA9ICQoIFwiPGRpdiBkYXRhLVwiICsgdGhpcy5fZ2V0TnMoKSArIFwicm9sZT0ncGFnZSc+XCIgK1xuXHRcdFx0XHRcdCggaHRtbC5zcGxpdCggLzxcXC8/Ym9keVtePl0qPi9nbWkgKVsxXSB8fCBcIlwiICkgK1xuXHRcdFx0XHRcdFwiPC9kaXY+XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVE9ETyB0YWdnaW5nIGEgcGFnZSB3aXRoIGV4dGVybmFsIHRvIG1ha2Ugc3VyZSB0aGF0IGVtYmVkZGVkIHBhZ2VzIGFyZW4ndFxuXHRcdFx0Ly8gcmVtb3ZlZCBieSB0aGUgdmFyaW91cyBwYWdlIGhhbmRsaW5nIGNvZGUgaXMgYmFkLiBIYXZpbmcgcGFnZSBoYW5kbGluZyBjb2RlXG5cdFx0XHQvLyBpbiBtYW55IHBsYWNlcyBpcyBiYWQuIFNvbHV0aW9ucyBwb3N0IDEuMFxuXHRcdFx0cGFnZS5hdHRyKCBcImRhdGEtXCIgKyB0aGlzLl9nZXROcygpICsgXCJ1cmxcIiwgJC5tb2JpbGUucGF0aC5jb252ZXJ0VXJsVG9EYXRhVXJsKGZpbGVVcmwpIClcblx0XHRcdFx0LmF0dHIoIFwiZGF0YS1cIiArIHRoaXMuX2dldE5zKCkgKyBcImV4dGVybmFsLXBhZ2VcIiwgdHJ1ZSApO1xuXG5cdFx0XHRyZXR1cm4gcGFnZTtcblx0XHR9LFxuXG5cdFx0X3NldExvYWRlZFRpdGxlOiBmdW5jdGlvbiggcGFnZSwgaHRtbCApIHtcblx0XHRcdC8vcGFnZSB0aXRsZSByZWdleHBcblx0XHRcdHZhciBuZXdQYWdlVGl0bGUgPSBodG1sLm1hdGNoKCAvPHRpdGxlW14+XSo+KFtePF0qKS8gKSAmJiBSZWdFeHAuJDE7XG5cblx0XHRcdGlmICggbmV3UGFnZVRpdGxlICYmICFwYWdlLmpxbURhdGEoXCJ0aXRsZVwiKSApIHtcblx0XHRcdFx0bmV3UGFnZVRpdGxlID0gJCggXCI8ZGl2PlwiICsgbmV3UGFnZVRpdGxlICsgXCI8L2Rpdj5cIiApLnRleHQoKTtcblx0XHRcdFx0cGFnZS5qcW1EYXRhKCBcInRpdGxlXCIsIG5ld1BhZ2VUaXRsZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfaXNSZXdyaXRhYmxlQmFzZVRhZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gJC5tb2JpbGUuZHluYW1pY0Jhc2VFbmFibGVkICYmICEkLnN1cHBvcnQuZHluYW1pY0Jhc2VUYWc7XG5cdFx0fSxcblxuXHRcdF9jcmVhdGVEYXRhVXJsOiBmdW5jdGlvbiggYWJzb2x1dGVVcmwgKSB7XG5cdFx0XHRyZXR1cm4gJC5tb2JpbGUucGF0aC5jb252ZXJ0VXJsVG9EYXRhVXJsKCBhYnNvbHV0ZVVybCApO1xuXHRcdH0sXG5cblx0XHRfY3JlYXRlRmlsZVVybDogZnVuY3Rpb24oIGFic29sdXRlVXJsICkge1xuXHRcdFx0cmV0dXJuICQubW9iaWxlLnBhdGguZ2V0RmlsZVBhdGgoIGFic29sdXRlVXJsICk7XG5cdFx0fSxcblxuXHRcdF90cmlnZ2VyV2l0aERlcHJlY2F0ZWQ6IGZ1bmN0aW9uKCBuYW1lLCBkYXRhLCBwYWdlICkge1xuXHRcdFx0dmFyIGRlcHJlY2F0ZWRFdmVudCA9ICQuRXZlbnQoIFwicGFnZVwiICsgbmFtZSApLFxuXHRcdFx0XHRuZXdFdmVudCA9ICQuRXZlbnQoIHRoaXMud2lkZ2V0TmFtZSArIG5hbWUgKTtcblxuXHRcdFx0Ly8gREVQUkVDQVRFRFxuXHRcdFx0Ly8gdHJpZ2dlciB0aGUgb2xkIGRlcHJlY2F0ZWQgZXZlbnQgb24gdGhlIHBhZ2UgaWYgaXQncyBwcm92aWRlZFxuXHRcdFx0KCBwYWdlIHx8IHRoaXMuZWxlbWVudCApLnRyaWdnZXIoIGRlcHJlY2F0ZWRFdmVudCwgZGF0YSApO1xuXG5cdFx0XHQvLyB1c2UgdGhlIHdpZGdldCB0cmlnZ2VyIG1ldGhvZCBmb3IgdGhlIG5ldyBjb250ZW50KiBldmVudFxuXHRcdFx0dGhpcy5fdHJpZ2dlciggbmFtZSwgbmV3RXZlbnQsIGRhdGEgKTtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGVwcmVjYXRlZEV2ZW50OiBkZXByZWNhdGVkRXZlbnQsXG5cdFx0XHRcdGV2ZW50OiBuZXdFdmVudFxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0Ly8gVE9ETyBpdCB3b3VsZCBiZSBuaWNlIHRvIHNwbGl0IHRoaXMgdXAgbW9yZSBidXQgZXZlcnl0aGluZyBhcHBlYXJzIHRvIGJlIFwib25lIG9mZlwiXG5cdFx0Ly8gICAgICBvciByZXF1aXJlIG9yZGVyaW5nIHN1Y2ggdGhhdCBvdGhlciBiaXRzIGFyZSBzcHJpbmtsZWQgaW4gYmV0d2VlbiBwYXJ0cyB0aGF0XG5cdFx0Ly8gICAgICBjb3VsZCBiZSBhYnN0cmFjdGVkIG91dCBhcyBhIGdyb3VwXG5cdFx0X2xvYWRTdWNjZXNzOiBmdW5jdGlvbiggYWJzVXJsLCB0cmlnZ2VyRGF0YSwgc2V0dGluZ3MsIGRlZmVycmVkICkge1xuXHRcdFx0dmFyIGZpbGVVcmwgPSB0aGlzLl9jcmVhdGVGaWxlVXJsKCBhYnNVcmwgKSxcblx0XHRcdFx0ZGF0YVVybCA9IHRoaXMuX2NyZWF0ZURhdGFVcmwoIGFic1VybCApO1xuXG5cdFx0XHRyZXR1cm4gJC5wcm94eShmdW5jdGlvbiggaHRtbCwgdGV4dFN0YXR1cywgeGhyICkge1xuXHRcdFx0XHQvL3ByZS1wYXJzZSBodG1sIHRvIGNoZWNrIGZvciBhIGRhdGEtdXJsLFxuXHRcdFx0XHQvL3VzZSBpdCBhcyB0aGUgbmV3IGZpbGVVcmwsIGJhc2UgcGF0aCwgZXRjXG5cdFx0XHRcdHZhciBjb250ZW50LFxuXG5cdFx0XHRcdFx0Ly8gVE9ETyBoYW5kbGUgZGlhbG9ncyBhZ2FpblxuXHRcdFx0XHRcdHBhZ2VFbGVtUmVnZXggPSBuZXcgUmVnRXhwKCBcIig8W14+XStcXFxcYmRhdGEtXCIgKyB0aGlzLl9nZXROcygpICsgXCJyb2xlPVtcXFwiJ10/cGFnZVtcXFwiJ10/W14+XSo+KVwiICksXG5cblx0XHRcdFx0XHRkYXRhVXJsUmVnZXggPSBuZXcgUmVnRXhwKCBcIlxcXFxiZGF0YS1cIiArIHRoaXMuX2dldE5zKCkgKyBcInVybD1bXFxcIiddPyhbXlxcXCInPl0qKVtcXFwiJ10/XCIgKTtcblxuXHRcdFx0XHQvLyBkYXRhLXVybCBtdXN0IGJlIHByb3ZpZGVkIGZvciB0aGUgYmFzZSB0YWcgc28gcmVzb3VyY2UgcmVxdWVzdHNcblx0XHRcdFx0Ly8gY2FuIGJlIGRpcmVjdGVkIHRvIHRoZSBjb3JyZWN0IHVybC4gbG9hZGluZyBpbnRvIGEgdGVtcHJvcmFyeVxuXHRcdFx0XHQvLyBlbGVtZW50IG1ha2VzIHRoZXNlIHJlcXVlc3RzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggcGFnZUVsZW1SZWdleC50ZXN0KCBodG1sICkgJiZcblx0XHRcdFx0XHRSZWdFeHAuJDEgJiZcblx0XHRcdFx0XHRkYXRhVXJsUmVnZXgudGVzdCggUmVnRXhwLiQxICkgJiZcblx0XHRcdFx0XHRSZWdFeHAuJDEgKSB7XG5cdFx0XHRcdFx0ZmlsZVVybCA9ICQubW9iaWxlLnBhdGguZ2V0RmlsZVBhdGgoICQoXCI8ZGl2PlwiICsgUmVnRXhwLiQxICsgXCI8L2Rpdj5cIikudGV4dCgpICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL2RvbnQgdXBkYXRlIHRoZSBiYXNlIHRhZyBpZiB3ZSBhcmUgcHJlZmV0Y2hpbmdcblx0XHRcdFx0aWYgKCBzZXR0aW5ncy5wcmVmZXRjaCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMuX2dldEJhc2UoKS5zZXQoIGZpbGVVcmwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRlbnQgPSB0aGlzLl9wYXJzZSggaHRtbCwgZmlsZVVybCApO1xuXG5cdFx0XHRcdHRoaXMuX3NldExvYWRlZFRpdGxlKCBjb250ZW50LCBodG1sICk7XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSBjb250ZW50IHJlZmVyZW5jZSBhbmQgeGhyIHRvIG91ciB0cmlnZ2VyRGF0YS5cblx0XHRcdFx0dHJpZ2dlckRhdGEueGhyID0geGhyO1xuXHRcdFx0XHR0cmlnZ2VyRGF0YS50ZXh0U3RhdHVzID0gdGV4dFN0YXR1cztcblxuXHRcdFx0XHQvLyBERVBSRUNBVEVEXG5cdFx0XHRcdHRyaWdnZXJEYXRhLnBhZ2UgPSBjb250ZW50O1xuXG5cdFx0XHRcdHRyaWdnZXJEYXRhLmNvbnRlbnQgPSBjb250ZW50O1xuXG5cdFx0XHRcdHRyaWdnZXJEYXRhLnRvUGFnZSA9IGNvbnRlbnQ7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgcHJldmVudGVkLCBzdG9wIGhlcmUhXG5cdFx0XHRcdC8vIE5vdGUgdGhhdCBpdCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGxpc3RlbmVyL2hhbmRsZXJcblx0XHRcdFx0Ly8gdGhhdCBjYWxsZWQgcHJldmVudERlZmF1bHQoKSwgdG8gcmVzb2x2ZS9yZWplY3QgdGhlXG5cdFx0XHRcdC8vIGRlZmVycmVkIG9iamVjdCB3aXRoaW4gdGhlIHRyaWdnZXJEYXRhLlxuXHRcdFx0XHRpZiAoIHRoaXMuX3RyaWdnZXJXaXRoRGVwcmVjYXRlZCggXCJsb2FkXCIgKS5ldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZXdyaXRlIHNyYyBhbmQgaHJlZiBhdHRycyB0byB1c2UgYSBiYXNlIHVybCBpZiB0aGUgYmFzZSB0YWcgd29uJ3Qgd29ya1xuXHRcdFx0XHRpZiAoIHRoaXMuX2lzUmV3cml0YWJsZUJhc2VUYWcoKSAmJiBjb250ZW50ICkge1xuXHRcdFx0XHRcdHRoaXMuX2dldEJhc2UoKS5yZXdyaXRlKCBmaWxlVXJsLCBjb250ZW50ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9pbmNsdWRlKCBjb250ZW50LCBzZXR0aW5ncyApO1xuXG5cdFx0XHRcdC8vIEVuaGFuY2luZyB0aGUgY29udGVudCBtYXkgcmVzdWx0IGluIG5ldyBkaWFsb2dzL3N1YiBjb250ZW50IGJlaW5nIGluc2VydGVkXG5cdFx0XHRcdC8vIGludG8gdGhlIERPTS4gSWYgdGhlIG9yaWdpbmFsIGFic1VybCByZWZlcnMgdG8gYSBzdWItY29udGVudCwgdGhhdCBpcyB0aGVcblx0XHRcdFx0Ly8gcmVhbCBjb250ZW50IHdlIGFyZSBpbnRlcmVzdGVkIGluLlxuXHRcdFx0XHRpZiAoIGFic1VybC5pbmRleE9mKCBcIiZcIiArICQubW9iaWxlLnN1YlBhZ2VVcmxLZXkgKSA+IC0xICkge1xuXHRcdFx0XHRcdGNvbnRlbnQgPSB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oIFwiW2RhdGEtXCIgKyB0aGlzLl9nZXROcygpICtcInVybD0nXCIgKyBkYXRhVXJsICsgXCInXVwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZW1vdmUgbG9hZGluZyBtZXNzYWdlLlxuXHRcdFx0XHRpZiAoIHNldHRpbmdzLnNob3dMb2FkTXNnICkge1xuXHRcdFx0XHRcdHRoaXMuX2hpZGVMb2FkaW5nKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKCBhYnNVcmwsIHNldHRpbmdzLCBjb250ZW50ICk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9LFxuXG5cdFx0X2xvYWREZWZhdWx0czoge1xuXHRcdFx0dHlwZTogXCJnZXRcIixcblx0XHRcdGRhdGE6IHVuZGVmaW5lZCxcblxuXHRcdFx0Ly8gREVQUkVDQVRFRFxuXHRcdFx0cmVsb2FkUGFnZTogZmFsc2UsXG5cblx0XHRcdHJlbG9hZDogZmFsc2UsXG5cblx0XHRcdC8vIEJ5IGRlZmF1bHQgd2UgcmVseSBvbiB0aGUgcm9sZSBkZWZpbmVkIGJ5IHRoZSBAZGF0YS1yb2xlIGF0dHJpYnV0ZS5cblx0XHRcdHJvbGU6IHVuZGVmaW5lZCxcblxuXHRcdFx0c2hvd0xvYWRNc2c6IGZhbHNlLFxuXG5cdFx0XHQvLyBUaGlzIGRlbGF5IGFsbG93cyBsb2FkcyB0aGF0IHB1bGwgZnJvbSBicm93c2VyIGNhY2hlIHRvXG5cdFx0XHQvLyBvY2N1ciB3aXRob3V0IHNob3dpbmcgdGhlIGxvYWRpbmcgbWVzc2FnZS5cblx0XHRcdGxvYWRNc2dEZWxheTogNTBcblx0XHR9LFxuXG5cdFx0bG9hZDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblx0XHRcdC8vIFRoaXMgZnVuY3Rpb24gdXNlcyBkZWZlcnJlZCBub3RpZmljYXRpb25zIHRvIGxldCBjYWxsZXJzXG5cdFx0XHQvLyBrbm93IHdoZW4gdGhlIGNvbnRlbnQgaXMgZG9uZSBsb2FkaW5nLCBvciBpZiBhbiBlcnJvciBoYXMgb2NjdXJyZWQuXG5cdFx0XHR2YXIgZGVmZXJyZWQgPSAoIG9wdGlvbnMgJiYgb3B0aW9ucy5kZWZlcnJlZCApIHx8ICQuRGVmZXJyZWQoKSxcblxuXHRcdFx0XHQvLyBUaGUgZGVmYXVsdCBsb2FkIG9wdGlvbnMgd2l0aCBvdmVycmlkZXMgc3BlY2lmaWVkIGJ5IHRoZSBjYWxsZXIuXG5cdFx0XHRcdHNldHRpbmdzID0gJC5leHRlbmQoIHt9LCB0aGlzLl9sb2FkRGVmYXVsdHMsIG9wdGlvbnMgKSxcblxuXHRcdFx0XHQvLyBUaGUgRE9NIGVsZW1lbnQgZm9yIHRoZSBjb250ZW50IGFmdGVyIGl0IGhhcyBiZWVuIGxvYWRlZC5cblx0XHRcdFx0Y29udGVudCA9IG51bGwsXG5cblx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIHZlcnNpb24gb2YgdGhlIFVSTCBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb24uIFRoaXNcblx0XHRcdFx0Ly8gdmVyc2lvbiBvZiB0aGUgVVJMIG1heSBjb250YWluIGRpYWxvZy9zdWJjb250ZW50IHBhcmFtcyBpbiBpdC5cblx0XHRcdFx0YWJzVXJsID0gJC5tb2JpbGUucGF0aC5tYWtlVXJsQWJzb2x1dGUoIHVybCwgdGhpcy5fZmluZEJhc2VXaXRoRGVmYXVsdCgpICksXG5cdFx0XHRcdGZpbGVVcmwsIGRhdGFVcmwsIHBibEV2ZW50LCB0cmlnZ2VyRGF0YTtcblxuXHRcdFx0Ly8gREVQUkVDQVRFRCByZWxvYWRQYWdlXG5cdFx0XHRzZXR0aW5ncy5yZWxvYWQgPSBzZXR0aW5ncy5yZWxvYWRQYWdlO1xuXG5cdFx0XHQvLyBJZiB0aGUgY2FsbGVyIHByb3ZpZGVkIGRhdGEsIGFuZCB3ZSdyZSB1c2luZyBcImdldFwiIHJlcXVlc3QsXG5cdFx0XHQvLyBhcHBlbmQgdGhlIGRhdGEgdG8gdGhlIFVSTC5cblx0XHRcdGlmICggc2V0dGluZ3MuZGF0YSAmJiBzZXR0aW5ncy50eXBlID09PSBcImdldFwiICkge1xuXHRcdFx0XHRhYnNVcmwgPSAkLm1vYmlsZS5wYXRoLmFkZFNlYXJjaFBhcmFtcyggYWJzVXJsLCBzZXR0aW5ncy5kYXRhICk7XG5cdFx0XHRcdHNldHRpbmdzLmRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSBjYWxsZXIgaXMgdXNpbmcgYSBcInBvc3RcIiByZXF1ZXN0LCByZWxvYWQgbXVzdCBiZSB0cnVlXG5cdFx0XHRpZiAoIHNldHRpbmdzLmRhdGEgJiYgc2V0dGluZ3MudHlwZSA9PT0gXCJwb3N0XCIgKSB7XG5cdFx0XHRcdHNldHRpbmdzLnJlbG9hZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBhYnNvbHV0ZSB2ZXJzaW9uIG9mIHRoZSBVUkwgbWludXMgYW55IGRpYWxvZy9zdWJjb250ZW50IHBhcmFtcy5cblx0XHRcdC8vIEluIG90aGVyd29yZHMgdGhlIHJlYWwgVVJMIG9mIHRoZSBjb250ZW50IHRvIGJlIGxvYWRlZC5cblx0XHRcdGZpbGVVcmwgPSB0aGlzLl9jcmVhdGVGaWxlVXJsKCBhYnNVcmwgKTtcblxuXHRcdFx0Ly8gVGhlIHZlcnNpb24gb2YgdGhlIFVybCBhY3R1YWxseSBzdG9yZWQgaW4gdGhlIGRhdGEtdXJsIGF0dHJpYnV0ZSBvZlxuXHRcdFx0Ly8gdGhlIGNvbnRlbnQuIEZvciBlbWJlZGRlZCBjb250ZW50LCBpdCBpcyBqdXN0IHRoZSBpZCBvZiB0aGUgcGFnZS4gRm9yXG5cdFx0XHQvLyBjb250ZW50IHdpdGhpbiB0aGUgc2FtZSBkb21haW4gYXMgdGhlIGRvY3VtZW50IGJhc2UsIGl0IGlzIHRoZSBzaXRlXG5cdFx0XHQvLyByZWxhdGl2ZSBwYXRoLiBGb3IgY3Jvc3MtZG9tYWluIGNvbnRlbnQgKFBob25lIEdhcCBvbmx5KSB0aGUgZW50aXJlXG5cdFx0XHQvLyBhYnNvbHV0ZSBVcmwgaXMgdXNlZCB0byBsb2FkIHRoZSBjb250ZW50LlxuXHRcdFx0ZGF0YVVybCA9IHRoaXMuX2NyZWF0ZURhdGFVcmwoIGFic1VybCApO1xuXG5cdFx0XHRjb250ZW50ID0gdGhpcy5fZmluZCggYWJzVXJsICk7XG5cblx0XHRcdC8vIElmIGl0IGlzbid0IGEgcmVmZXJlbmNlIHRvIHRoZSBmaXJzdCBjb250ZW50IGFuZCByZWZlcnMgdG8gbWlzc2luZ1xuXHRcdFx0Ly8gZW1iZWRkZWQgY29udGVudCByZWplY3QgdGhlIGRlZmVycmVkIGFuZCByZXR1cm5cblx0XHRcdGlmICggY29udGVudC5sZW5ndGggPT09IDAgJiZcblx0XHRcdFx0JC5tb2JpbGUucGF0aC5pc0VtYmVkZGVkUGFnZShmaWxlVXJsKSAmJlxuXHRcdFx0XHQhJC5tb2JpbGUucGF0aC5pc0ZpcnN0UGFnZVVybChmaWxlVXJsKSApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0KCBhYnNVcmwsIHNldHRpbmdzICk7XG5cdFx0XHRcdHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc2V0IGJhc2UgdG8gdGhlIGRlZmF1bHQgZG9jdW1lbnQgYmFzZVxuXHRcdFx0Ly8gVE9ETyBmaWd1cmUgb3V0IHdoeSB3ZSBkb2UgdGhpc1xuXHRcdFx0dGhpcy5fZ2V0QmFzZSgpLnJlc2V0KCk7XG5cblx0XHRcdC8vIElmIHRoZSBjb250ZW50IHdlIGFyZSBpbnRlcmVzdGVkIGluIGlzIGFscmVhZHkgaW4gdGhlIERPTSxcblx0XHRcdC8vIGFuZCB0aGUgY2FsbGVyIGRpZCBub3QgaW5kaWNhdGUgdGhhdCB3ZSBzaG91bGQgZm9yY2UgYVxuXHRcdFx0Ly8gcmVsb2FkIG9mIHRoZSBmaWxlLCB3ZSBhcmUgZG9uZS4gUmVzb2x2ZSB0aGUgZGVmZXJycmVkIHNvIHRoYXRcblx0XHRcdC8vIHVzZXJzIGNhbiBiaW5kIHRvIC5kb25lIG9uIHRoZSBwcm9taXNlXG5cdFx0XHRpZiAoIGNvbnRlbnQubGVuZ3RoICYmICFzZXR0aW5ncy5yZWxvYWQgKSB7XG5cdFx0XHRcdHRoaXMuX2VuaGFuY2UoIGNvbnRlbnQsIHNldHRpbmdzLnJvbGUgKTtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZSggYWJzVXJsLCBzZXR0aW5ncywgY29udGVudCApO1xuXG5cdFx0XHRcdC8vaWYgd2UgYXJlIHJlbG9hZGluZyB0aGUgY29udGVudCBtYWtlIHN1cmUgd2UgdXBkYXRlXG5cdFx0XHRcdC8vIHRoZSBiYXNlIGlmIGl0cyBub3QgYSBwcmVmZXRjaFxuXHRcdFx0XHRpZiAoICFzZXR0aW5ncy5wcmVmZXRjaCApIHtcblx0XHRcdFx0XHR0aGlzLl9nZXRCYXNlKCkuc2V0KHVybCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHR0cmlnZ2VyRGF0YSA9IHtcblx0XHRcdFx0dXJsOiB1cmwsXG5cdFx0XHRcdGFic1VybDogYWJzVXJsLFxuXHRcdFx0XHR0b1BhZ2U6IHVybCxcblx0XHRcdFx0cHJldlBhZ2U6IG9wdGlvbnMgPyBvcHRpb25zLmZyb21QYWdlIDogdW5kZWZpbmVkLFxuXHRcdFx0XHRkYXRhVXJsOiBkYXRhVXJsLFxuXHRcdFx0XHRkZWZlcnJlZDogZGVmZXJyZWQsXG5cdFx0XHRcdG9wdGlvbnM6IHNldHRpbmdzXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBMZXQgbGlzdGVuZXJzIGtub3cgd2UncmUgYWJvdXQgdG8gbG9hZCBjb250ZW50LlxuXHRcdFx0cGJsRXZlbnQgPSB0aGlzLl90cmlnZ2VyV2l0aERlcHJlY2F0ZWQoIFwiYmVmb3JlbG9hZFwiLCB0cmlnZ2VyRGF0YSApO1xuXG5cdFx0XHQvLyBJZiB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBwcmV2ZW50ZWQsIHN0b3AgaGVyZSFcblx0XHRcdGlmICggcGJsRXZlbnQuZGVwcmVjYXRlZEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8XG5cdFx0XHRcdHBibEV2ZW50LmV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXHRcdFx0XHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNldHRpbmdzLnNob3dMb2FkTXNnICkge1xuXHRcdFx0XHR0aGlzLl9zaG93TG9hZGluZyggc2V0dGluZ3MubG9hZE1zZ0RlbGF5ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc2V0IGJhc2UgdG8gdGhlIGRlZmF1bHQgZG9jdW1lbnQgYmFzZS5cblx0XHRcdC8vIG9ubHkgcmVzZXQgaWYgd2UgYXJlIG5vdCBwcmVmZXRjaGluZ1xuXHRcdFx0aWYgKCBzZXR0aW5ncy5wcmVmZXRjaCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLl9nZXRCYXNlKCkucmVzZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhKCAkLm1vYmlsZS5hbGxvd0Nyb3NzRG9tYWluUGFnZXMgfHxcblx0XHRcdFx0JC5tb2JpbGUucGF0aC5pc1NhbWVEb21haW4oJC5tb2JpbGUucGF0aC5kb2N1bWVudFVybCwgYWJzVXJsICkgKSApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0KCBhYnNVcmwsIHNldHRpbmdzICk7XG5cdFx0XHRcdHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvYWQgdGhlIG5ldyBjb250ZW50LlxuXHRcdFx0JC5hamF4KHtcblx0XHRcdFx0dXJsOiBmaWxlVXJsLFxuXHRcdFx0XHR0eXBlOiBzZXR0aW5ncy50eXBlLFxuXHRcdFx0XHRkYXRhOiBzZXR0aW5ncy5kYXRhLFxuXHRcdFx0XHRjb250ZW50VHlwZTogc2V0dGluZ3MuY29udGVudFR5cGUsXG5cdFx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdFx0c3VjY2VzczogdGhpcy5fbG9hZFN1Y2Nlc3MoIGFic1VybCwgdHJpZ2dlckRhdGEsIHNldHRpbmdzLCBkZWZlcnJlZCApLFxuXHRcdFx0XHRlcnJvcjogdGhpcy5fbG9hZEVycm9yKCBhYnNVcmwsIHRyaWdnZXJEYXRhLCBzZXR0aW5ncywgZGVmZXJyZWQgKVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG5cdFx0fSxcblxuXHRcdF9sb2FkRXJyb3I6IGZ1bmN0aW9uKCBhYnNVcmwsIHRyaWdnZXJEYXRhLCBzZXR0aW5ncywgZGVmZXJyZWQgKSB7XG5cdFx0XHRyZXR1cm4gJC5wcm94eShmdW5jdGlvbiggeGhyLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93biApIHtcblx0XHRcdFx0Ly9zZXQgYmFzZSBiYWNrIHRvIGN1cnJlbnQgcGF0aFxuXHRcdFx0XHR0aGlzLl9nZXRCYXNlKCkuc2V0KCAkLm1vYmlsZS5wYXRoLmdldCgpICk7XG5cblx0XHRcdFx0Ly8gQWRkIGVycm9yIGluZm8gdG8gb3VyIHRyaWdnZXJEYXRhLlxuXHRcdFx0XHR0cmlnZ2VyRGF0YS54aHIgPSB4aHI7XG5cdFx0XHRcdHRyaWdnZXJEYXRhLnRleHRTdGF0dXMgPSB0ZXh0U3RhdHVzO1xuXHRcdFx0XHR0cmlnZ2VyRGF0YS5lcnJvclRocm93biA9IGVycm9yVGhyb3duO1xuXG5cdFx0XHRcdC8vIExldCBsaXN0ZW5lcnMga25vdyB0aGUgcGFnZSBsb2FkIGZhaWxlZC5cblx0XHRcdFx0dmFyIHBsZkV2ZW50ID0gdGhpcy5fdHJpZ2dlcldpdGhEZXByZWNhdGVkKCBcImxvYWRmYWlsZWRcIiwgdHJpZ2dlckRhdGEgKTtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBwcmV2ZW50ZWQsIHN0b3AgaGVyZSFcblx0XHRcdFx0Ly8gTm90ZSB0aGF0IGl0IGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgbGlzdGVuZXIvaGFuZGxlclxuXHRcdFx0XHQvLyB0aGF0IGNhbGxlZCBwcmV2ZW50RGVmYXVsdCgpLCB0byByZXNvbHZlL3JlamVjdCB0aGVcblx0XHRcdFx0Ly8gZGVmZXJyZWQgb2JqZWN0IHdpdGhpbiB0aGUgdHJpZ2dlckRhdGEuXG5cdFx0XHRcdGlmICggcGxmRXZlbnQuZGVwcmVjYXRlZEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8XG5cdFx0XHRcdFx0cGxmRXZlbnQuZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGxvYWRpbmcgbWVzc2FnZS5cblx0XHRcdFx0aWYgKCBzZXR0aW5ncy5zaG93TG9hZE1zZyApIHtcblx0XHRcdFx0XHR0aGlzLl9zaG93RXJyb3IoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdCggYWJzVXJsLCBzZXR0aW5ncyApO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fSxcblxuXHRcdF9nZXRUcmFuc2l0aW9uSGFuZGxlcjogZnVuY3Rpb24oIHRyYW5zaXRpb24gKSB7XG5cdFx0XHR0cmFuc2l0aW9uID0gJC5tb2JpbGUuX21heWJlRGVncmFkZVRyYW5zaXRpb24oIHRyYW5zaXRpb24gKTtcblxuXHRcdFx0Ly9maW5kIHRoZSB0cmFuc2l0aW9uIGhhbmRsZXIgZm9yIHRoZSBzcGVjaWZpZWQgdHJhbnNpdGlvbi4gSWYgdGhlcmVcblx0XHRcdC8vaXNuJ3Qgb25lIGluIG91ciB0cmFuc2l0aW9uSGFuZGxlcnMgZGljdGlvbmFyeSwgdXNlIHRoZSBkZWZhdWx0IG9uZS5cblx0XHRcdC8vY2FsbCB0aGUgaGFuZGxlciBpbW1lZGlhdGVseSB0byBraWNrLW9mZiB0aGUgdHJhbnNpdGlvbi5cblx0XHRcdHJldHVybiAkLm1vYmlsZS50cmFuc2l0aW9uSGFuZGxlcnNbIHRyYW5zaXRpb24gXSB8fCAkLm1vYmlsZS5kZWZhdWx0VHJhbnNpdGlvbkhhbmRsZXI7XG5cdFx0fSxcblxuXHRcdC8vIFRPRE8gbW92ZSBpbnRvIHRyYW5zaXRpb24gaGFuZGxlcnM/XG5cdFx0X3RyaWdnZXJDc3NUcmFuc2l0aW9uRXZlbnRzOiBmdW5jdGlvbiggdG8sIGZyb20sIHByZWZpeCApIHtcblx0XHRcdHZhciBzYW1lUGFnZSA9IGZhbHNlO1xuXG5cdFx0XHRwcmVmaXggPSBwcmVmaXggfHwgXCJcIjtcblxuXHRcdFx0Ly8gVE9ETyBkZWNpZGUgaWYgdGhlc2UgZXZlbnRzIHNob3VsZCBpbiBmYWN0IGJlIHRyaWdnZXJlZCBvbiB0aGUgY29udGFpbmVyXG5cdFx0XHRpZiAoIGZyb20gKSB7XG5cblx0XHRcdFx0Ly9DaGVjayBpZiB0aGlzIGlzIGEgc2FtZSBwYWdlIHRyYW5zaXRpb24gYW5kIHRlbGwgdGhlIGhhbmRsZXIgaW4gcGFnZVxuXHRcdFx0XHRpZiggdG9bMF0gPT09IGZyb21bMF0gKXtcblx0XHRcdFx0XHRzYW1lUGFnZSA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL3RyaWdnZXIgYmVmb3JlIHNob3cvaGlkZSBldmVudHNcblx0XHRcdFx0Ly8gVE9ETyBkZXByZWNhdGUgbmV4dFBhZ2UgaW4gZmF2b3Igb2YgbmV4dFxuXHRcdFx0XHR0aGlzLl90cmlnZ2VyV2l0aERlcHJlY2F0ZWQoIHByZWZpeCArIFwiaGlkZVwiLCB7XG5cblx0XHRcdFx0XHQvLyBEZXByZWNhdGVkIGluIDEuNCByZW1vdmUgaW4gMS41XG5cdFx0XHRcdFx0bmV4dFBhZ2U6IHRvLFxuXHRcdFx0XHRcdHRvUGFnZTogdG8sXG5cdFx0XHRcdFx0cHJldlBhZ2U6IGZyb20sXG5cdFx0XHRcdFx0c2FtZVBhZ2U6IHNhbWVQYWdlXG5cdFx0XHRcdH0sIGZyb20gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVE9ETyBkZXByZWNhdGUgcHJldlBhZ2UgaW4gZmF2b3Igb2YgcHJldmlvdXNcblx0XHRcdHRoaXMuX3RyaWdnZXJXaXRoRGVwcmVjYXRlZCggcHJlZml4ICsgXCJzaG93XCIsIHtcblx0XHRcdFx0cHJldlBhZ2U6IGZyb20gfHwgJCggXCJcIiApLFxuXHRcdFx0XHR0b1BhZ2U6IHRvXG5cdFx0XHR9LCB0byApO1xuXHRcdH0sXG5cblx0XHQvLyBUT0RPIG1ha2UgcHJpdmF0ZSBvbmNlIGNoYW5nZSBoYXMgYmVlbiBkZWZpbmVkIGluIHRoZSB3aWRnZXRcblx0XHRfY3NzVHJhbnNpdGlvbjogZnVuY3Rpb24oIHRvLCBmcm9tLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHRyYW5zaXRpb24gPSBvcHRpb25zLnRyYW5zaXRpb24sXG5cdFx0XHRcdHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG5cdFx0XHRcdGRlZmVycmVkID0gb3B0aW9ucy5kZWZlcnJlZCxcblx0XHRcdFx0VHJhbnNpdGlvbkhhbmRsZXIsXG5cdFx0XHRcdHByb21pc2U7XG5cblx0XHRcdHRoaXMuX3RyaWdnZXJDc3NUcmFuc2l0aW9uRXZlbnRzKCB0bywgZnJvbSwgXCJiZWZvcmVcIiApO1xuXG5cdFx0XHQvLyBUT0RPIHB1dCB0aGlzIGluIGEgYmluZGluZyB0byBldmVudHMgKm91dHNpZGUqIHRoZSB3aWRnZXRcblx0XHRcdHRoaXMuX2hpZGVMb2FkaW5nKCk7XG5cblx0XHRcdFRyYW5zaXRpb25IYW5kbGVyID0gdGhpcy5fZ2V0VHJhbnNpdGlvbkhhbmRsZXIoIHRyYW5zaXRpb24gKTtcblxuXHRcdFx0cHJvbWlzZSA9ICggbmV3IFRyYW5zaXRpb25IYW5kbGVyKCB0cmFuc2l0aW9uLCByZXZlcnNlLCB0bywgZnJvbSApICkudHJhbnNpdGlvbigpO1xuXG5cdFx0XHRwcm9taXNlLmRvbmUoICQucHJveHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyQ3NzVHJhbnNpdGlvbkV2ZW50cyggdG8sIGZyb20gKTtcblx0XHRcdH0sIHRoaXMgKSk7XG5cblx0XHRcdC8vIFRPRE8gdGVtcG9yYXJ5IGFjY29tb2RhdGlvbiBvZiBhcmd1bWVudCBkZWZlcnJlZFxuXHRcdFx0cHJvbWlzZS5kb25lKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlLmFwcGx5KCBkZWZlcnJlZCwgYXJndW1lbnRzICk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0X3JlbGVhc2VUcmFuc2l0aW9uTG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHQvL3JlbGVhc2UgdHJhbnNpdGlvbiBsb2NrIHNvIG5hdmlnYXRpb24gaXMgZnJlZSBhZ2FpblxuXHRcdFx0aXNQYWdlVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuXHRcdFx0aWYgKCBwYWdlVHJhbnNpdGlvblF1ZXVlLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdCQubW9iaWxlLmNoYW5nZVBhZ2UuYXBwbHkoIG51bGwsIHBhZ2VUcmFuc2l0aW9uUXVldWUucG9wKCkgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3JlbW92ZUFjdGl2ZUxpbmtDbGFzczogZnVuY3Rpb24oIGZvcmNlICkge1xuXHRcdFx0Ly9jbGVhciBvdXQgdGhlIGFjdGl2ZSBidXR0b24gc3RhdGVcblx0XHRcdCQubW9iaWxlLnJlbW92ZUFjdGl2ZUxpbmtDbGFzcyggZm9yY2UgKTtcblx0XHR9LFxuXG5cdFx0X2xvYWRVcmw6IGZ1bmN0aW9uKCB0bywgdHJpZ2dlckRhdGEsIHNldHRpbmdzICkge1xuXHRcdFx0Ly8gcHJlc2VydmUgdGhlIG9yaWdpbmFsIHRhcmdldCBhcyB0aGUgZGF0YVVybCB2YWx1ZSB3aWxsIGJlXG5cdFx0XHQvLyBzaW1wbGlmaWVkIGVnLCByZW1vdmluZyB1aS1zdGF0ZSwgYW5kIHJlbW92aW5nIHF1ZXJ5IHBhcmFtc1xuXHRcdFx0Ly8gZnJvbSB0aGUgaGFzaCB0aGlzIGlzIHNvIHRoYXQgdXNlcnMgd2hvIHdhbnQgdG8gdXNlIHF1ZXJ5XG5cdFx0XHQvLyBwYXJhbXMgaGF2ZSBhY2Nlc3MgdG8gdGhlbSBpbiB0aGUgZXZlbnQgYmluZGluZ3MgZm9yIHRoZSBwYWdlXG5cdFx0XHQvLyBsaWZlIGN5Y2xlIFNlZSBpc3N1ZSAjNTA4NVxuXHRcdFx0c2V0dGluZ3MudGFyZ2V0ID0gdG87XG5cdFx0XHRzZXR0aW5ncy5kZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcblxuXHRcdFx0dGhpcy5sb2FkKCB0bywgc2V0dGluZ3MgKTtcblxuXHRcdFx0c2V0dGluZ3MuZGVmZXJyZWQuZG9uZSgkLnByb3h5KGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMsIGNvbnRlbnQgKSB7XG5cdFx0XHRcdGlzUGFnZVRyYW5zaXRpb25pbmcgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyBzdG9yZSB0aGUgb3JpZ2luYWwgYWJzb2x1dGUgdXJsIHNvIHRoYXQgaXQgY2FuIGJlIHByb3ZpZGVkXG5cdFx0XHRcdC8vIHRvIGV2ZW50cyBpbiB0aGUgdHJpZ2dlckRhdGEgb2YgdGhlIHN1YnNlcXVlbnQgY2hhbmdlUGFnZSBjYWxsXG5cdFx0XHRcdG9wdGlvbnMuYWJzVXJsID0gdHJpZ2dlckRhdGEuYWJzVXJsO1xuXG5cdFx0XHRcdHRoaXMudHJhbnNpdGlvbiggY29udGVudCwgdHJpZ2dlckRhdGEsIG9wdGlvbnMgKTtcblx0XHRcdH0sIHRoaXMpKTtcblxuXHRcdFx0c2V0dGluZ3MuZGVmZXJyZWQuZmFpbCgkLnByb3h5KGZ1bmN0aW9uKC8qIHVybCwgb3B0aW9ucyAqLykge1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVBY3RpdmVMaW5rQ2xhc3MoIHRydWUgKTtcblx0XHRcdFx0dGhpcy5fcmVsZWFzZVRyYW5zaXRpb25Mb2NrKCk7XG5cdFx0XHRcdHRoaXMuX3RyaWdnZXJXaXRoRGVwcmVjYXRlZCggXCJjaGFuZ2VmYWlsZWRcIiwgdHJpZ2dlckRhdGEgKTtcblx0XHRcdH0sIHRoaXMpKTtcblx0XHR9LFxuXG5cdFx0X3RyaWdnZXJQYWdlQmVmb3JlQ2hhbmdlOiBmdW5jdGlvbiggdG8sIHRyaWdnZXJEYXRhLCBzZXR0aW5ncyApIHtcblx0XHRcdHZhciByZXR1cm5FdmVudHM7XG5cblx0XHRcdHRyaWdnZXJEYXRhLnByZXZQYWdlID0gdGhpcy5hY3RpdmVQYWdlO1xuXHRcdFx0JC5leHRlbmQoIHRyaWdnZXJEYXRhLCB7XG5cdFx0XHRcdHRvUGFnZTogdG8sXG5cdFx0XHRcdG9wdGlvbnM6IHNldHRpbmdzXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gTk9URTogcHJlc2VydmUgdGhlIG9yaWdpbmFsIHRhcmdldCBhcyB0aGUgZGF0YVVybCB2YWx1ZSB3aWxsIGJlXG5cdFx0XHQvLyBzaW1wbGlmaWVkIGVnLCByZW1vdmluZyB1aS1zdGF0ZSwgYW5kIHJlbW92aW5nIHF1ZXJ5IHBhcmFtcyBmcm9tXG5cdFx0XHQvLyB0aGUgaGFzaCB0aGlzIGlzIHNvIHRoYXQgdXNlcnMgd2hvIHdhbnQgdG8gdXNlIHF1ZXJ5IHBhcmFtcyBoYXZlXG5cdFx0XHQvLyBhY2Nlc3MgdG8gdGhlbSBpbiB0aGUgZXZlbnQgYmluZGluZ3MgZm9yIHRoZSBwYWdlIGxpZmUgY3ljbGVcblx0XHRcdC8vIFNlZSBpc3N1ZSAjNTA4NVxuXHRcdFx0aWYgKCAkLnR5cGUodG8pID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHQvLyBpZiB0aGUgdG9QYWdlIGlzIGEgc3RyaW5nIHNpbXBseSBjb252ZXJ0IGl0XG5cdFx0XHRcdHRyaWdnZXJEYXRhLmFic1VybCA9ICQubW9iaWxlLnBhdGgubWFrZVVybEFic29sdXRlKCB0bywgdGhpcy5fZmluZEJhc2VXaXRoRGVmYXVsdCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBpZiB0aGUgdG9QYWdlIGlzIGEgalF1ZXJ5IG9iamVjdCBncmFiIHRoZSBhYnNvbHV0ZSB1cmwgc3RvcmVkXG5cdFx0XHRcdC8vIGluIHRoZSBsb2FkUGFnZSBjYWxsYmFjayB3aGVyZSBpdCBleGlzdHNcblx0XHRcdFx0dHJpZ2dlckRhdGEuYWJzVXJsID0gc2V0dGluZ3MuYWJzVXJsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMZXQgbGlzdGVuZXJzIGtub3cgd2UncmUgYWJvdXQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IHBhZ2UuXG5cdFx0XHRyZXR1cm5FdmVudHMgPSB0aGlzLl90cmlnZ2VyV2l0aERlcHJlY2F0ZWQoIFwiYmVmb3JlY2hhbmdlXCIsIHRyaWdnZXJEYXRhICk7XG5cblx0XHRcdC8vIElmIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHByZXZlbnRlZCwgc3RvcCBoZXJlIVxuXHRcdFx0aWYgKCByZXR1cm5FdmVudHMuZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHxcblx0XHRcdFx0cmV0dXJuRXZlbnRzLmRlcHJlY2F0ZWRFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Y2hhbmdlOiBmdW5jdGlvbiggdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHQvLyBJZiB3ZSBhcmUgaW4gdGhlIG1pZHN0IG9mIGEgdHJhbnNpdGlvbiwgcXVldWUgdGhlIGN1cnJlbnQgcmVxdWVzdC5cblx0XHRcdC8vIFdlJ2xsIGNhbGwgY2hhbmdlUGFnZSgpIG9uY2Ugd2UncmUgZG9uZSB3aXRoIHRoZSBjdXJyZW50IHRyYW5zaXRpb25cblx0XHRcdC8vIHRvIHNlcnZpY2UgdGhlIHJlcXVlc3QuXG5cdFx0XHRpZiAoIGlzUGFnZVRyYW5zaXRpb25pbmcgKSB7XG5cdFx0XHRcdHBhZ2VUcmFuc2l0aW9uUXVldWUudW5zaGlmdCggYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHNldHRpbmdzID0gJC5leHRlbmQoIHt9LCAkLm1vYmlsZS5jaGFuZ2VQYWdlLmRlZmF1bHRzLCBvcHRpb25zICksXG5cdFx0XHRcdHRyaWdnZXJEYXRhID0ge307XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgZnJvbVBhZ2UuXG5cdFx0XHRzZXR0aW5ncy5mcm9tUGFnZSA9IHNldHRpbmdzLmZyb21QYWdlIHx8IHRoaXMuYWN0aXZlUGFnZTtcblxuXHRcdFx0Ly8gaWYgdGhlIHBhZ2UgYmVmb3JlY2hhbmdlIGRlZmF1bHQgaXMgcHJldmVudGVkIHJldHVybiBlYXJseVxuXHRcdFx0aWYgKCAhdGhpcy5fdHJpZ2dlclBhZ2VCZWZvcmVDaGFuZ2UodG8sIHRyaWdnZXJEYXRhLCBzZXR0aW5ncykgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2UgYWxsb3cgXCJwYWdlYmVmb3JlY2hhbmdlXCIgb2JzZXJ2ZXJzIHRvIG1vZGlmeSB0aGUgdG8gaW5cblx0XHRcdC8vIHRoZSB0cmlnZ2VyIGRhdGEgdG8gYWxsb3cgZm9yIHJlZGlyZWN0cy4gTWFrZSBzdXJlIG91ciB0byBpc1xuXHRcdFx0Ly8gdXBkYXRlZC4gV2UgYWxzbyBuZWVkIHRvIHJlLWV2YWx1YXRlIHdoZXRoZXIgaXQgaXMgYSBzdHJpbmcsXG5cdFx0XHQvLyBiZWNhdXNlIGFuIG9iamVjdCBjYW4gYWxzbyBiZSByZXBsYWNlZCBieSBhIHN0cmluZ1xuXHRcdFx0dG8gPSB0cmlnZ2VyRGF0YS50b1BhZ2U7XG5cblx0XHRcdC8vIElmIHRoZSBjYWxsZXIgcGFzc2VkIHVzIGEgdXJsLCBjYWxsIGxvYWRQYWdlKClcblx0XHRcdC8vIHRvIG1ha2Ugc3VyZSBpdCBpcyBsb2FkZWQgaW50byB0aGUgRE9NLiBXZSdsbCBsaXN0ZW5cblx0XHRcdC8vIHRvIHRoZSBwcm9taXNlIG9iamVjdCBpdCByZXR1cm5zIHNvIHdlIGtub3cgd2hlblxuXHRcdFx0Ly8gaXQgaXMgZG9uZSBsb2FkaW5nIG9yIGlmIGFuIGVycm9yIG9jdXJyZWQuXG5cdFx0XHRpZiAoICQudHlwZSh0bykgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdC8vIFNldCB0aGUgaXNQYWdlVHJhbnNpdGlvbmluZyBmbGFnIHRvIHByZXZlbnQgYW55IHJlcXVlc3RzIGZyb21cblx0XHRcdFx0Ly8gZW50ZXJpbmcgdGhpcyBtZXRob2Qgd2hpbGUgd2UgYXJlIGluIHRoZSBtaWRzdCBvZiBsb2FkaW5nIGEgcGFnZVxuXHRcdFx0XHQvLyBvciB0cmFuc2l0aW9uaW5nLlxuXHRcdFx0XHRpc1BhZ2VUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcblxuXHRcdFx0XHR0aGlzLl9sb2FkVXJsKCB0bywgdHJpZ2dlckRhdGEsIHNldHRpbmdzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnRyYW5zaXRpb24oIHRvLCB0cmlnZ2VyRGF0YSwgc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dHJhbnNpdGlvbjogZnVuY3Rpb24oIHRvUGFnZSwgdHJpZ2dlckRhdGEsIHNldHRpbmdzICkge1xuXHRcdFx0dmFyIGZyb21QYWdlLCB1cmwsIHBhZ2VVcmwsIGZpbGVVcmwsXG5cdFx0XHRcdGFjdGl2ZSwgYWN0aXZlSXNJbml0aWFsUGFnZSxcblx0XHRcdFx0aGlzdG9yeURpciwgcGFnZVRpdGxlLCBpc0RpYWxvZyxcblx0XHRcdFx0YWxyZWFkeVRoZXJlLCBuZXdQYWdlVGl0bGUsXG5cdFx0XHRcdHBhcmFtcyxcdGNzc1RyYW5zaXRpb25EZWZlcnJlZCxcblx0XHRcdFx0YmVmb3JlVHJhbnNpdGlvbjtcblxuXHRcdFx0Ly8gSWYgd2UgYXJlIGluIHRoZSBtaWRzdCBvZiBhIHRyYW5zaXRpb24sIHF1ZXVlIHRoZSBjdXJyZW50IHJlcXVlc3QuXG5cdFx0XHQvLyBXZSdsbCBjYWxsIGNoYW5nZVBhZ2UoKSBvbmNlIHdlJ3JlIGRvbmUgd2l0aCB0aGUgY3VycmVudCB0cmFuc2l0aW9uXG5cdFx0XHQvLyB0byBzZXJ2aWNlIHRoZSByZXF1ZXN0LlxuXHRcdFx0aWYgKCBpc1BhZ2VUcmFuc2l0aW9uaW5nICkge1xuXHRcdFx0XHQvLyBtYWtlIHN1cmUgdG8gb25seSBxdWV1ZSB0aGUgdG8gYW5kIHNldHRpbmdzIHZhbHVlcyBzbyB0aGUgYXJndW1lbnRzXG5cdFx0XHRcdC8vIHdvcmsgd2l0aCBhIGNhbGwgdG8gdGhlIGNoYW5nZSBtZXRob2Rcblx0XHRcdFx0cGFnZVRyYW5zaXRpb25RdWV1ZS51bnNoaWZ0KCBbdG9QYWdlLCBzZXR0aW5nc10gKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBERVBSRUNBVEVEIC0gdGhpcyBjYWxsIG9ubHksIGluIGZhdm9yIG9mIHRoZSBiZWZvcmUgdHJhbnNpdGlvblxuXHRcdFx0Ly8gaWYgdGhlIHBhZ2UgYmVmb3JlY2hhbmdlIGRlZmF1bHQgaXMgcHJldmVudGVkIHJldHVybiBlYXJseVxuXHRcdFx0aWYgKCAhdGhpcy5fdHJpZ2dlclBhZ2VCZWZvcmVDaGFuZ2UodG9QYWdlLCB0cmlnZ2VyRGF0YSwgc2V0dGluZ3MpICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRyaWdnZXJEYXRhLnByZXZQYWdlID0gc2V0dGluZ3MuZnJvbVBhZ2U7XG5cdFx0XHQvLyBpZiB0aGUgKGNvbnRlbnR8cGFnZSliZWZvcmV0cmFuc2l0aW9uIGRlZmF1bHQgaXMgcHJldmVudGVkIHJldHVybiBlYXJseVxuXHRcdFx0Ly8gTm90ZSwgd2UgaGF2ZSB0byBjaGVjayBmb3IgYm90aCB0aGUgZGVwcmVjYXRlZCBhbmQgbmV3IGV2ZW50c1xuXHRcdFx0YmVmb3JlVHJhbnNpdGlvbiA9IHRoaXMuX3RyaWdnZXJXaXRoRGVwcmVjYXRlZCggXCJiZWZvcmV0cmFuc2l0aW9uXCIsIHRyaWdnZXJEYXRhICk7XG5cdFx0XHRpZiAoYmVmb3JlVHJhbnNpdGlvbi5kZXByZWNhdGVkRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHxcblx0XHRcdFx0YmVmb3JlVHJhbnNpdGlvbi5ldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGlzUGFnZVRyYW5zaXRpb25pbmcgZmxhZyB0byBwcmV2ZW50IGFueSByZXF1ZXN0cyBmcm9tXG5cdFx0XHQvLyBlbnRlcmluZyB0aGlzIG1ldGhvZCB3aGlsZSB3ZSBhcmUgaW4gdGhlIG1pZHN0IG9mIGxvYWRpbmcgYSBwYWdlXG5cdFx0XHQvLyBvciB0cmFuc2l0aW9uaW5nLlxuXHRcdFx0aXNQYWdlVHJhbnNpdGlvbmluZyA9IHRydWU7XG5cblx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZmlyc3QtcGFnZSBvZiB0aGUgYXBwbGljYXRpb24sIHdlIG5lZWQgdG8gbWFrZVxuXHRcdFx0Ly8gc3VyZSBzZXR0aW5ncy5kYXRhVXJsIGlzIHNldCB0byB0aGUgYXBwbGljYXRpb24gZG9jdW1lbnQgdXJsLiBUaGlzIGFsbG93c1xuXHRcdFx0Ly8gdXMgdG8gYXZvaWQgZ2VuZXJhdGluZyBhIGRvY3VtZW50IHVybCB3aXRoIGFuIGlkIGhhc2ggaW4gdGhlIGNhc2Ugd2hlcmUgdGhlXG5cdFx0XHQvLyBmaXJzdC1wYWdlIG9mIHRoZSBkb2N1bWVudCBoYXMgYW4gaWQgYXR0cmlidXRlIHNwZWNpZmllZC5cblx0XHRcdGlmICggdG9QYWdlWyAwIF0gPT09ICQubW9iaWxlLmZpcnN0UGFnZVsgMCBdICYmICFzZXR0aW5ncy5kYXRhVXJsICkge1xuXHRcdFx0XHRzZXR0aW5ncy5kYXRhVXJsID0gJC5tb2JpbGUucGF0aC5kb2N1bWVudFVybC5ocmVmTm9IYXNoO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgY2FsbGVyIHBhc3NlZCB1cyBhIHJlYWwgcGFnZSBET00gZWxlbWVudC4gVXBkYXRlIG91clxuXHRcdFx0Ly8gaW50ZXJuYWwgc3RhdGUgYW5kIHRoZW4gdHJpZ2dlciBhIHRyYW5zaXRpb24gdG8gdGhlIHBhZ2UuXG5cdFx0XHRmcm9tUGFnZSA9IHNldHRpbmdzLmZyb21QYWdlO1xuXHRcdFx0dXJsID0gKCBzZXR0aW5ncy5kYXRhVXJsICYmICQubW9iaWxlLnBhdGguY29udmVydFVybFRvRGF0YVVybChzZXR0aW5ncy5kYXRhVXJsKSApIHx8XG5cdFx0XHRcdHRvUGFnZS5qcW1EYXRhKCBcInVybFwiICk7XG5cblx0XHRcdC8vIFRoZSBwYWdlVXJsIHZhciBpcyB1c3VhbGx5IHRoZSBzYW1lIGFzIHVybCwgZXhjZXB0IHdoZW4gdXJsIGlzIG9ic2N1cmVkXG5cdFx0XHQvLyBhcyBhIGRpYWxvZyB1cmwuIHBhZ2VVcmwgYWx3YXlzIGNvbnRhaW5zIHRoZSBmaWxlIHBhdGhcblx0XHRcdHBhZ2VVcmwgPSB1cmw7XG5cdFx0XHRmaWxlVXJsID0gJC5tb2JpbGUucGF0aC5nZXRGaWxlUGF0aCggdXJsICk7XG5cdFx0XHRhY3RpdmUgPSAkLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5LmdldEFjdGl2ZSgpO1xuXHRcdFx0YWN0aXZlSXNJbml0aWFsUGFnZSA9ICQubW9iaWxlLm5hdmlnYXRlLmhpc3RvcnkuYWN0aXZlSW5kZXggPT09IDA7XG5cdFx0XHRoaXN0b3J5RGlyID0gMDtcblx0XHRcdHBhZ2VUaXRsZSA9IGRvY3VtZW50LnRpdGxlO1xuXHRcdFx0aXNEaWFsb2cgPSAoIHNldHRpbmdzLnJvbGUgPT09IFwiZGlhbG9nXCIgfHxcblx0XHRcdFx0dG9QYWdlLmpxbURhdGEoIFwicm9sZVwiICkgPT09IFwiZGlhbG9nXCIgKSAmJlxuXHRcdFx0XHR0b1BhZ2UuanFtRGF0YSggXCJkaWFsb2dcIiApICE9PSB0cnVlO1xuXG5cdFx0XHQvLyBCeSBkZWZhdWx0LCB3ZSBwcmV2ZW50IGNoYW5nZVBhZ2UgcmVxdWVzdHMgd2hlbiB0aGUgZnJvbVBhZ2UgYW5kIHRvUGFnZVxuXHRcdFx0Ly8gYXJlIHRoZSBzYW1lIGVsZW1lbnQsIGJ1dCBmb2xrcyB0aGF0IGdlbmVyYXRlIGNvbnRlbnRcblx0XHRcdC8vIG1hbnVhbGx5L2R5bmFtaWNhbGx5IGFuZCByZXVzZSBwYWdlcyB3YW50IHRvIGJlIGFibGUgdG8gdHJhbnNpdGlvbiB0b1xuXHRcdFx0Ly8gdGhlIHNhbWUgcGFnZS4gVG8gYWxsb3cgdGhpcywgdGhleSB3aWxsIG5lZWQgdG8gY2hhbmdlIHRoZSBkZWZhdWx0XG5cdFx0XHQvLyB2YWx1ZSBvZiBhbGxvd1NhbWVQYWdlVHJhbnNpdGlvbiB0byB0cnVlLCAqT1IqLCBwYXNzIGl0IGluIGFzIGFuXG5cdFx0XHQvLyBvcHRpb24gd2hlbiB0aGV5IG1hbnVhbGx5IGNhbGwgY2hhbmdlUGFnZSgpLiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdFxuXHRcdFx0Ly8gb3VyIGRlZmF1bHQgdHJhbnNpdGlvbiBhbmltYXRpb25zIGFzc3VtZSB0aGF0IHRoZSBmb3JtUGFnZSBhbmQgdG9QYWdlXG5cdFx0XHQvLyBhcmUgZGlmZmVyZW50IGVsZW1lbnRzLCBzbyB0aGV5IG1heSBiZWhhdmUgdW5leHBlY3RlZGx5LiBJdCBpcyB1cCB0b1xuXHRcdFx0Ly8gdGhlIGRldmVsb3BlciB0aGF0IHR1cm5zIG9uIHRoZSBhbGxvd1NhbWVQYWdlVHJhbnNpdGlvbmEgb3B0aW9uIHRvXG5cdFx0XHQvLyBlaXRoZXIgdHVybiBvZmYgdHJhbnNpdGlvbiBhbmltYXRpb25zLCBvciBtYWtlIHN1cmUgdGhhdCBhbiBhcHByb3ByaWF0ZVxuXHRcdFx0Ly8gYW5pbWF0aW9uIHRyYW5zaXRpb24gaXMgdXNlZC5cblx0XHRcdGlmICggZnJvbVBhZ2UgJiYgZnJvbVBhZ2VbMF0gPT09IHRvUGFnZVswXSAmJlxuXHRcdFx0XHQhc2V0dGluZ3MuYWxsb3dTYW1lUGFnZVRyYW5zaXRpb24gKSB7XG5cblx0XHRcdFx0aXNQYWdlVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyV2l0aERlcHJlY2F0ZWQoIFwidHJhbnNpdGlvblwiLCB0cmlnZ2VyRGF0YSApO1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyV2l0aERlcHJlY2F0ZWQoIFwiY2hhbmdlXCIsIHRyaWdnZXJEYXRhICk7XG5cblx0XHRcdFx0Ly8gRXZlbiBpZiB0aGVyZSBpcyBubyBwYWdlIGNoYW5nZSB0byBiZSBkb25lLCB3ZSBzaG91bGQga2VlcCB0aGVcblx0XHRcdFx0Ly8gdXJsSGlzdG9yeSBpbiBzeW5jIHdpdGggdGhlIGhhc2ggY2hhbmdlc1xuXHRcdFx0XHRpZiAoIHNldHRpbmdzLmZyb21IYXNoQ2hhbmdlICkge1xuXHRcdFx0XHRcdCQubW9iaWxlLm5hdmlnYXRlLmhpc3RvcnkuZGlyZWN0KHsgdXJsOiB1cmwgfSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBwYWdlIHdlIGFyZSBnaXZlbiBoYXMgYWxyZWFkeSBiZWVuIGVuaGFuY2VkLlxuXHRcdFx0dG9QYWdlLnBhZ2UoeyByb2xlOiBzZXR0aW5ncy5yb2xlIH0pO1xuXG5cdFx0XHQvLyBJZiB0aGUgY2hhbmdlUGFnZSByZXF1ZXN0IHdhcyBzZW50IGZyb20gYSBoYXNoQ2hhbmdlIGV2ZW50LCBjaGVjayB0b1xuXHRcdFx0Ly8gc2VlIGlmIHRoZSBwYWdlIGlzIGFscmVhZHkgd2l0aGluIHRoZSB1cmxIaXN0b3J5IHN0YWNrLiBJZiBzbywgd2UnbGxcblx0XHRcdC8vIGFzc3VtZSB0aGUgdXNlciBoaXQgdGhlIGZvcndhcmQvYmFjayBidXR0b24gYW5kIHdpbGwgdHJ5IHRvIG1hdGNoIHRoZVxuXHRcdFx0Ly8gdHJhbnNpdGlvbiBhY2NvcmRpbmdseS5cblx0XHRcdGlmICggc2V0dGluZ3MuZnJvbUhhc2hDaGFuZ2UgKSB7XG5cdFx0XHRcdGhpc3RvcnlEaXIgPSBzZXR0aW5ncy5kaXJlY3Rpb24gPT09IFwiYmFja1wiID8gLTEgOiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLaWxsIHRoZSBrZXlib2FyZC5cblx0XHRcdC8vIFhYWF9qYmxhczogV2UgbmVlZCB0byBzdG9wIGNyYXdsaW5nIHRoZSBlbnRpcmUgZG9jdW1lbnQgdG8ga2lsbCBmb2N1cy5cblx0XHRcdC8vICAgICAgICAgICAgSW5zdGVhZCwgd2Ugc2hvdWxkIGJlIHRyYWNraW5nIGZvY3VzIHdpdGggYSBkZWxlZ2F0ZSgpXG5cdFx0XHQvLyAgICAgICAgICAgIGhhbmRsZXIgc28gd2UgYWxyZWFkeSBoYXZlIHRoZSBlbGVtZW50IGluIGhhbmQgYXQgdGhpc1xuXHRcdFx0Ly8gICAgICAgICAgICBwb2ludC5cblx0XHRcdC8vIFdyYXAgdGhpcyBpbiBhIHRyeS9jYXRjaCBibG9jayBzaW5jZSBJRTkgdGhyb3cgXCJVbnNwZWNpZmllZCBlcnJvclwiIGlmXG5cdFx0XHQvLyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlzIHVuZGVmaW5lZCB3aGVuIHdlIGFyZSBpbiBhbiBJRnJhbWUuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiZcblx0XHRcdFx0XHRkb2N1bWVudC5hY3RpdmVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiYm9keVwiICkge1xuXG5cdFx0XHRcdFx0JCggZG9jdW1lbnQuYWN0aXZlRWxlbWVudCApLmJsdXIoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkKCBcImlucHV0OmZvY3VzLCB0ZXh0YXJlYTpmb2N1cywgc2VsZWN0OmZvY3VzXCIgKS5ibHVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2goIGUgKSB7fVxuXG5cdFx0XHQvLyBSZWNvcmQgd2hldGhlciB3ZSBhcmUgYXQgYSBwbGFjZSBpbiBoaXN0b3J5IHdoZXJlIGEgZGlhbG9nIHVzZWQgdG8gYmUgLVxuXHRcdFx0Ly8gaWYgc28sIGRvIG5vdCBhZGQgYSBuZXcgaGlzdG9yeSBlbnRyeSBhbmQgZG8gbm90IGNoYW5nZSB0aGUgaGFzaCBlaXRoZXJcblx0XHRcdGFscmVhZHlUaGVyZSA9IGZhbHNlO1xuXG5cdFx0XHQvLyBJZiB3ZSdyZSBkaXNwbGF5aW5nIHRoZSBwYWdlIGFzIGEgZGlhbG9nLCB3ZSBkb24ndCB3YW50IHRoZSB1cmxcblx0XHRcdC8vIGZvciB0aGUgZGlhbG9nIGNvbnRlbnQgdG8gYmUgdXNlZCBpbiB0aGUgaGFzaC4gSW5zdGVhZCwgd2Ugd2FudFxuXHRcdFx0Ly8gdG8gYXBwZW5kIHRoZSBkaWFsb2dIYXNoS2V5IHRvIHRoZSB1cmwgb2YgdGhlIGN1cnJlbnQgcGFnZS5cblx0XHRcdGlmICggaXNEaWFsb2cgJiYgYWN0aXZlICkge1xuXHRcdFx0XHQvLyBvbiB0aGUgaW5pdGlhbCBwYWdlIGxvYWQgYWN0aXZlLnVybCBpcyB1bmRlZmluZWQgYW5kIGluIHRoYXQgY2FzZVxuXHRcdFx0XHQvLyBzaG91bGQgYmUgYW4gZW1wdHkgc3RyaW5nLiBNb3ZpbmcgdGhlIHVuZGVmaW5lZCAtPiBlbXB0eSBzdHJpbmcgYmFja1xuXHRcdFx0XHQvLyBpbnRvIHVybEhpc3RvcnkuYWRkTmV3IHNlZW1lZCBpbXBydWRlbnQgZ2l2ZW4gdW5kZWZpbmVkIGJldHRlclxuXHRcdFx0XHQvLyByZXByZXNlbnRzIHRoZSB1cmwgc3RhdGVcblxuXHRcdFx0XHQvLyBJZiB3ZSBhcmUgYXQgYSBwbGFjZSBpbiBoaXN0b3J5IHRoYXQgb25jZSBiZWxvbmdlZCB0byBhIGRpYWxvZywgcmV1c2Vcblx0XHRcdFx0Ly8gdGhpcyBzdGF0ZSB3aXRob3V0IGFkZGluZyB0byB1cmxIaXN0b3J5IGFuZCB3aXRob3V0IG1vZGlmeWluZyB0aGVcblx0XHRcdFx0Ly8gaGFzaC4gSG93ZXZlciwgaWYgYSBkaWFsb2cgaXMgYWxyZWFkeSBkaXNwbGF5ZWQgYXQgdGhpcyBwb2ludCwgYW5kXG5cdFx0XHRcdC8vIHdlJ3JlIGFib3V0IHRvIGRpc3BsYXkgYW5vdGhlciBkaWFsb2csIHRoZW4gd2UgbXVzdCBhZGQgYW5vdGhlciBoYXNoXG5cdFx0XHRcdC8vIGFuZCBoaXN0b3J5IGVudHJ5IG9uIHRvcCBzbyB0aGF0IG9uZSBtYXkgbmF2aWdhdGUgYmFjayB0byB0aGVcblx0XHRcdFx0Ly8gb3JpZ2luYWwgZGlhbG9nXG5cdFx0XHRcdGlmICggYWN0aXZlLnVybCAmJlxuXHRcdFx0XHRcdGFjdGl2ZS51cmwuaW5kZXhPZiggJC5tb2JpbGUuZGlhbG9nSGFzaEtleSApID4gLTEgJiZcblx0XHRcdFx0XHR0aGlzLmFjdGl2ZVBhZ2UgJiZcblx0XHRcdFx0XHQhdGhpcy5hY3RpdmVQYWdlLmhhc0NsYXNzKCBcInVpLWRpYWxvZ1wiICkgJiZcblx0XHRcdFx0XHQkLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5LmFjdGl2ZUluZGV4ID4gMCApIHtcblxuXHRcdFx0XHRcdHNldHRpbmdzLmNoYW5nZUhhc2ggPSBmYWxzZTtcblx0XHRcdFx0XHRhbHJlYWR5VGhlcmUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTm9ybWFsbHksIHdlIHRhY2sgb24gYSBkaWFsb2cgaGFzaCBrZXksIGJ1dCBpZiB0aGlzIGlzIHRoZSBsb2NhdGlvblxuXHRcdFx0XHQvLyBvZiBhIHN0YWxlIGRpYWxvZywgd2UgcmV1c2UgdGhlIFVSTCBmcm9tIHRoZSBlbnRyeVxuXHRcdFx0XHR1cmwgPSAoIGFjdGl2ZS51cmwgfHwgXCJcIiApO1xuXG5cdFx0XHRcdC8vIGFjY291bnQgZm9yIGFic29sdXRlIHVybHMgaW5zdGVhZCBvZiBqdXN0IHJlbGF0aXZlIHVybHMgdXNlIGFzIGhhc2hlc1xuXHRcdFx0XHRpZiAoICFhbHJlYWR5VGhlcmUgJiYgdXJsLmluZGV4T2YoXCIjXCIpID4gLTEgKSB7XG5cdFx0XHRcdFx0dXJsICs9ICQubW9iaWxlLmRpYWxvZ0hhc2hLZXk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dXJsICs9IFwiI1wiICsgJC5tb2JpbGUuZGlhbG9nSGFzaEtleTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHRhY2sgb24gYW5vdGhlciBkaWFsb2dIYXNoS2V5IGlmIHRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIGluaXRpYWwgaGFzaFxuXHRcdFx0XHQvLyB0aGlzIG1ha2VzIHN1cmUgdGhhdCBhIGhpc3RvcnkgZW50cnkgaXMgY3JlYXRlZCBmb3IgdGhpcyBkaWFsb2dcblx0XHRcdFx0aWYgKCAkLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5LmFjdGl2ZUluZGV4ID09PSAwICYmIHVybCA9PT0gJC5tb2JpbGUubmF2aWdhdGUuaGlzdG9yeS5pbml0aWFsRHN0ICkge1xuXHRcdFx0XHRcdHVybCArPSAkLm1vYmlsZS5kaWFsb2dIYXNoS2V5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHRpdGxlIGVsZW1lbnQgd2Fzbid0IGZvdW5kLCB0cnkgdGhlIHBhZ2UgZGl2IGRhdGEgYXR0ciB0b29cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBkZWVwLWxpbmsgb3IgYSByZWxvYWQgKCBhY3RpdmUgPT09IHVuZGVmaW5lZCApIHRoZW4ganVzdFxuXHRcdFx0Ly8gdXNlIHBhZ2VUaXRsZVxuXHRcdFx0bmV3UGFnZVRpdGxlID0gKCAhYWN0aXZlICkgPyBwYWdlVGl0bGUgOiB0b1BhZ2UuanFtRGF0YSggXCJ0aXRsZVwiICkgfHxcblx0XHRcdFx0dG9QYWdlLmNoaWxkcmVuKCBcIjpqcW1EYXRhKHJvbGU9J2hlYWRlcicpXCIgKS5maW5kKCBcIi51aS10aXRsZVwiICkudGV4dCgpO1xuXHRcdFx0aWYgKCAhIW5ld1BhZ2VUaXRsZSAmJiBwYWdlVGl0bGUgPT09IGRvY3VtZW50LnRpdGxlICkge1xuXHRcdFx0XHRwYWdlVGl0bGUgPSBuZXdQYWdlVGl0bGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICF0b1BhZ2UuanFtRGF0YSggXCJ0aXRsZVwiICkgKSB7XG5cdFx0XHRcdHRvUGFnZS5qcW1EYXRhKCBcInRpdGxlXCIsIHBhZ2VUaXRsZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIHRyYW5zaXRpb24gZGVmaW5lZC5cblx0XHRcdHNldHRpbmdzLnRyYW5zaXRpb24gPSBzZXR0aW5ncy50cmFuc2l0aW9uIHx8XG5cdFx0XHRcdCggKCBoaXN0b3J5RGlyICYmICFhY3RpdmVJc0luaXRpYWxQYWdlICkgPyBhY3RpdmUudHJhbnNpdGlvbiA6IHVuZGVmaW5lZCApIHx8XG5cdFx0XHRcdCggaXNEaWFsb2cgPyAkLm1vYmlsZS5kZWZhdWx0RGlhbG9nVHJhbnNpdGlvbiA6ICQubW9iaWxlLmRlZmF1bHRQYWdlVHJhbnNpdGlvbiApO1xuXG5cdFx0XHQvL2FkZCBwYWdlIHRvIGhpc3Rvcnkgc3RhY2sgaWYgaXQncyBub3QgYmFjayBvciBmb3J3YXJkXG5cdFx0XHRpZiAoICFoaXN0b3J5RGlyICYmIGFscmVhZHlUaGVyZSApIHtcblx0XHRcdFx0JC5tb2JpbGUubmF2aWdhdGUuaGlzdG9yeS5nZXRBY3RpdmUoKS5wYWdlVXJsID0gcGFnZVVybDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBsb2NhdGlvbiBoYXNoLlxuXHRcdFx0aWYgKCB1cmwgJiYgIXNldHRpbmdzLmZyb21IYXNoQ2hhbmdlICkge1xuXG5cdFx0XHRcdC8vIHJlYnVpbGRpbmcgdGhlIGhhc2ggaGVyZSBzaW5jZSB3ZSBsb29zZSBpdCBlYXJsaWVyIG9uXG5cdFx0XHRcdC8vIFRPRE8gcHJlc2VydmUgdGhlIG9yaWdpbmFsbHkgcGFzc2VkIGluIHBhdGhcblx0XHRcdFx0aWYgKCAhJC5tb2JpbGUucGF0aC5pc1BhdGgoIHVybCApICYmIHVybC5pbmRleE9mKCBcIiNcIiApIDwgMCApIHtcblx0XHRcdFx0XHR1cmwgPSBcIiNcIiArIHVybDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRPRE8gdGhlIHByb3BlcnR5IG5hbWVzIGhlcmUgYXJlIGp1c3Qgc2lsbHlcblx0XHRcdFx0cGFyYW1zID0ge1xuXHRcdFx0XHRcdHRyYW5zaXRpb246IHNldHRpbmdzLnRyYW5zaXRpb24sXG5cdFx0XHRcdFx0dGl0bGU6IHBhZ2VUaXRsZSxcblx0XHRcdFx0XHRwYWdlVXJsOiBwYWdlVXJsLFxuXHRcdFx0XHRcdHJvbGU6IHNldHRpbmdzLnJvbGVcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAoIHNldHRpbmdzLmNoYW5nZUhhc2ggIT09IGZhbHNlICYmICQubW9iaWxlLmhhc2hMaXN0ZW5pbmdFbmFibGVkICkge1xuXHRcdFx0XHRcdCQubW9iaWxlLm5hdmlnYXRlKCB1cmwsIHBhcmFtcywgdHJ1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRvUGFnZVsgMCBdICE9PSAkLm1vYmlsZS5maXJzdFBhZ2VbIDAgXSApIHtcblx0XHRcdFx0XHQkLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5LmFkZCggdXJsLCBwYXJhbXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvL3NldCBwYWdlIHRpdGxlXG5cdFx0XHRkb2N1bWVudC50aXRsZSA9IHBhZ2VUaXRsZTtcblxuXHRcdFx0Ly9zZXQgXCJ0b1BhZ2VcIiBhcyBhY3RpdmVQYWdlIGRlcHJlY2F0ZWQgaW4gMS40IHJlbW92ZSBpbiAxLjVcblx0XHRcdCQubW9iaWxlLmFjdGl2ZVBhZ2UgPSB0b1BhZ2U7XG5cblx0XHRcdC8vbmV3IHdheSB0byBoYW5kbGUgYWN0aXZlUGFnZVxuXHRcdFx0dGhpcy5hY3RpdmVQYWdlID0gdG9QYWdlO1xuXG5cdFx0XHQvLyBJZiB3ZSdyZSBuYXZpZ2F0aW5nIGJhY2sgaW4gdGhlIFVSTCBoaXN0b3J5LCBzZXQgcmV2ZXJzZSBhY2NvcmRpbmdseS5cblx0XHRcdHNldHRpbmdzLnJldmVyc2UgPSBzZXR0aW5ncy5yZXZlcnNlIHx8IGhpc3RvcnlEaXIgPCAwO1xuXG5cdFx0XHRjc3NUcmFuc2l0aW9uRGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XG5cblx0XHRcdHRoaXMuX2Nzc1RyYW5zaXRpb24odG9QYWdlLCBmcm9tUGFnZSwge1xuXHRcdFx0XHR0cmFuc2l0aW9uOiBzZXR0aW5ncy50cmFuc2l0aW9uLFxuXHRcdFx0XHRyZXZlcnNlOiBzZXR0aW5ncy5yZXZlcnNlLFxuXHRcdFx0XHRkZWZlcnJlZDogY3NzVHJhbnNpdGlvbkRlZmVycmVkXG5cdFx0XHR9KTtcblxuXHRcdFx0Y3NzVHJhbnNpdGlvbkRlZmVycmVkLmRvbmUoJC5wcm94eShmdW5jdGlvbiggbmFtZSwgcmV2ZXJzZSwgJHRvLCAkZnJvbSwgYWxyZWFkeUZvY3VzZWQgKSB7XG5cdFx0XHRcdCQubW9iaWxlLnJlbW92ZUFjdGl2ZUxpbmtDbGFzcygpO1xuXG5cdFx0XHRcdC8vaWYgdGhlcmUncyBhIGR1cGxpY2F0ZUNhY2hlZFBhZ2UsIHJlbW92ZSBpdCBmcm9tIHRoZSBET00gbm93IHRoYXQgaXQncyBoaWRkZW5cblx0XHRcdFx0aWYgKCBzZXR0aW5ncy5kdXBsaWNhdGVDYWNoZWRQYWdlICkge1xuXHRcdFx0XHRcdHNldHRpbmdzLmR1cGxpY2F0ZUNhY2hlZFBhZ2UucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBkZXNwaXRlIHZpc2liaWxpdHk6IGhpZGRlbiBhZGRyZXNzZXMgaXNzdWUgIzI5NjVcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktbW9iaWxlL2lzc3Vlcy8yOTY1XG5cdFx0XHRcdGlmICggIWFscmVhZHlGb2N1c2VkICkge1xuXHRcdFx0XHRcdCQubW9iaWxlLmZvY3VzUGFnZSggdG9QYWdlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9yZWxlYXNlVHJhbnNpdGlvbkxvY2soKTtcblx0XHRcdFx0dGhpcy5fdHJpZ2dlcldpdGhEZXByZWNhdGVkKCBcInRyYW5zaXRpb25cIiwgdHJpZ2dlckRhdGEgKTtcblx0XHRcdFx0dGhpcy5fdHJpZ2dlcldpdGhEZXByZWNhdGVkKCBcImNoYW5nZVwiLCB0cmlnZ2VyRGF0YSApO1xuXHRcdFx0fSwgdGhpcykpO1xuXHRcdH0sXG5cblx0XHQvLyBkZXRlcm1pbmUgdGhlIGN1cnJlbnQgYmFzZSB1cmxcblx0XHRfZmluZEJhc2VXaXRoRGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xvc2VzdEJhc2UgPSAoIHRoaXMuYWN0aXZlUGFnZSAmJlxuXHRcdFx0JC5tb2JpbGUuZ2V0Q2xvc2VzdEJhc2VVcmwoIHRoaXMuYWN0aXZlUGFnZSApICk7XG5cdFx0cmV0dXJuIGNsb3Nlc3RCYXNlIHx8ICQubW9iaWxlLnBhdGguZG9jdW1lbnRCYXNlLmhyZWZOb0hhc2g7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBUaGUgZm9sbG93aW5nIGhhbmRsZXJzIHNob3VsZCBiZSBib3VuZCBhZnRlciBtb2JpbGVpbml0IGhhcyBiZWVuIHRyaWdnZXJlZFxuXHQvLyB0aGUgZm9sbG93aW5nIGRlZmVycmVkIGlzIHJlc29sdmVkIGluIHRoZSBpbml0IGZpbGVcblx0JC5tb2JpbGUubmF2cmVhZHlEZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcblxuXHQvL3RoZXNlIHZhcmlhYmxlcyBtYWtlIGFsbCBwYWdlIGNvbnRhaW5lcnMgdXNlIHRoZSBzYW1lIHF1ZXVlIGFuZCBvbmx5IG5hdmlnYXRlIG9uZSBhdCBhIHRpbWVcblx0Ly8gcXVldWUgdG8gaG9sZCBzaW11bHRhbmlvdXMgcGFnZSB0cmFuc2l0aW9uc1xuXHR2YXIgcGFnZVRyYW5zaXRpb25RdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gaW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHBhZ2UgaXMgaW4gcHJvY2VzcyBvZiB0cmFuc2l0aW9uaW5nXG5cdFx0aXNQYWdlVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuXG59KSggalF1ZXJ5ICk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG5cdFx0Ly8gcmVzb2x2ZWQgb24gZG9tcmVhZHlcblx0dmFyIGRvbXJlYWR5RGVmZXJyZWQgPSAkLkRlZmVycmVkKCksXG5cblx0XHQvLyByZXNvbHZlZCBhbmQgbnVsbGVkIG9uIHdpbmRvdy5sb2FkKClcblx0XHRsb2FkRGVmZXJyZWQgPSAkLkRlZmVycmVkKCksXG5cblx0XHQvLyBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBhYm92ZSBkZWZlcnJlZFxuXHRcdHBhZ2VJc0Z1bGx5TG9hZGVkID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFJlc29sdmUgYW5kIG51bGwgdGhlIGRlZmVycmVkXG5cdFx0XHRsb2FkRGVmZXJyZWQucmVzb2x2ZSgpO1xuXHRcdFx0bG9hZERlZmVycmVkID0gbnVsbDtcblx0XHR9LFxuXG5cdFx0ZG9jdW1lbnRVcmwgPSAkLm1vYmlsZS5wYXRoLmRvY3VtZW50VXJsLFxuXG5cdFx0Ly8gdXNlZCB0byB0cmFjayBsYXN0IHZjbGlja2VkIGVsZW1lbnQgdG8gbWFrZSBzdXJlIGl0cyB2YWx1ZSBpcyBhZGRlZCB0byBmb3JtIGRhdGFcblx0XHQkbGFzdFZDbGlja2VkID0gbnVsbDtcblxuXHQvKiBFdmVudCBCaW5kaW5ncyAtIGhhc2hjaGFuZ2UsIHN1Ym1pdCwgYW5kIGNsaWNrICovXG5cdGZ1bmN0aW9uIGZpbmRDbG9zZXN0TGluayggZWxlIClcdHtcblx0XHR3aGlsZSAoIGVsZSApIHtcblx0XHRcdC8vIExvb2sgZm9yIHRoZSBjbG9zZXN0IGVsZW1lbnQgd2l0aCBhIG5vZGVOYW1lIG9mIFwiYVwiLlxuXHRcdFx0Ly8gTm90ZSB0aGF0IHdlIGFyZSBjaGVja2luZyBpZiB3ZSBoYXZlIGEgdmFsaWQgbm9kZU5hbWVcblx0XHRcdC8vIGJlZm9yZSBhdHRlbXB0aW5nIHRvIGFjY2VzcyBpdC4gVGhpcyBpcyBiZWNhdXNlIHRoZVxuXHRcdFx0Ly8gbm9kZSB3ZSBnZXQgY2FsbGVkIHdpdGggY291bGQgaGF2ZSBvcmlnaW5hdGVkIGZyb20gd2l0aGluXG5cdFx0XHQvLyBhbiBlbWJlZGRlZCBTVkcgZG9jdW1lbnQgd2hlcmUgc29tZSBzeW1ib2wgaW5zdGFuY2UgZWxlbWVudHNcblx0XHRcdC8vIGRvbid0IGhhdmUgbm9kZU5hbWUgZGVmaW5lZCBvbiB0aGVtLCBvciBzdHJpbmdzIGFyZSBvZiB0eXBlXG5cdFx0XHQvLyBTVkdBbmltYXRlZFN0cmluZy5cblx0XHRcdGlmICggKCB0eXBlb2YgZWxlLm5vZGVOYW1lID09PSBcInN0cmluZ1wiICkgJiYgZWxlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiYVwiICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGVsZSA9IGVsZS5wYXJlbnROb2RlO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlO1xuXHR9XG5cblx0JC5tb2JpbGUubG9hZFBhZ2UgPSBmdW5jdGlvbiggdXJsLCBvcHRzICkge1xuXHRcdHZhciBjb250YWluZXI7XG5cblx0XHRvcHRzID0gb3B0cyB8fCB7fTtcblx0XHRjb250YWluZXIgPSAoIG9wdHMucGFnZUNvbnRhaW5lciB8fCAkLm1vYmlsZS5wYWdlQ29udGFpbmVyICk7XG5cblx0XHQvLyBjcmVhdGUgdGhlIGRlZmVycmVkIHRoYXQgd2lsbCBiZSBzdXBwbGllZCB0byBsb2FkUGFnZSBjYWxsZXJzXG5cdFx0Ly8gYW5kIHJlc29sdmVkIGJ5IHRoZSBjb250ZW50IHdpZGdldCdzIGxvYWQgbWV0aG9kXG5cdFx0b3B0cy5kZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcblxuXHRcdC8vIFByZWZlcnJpbmcgdG8gYWxsb3cgZXhjZXB0aW9ucyBmb3IgdW5pbml0aWFsaXplZCBvcHRzLnBhZ2VDb250YWluZXJcblx0XHQvLyB3aWRnZXRzIHNvIHdlIGtub3cgaWYgd2UgbmVlZCB0byBmb3JjZSBpbml0IGhlcmUgZm9yIHVzZXJzXG5cdFx0Y29udGFpbmVyLnBhZ2Vjb250YWluZXIoIFwibG9hZFwiLCB1cmwsIG9wdHMgKTtcblxuXHRcdC8vIHByb3ZpZGUgdGhlIGRlZmVycmVkXG5cdFx0cmV0dXJuIG9wdHMuZGVmZXJyZWQucHJvbWlzZSgpO1xuXHR9O1xuXG5cdC8vZGVmaW5lIHZhcnMgZm9yIGludGVyYWwgdXNlXG5cblx0LyogaW50ZXJuYWwgdXRpbGl0eSBmdW5jdGlvbnMgKi9cblxuXHQvLyBOT1RFIElzc3VlICM0OTUwIEFuZHJvaWQgcGhvbmVnYXAgZG9lc24ndCBuYXZpZ2F0ZSBiYWNrIHByb3Blcmx5XG5cdC8vICAgICAgd2hlbiBhIGZ1bGwgcGFnZSByZWZyZXNoIGhhcyB0YWtlbiBwbGFjZS4gSXQgYXBwZWFycyB0aGF0IGhhc2hjaGFuZ2Vcblx0Ly8gICAgICBhbmQgcmVwbGFjZXN0YXRlIGhpc3RvcnkgYWx0ZXJhdGlvbnMgd29yayBmaW5lIGJ1dCB3ZSBuZWVkIHRvIHN1cHBvcnRcblx0Ly8gICAgICBib3RoIGZvcm1zIG9mIGhpc3RvcnkgdHJhdmVyc2FsIGluIG91ciBjb2RlIHRoYXQgdXNlcyBiYWNrd2FyZCBoaXN0b3J5XG5cdC8vICAgICAgbW92ZW1lbnRcblx0JC5tb2JpbGUuYmFjayA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuYXYgPSB3aW5kb3cubmF2aWdhdG9yO1xuXG5cdFx0Ly8gaWYgdGhlIHNldHRpbmcgaXMgb24gYW5kIHRoZSBuYXZpZ2F0b3Igb2JqZWN0IGlzXG5cdFx0Ly8gYXZhaWxhYmxlIHVzZSB0aGUgcGhvbmVnYXAgbmF2aWdhdGlvbiBjYXBhYmlsaXR5XG5cdFx0aWYgKCB0aGlzLnBob25lZ2FwTmF2aWdhdGlvbkVuYWJsZWQgJiZcblx0XHRcdG5hdiAmJlxuXHRcdFx0bmF2LmFwcCAmJlxuXHRcdFx0bmF2LmFwcC5iYWNrSGlzdG9yeSApIHtcblx0XHRcdG5hdi5hcHAuYmFja0hpc3RvcnkoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JC5tb2JpbGUucGFnZUNvbnRhaW5lci5wYWdlY29udGFpbmVyKCBcImJhY2tcIiApO1xuXHRcdH1cblx0fTtcblxuXHQvLyBEaXJlY3QgZm9jdXMgdG8gdGhlIHBhZ2UgdGl0bGUsIG9yIG90aGVyd2lzZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudFxuXHQkLm1vYmlsZS5mb2N1c1BhZ2UgPSBmdW5jdGlvbiAoIHBhZ2UgKSB7XG5cdFx0dmFyIGF1dG9mb2N1cyA9IHBhZ2UuZmluZCggXCJbYXV0b2ZvY3VzXVwiICksXG5cdFx0XHRwYWdlVGl0bGUgPSBwYWdlLmZpbmQoIFwiLnVpLXRpdGxlOmVxKDApXCIgKTtcblxuXHRcdGlmICggYXV0b2ZvY3VzLmxlbmd0aCApIHtcblx0XHRcdGF1dG9mb2N1cy5mb2N1cygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggcGFnZVRpdGxlLmxlbmd0aCApIHtcblx0XHRcdHBhZ2VUaXRsZS5mb2N1cygpO1xuXHRcdH0gZWxzZXtcblx0XHRcdHBhZ2UuZm9jdXMoKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gTm8tb3AgaW1wbGVtZW50YXRpb24gb2YgdHJhbnNpdGlvbiBkZWdyYWRhdGlvblxuXHQkLm1vYmlsZS5fbWF5YmVEZWdyYWRlVHJhbnNpdGlvbiA9ICQubW9iaWxlLl9tYXliZURlZ3JhZGVUcmFuc2l0aW9uIHx8IGZ1bmN0aW9uKCB0cmFuc2l0aW9uICkge1xuXHRcdHJldHVybiB0cmFuc2l0aW9uO1xuXHR9O1xuXG5cdC8vIEV4cG9zZWQgJC5tb2JpbGUgbWV0aG9kc1xuXG5cdCQubW9iaWxlLmNoYW5nZVBhZ2UgPSBmdW5jdGlvbiggdG8sIG9wdGlvbnMgKSB7XG5cdFx0JC5tb2JpbGUucGFnZUNvbnRhaW5lci5wYWdlY29udGFpbmVyKCBcImNoYW5nZVwiLCB0bywgb3B0aW9ucyApO1xuXHR9O1xuXG5cdCQubW9iaWxlLmNoYW5nZVBhZ2UuZGVmYXVsdHMgPSB7XG5cdFx0dHJhbnNpdGlvbjogdW5kZWZpbmVkLFxuXHRcdHJldmVyc2U6IGZhbHNlLFxuXHRcdGNoYW5nZUhhc2g6IHRydWUsXG5cdFx0ZnJvbUhhc2hDaGFuZ2U6IGZhbHNlLFxuXHRcdHJvbGU6IHVuZGVmaW5lZCwgLy8gQnkgZGVmYXVsdCB3ZSByZWx5IG9uIHRoZSByb2xlIGRlZmluZWQgYnkgdGhlIEBkYXRhLXJvbGUgYXR0cmlidXRlLlxuXHRcdGR1cGxpY2F0ZUNhY2hlZFBhZ2U6IHVuZGVmaW5lZCxcblx0XHRwYWdlQ29udGFpbmVyOiB1bmRlZmluZWQsXG5cdFx0c2hvd0xvYWRNc2c6IHRydWUsIC8vbG9hZGluZyBtZXNzYWdlIHNob3dzIGJ5IGRlZmF1bHQgd2hlbiBwYWdlcyBhcmUgYmVpbmcgZmV0Y2hlZCBkdXJpbmcgY2hhbmdlUGFnZVxuXHRcdGRhdGFVcmw6IHVuZGVmaW5lZCxcblx0XHRmcm9tUGFnZTogdW5kZWZpbmVkLFxuXHRcdGFsbG93U2FtZVBhZ2VUcmFuc2l0aW9uOiBmYWxzZVxuXHR9O1xuXG5cdCQubW9iaWxlLl9yZWdpc3RlckludGVybmFsRXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGdldEFqYXhGb3JtRGF0YSA9IGZ1bmN0aW9uKCAkZm9ybSwgY2FsY3VsYXRlT25seSApIHtcblx0XHRcdHZhciB1cmwsIHJldCA9IHRydWUsIGZvcm1EYXRhLCB2Y2xpY2tlZE5hbWUsIG1ldGhvZDtcblx0XHRcdGlmICggISQubW9iaWxlLmFqYXhFbmFibGVkIHx8XG5cdFx0XHRcdFx0Ly8gdGVzdCB0aGF0IHRoZSBmb3JtIGlzLCBpdHNlbGYsIGFqYXggZmFsc2Vcblx0XHRcdFx0XHQkZm9ybS5pcyggXCI6anFtRGF0YShhamF4PSdmYWxzZScpXCIgKSB8fFxuXHRcdFx0XHRcdC8vIHRlc3QgdGhhdCAkLm1vYmlsZS5pZ25vcmVDb250ZW50RW5hYmxlZCBpcyBzZXQgYW5kXG5cdFx0XHRcdFx0Ly8gdGhlIGZvcm0gb3Igb25lIG9mIGl0J3MgcGFyZW50cyBpcyBhamF4PWZhbHNlXG5cdFx0XHRcdFx0ISRmb3JtLmpxbUhpamFja2FibGUoKS5sZW5ndGggfHxcblx0XHRcdFx0XHQkZm9ybS5hdHRyKCBcInRhcmdldFwiICkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dXJsID0gKCAkbGFzdFZDbGlja2VkICYmICRsYXN0VkNsaWNrZWQuYXR0ciggXCJmb3JtYWN0aW9uXCIgKSApIHx8XG5cdFx0XHRcdCRmb3JtLmF0dHIoIFwiYWN0aW9uXCIgKTtcblx0XHRcdG1ldGhvZCA9ICggJGZvcm0uYXR0ciggXCJtZXRob2RcIiApIHx8IFwiZ2V0XCIgKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHQvLyBJZiBubyBhY3Rpb24gaXMgc3BlY2lmaWVkLCBicm93c2VycyBkZWZhdWx0IHRvIHVzaW5nIHRoZVxuXHRcdFx0Ly8gVVJMIG9mIHRoZSBkb2N1bWVudCBjb250YWluaW5nIHRoZSBmb3JtLiBTaW5jZSB3ZSBkeW5hbWljYWxseVxuXHRcdFx0Ly8gcHVsbCBpbiBwYWdlcyBmcm9tIGV4dGVybmFsIGRvY3VtZW50cywgdGhlIGZvcm0gc2hvdWxkIHN1Ym1pdFxuXHRcdFx0Ly8gdG8gdGhlIFVSTCBmb3IgdGhlIHNvdXJjZSBkb2N1bWVudCBvZiB0aGUgcGFnZSBjb250YWluaW5nXG5cdFx0XHQvLyB0aGUgZm9ybS5cblx0XHRcdGlmICggIXVybCApIHtcblx0XHRcdFx0Ly8gR2V0IHRoZSBAZGF0YS11cmwgZm9yIHRoZSBwYWdlIGNvbnRhaW5pbmcgdGhlIGZvcm0uXG5cdFx0XHRcdHVybCA9ICQubW9iaWxlLmdldENsb3Nlc3RCYXNlVXJsKCAkZm9ybSApO1xuXG5cdFx0XHRcdC8vIE5PVEU6IElmIHRoZSBtZXRob2QgaXMgXCJnZXRcIiwgd2UgbmVlZCB0byBzdHJpcCBvZmYgdGhlIHF1ZXJ5IHN0cmluZ1xuXHRcdFx0XHQvLyBiZWNhdXNlIGl0IHdpbGwgZ2V0IHJlcGxhY2VkIHdpdGggdGhlIG5ldyBmb3JtIGRhdGEuIFNlZSBpc3N1ZSAjNTcxMC5cblx0XHRcdFx0aWYgKCBtZXRob2QgPT09IFwiZ2V0XCIgKSB7XG5cdFx0XHRcdFx0dXJsID0gJC5tb2JpbGUucGF0aC5wYXJzZVVybCggdXJsICkuaHJlZk5vU2VhcmNoO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB1cmwgPT09ICQubW9iaWxlLnBhdGguZG9jdW1lbnRCYXNlLmhyZWZOb0hhc2ggKSB7XG5cdFx0XHRcdFx0Ly8gVGhlIHVybCB3ZSBnb3QgYmFjayBtYXRjaGVzIHRoZSBkb2N1bWVudCBiYXNlLFxuXHRcdFx0XHRcdC8vIHdoaWNoIG1lYW5zIHRoZSBwYWdlIG11c3QgYmUgYW4gaW50ZXJuYWwvZW1iZWRkZWQgcGFnZSxcblx0XHRcdFx0XHQvLyBzbyBkZWZhdWx0IHRvIHVzaW5nIHRoZSBhY3R1YWwgZG9jdW1lbnQgdXJsIGFzIGEgYnJvd3NlclxuXHRcdFx0XHRcdC8vIHdvdWxkLlxuXHRcdFx0XHRcdHVybCA9IGRvY3VtZW50VXJsLmhyZWZOb1NlYXJjaDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR1cmwgPSAkLm1vYmlsZS5wYXRoLm1ha2VVcmxBYnNvbHV0ZSggIHVybCwgJC5tb2JpbGUuZ2V0Q2xvc2VzdEJhc2VVcmwoICRmb3JtICkgKTtcblxuXHRcdFx0aWYgKCAoICQubW9iaWxlLnBhdGguaXNFeHRlcm5hbCggdXJsICkgJiYgISQubW9iaWxlLnBhdGguaXNQZXJtaXR0ZWRDcm9zc0RvbWFpblJlcXVlc3QoIGRvY3VtZW50VXJsLCB1cmwgKSApICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggIWNhbGN1bGF0ZU9ubHkgKSB7XG5cdFx0XHRcdGZvcm1EYXRhID0gJGZvcm0uc2VyaWFsaXplQXJyYXkoKTtcblxuXHRcdFx0XHRpZiAoICRsYXN0VkNsaWNrZWQgJiYgJGxhc3RWQ2xpY2tlZFsgMCBdLmZvcm0gPT09ICRmb3JtWyAwIF0gKSB7XG5cdFx0XHRcdFx0dmNsaWNrZWROYW1lID0gJGxhc3RWQ2xpY2tlZC5hdHRyKCBcIm5hbWVcIiApO1xuXHRcdFx0XHRcdGlmICggdmNsaWNrZWROYW1lICkge1xuXHRcdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoZSBsYXN0IGNsaWNrZWQgZWxlbWVudCBpcyBpbmNsdWRlZCBpbiB0aGUgZm9ybVxuXHRcdFx0XHRcdFx0JC5lYWNoKCBmb3JtRGF0YSwgZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggdmFsdWUubmFtZSA9PT0gdmNsaWNrZWROYW1lICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVuc2V0IHZjbGlja2VkTmFtZSAtIHdlJ3ZlIGZvdW5kIGl0IGluIHRoZSBzZXJpYWxpemVkIGRhdGEgYWxyZWFkeVxuXHRcdFx0XHRcdFx0XHRcdHZjbGlja2VkTmFtZSA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGlmICggdmNsaWNrZWROYW1lICkge1xuXHRcdFx0XHRcdFx0XHRmb3JtRGF0YS5wdXNoKCB7IG5hbWU6IHZjbGlja2VkTmFtZSwgdmFsdWU6ICRsYXN0VkNsaWNrZWQuYXR0ciggXCJ2YWx1ZVwiICkgfSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IHtcblx0XHRcdFx0XHR1cmw6IHVybCxcblx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHR0eXBlOlx0XHRtZXRob2QsXG5cdFx0XHRcdFx0XHRkYXRhOlx0XHQkLnBhcmFtKCBmb3JtRGF0YSApLFxuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbjpcdCRmb3JtLmpxbURhdGEoIFwidHJhbnNpdGlvblwiICksXG5cdFx0XHRcdFx0XHRyZXZlcnNlOlx0JGZvcm0uanFtRGF0YSggXCJkaXJlY3Rpb25cIiApID09PSBcInJldmVyc2VcIixcblx0XHRcdFx0XHRcdHJlbG9hZFBhZ2U6XHR0cnVlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH07XG5cblx0XHQvL2JpbmQgdG8gZm9ybSBzdWJtaXQgZXZlbnRzLCBoYW5kbGUgd2l0aCBBamF4XG5cdFx0JC5tb2JpbGUuZG9jdW1lbnQuZGVsZWdhdGUoIFwiZm9ybVwiLCBcInN1Ym1pdFwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgZm9ybURhdGE7XG5cblx0XHRcdGlmICggIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXHRcdFx0XHRmb3JtRGF0YSA9IGdldEFqYXhGb3JtRGF0YSggJCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggZm9ybURhdGEgKSB7XG5cdFx0XHRcdFx0JC5tb2JpbGUuY2hhbmdlUGFnZSggZm9ybURhdGEudXJsLCBmb3JtRGF0YS5vcHRpb25zICk7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly9hZGQgYWN0aXZlIHN0YXRlIG9uIHZjbGlja1xuXHRcdCQubW9iaWxlLmRvY3VtZW50LmJpbmQoIFwidmNsaWNrXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciAkYnRuLCBidG5FbHMsIHRhcmdldCA9IGV2ZW50LnRhcmdldCwgbmVlZENsb3Nlc3QgPSBmYWxzZTtcblx0XHRcdC8vIGlmIHRoaXMgaXNuJ3QgYSBsZWZ0IGNsaWNrIHdlIGRvbid0IGNhcmUuIEl0cyBpbXBvcnRhbnQgdG8gbm90ZVxuXHRcdFx0Ly8gdGhhdCB3aGVuIHRoZSB2aXJ0dWFsIGV2ZW50IGlzIGdlbmVyYXRlZCBpdCB3aWxsIGNyZWF0ZSB0aGUgd2hpY2ggYXR0clxuXHRcdFx0aWYgKCBldmVudC53aGljaCA+IDEgfHwgISQubW9iaWxlLmxpbmtCaW5kaW5nRW5hYmxlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZWNvcmQgdGhhdCB0aGlzIGVsZW1lbnQgd2FzIGNsaWNrZWQsIGluIGNhc2Ugd2UgbmVlZCBpdCBmb3IgY29ycmVjdFxuXHRcdFx0Ly8gZm9ybSBzdWJtaXNzaW9uIGR1cmluZyB0aGUgXCJzdWJtaXRcIiBoYW5kbGVyIGFib3ZlXG5cdFx0XHQkbGFzdFZDbGlja2VkID0gJCggdGFyZ2V0ICk7XG5cblx0XHRcdC8vIFRyeSB0byBmaW5kIGEgdGFyZ2V0IGVsZW1lbnQgdG8gd2hpY2ggdGhlIGFjdGl2ZSBjbGFzcyB3aWxsIGJlIGFwcGxpZWRcblx0XHRcdGlmICggJC5kYXRhKCB0YXJnZXQsIFwibW9iaWxlLWJ1dHRvblwiICkgKSB7XG5cdFx0XHRcdC8vIElmIHRoZSBmb3JtIHdpbGwgbm90IGJlIHN1Ym1pdHRlZCB2aWEgQUpBWCwgZG8gbm90IGFkZCBhY3RpdmUgY2xhc3Ncblx0XHRcdFx0aWYgKCAhZ2V0QWpheEZvcm1EYXRhKCAkKCB0YXJnZXQgKS5jbG9zZXN0KCBcImZvcm1cIiApLCB0cnVlICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFdlIHdpbGwgYXBwbHkgdGhlIGFjdGl2ZSBzdGF0ZSB0byB0aGlzIGJ1dHRvbiB3aWRnZXQgLSB0aGUgcGFyZW50XG5cdFx0XHRcdC8vIG9mIHRoZSBpbnB1dCB0aGF0IHdhcyBjbGlja2VkIHdpbGwgaGF2ZSB0aGUgYXNzb2NpYXRlZCBkYXRhXG5cdFx0XHRcdGlmICggdGFyZ2V0LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldCA9IGZpbmRDbG9zZXN0TGluayggdGFyZ2V0ICk7XG5cdFx0XHRcdGlmICggISggdGFyZ2V0ICYmICQubW9iaWxlLnBhdGgucGFyc2VVcmwoIHRhcmdldC5nZXRBdHRyaWJ1dGUoIFwiaHJlZlwiICkgfHwgXCIjXCIgKS5oYXNoICE9PSBcIiNcIiApICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRPRE8gdGVhY2ggJC5tb2JpbGUuaGlqYWNrYWJsZSB0byBvcGVyYXRlIG9uIHJhdyBkb20gZWxlbWVudHMgc28gdGhlXG5cdFx0XHRcdC8vIGxpbmsgd3JhcHBpbmcgY2FuIGJlIGF2b2lkZWRcblx0XHRcdFx0aWYgKCAhJCggdGFyZ2V0ICkuanFtSGlqYWNrYWJsZSgpLmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQXZvaWQgY2FsbGluZyAuY2xvc2VzdCBieSB1c2luZyB0aGUgZGF0YSBzZXQgZHVyaW5nIC5idXR0b25NYXJrdXAoKVxuXHRcdFx0Ly8gTGlzdCBpdGVtcyBoYXZlIHRoZSBidXR0b24gZGF0YSBpbiB0aGUgcGFyZW50IG9mIHRoZSBlbGVtZW50IGNsaWNrZWRcblx0XHRcdGlmICggISF+dGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKCBcInVpLWxpbmstaW5oZXJpdFwiICkgKSB7XG5cdFx0XHRcdGlmICggdGFyZ2V0LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0YnRuRWxzID0gJC5kYXRhKCB0YXJnZXQucGFyZW50Tm9kZSwgXCJidXR0b25FbGVtZW50c1wiICk7XG5cdFx0XHRcdH1cblx0XHRcdC8vIE90aGVyd2lzZSwgbG9vayBmb3IgdGhlIGRhdGEgb24gdGhlIHRhcmdldCBpdHNlbGZcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ0bkVscyA9ICQuZGF0YSggdGFyZ2V0LCBcImJ1dHRvbkVsZW1lbnRzXCIgKTtcblx0XHRcdH1cblx0XHRcdC8vIElmIGZvdW5kLCBncmFiIHRoZSBidXR0b24ncyBvdXRlciBlbGVtZW50XG5cdFx0XHRpZiAoIGJ0bkVscyApIHtcblx0XHRcdFx0dGFyZ2V0ID0gYnRuRWxzLm91dGVyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmVlZENsb3Nlc3QgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQkYnRuID0gJCggdGFyZ2V0ICk7XG5cdFx0XHQvLyBJZiB0aGUgb3V0ZXIgZWxlbWVudCB3YXNuJ3QgZm91bmQgYnkgdGhlIG91ciBoZXVyaXN0aWNzLCB1c2UgLmNsb3Nlc3QoKVxuXHRcdFx0aWYgKCBuZWVkQ2xvc2VzdCApIHtcblx0XHRcdFx0JGJ0biA9ICRidG4uY2xvc2VzdCggXCIudWktYnRuXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAkYnRuLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0ISggJGJ0bi5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiIHx8XG5cblx0XHRcdFx0XHQvLyBERVBSRUNBVEVEIGFzIG9mIDEuNC4wIC0gcmVtb3ZlIGFmdGVyIDEuNC4wIHJlbGVhc2Vcblx0XHRcdFx0XHQvLyBvbmx5IHVpLXN0YXRlLWRpc2FibGVkIHNob3VsZCBiZSBwcmVzZW50IHRoZXJlYWZ0ZXJcblx0XHRcdFx0XHQkYnRuLmhhc0NsYXNzKCBcInVpLWRpc2FibGVkXCIgKSApICkgKSB7XG5cdFx0XHRcdCQubW9iaWxlLnJlbW92ZUFjdGl2ZUxpbmtDbGFzcyggdHJ1ZSApO1xuXHRcdFx0XHQkLm1vYmlsZS5hY3RpdmVDbGlja2VkTGluayA9ICRidG47XG5cdFx0XHRcdCQubW9iaWxlLmFjdGl2ZUNsaWNrZWRMaW5rLmFkZENsYXNzKCAkLm1vYmlsZS5hY3RpdmVCdG5DbGFzcyApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gY2xpY2sgcm91dGluZyAtIGRpcmVjdCB0byBIVFRQIG9yIEFqYXgsIGFjY29yZGluZ2x5XG5cdFx0JC5tb2JpbGUuZG9jdW1lbnQuYmluZCggXCJjbGlja1wiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRpZiAoICEkLm1vYmlsZS5saW5rQmluZGluZ0VuYWJsZWQgfHwgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxpbmsgPSBmaW5kQ2xvc2VzdExpbmsoIGV2ZW50LnRhcmdldCApLFxuXHRcdFx0XHQkbGluayA9ICQoIGxpbmsgKSxcblxuXHRcdFx0XHQvL3JlbW92ZSBhY3RpdmUgbGluayBjbGFzcyBpZiBleHRlcm5hbCAodGhlbiBpdCB3b24ndCBiZSB0aGVyZSBpZiB5b3UgY29tZSBiYWNrKVxuXHRcdFx0XHRodHRwQ2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyAkLm1vYmlsZS5yZW1vdmVBY3RpdmVMaW5rQ2xhc3MoIHRydWUgKTsgfSwgMjAwICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGJhc2VVcmwsIGhyZWYsXG5cdFx0XHRcdHVzZURlZmF1bHRVcmxIYW5kbGluZywgaXNFeHRlcm5hbCxcblx0XHRcdFx0dHJhbnNpdGlvbiwgcmV2ZXJzZSwgcm9sZTtcblxuXHRcdFx0Ly8gSWYgYSBidXR0b24gd2FzIGNsaWNrZWQsIGNsZWFuIHVwIHRoZSBhY3RpdmUgY2xhc3MgYWRkZWQgYnkgdmNsaWNrIGFib3ZlXG5cdFx0XHRpZiAoICQubW9iaWxlLmFjdGl2ZUNsaWNrZWRMaW5rICYmXG5cdFx0XHRcdCQubW9iaWxlLmFjdGl2ZUNsaWNrZWRMaW5rWyAwIF0gPT09IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRodHRwQ2xlYW51cCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGVyZSBpcyBubyBsaW5rIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2xpY2sgb3IgaXRzIG5vdCBhIGxlZnRcblx0XHRcdC8vIGNsaWNrIHdlIHdhbnQgdG8gaWdub3JlIHRoZSBjbGlja1xuXHRcdFx0Ly8gVE9ETyB0ZWFjaCAkLm1vYmlsZS5oaWphY2thYmxlIHRvIG9wZXJhdGUgb24gcmF3IGRvbSBlbGVtZW50cyBzbyB0aGUgbGluayB3cmFwcGluZ1xuXHRcdFx0Ly8gY2FuIGJlIGF2b2lkZWRcblx0XHRcdGlmICggIWxpbmsgfHwgZXZlbnQud2hpY2ggPiAxIHx8ICEkbGluay5qcW1IaWphY2thYmxlKCkubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vaWYgdGhlcmUncyBhIGRhdGEtcmVsPWJhY2sgYXR0ciwgZ28gYmFjayBpbiBoaXN0b3J5XG5cdFx0XHRpZiAoICRsaW5rLmlzKCBcIjpqcW1EYXRhKHJlbD0nYmFjaycpXCIgKSApIHtcblx0XHRcdFx0JC5tb2JpbGUuYmFjaygpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGJhc2VVcmwgPSAkLm1vYmlsZS5nZXRDbG9zZXN0QmFzZVVybCggJGxpbmsgKTtcblxuXHRcdFx0Ly9nZXQgaHJlZiwgaWYgZGVmaW5lZCwgb3RoZXJ3aXNlIGRlZmF1bHQgdG8gZW1wdHkgaGFzaFxuXHRcdFx0aHJlZiA9ICQubW9iaWxlLnBhdGgubWFrZVVybEFic29sdXRlKCAkbGluay5hdHRyKCBcImhyZWZcIiApIHx8IFwiI1wiLCBiYXNlVXJsICk7XG5cblx0XHRcdC8vaWYgYWpheCBpcyBkaXNhYmxlZCwgZXhpdCBlYXJseVxuXHRcdFx0aWYgKCAhJC5tb2JpbGUuYWpheEVuYWJsZWQgJiYgISQubW9iaWxlLnBhdGguaXNFbWJlZGRlZFBhZ2UoIGhyZWYgKSApIHtcblx0XHRcdFx0aHR0cENsZWFudXAoKTtcblx0XHRcdFx0Ly91c2UgZGVmYXVsdCBjbGljayBoYW5kbGluZ1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFhYWF9qYmxhczogSWRlYWxseSBsaW5rcyB0byBhcHBsaWNhdGlvbiBwYWdlcyBzaG91bGQgYmUgc3BlY2lmaWVkIGFzXG5cdFx0XHQvLyAgICAgICAgICAgIGFuIHVybCB0byB0aGUgYXBwbGljYXRpb24gZG9jdW1lbnQgd2l0aCBhIGhhc2ggdGhhdCBpcyBlaXRoZXJcblx0XHRcdC8vICAgICAgICAgICAgdGhlIHNpdGUgcmVsYXRpdmUgcGF0aCBvciBpZCB0byB0aGUgcGFnZS4gQnV0IHNvbWUgb2YgdGhlXG5cdFx0XHQvLyAgICAgICAgICAgIGludGVybmFsIGNvZGUgdGhhdCBkeW5hbWljYWxseSBnZW5lcmF0ZXMgc3ViLXBhZ2VzIGZvciBuZXN0ZWRcblx0XHRcdC8vICAgICAgICAgICAgbGlzdHMgYW5kIHNlbGVjdCBkaWFsb2dzLCBqdXN0IHdyaXRlIGEgaGFzaCBpbiB0aGUgbGluayB0aGV5XG5cdFx0XHQvLyAgICAgICAgICAgIGNyZWF0ZS4gVGhpcyBtZWFucyB0aGUgYWN0dWFsIFVSTCBwYXRoIGlzIGJhc2VkIG9uIHdoYXRldmVyXG5cdFx0XHQvLyAgICAgICAgICAgIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBiYXNlIHRhZyBpcyBhdCB0aGUgdGltZSB0aGlzIGNvZGVcblx0XHRcdC8vICAgICAgICAgICAgaXMgY2FsbGVkLiBGb3Igbm93IHdlIGFyZSBqdXN0IGFzc3VtaW5nIHRoYXQgYW55IHVybCB3aXRoIGFcblx0XHRcdC8vICAgICAgICAgICAgaGFzaCBpbiBpdCBpcyBhbiBhcHBsaWNhdGlvbiBwYWdlIHJlZmVyZW5jZS5cblx0XHRcdGlmICggaHJlZi5zZWFyY2goIFwiI1wiICkgIT09IC0xICkge1xuXHRcdFx0XHRocmVmID0gaHJlZi5yZXBsYWNlKCAvW14jXSojLywgXCJcIiApO1xuXHRcdFx0XHRpZiAoICFocmVmICkge1xuXHRcdFx0XHRcdC8vbGluayB3YXMgYW4gZW1wdHkgaGFzaCBtZWFudCBwdXJlbHlcblx0XHRcdFx0XHQvL2ZvciBpbnRlcmFjdGlvbiwgc28gd2UgaWdub3JlIGl0LlxuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCAkLm1vYmlsZS5wYXRoLmlzUGF0aCggaHJlZiApICkge1xuXHRcdFx0XHRcdC8vd2UgaGF2ZSBhcGF0aCBzbyBtYWtlIGl0IHRoZSBocmVmIHdlIHdhbnQgdG8gbG9hZC5cblx0XHRcdFx0XHRocmVmID0gJC5tb2JpbGUucGF0aC5tYWtlVXJsQWJzb2x1dGUoIGhyZWYsIGJhc2VVcmwgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvL3dlIGhhdmUgYSBzaW1wbGUgaWQgc28gdXNlIHRoZSBkb2N1bWVudFVybCBhcyBpdHMgYmFzZS5cblx0XHRcdFx0XHRocmVmID0gJC5tb2JpbGUucGF0aC5tYWtlVXJsQWJzb2x1dGUoIFwiI1wiICsgaHJlZiwgZG9jdW1lbnRVcmwuaHJlZk5vSGFzaCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3VsZCB3ZSBoYW5kbGUgdGhpcyBsaW5rLCBvciBsZXQgdGhlIGJyb3dzZXIgZGVhbCB3aXRoIGl0P1xuXHRcdFx0dXNlRGVmYXVsdFVybEhhbmRsaW5nID0gJGxpbmsuaXMoIFwiW3JlbD0nZXh0ZXJuYWwnXVwiICkgfHwgJGxpbmsuaXMoIFwiOmpxbURhdGEoYWpheD0nZmFsc2UnKVwiICkgfHwgJGxpbmsuaXMoIFwiW3RhcmdldF1cIiApO1xuXG5cdFx0XHQvLyBTb21lIGVtYmVkZGVkIGJyb3dzZXJzLCBsaWtlIHRoZSB3ZWIgdmlldyBpbiBQaG9uZSBHYXAsIGFsbG93IGNyb3NzLWRvbWFpbiBYSFJcblx0XHRcdC8vIHJlcXVlc3RzIGlmIHRoZSBkb2N1bWVudCBkb2luZyB0aGUgcmVxdWVzdCB3YXMgbG9hZGVkIHZpYSB0aGUgZmlsZTovLyBwcm90b2NvbC5cblx0XHRcdC8vIFRoaXMgaXMgdXN1YWxseSB0byBhbGxvdyB0aGUgYXBwbGljYXRpb24gdG8gXCJwaG9uZSBob21lXCIgYW5kIGZldGNoIGFwcCBzcGVjaWZpY1xuXHRcdFx0Ly8gZGF0YS4gV2Ugbm9ybWFsbHkgbGV0IHRoZSBicm93c2VyIGhhbmRsZSBleHRlcm5hbC9jcm9zcy1kb21haW4gdXJscywgYnV0IGlmIHRoZVxuXHRcdFx0Ly8gYWxsb3dDcm9zc0RvbWFpblBhZ2VzIG9wdGlvbiBpcyB0cnVlLCB3ZSB3aWxsIGFsbG93IGNyb3NzLWRvbWFpbiBodHRwL2h0dHBzXG5cdFx0XHQvLyByZXF1ZXN0cyB0byBnbyB0aHJvdWdoIG91ciBwYWdlIGxvYWRpbmcgbG9naWMuXG5cblx0XHRcdC8vY2hlY2sgZm9yIHByb3RvY29sIG9yIHJlbCBhbmQgaXRzIG5vdCBhbiBlbWJlZGRlZCBwYWdlXG5cdFx0XHQvL1RPRE8gb3ZlcmxhcCBpbiBsb2dpYyBmcm9tIGlzRXh0ZXJuYWwsIHJlbD1leHRlcm5hbCBjaGVjayBzaG91bGQgYmVcblx0XHRcdC8vICAgICBtb3ZlZCBpbnRvIG1vcmUgY29tcHJlaGVuc2l2ZSBpc0V4dGVybmFsTGlua1xuXHRcdFx0aXNFeHRlcm5hbCA9IHVzZURlZmF1bHRVcmxIYW5kbGluZyB8fCAoICQubW9iaWxlLnBhdGguaXNFeHRlcm5hbCggaHJlZiApICYmICEkLm1vYmlsZS5wYXRoLmlzUGVybWl0dGVkQ3Jvc3NEb21haW5SZXF1ZXN0KCBkb2N1bWVudFVybCwgaHJlZiApICk7XG5cblx0XHRcdGlmICggaXNFeHRlcm5hbCApIHtcblx0XHRcdFx0aHR0cENsZWFudXAoKTtcblx0XHRcdFx0Ly91c2UgZGVmYXVsdCBjbGljayBoYW5kbGluZ1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vdXNlIGFqYXhcblx0XHRcdHRyYW5zaXRpb24gPSAkbGluay5qcW1EYXRhKCBcInRyYW5zaXRpb25cIiApO1xuXHRcdFx0cmV2ZXJzZSA9ICRsaW5rLmpxbURhdGEoIFwiZGlyZWN0aW9uXCIgKSA9PT0gXCJyZXZlcnNlXCIgfHxcblx0XHRcdFx0XHRcdC8vIGRlcHJlY2F0ZWQgLSByZW1vdmUgYnkgMS4wXG5cdFx0XHRcdFx0XHQkbGluay5qcW1EYXRhKCBcImJhY2tcIiApO1xuXG5cdFx0XHQvL3RoaXMgbWF5IG5lZWQgdG8gYmUgbW9yZSBzcGVjaWZpYyBhcyB3ZSB1c2UgZGF0YS1yZWwgbW9yZVxuXHRcdFx0cm9sZSA9ICRsaW5rLmF0dHIoIFwiZGF0YS1cIiArICQubW9iaWxlLm5zICsgXCJyZWxcIiApIHx8IHVuZGVmaW5lZDtcblxuXHRcdFx0JC5tb2JpbGUuY2hhbmdlUGFnZSggaHJlZiwgeyB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLCByZXZlcnNlOiByZXZlcnNlLCByb2xlOiByb2xlLCBsaW5rOiAkbGluayB9ICk7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH0pO1xuXG5cdFx0Ly9wcmVmZXRjaCBwYWdlcyB3aGVuIGFuY2hvcnMgd2l0aCBkYXRhLXByZWZldGNoIGFyZSBlbmNvdW50ZXJlZFxuXHRcdCQubW9iaWxlLmRvY3VtZW50LmRlbGVnYXRlKCBcIi51aS1wYWdlXCIsIFwicGFnZXNob3cucHJlZmV0Y2hcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdXJscyA9IFtdO1xuXHRcdFx0JCggdGhpcyApLmZpbmQoIFwiYTpqcW1EYXRhKHByZWZldGNoKVwiICkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyICRsaW5rID0gJCggdGhpcyApLFxuXHRcdFx0XHRcdHVybCA9ICRsaW5rLmF0dHIoIFwiaHJlZlwiICk7XG5cblx0XHRcdFx0aWYgKCB1cmwgJiYgJC5pbkFycmF5KCB1cmwsIHVybHMgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0dXJscy5wdXNoKCB1cmwgKTtcblxuXHRcdFx0XHRcdCQubW9iaWxlLmxvYWRQYWdlKCB1cmwsIHsgcm9sZTogJGxpbmsuYXR0ciggXCJkYXRhLVwiICsgJC5tb2JpbGUubnMgKyBcInJlbFwiICkscHJlZmV0Y2g6IHRydWUgfSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdC8vIFRPRE8gZW5zdXJlIHRoYXQgdGhlIG5hdmlnYXRlIGJpbmRpbmcgaW4gdGhlIGNvbnRlbnQgd2lkZ2V0IGhhcHBlbnMgYXQgdGhlIHJpZ2h0IHRpbWVcblx0XHQkLm1vYmlsZS5wYWdlQ29udGFpbmVyLnBhZ2Vjb250YWluZXIoKTtcblxuXHRcdC8vc2V0IHBhZ2UgbWluLWhlaWdodHMgdG8gYmUgZGV2aWNlIHNwZWNpZmljXG5cdFx0JC5tb2JpbGUuZG9jdW1lbnQuYmluZCggXCJwYWdlc2hvd1wiLCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gV2UgbmVlZCB0byB3YWl0IGZvciB3aW5kb3cubG9hZCB0byBtYWtlIHN1cmUgdGhhdCBzdHlsZXMgaGF2ZSBhbHJlYWR5IGJlZW4gcmVuZGVyZWQsXG5cdFx0XHQvLyBvdGhlcndpc2UgaGVpZ2h0cyBvZiBleHRlcm5hbCB0b29sYmFycyB3aWxsIGhhdmUgdGhlIHdyb25nIHZhbHVlXG5cdFx0XHRpZiAoIGxvYWREZWZlcnJlZCApIHtcblx0XHRcdFx0bG9hZERlZmVycmVkLmRvbmUoICQubW9iaWxlLnJlc2V0QWN0aXZlUGFnZUhlaWdodCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JC5tb2JpbGUucmVzZXRBY3RpdmVQYWdlSGVpZ2h0KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0JC5tb2JpbGUud2luZG93LmJpbmQoIFwidGhyb3R0bGVkcmVzaXplXCIsICQubW9iaWxlLnJlc2V0QWN0aXZlUGFnZUhlaWdodCApO1xuXG5cdH07Ly9uYXZyZWFkeURlZmVycmVkIGRvbmUgY2FsbGJhY2tcblxuXHQkKCBmdW5jdGlvbigpIHsgZG9tcmVhZHlEZWZlcnJlZC5yZXNvbHZlKCk7IH0gKTtcblxuXHQvLyBBY2NvdW50IGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgbG9hZCBldmVudCBoYXMgYWxyZWFkeSBmaXJlZFxuXHRpZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiApIHtcblx0XHRwYWdlSXNGdWxseUxvYWRlZCgpO1xuXHR9IGVsc2Uge1xuXHRcdCQubW9iaWxlLndpbmRvdy5sb2FkKCBwYWdlSXNGdWxseUxvYWRlZCApO1xuXHR9XG5cblx0JC53aGVuKCBkb21yZWFkeURlZmVycmVkLCAkLm1vYmlsZS5uYXZyZWFkeURlZmVycmVkICkuZG9uZSggZnVuY3Rpb24oKSB7ICQubW9iaWxlLl9yZWdpc3RlckludGVybmFsRXZlbnRzKCk7IH0gKTtcbn0pKCBqUXVlcnkgKTtcblxuXG4oZnVuY3Rpb24oICQsIHdpbmRvdywgdW5kZWZpbmVkICkge1xuXG5cdC8vIFRPRE8gcmVtb3ZlIGRpcmVjdCByZWZlcmVuY2VzIHRvICQubW9iaWxlIGFuZCBwcm9wZXJ0aWVzLCB3ZSBzaG91bGRcblx0Ly8gICAgICBmYXZvciBpbmplY3Rpb24gd2l0aCBwYXJhbXMgdG8gdGhlIGNvbnN0cnVjdG9yXG5cdCQubW9iaWxlLlRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmluaXQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9O1xuXG5cdCQuZXh0ZW5kKCQubW9iaWxlLlRyYW5zaXRpb24ucHJvdG90eXBlLCB7XG5cdFx0dG9QcmVDbGFzczogXCIgdWktcGFnZS1wcmUtaW5cIixcblxuXHRcdGluaXQ6IGZ1bmN0aW9uKCBuYW1lLCByZXZlcnNlLCAkdG8sICRmcm9tICkge1xuXHRcdFx0JC5leHRlbmQodGhpcywge1xuXHRcdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0XHRyZXZlcnNlOiByZXZlcnNlLFxuXHRcdFx0XHQkdG86ICR0byxcblx0XHRcdFx0JGZyb206ICRmcm9tLFxuXHRcdFx0XHRkZWZlcnJlZDogbmV3ICQuRGVmZXJyZWQoKVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGNsZWFuRnJvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLiRmcm9tXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggJC5tb2JpbGUuYWN0aXZlUGFnZUNsYXNzICsgXCIgb3V0IGluIHJldmVyc2UgXCIgKyB0aGlzLm5hbWUgKVxuXHRcdFx0XHQuaGVpZ2h0KCBcIlwiICk7XG5cdFx0fSxcblxuXHRcdC8vIE5PVEUgb3ZlcnJpZGRlbiBieSBjaGlsZCBvYmplY3QgcHJvdG90eXBlcywgbm9vcCdkIGhlcmUgYXMgZGVmYXVsdHNcblx0XHRiZWZvcmVEb25lSW46IGZ1bmN0aW9uKCkge30sXG5cdFx0YmVmb3JlRG9uZU91dDogZnVuY3Rpb24oKSB7fSxcblx0XHRiZWZvcmVTdGFydE91dDogZnVuY3Rpb24oKSB7fSxcblxuXHRcdGRvbmVJbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmJlZm9yZURvbmVJbigpO1xuXG5cdFx0XHR0aGlzLiR0by5yZW1vdmVDbGFzcyggXCJvdXQgaW4gcmV2ZXJzZSBcIiArIHRoaXMubmFtZSApLmhlaWdodCggXCJcIiApO1xuXG5cdFx0XHR0aGlzLnRvZ2dsZVZpZXdwb3J0Q2xhc3MoKTtcblxuXHRcdFx0Ly8gSW4gc29tZSBicm93c2VycyAoaU9TNSksIDNEIHRyYW5zaXRpb25zIGJsb2NrIHRoZSBhYmlsaXR5IHRvIHNjcm9sbCB0byB0aGUgZGVzaXJlZCBsb2NhdGlvbiBkdXJpbmcgdHJhbnNpdGlvblxuXHRcdFx0Ly8gVGhpcyBlbnN1cmVzIHdlIGp1bXAgdG8gdGhhdCBzcG90IGFmdGVyIHRoZSBmYWN0LCBpZiB3ZSBhcmVuJ3QgdGhlcmUgYWxyZWFkeS5cblx0XHRcdGlmICggJC5tb2JpbGUud2luZG93LnNjcm9sbFRvcCgpICE9PSB0aGlzLnRvU2Nyb2xsICkge1xuXHRcdFx0XHR0aGlzLnNjcm9sbFBhZ2UoKTtcblx0XHRcdH1cblx0XHRcdGlmICggIXRoaXMuc2VxdWVudGlhbCApIHtcblx0XHRcdFx0dGhpcy4kdG8uYWRkQ2xhc3MoICQubW9iaWxlLmFjdGl2ZVBhZ2VDbGFzcyApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5kZWZlcnJlZC5yZXNvbHZlKCB0aGlzLm5hbWUsIHRoaXMucmV2ZXJzZSwgdGhpcy4kdG8sIHRoaXMuJGZyb20sIHRydWUgKTtcblx0XHR9LFxuXG5cdFx0ZG9uZU91dDogZnVuY3Rpb24oIHNjcmVlbkhlaWdodCwgcmV2ZXJzZUNsYXNzLCBub25lLCBwcmV2ZW50Rm9jdXMgKSB7XG5cdFx0XHR0aGlzLmJlZm9yZURvbmVPdXQoKTtcblx0XHRcdHRoaXMuc3RhcnRJbiggc2NyZWVuSGVpZ2h0LCByZXZlcnNlQ2xhc3MsIG5vbmUsIHByZXZlbnRGb2N1cyApO1xuXHRcdH0sXG5cblx0XHRoaWRlSW46IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRcdC8vIFByZXZlbnQgZmxpY2tlcmluZyBpbiBwaG9uZWdhcCBjb250YWluZXI6IHNlZSBjb21tZW50cyBhdCAjNDAyNCByZWdhcmRpbmcgaU9TXG5cdFx0XHR0aGlzLiR0by5jc3MoIFwiei1pbmRleFwiLCAtMTAgKTtcblx0XHRcdGNhbGxiYWNrLmNhbGwoIHRoaXMgKTtcblx0XHRcdHRoaXMuJHRvLmNzcyggXCJ6LWluZGV4XCIsIFwiXCIgKTtcblx0XHR9LFxuXG5cdFx0c2Nyb2xsUGFnZTogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBCeSB1c2luZyBzY3JvbGxUbyBpbnN0ZWFkIG9mIHNpbGVudFNjcm9sbCwgd2UgY2FuIGtlZXAgdGhpbmdzIGJldHRlciBpbiBvcmRlclxuXHRcdFx0Ly8gSnVzdCB0byBiZSBwcmVjYXV0aW9zLCBkaXNhYmxlIHNjcm9sbHN0YXJ0IGxpc3RlbmluZyBsaWtlIHNpbGVudFNjcm9sbCB3b3VsZFxuXHRcdFx0JC5ldmVudC5zcGVjaWFsLnNjcm9sbHN0YXJ0LmVuYWJsZWQgPSBmYWxzZTtcblx0XHRcdC8vaWYgd2UgYXJlIGhpZGluZyB0aGUgdXJsIGJhciBvciB0aGUgcGFnZSB3YXMgcHJldmlvdXNseSBzY3JvbGxlZCBzY3JvbGwgdG8gaGlkZSBvciByZXR1cm4gdG8gcG9zaXRpb25cblx0XHRcdGlmICggJC5tb2JpbGUuaGlkZVVybEJhciB8fCB0aGlzLnRvU2Nyb2xsICE9PSAkLm1vYmlsZS5kZWZhdWx0SG9tZVNjcm9sbCApIHtcblx0XHRcdFx0d2luZG93LnNjcm9sbFRvKCAwLCB0aGlzLnRvU2Nyb2xsICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlZW5hYmxlIHNjcm9sbHN0YXJ0IGxpc3RlbmluZyBsaWtlIHNpbGVudFNjcm9sbCB3b3VsZFxuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQuZXZlbnQuc3BlY2lhbC5zY3JvbGxzdGFydC5lbmFibGVkID0gdHJ1ZTtcblx0XHRcdH0sIDE1MCApO1xuXHRcdH0sXG5cblx0XHRzdGFydEluOiBmdW5jdGlvbiggc2NyZWVuSGVpZ2h0LCByZXZlcnNlQ2xhc3MsIG5vbmUsIHByZXZlbnRGb2N1cyApIHtcblx0XHRcdHRoaXMuaGlkZUluKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLiR0by5hZGRDbGFzcyggJC5tb2JpbGUuYWN0aXZlUGFnZUNsYXNzICsgdGhpcy50b1ByZUNsYXNzICk7XG5cblx0XHRcdFx0Ly8gU2VuZCBmb2N1cyB0byBwYWdlIGFzIGl0IGlzIG5vdyBkaXNwbGF5OiBibG9ja1xuXHRcdFx0XHRpZiAoICFwcmV2ZW50Rm9jdXMgKSB7XG5cdFx0XHRcdFx0JC5tb2JpbGUuZm9jdXNQYWdlKCB0aGlzLiR0byApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IHRvIHBhZ2UgaGVpZ2h0XG5cdFx0XHRcdHRoaXMuJHRvLmhlaWdodCggc2NyZWVuSGVpZ2h0ICsgdGhpcy50b1Njcm9sbCApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAhbm9uZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxQYWdlKCk7XG4gICAgICAgICAgICAgICAgfVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuJHRvXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggdGhpcy50b1ByZUNsYXNzIClcblx0XHRcdFx0LmFkZENsYXNzKCB0aGlzLm5hbWUgKyBcIiBpbiBcIiArIHJldmVyc2VDbGFzcyApO1xuXG5cdFx0XHRpZiAoICFub25lICkge1xuXHRcdFx0XHR0aGlzLiR0by5hbmltYXRpb25Db21wbGV0ZSggJC5wcm94eShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLmRvbmVJbigpO1xuXHRcdFx0XHR9LCB0aGlzICkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5kb25lSW4oKTtcblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRzdGFydE91dDogZnVuY3Rpb24oIHNjcmVlbkhlaWdodCwgcmV2ZXJzZUNsYXNzLCBub25lICkge1xuXHRcdFx0dGhpcy5iZWZvcmVTdGFydE91dCggc2NyZWVuSGVpZ2h0LCByZXZlcnNlQ2xhc3MsIG5vbmUgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBmcm9tIHBhZ2UncyBoZWlnaHQgYW5kIHN0YXJ0IGl0IHRyYW5zaXRpb25pbmcgb3V0XG5cdFx0XHQvLyBOb3RlOiBzZXR0aW5nIGFuIGV4cGxpY2l0IGhlaWdodCBoZWxwcyBlbGltaW5hdGUgdGlsaW5nIGluIHRoZSB0cmFuc2l0aW9uc1xuXHRcdFx0dGhpcy4kZnJvbVxuXHRcdFx0XHQuaGVpZ2h0KCBzY3JlZW5IZWlnaHQgKyAkLm1vYmlsZS53aW5kb3cuc2Nyb2xsVG9wKCkgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIHRoaXMubmFtZSArIFwiIG91dFwiICsgcmV2ZXJzZUNsYXNzICk7XG5cdFx0fSxcblxuXHRcdHRvZ2dsZVZpZXdwb3J0Q2xhc3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0JC5tb2JpbGUucGFnZUNvbnRhaW5lci50b2dnbGVDbGFzcyggXCJ1aS1tb2JpbGUtdmlld3BvcnQtdHJhbnNpdGlvbmluZyB2aWV3cG9ydC1cIiArIHRoaXMubmFtZSApO1xuXHRcdH0sXG5cblx0XHR0cmFuc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIE5PVEUgbWFueSBvZiB0aGVzZSBjb3VsZCBiZSBjYWxjdWxhdGVkL3JlY29yZGVkIGluIHRoZSBjb25zdHJ1Y3RvciwgaXQncyBteVxuXHRcdFx0Ly8gICAgICBvcGluaW9uIHRoYXQgYmluZGluZyB0aGVtIGFzIGxhdGUgYXMgcG9zc2libGUgaGFzIHZhbHVlIHdpdGggcmVnYXJkcyB0b1xuXHRcdFx0Ly8gICAgICBiZXR0ZXIgdHJhbnNpdGlvbnMgd2l0aCBmZXdlciBidWdzLiBJZSwgaXQncyBub3QgZ3VhcmFudGVlZCB0aGF0IHRoZVxuXHRcdFx0Ly8gICAgICBvYmplY3Qgd2lsbCBiZSBjcmVhdGVkIGFuZCB0cmFuc2l0aW9uIHdpbGwgYmUgcnVuIGltbWVkaWF0ZWx5IGFmdGVyIGFzXG5cdFx0XHQvLyAgICAgIGl0IGlzIHRvZGF5LiBTbyB3ZSB3YWl0IHVudGlsIHRyYW5zaXRpb24gaXMgaW52b2tlZCB0byBnYXRoZXIgdGhlIGZvbGxvd2luZ1xuXHRcdFx0dmFyIG5vbmUsXG5cdFx0XHRcdHJldmVyc2VDbGFzcyA9IHRoaXMucmV2ZXJzZSA/IFwiIHJldmVyc2VcIiA6IFwiXCIsXG5cdFx0XHRcdHNjcmVlbkhlaWdodCA9ICQubW9iaWxlLmdldFNjcmVlbkhlaWdodCgpLFxuXHRcdFx0XHRtYXhUcmFuc2l0aW9uT3ZlcnJpZGUgPSAkLm1vYmlsZS5tYXhUcmFuc2l0aW9uV2lkdGggIT09IGZhbHNlICYmXG5cdFx0XHRcdFx0JC5tb2JpbGUud2luZG93LndpZHRoKCkgPiAkLm1vYmlsZS5tYXhUcmFuc2l0aW9uV2lkdGg7XG5cblx0XHRcdHRoaXMudG9TY3JvbGwgPSAkLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5LmdldEFjdGl2ZSgpLmxhc3RTY3JvbGwgfHwgJC5tb2JpbGUuZGVmYXVsdEhvbWVTY3JvbGw7XG5cblx0XHRcdG5vbmUgPSAhJC5zdXBwb3J0LmNzc1RyYW5zaXRpb25zIHx8ICEkLnN1cHBvcnQuY3NzQW5pbWF0aW9ucyB8fFxuXHRcdFx0XHRtYXhUcmFuc2l0aW9uT3ZlcnJpZGUgfHwgIXRoaXMubmFtZSB8fCB0aGlzLm5hbWUgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRcdE1hdGgubWF4KCAkLm1vYmlsZS53aW5kb3cuc2Nyb2xsVG9wKCksIHRoaXMudG9TY3JvbGwgKSA+XG5cdFx0XHRcdFx0JC5tb2JpbGUuZ2V0TWF4U2Nyb2xsRm9yVHJhbnNpdGlvbigpO1xuXG5cdFx0XHR0aGlzLnRvZ2dsZVZpZXdwb3J0Q2xhc3MoKTtcblxuXHRcdFx0aWYgKCB0aGlzLiRmcm9tICYmICFub25lICkge1xuXHRcdFx0XHR0aGlzLnN0YXJ0T3V0KCBzY3JlZW5IZWlnaHQsIHJldmVyc2VDbGFzcywgbm9uZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5kb25lT3V0KCBzY3JlZW5IZWlnaHQsIHJldmVyc2VDbGFzcywgbm9uZSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5kZWZlcnJlZC5wcm9taXNlKCk7XG5cdFx0fVxuXHR9KTtcbn0pKCBqUXVlcnksIHRoaXMgKTtcblxuXG4oZnVuY3Rpb24oICQgKSB7XG5cblx0JC5tb2JpbGUuU2VyaWFsVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9O1xuXG5cdCQuZXh0ZW5kKCQubW9iaWxlLlNlcmlhbFRyYW5zaXRpb24ucHJvdG90eXBlLCAkLm1vYmlsZS5UcmFuc2l0aW9uLnByb3RvdHlwZSwge1xuXHRcdHNlcXVlbnRpYWw6IHRydWUsXG5cblx0XHRiZWZvcmVEb25lT3V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggdGhpcy4kZnJvbSApIHtcblx0XHRcdFx0dGhpcy5jbGVhbkZyb20oKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JlU3RhcnRPdXQ6IGZ1bmN0aW9uKCBzY3JlZW5IZWlnaHQsIHJldmVyc2VDbGFzcywgbm9uZSApIHtcblx0XHRcdHRoaXMuJGZyb20uYW5pbWF0aW9uQ29tcGxldGUoJC5wcm94eShmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5kb25lT3V0KCBzY3JlZW5IZWlnaHQsIHJldmVyc2VDbGFzcywgbm9uZSApO1xuXHRcdFx0fSwgdGhpcyApKTtcblx0XHR9XG5cdH0pO1xuXG59KSggalF1ZXJ5ICk7XG5cblxuKGZ1bmN0aW9uKCAkICkge1xuXG5cdCQubW9iaWxlLkNvbmN1cnJlbnRUcmFuc2l0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH07XG5cblx0JC5leHRlbmQoJC5tb2JpbGUuQ29uY3VycmVudFRyYW5zaXRpb24ucHJvdG90eXBlLCAkLm1vYmlsZS5UcmFuc2l0aW9uLnByb3RvdHlwZSwge1xuXHRcdHNlcXVlbnRpYWw6IGZhbHNlLFxuXG5cdFx0YmVmb3JlRG9uZUluOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggdGhpcy4kZnJvbSApIHtcblx0XHRcdFx0dGhpcy5jbGVhbkZyb20oKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JlU3RhcnRPdXQ6IGZ1bmN0aW9uKCBzY3JlZW5IZWlnaHQsIHJldmVyc2VDbGFzcywgbm9uZSApIHtcblx0XHRcdHRoaXMuZG9uZU91dCggc2NyZWVuSGVpZ2h0LCByZXZlcnNlQ2xhc3MsIG5vbmUgKTtcblx0XHR9XG5cdH0pO1xuXG59KSggalF1ZXJ5ICk7XG5cblxuKGZ1bmN0aW9uKCAkICkge1xuXG5cdC8vIGdlbmVyYXRlIHRoZSBoYW5kbGVycyBmcm9tIHRoZSBhYm92ZVxuXHR2YXIgZGVmYXVsdEdldE1heFNjcm9sbEZvclRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJC5tb2JpbGUuZ2V0U2NyZWVuSGVpZ2h0KCkgKiAzO1xuXHR9O1xuXG5cdC8vdHJhbnNpdGlvbiBoYW5kbGVyIGRpY3Rpb25hcnkgZm9yIDNyZCBwYXJ0eSB0cmFuc2l0aW9uc1xuXHQkLm1vYmlsZS50cmFuc2l0aW9uSGFuZGxlcnMgPSB7XG5cdFx0XCJzZXF1ZW50aWFsXCI6ICQubW9iaWxlLlNlcmlhbFRyYW5zaXRpb24sXG5cdFx0XCJzaW11bHRhbmVvdXNcIjogJC5tb2JpbGUuQ29uY3VycmVudFRyYW5zaXRpb25cblx0fTtcblxuXHQvLyBNYWtlIG91ciB0cmFuc2l0aW9uIGhhbmRsZXIgdGhlIHB1YmxpYyBkZWZhdWx0LlxuXHQkLm1vYmlsZS5kZWZhdWx0VHJhbnNpdGlvbkhhbmRsZXIgPSAkLm1vYmlsZS50cmFuc2l0aW9uSGFuZGxlcnMuc2VxdWVudGlhbDtcblxuXHQkLm1vYmlsZS50cmFuc2l0aW9uRmFsbGJhY2tzID0ge307XG5cblx0Ly8gSWYgdHJhbnNpdGlvbiBpcyBkZWZpbmVkLCBjaGVjayBpZiBjc3MgM0QgdHJhbnNmb3JtcyBhcmUgc3VwcG9ydGVkLCBhbmQgaWYgbm90LCBpZiBhIGZhbGxiYWNrIGlzIHNwZWNpZmllZFxuXHQkLm1vYmlsZS5fbWF5YmVEZWdyYWRlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCB0cmFuc2l0aW9uICkge1xuXHRcdGlmICggdHJhbnNpdGlvbiAmJiAhJC5zdXBwb3J0LmNzc1RyYW5zZm9ybTNkICYmICQubW9iaWxlLnRyYW5zaXRpb25GYWxsYmFja3NbIHRyYW5zaXRpb24gXSApIHtcblx0XHRcdHRyYW5zaXRpb24gPSAkLm1vYmlsZS50cmFuc2l0aW9uRmFsbGJhY2tzWyB0cmFuc2l0aW9uIF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRyYW5zaXRpb247XG5cdH07XG5cblx0Ly8gU2V0IHRoZSBnZXRNYXhTY3JvbGxGb3JUcmFuc2l0aW9uIHRvIGRlZmF1bHQgaWYgbm8gaW1wbGVtZW50YXRpb24gd2FzIHNldCBieSB1c2VyXG5cdCQubW9iaWxlLmdldE1heFNjcm9sbEZvclRyYW5zaXRpb24gPSAkLm1vYmlsZS5nZXRNYXhTY3JvbGxGb3JUcmFuc2l0aW9uIHx8IGRlZmF1bHRHZXRNYXhTY3JvbGxGb3JUcmFuc2l0aW9uO1xuXG59KSggalF1ZXJ5ICk7XG5cbi8qXG4qIGZhbGxiYWNrIHRyYW5zaXRpb24gZm9yIGZsaXAgaW4gbm9uLTNEIHN1cHBvcnRpbmcgYnJvd3NlcnMgKHdoaWNoIHRlbmQgdG8gaGFuZGxlIGNvbXBsZXggdHJhbnNpdGlvbnMgcG9vcmx5IGluIGdlbmVyYWxcbiovXG5cbihmdW5jdGlvbiggJCwgd2luZG93LCB1bmRlZmluZWQgKSB7XG5cbiQubW9iaWxlLnRyYW5zaXRpb25GYWxsYmFja3MuZmxpcCA9IFwiZmFkZVwiO1xuXG59KSggalF1ZXJ5LCB0aGlzICk7XG5cbi8qXG4qIGZhbGxiYWNrIHRyYW5zaXRpb24gZm9yIGZsb3cgaW4gbm9uLTNEIHN1cHBvcnRpbmcgYnJvd3NlcnMgKHdoaWNoIHRlbmQgdG8gaGFuZGxlIGNvbXBsZXggdHJhbnNpdGlvbnMgcG9vcmx5IGluIGdlbmVyYWxcbiovXG5cbihmdW5jdGlvbiggJCwgd2luZG93LCB1bmRlZmluZWQgKSB7XG5cbiQubW9iaWxlLnRyYW5zaXRpb25GYWxsYmFja3MuZmxvdyA9IFwiZmFkZVwiO1xuXG59KSggalF1ZXJ5LCB0aGlzICk7XG5cbi8qXG4qIGZhbGxiYWNrIHRyYW5zaXRpb24gZm9yIHBvcCBpbiBub24tM0Qgc3VwcG9ydGluZyBicm93c2VycyAod2hpY2ggdGVuZCB0byBoYW5kbGUgY29tcGxleCB0cmFuc2l0aW9ucyBwb29ybHkgaW4gZ2VuZXJhbFxuKi9cblxuKGZ1bmN0aW9uKCAkLCB3aW5kb3csIHVuZGVmaW5lZCApIHtcblxuJC5tb2JpbGUudHJhbnNpdGlvbkZhbGxiYWNrcy5wb3AgPSBcImZhZGVcIjtcblxufSkoIGpRdWVyeSwgdGhpcyApO1xuXG4vKlxuKiBmYWxsYmFjayB0cmFuc2l0aW9uIGZvciBzbGlkZSBpbiBub24tM0Qgc3VwcG9ydGluZyBicm93c2VycyAod2hpY2ggdGVuZCB0byBoYW5kbGUgY29tcGxleCB0cmFuc2l0aW9ucyBwb29ybHkgaW4gZ2VuZXJhbFxuKi9cblxuKGZ1bmN0aW9uKCAkLCB3aW5kb3csIHVuZGVmaW5lZCApIHtcblxuLy8gVXNlIHRoZSBzaW11bHRhbmVvdXMgdHJhbnNpdGlvbnMgaGFuZGxlciBmb3Igc2xpZGUgdHJhbnNpdGlvbnNcbiQubW9iaWxlLnRyYW5zaXRpb25IYW5kbGVycy5zbGlkZSA9ICQubW9iaWxlLnRyYW5zaXRpb25IYW5kbGVycy5zaW11bHRhbmVvdXM7XG5cbi8vIFNldCB0aGUgc2xpZGUgdHJhbnNpdGlvbnMncyBmYWxsYmFjayB0byBcImZhZGVcIlxuJC5tb2JpbGUudHJhbnNpdGlvbkZhbGxiYWNrcy5zbGlkZSA9IFwiZmFkZVwiO1xuXG59KSggalF1ZXJ5LCB0aGlzICk7XG5cbi8qXG4qIGZhbGxiYWNrIHRyYW5zaXRpb24gZm9yIHNsaWRlZG93biBpbiBub24tM0Qgc3VwcG9ydGluZyBicm93c2VycyAod2hpY2ggdGVuZCB0byBoYW5kbGUgY29tcGxleCB0cmFuc2l0aW9ucyBwb29ybHkgaW4gZ2VuZXJhbFxuKi9cblxuKGZ1bmN0aW9uKCAkLCB3aW5kb3csIHVuZGVmaW5lZCApIHtcblxuJC5tb2JpbGUudHJhbnNpdGlvbkZhbGxiYWNrcy5zbGlkZWRvd24gPSBcImZhZGVcIjtcblxufSkoIGpRdWVyeSwgdGhpcyApO1xuXG4vKlxuKiBmYWxsYmFjayB0cmFuc2l0aW9uIGZvciBzbGlkZWZhZGUgaW4gbm9uLTNEIHN1cHBvcnRpbmcgYnJvd3NlcnMgKHdoaWNoIHRlbmQgdG8gaGFuZGxlIGNvbXBsZXggdHJhbnNpdGlvbnMgcG9vcmx5IGluIGdlbmVyYWxcbiovXG5cbihmdW5jdGlvbiggJCwgd2luZG93LCB1bmRlZmluZWQgKSB7XG5cbi8vIFNldCB0aGUgc2xpZGUgdHJhbnNpdGlvbnMncyBmYWxsYmFjayB0byBcImZhZGVcIlxuJC5tb2JpbGUudHJhbnNpdGlvbkZhbGxiYWNrcy5zbGlkZWZhZGUgPSBcImZhZGVcIjtcblxufSkoIGpRdWVyeSwgdGhpcyApO1xuXG4vKlxuKiBmYWxsYmFjayB0cmFuc2l0aW9uIGZvciBzbGlkZXVwIGluIG5vbi0zRCBzdXBwb3J0aW5nIGJyb3dzZXJzICh3aGljaCB0ZW5kIHRvIGhhbmRsZSBjb21wbGV4IHRyYW5zaXRpb25zIHBvb3JseSBpbiBnZW5lcmFsXG4qL1xuXG4oZnVuY3Rpb24oICQsIHdpbmRvdywgdW5kZWZpbmVkICkge1xuXG4kLm1vYmlsZS50cmFuc2l0aW9uRmFsbGJhY2tzLnNsaWRldXAgPSBcImZhZGVcIjtcblxufSkoIGpRdWVyeSwgdGhpcyApO1xuXG4vKlxuKiBmYWxsYmFjayB0cmFuc2l0aW9uIGZvciB0dXJuIGluIG5vbi0zRCBzdXBwb3J0aW5nIGJyb3dzZXJzICh3aGljaCB0ZW5kIHRvIGhhbmRsZSBjb21wbGV4IHRyYW5zaXRpb25zIHBvb3JseSBpbiBnZW5lcmFsXG4qL1xuXG4oZnVuY3Rpb24oICQsIHdpbmRvdywgdW5kZWZpbmVkICkge1xuXG4kLm1vYmlsZS50cmFuc2l0aW9uRmFsbGJhY2tzLnR1cm4gPSBcImZhZGVcIjtcblxufSkoIGpRdWVyeSwgdGhpcyApO1xuXG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLm1vYmlsZS5kZWdyYWRlSW5wdXRzID0ge1xuXHRjb2xvcjogZmFsc2UsXG5cdGRhdGU6IGZhbHNlLFxuXHRkYXRldGltZTogZmFsc2UsXG5cdFwiZGF0ZXRpbWUtbG9jYWxcIjogZmFsc2UsXG5cdGVtYWlsOiBmYWxzZSxcblx0bW9udGg6IGZhbHNlLFxuXHRudW1iZXI6IGZhbHNlLFxuXHRyYW5nZTogXCJudW1iZXJcIixcblx0c2VhcmNoOiBcInRleHRcIixcblx0dGVsOiBmYWxzZSxcblx0dGltZTogZmFsc2UsXG5cdHVybDogZmFsc2UsXG5cdHdlZWs6IGZhbHNlXG59O1xuLy8gQmFja2NvbXBhdCByZW1vdmUgaW4gMS41XG4kLm1vYmlsZS5wYWdlLnByb3RvdHlwZS5vcHRpb25zLmRlZ3JhZGVJbnB1dHMgPSAkLm1vYmlsZS5kZWdyYWRlSW5wdXRzO1xuXG4vLyBBdXRvIHNlbGYtaW5pdCB3aWRnZXRzXG4kLm1vYmlsZS5kZWdyYWRlSW5wdXRzV2l0aGluID0gZnVuY3Rpb24oIHRhcmdldCApIHtcblxuXHR0YXJnZXQgPSAkKCB0YXJnZXQgKTtcblxuXHQvLyBEZWdyYWRlIGlucHV0cyB0byBhdm9pZCBwb29ybHkgaW1wbGVtZW50ZWQgbmF0aXZlIGZ1bmN0aW9uYWxpdHlcblx0dGFyZ2V0LmZpbmQoIFwiaW5wdXRcIiApLm5vdCggJC5tb2JpbGUucGFnZS5wcm90b3R5cGUua2VlcE5hdGl2ZVNlbGVjdG9yKCkgKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtZW50ID0gJCggdGhpcyApLFxuXHRcdFx0dHlwZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApLFxuXHRcdFx0b3B0VHlwZSA9ICQubW9iaWxlLmRlZ3JhZGVJbnB1dHNbIHR5cGUgXSB8fCBcInRleHRcIixcblx0XHRcdGh0bWwsIGhhc1R5cGUsIGZpbmRzdHIsIHJlcHN0cjtcblxuXHRcdGlmICggJC5tb2JpbGUuZGVncmFkZUlucHV0c1sgdHlwZSBdICkge1xuXHRcdFx0aHRtbCA9ICQoIFwiPGRpdj5cIiApLmh0bWwoIGVsZW1lbnQuY2xvbmUoKSApLmh0bWwoKTtcblx0XHRcdC8vIEluIElFIGJyb3dzZXJzLCB0aGUgdHlwZSBzb21ldGltZXMgZG9lc24ndCBleGlzdCBpbiB0aGUgY2xvbmVkIG1hcmt1cCwgc28gd2UgcmVwbGFjZSB0aGUgY2xvc2luZyB0YWcgaW5zdGVhZFxuXHRcdFx0aGFzVHlwZSA9IGh0bWwuaW5kZXhPZiggXCIgdHlwZT1cIiApID4gLTE7XG5cdFx0XHRmaW5kc3RyID0gaGFzVHlwZSA/IC9cXHMrdHlwZT1bXCInXT9cXHcrWydcIl0/LyA6IC9cXC8/Pi87XG5cdFx0XHRyZXBzdHIgPSBcIiB0eXBlPVxcXCJcIiArIG9wdFR5cGUgKyBcIlxcXCIgZGF0YS1cIiArICQubW9iaWxlLm5zICsgXCJ0eXBlPVxcXCJcIiArIHR5cGUgKyBcIlxcXCJcIiArICggaGFzVHlwZSA/IFwiXCIgOiBcIj5cIiApO1xuXG5cdFx0XHRlbGVtZW50LnJlcGxhY2VXaXRoKCBodG1sLnJlcGxhY2UoIGZpbmRzdHIsIHJlcHN0ciApICk7XG5cdFx0fVxuXHR9KTtcblxufTtcblxufSkoIGpRdWVyeSApO1xuXG4oZnVuY3Rpb24oICQsIHdpbmRvdywgdW5kZWZpbmVkICkge1xuXG4kLndpZGdldCggXCJtb2JpbGUucGFnZVwiLCAkLm1vYmlsZS5wYWdlLCB7XG5cdG9wdGlvbnM6IHtcblxuXHRcdC8vIEFjY2VwdHMgbGVmdCwgcmlnaHQgYW5kIG5vbmVcblx0XHRjbG9zZUJ0bjogXCJsZWZ0XCIsXG5cdFx0Y2xvc2VCdG5UZXh0OiBcIkNsb3NlXCIsXG5cdFx0b3ZlcmxheVRoZW1lOiBcImFcIixcblx0XHRjb3JuZXJzOiB0cnVlLFxuXHRcdGRpYWxvZzogZmFsc2Vcblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmRpYWxvZyApIHtcblxuXHRcdFx0JC5leHRlbmQoIHRoaXMsIHtcblx0XHRcdFx0X2lubmVyOiB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oKSxcblx0XHRcdFx0X2hlYWRlckNsb3NlQnV0dG9uOiBudWxsXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKCAhdGhpcy5vcHRpb25zLmVuaGFuY2VkICkge1xuXHRcdFx0XHR0aGlzLl9zZXRDbG9zZUJ0biggdGhpcy5vcHRpb25zLmNsb3NlQnRuICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9lbmhhbmNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zdXBlcigpO1xuXG5cdFx0Ly8gQ2xhc3MgdGhlIG1hcmt1cCBmb3IgZGlhbG9nIHN0eWxpbmcgYW5kIHdyYXAgaW50ZXJpb3Jcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaWFsb2cgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoIFwidWktZGlhbG9nXCIgKVxuXHRcdFx0XHQud3JhcElubmVyKCAkKCBcIjxkaXYvPlwiLCB7XG5cblx0XHRcdFx0XHQvLyBBUklBIHJvbGVcblx0XHRcdFx0XHRcInJvbGVcIiA6IFwiZGlhbG9nXCIsXG5cdFx0XHRcdFx0XCJjbGFzc1wiIDogXCJ1aS1kaWFsb2ctY29udGFpbiB1aS1vdmVybGF5LXNoYWRvd1wiICtcblx0XHRcdFx0XHRcdCggdGhpcy5vcHRpb25zLmNvcm5lcnMgPyBcIiB1aS1jb3JuZXItYWxsXCIgOiBcIlwiIClcblx0XHRcdFx0fSkpO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGNsb3NlQnV0dG9uTG9jYXRpb24sIGNsb3NlQnV0dG9uVGV4dCxcblx0XHRcdGN1cnJlbnRPcHRzID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKCBvcHRpb25zLmNvcm5lcnMgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuX2lubmVyLnRvZ2dsZUNsYXNzKCBcInVpLWNvcm5lci1hbGxcIiwgISFvcHRpb25zLmNvcm5lcnMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMub3ZlcmxheVRoZW1lICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoICQubW9iaWxlLmFjdGl2ZVBhZ2VbIDAgXSA9PT0gdGhpcy5lbGVtZW50WyAwIF0gKSB7XG5cdFx0XHRcdGN1cnJlbnRPcHRzLm92ZXJsYXlUaGVtZSA9IG9wdGlvbnMub3ZlcmxheVRoZW1lO1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVQYWdlQmVmb3JlU2hvdygpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy5jbG9zZUJ0blRleHQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGNsb3NlQnV0dG9uTG9jYXRpb24gPSBjdXJyZW50T3B0cy5jbG9zZUJ0bjtcblx0XHRcdGNsb3NlQnV0dG9uVGV4dCA9IG9wdGlvbnMuY2xvc2VCdG5UZXh0O1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy5jbG9zZUJ0biAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y2xvc2VCdXR0b25Mb2NhdGlvbiA9IG9wdGlvbnMuY2xvc2VCdG47XG5cdFx0fVxuXG5cdFx0aWYgKCBjbG9zZUJ1dHRvbkxvY2F0aW9uICkge1xuXHRcdFx0dGhpcy5fc2V0Q2xvc2VCdG4oIGNsb3NlQnV0dG9uTG9jYXRpb24sIGNsb3NlQnV0dG9uVGV4dCApO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N1cGVyKCBvcHRpb25zICk7XG5cdH0sXG5cblx0X2hhbmRsZVBhZ2VCZWZvcmVTaG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMub3ZlcmxheVRoZW1lICYmIHRoaXMub3B0aW9ucy5kaWFsb2cgKSB7XG5cdFx0XHR0aGlzLnJlbW92ZUNvbnRhaW5lckJhY2tncm91bmQoKTtcblx0XHRcdHRoaXMuc2V0Q29udGFpbmVyQmFja2dyb3VuZCggdGhpcy5vcHRpb25zLm92ZXJsYXlUaGVtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Q2xvc2VCdG46IGZ1bmN0aW9uKCBsb2NhdGlvbiwgdGV4dCApIHtcblx0XHR2YXIgZHN0LFxuXHRcdFx0YnRuID0gdGhpcy5faGVhZGVyQ2xvc2VCdXR0b247XG5cblx0XHQvLyBTYW5pdGl6ZSB2YWx1ZVxuXHRcdGxvY2F0aW9uID0gXCJsZWZ0XCIgPT09IGxvY2F0aW9uID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIgPT09IGxvY2F0aW9uID8gXCJyaWdodFwiIDogXCJub25lXCI7XG5cblx0XHRpZiAoIFwibm9uZVwiID09PSBsb2NhdGlvbiApIHtcblx0XHRcdGlmICggYnRuICkge1xuXHRcdFx0XHRidG4ucmVtb3ZlKCk7XG5cdFx0XHRcdGJ0biA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICggYnRuICkge1xuXHRcdFx0YnRuLnJlbW92ZUNsYXNzKCBcInVpLWJ0bi1sZWZ0IHVpLWJ0bi1yaWdodFwiICkuYWRkQ2xhc3MoIFwidWktYnRuLVwiICsgbG9jYXRpb24gKTtcblx0XHRcdGlmICggdGV4dCApIHtcblx0XHRcdFx0YnRuLnRleHQoIHRleHQgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZHN0ID0gdGhpcy5faW5uZXIuZmluZCggXCI6anFtRGF0YShyb2xlPSdoZWFkZXInKVwiICkuZmlyc3QoKTtcblx0XHRcdGJ0biA9ICQoIFwiPGE+PC9hPlwiLCB7XG5cdFx0XHRcdFx0XCJocmVmXCI6IFwiI1wiLFxuXHRcdFx0XHRcdFwiY2xhc3NcIjogXCJ1aS1idG4gdWktY29ybmVyLWFsbCB1aS1pY29uLWRlbGV0ZSB1aS1idG4taWNvbi1ub3RleHQgdWktYnRuLVwiICsgbG9jYXRpb25cblx0XHRcdFx0fSlcblx0XHRcdFx0LmF0dHIoIFwiZGF0YS1cIiArICQubW9iaWxlLm5zICsgXCJyZWxcIiwgXCJiYWNrXCIgKVxuXHRcdFx0XHQudGV4dCggdGV4dCB8fCB0aGlzLm9wdGlvbnMuY2xvc2VCdG5UZXh0IHx8IFwiXCIgKVxuXHRcdFx0XHQucHJlcGVuZFRvKCBkc3QgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9oZWFkZXJDbG9zZUJ1dHRvbiA9IGJ0bjtcblx0fVxufSk7XG5cbn0pKCBqUXVlcnksIHRoaXMgKTtcblxuKGZ1bmN0aW9uKCAkLCB3aW5kb3csIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoIFwibW9iaWxlLmRpYWxvZ1wiLCB7XG5cdG9wdGlvbnM6IHtcblxuXHRcdC8vIEFjY2VwdHMgbGVmdCwgcmlnaHQgYW5kIG5vbmVcblx0XHRjbG9zZUJ0bjogXCJsZWZ0XCIsXG5cdFx0Y2xvc2VCdG5UZXh0OiBcIkNsb3NlXCIsXG5cdFx0b3ZlcmxheVRoZW1lOiBcImFcIixcblx0XHRjb3JuZXJzOiB0cnVlXG5cdH0sXG5cblx0Ly8gT3ZlcnJpZGUgdGhlIHRoZW1lIHNldCBieSB0aGUgcGFnZSBwbHVnaW4gb24gcGFnZXNob3dcblx0X2hhbmRsZVBhZ2VCZWZvcmVTaG93OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9pc0Nsb3NlYWJsZSA9IHRydWU7XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMub3ZlcmxheVRoZW1lICkge1xuXHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdC5wYWdlKCBcInJlbW92ZUNvbnRhaW5lckJhY2tncm91bmRcIiApXG5cdFx0XHRcdC5wYWdlKCBcInNldENvbnRhaW5lckJhY2tncm91bmRcIiwgdGhpcy5vcHRpb25zLm92ZXJsYXlUaGVtZSApO1xuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlUGFnZUJlZm9yZUhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2lzQ2xvc2VhYmxlID0gZmFsc2U7XG5cdH0sXG5cblx0Ly8gY2xpY2sgYW5kIHN1Ym1pdCBldmVudHM6XG5cdC8vIC0gY2xpY2tzIGFuZCBzdWJtaXRzIHNob3VsZCB1c2UgdGhlIGNsb3NpbmcgdHJhbnNpdGlvbiB0aGF0IHRoZSBkaWFsb2dcblx0Ly8gICBvcGVuZWQgd2l0aCB1bmxlc3MgYSBkYXRhLXRyYW5zaXRpb24gaXMgc3BlY2lmaWVkIG9uIHRoZSBsaW5rL2Zvcm1cblx0Ly8gLSBpZiB0aGUgY2xpY2sgd2FzIG9uIHRoZSBjbG9zZSBidXR0b24sIG9yIHRoZSBsaW5rIGhhcyBhIGRhdGEtcmVsPVwiYmFja1wiXG5cdC8vICAgaXQnbGwgZ28gYmFjayBpbiBoaXN0b3J5IG5hdHVyYWxseVxuXHRfaGFuZGxlVkNsaWNrU3VibWl0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGF0dHJzLFxuXHRcdFx0JHRhcmdldCA9ICQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIGV2ZW50LnR5cGUgPT09IFwidmNsaWNrXCIgPyBcImFcIiA6IFwiZm9ybVwiICk7XG5cblx0XHRpZiAoICR0YXJnZXQubGVuZ3RoICYmICEkdGFyZ2V0LmpxbURhdGEoIFwidHJhbnNpdGlvblwiICkgKSB7XG5cdFx0XHRhdHRycyA9IHt9O1xuXHRcdFx0YXR0cnNbIFwiZGF0YS1cIiArICQubW9iaWxlLm5zICsgXCJ0cmFuc2l0aW9uXCIgXSA9XG5cdFx0XHRcdCggJC5tb2JpbGUubmF2aWdhdGUuaGlzdG9yeS5nZXRBY3RpdmUoKSB8fCB7fSApWyBcInRyYW5zaXRpb25cIiBdIHx8XG5cdFx0XHRcdCQubW9iaWxlLmRlZmF1bHREaWFsb2dUcmFuc2l0aW9uO1xuXHRcdFx0YXR0cnNbIFwiZGF0YS1cIiArICQubW9iaWxlLm5zICsgXCJkaXJlY3Rpb25cIiBdID0gXCJyZXZlcnNlXCI7XG5cdFx0XHQkdGFyZ2V0LmF0dHIoIGF0dHJzICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0b3B0cyA9IHRoaXMub3B0aW9ucztcblxuXHRcdC8vIENsYXNzIHRoZSBtYXJrdXAgZm9yIGRpYWxvZyBzdHlsaW5nIGFuZCB3cmFwIGludGVyaW9yXG5cdFx0ZWxlbS5hZGRDbGFzcyggXCJ1aS1kaWFsb2dcIiApXG5cdFx0XHQud3JhcElubmVyKCAkKCBcIjxkaXYvPlwiLCB7XG5cblx0XHRcdFx0Ly8gQVJJQSByb2xlXG5cdFx0XHRcdFwicm9sZVwiIDogXCJkaWFsb2dcIixcblx0XHRcdFx0XCJjbGFzc1wiIDogXCJ1aS1kaWFsb2ctY29udGFpbiB1aS1vdmVybGF5LXNoYWRvd1wiICtcblx0XHRcdFx0XHQoICEhb3B0cy5jb3JuZXJzID8gXCIgdWktY29ybmVyLWFsbFwiIDogXCJcIiApXG5cdFx0XHR9KSk7XG5cblx0XHQkLmV4dGVuZCggdGhpcywge1xuXHRcdFx0X2lzQ2xvc2VhYmxlOiBmYWxzZSxcblx0XHRcdF9pbm5lcjogZWxlbS5jaGlsZHJlbigpLFxuXHRcdFx0X2hlYWRlckNsb3NlQnV0dG9uOiBudWxsXG5cdFx0fSk7XG5cblx0XHR0aGlzLl9vbiggZWxlbSwge1xuXHRcdFx0dmNsaWNrOiBcIl9oYW5kbGVWQ2xpY2tTdWJtaXRcIixcblx0XHRcdHN1Ym1pdDogXCJfaGFuZGxlVkNsaWNrU3VibWl0XCIsXG5cdFx0XHRwYWdlYmVmb3Jlc2hvdzogXCJfaGFuZGxlUGFnZUJlZm9yZVNob3dcIixcblx0XHRcdHBhZ2ViZWZvcmVoaWRlOiBcIl9oYW5kbGVQYWdlQmVmb3JlSGlkZVwiXG5cdFx0fSk7XG5cblx0XHR0aGlzLl9zZXRDbG9zZUJ0biggb3B0cy5jbG9zZUJ0biApO1xuXHR9LFxuXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIgY2xvc2VCdXR0b25Mb2NhdGlvbiwgY2xvc2VCdXR0b25UZXh0LFxuXHRcdFx0Y3VycmVudE9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAoIG9wdGlvbnMuY29ybmVycyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5faW5uZXIudG9nZ2xlQ2xhc3MoIFwidWktY29ybmVyLWFsbFwiLCAhIW9wdGlvbnMuY29ybmVycyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy5vdmVybGF5VGhlbWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggJC5tb2JpbGUuYWN0aXZlUGFnZVsgMCBdID09PSB0aGlzLmVsZW1lbnRbIDAgXSApIHtcblx0XHRcdFx0Y3VycmVudE9wdHMub3ZlcmxheVRoZW1lID0gb3B0aW9ucy5vdmVybGF5VGhlbWU7XG5cdFx0XHRcdHRoaXMuX2hhbmRsZVBhZ2VCZWZvcmVTaG93KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLmNsb3NlQnRuVGV4dCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y2xvc2VCdXR0b25Mb2NhdGlvbiA9IGN1cnJlbnRPcHRzLmNsb3NlQnRuO1xuXHRcdFx0Y2xvc2VCdXR0b25UZXh0ID0gb3B0aW9ucy5jbG9zZUJ0blRleHQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLmNsb3NlQnRuICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjbG9zZUJ1dHRvbkxvY2F0aW9uID0gb3B0aW9ucy5jbG9zZUJ0bjtcblx0XHR9XG5cblx0XHRpZiAoIGNsb3NlQnV0dG9uTG9jYXRpb24gKSB7XG5cdFx0XHR0aGlzLl9zZXRDbG9zZUJ0biggY2xvc2VCdXR0b25Mb2NhdGlvbiwgY2xvc2VCdXR0b25UZXh0ICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3VwZXIoIG9wdGlvbnMgKTtcblx0fSxcblxuXHRfc2V0Q2xvc2VCdG46IGZ1bmN0aW9uKCBsb2NhdGlvbiwgdGV4dCApIHtcblx0XHR2YXIgZHN0LFxuXHRcdFx0YnRuID0gdGhpcy5faGVhZGVyQ2xvc2VCdXR0b247XG5cblx0XHQvLyBTYW5pdGl6ZSB2YWx1ZVxuXHRcdGxvY2F0aW9uID0gXCJsZWZ0XCIgPT09IGxvY2F0aW9uID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIgPT09IGxvY2F0aW9uID8gXCJyaWdodFwiIDogXCJub25lXCI7XG5cblx0XHRpZiAoIFwibm9uZVwiID09PSBsb2NhdGlvbiApIHtcblx0XHRcdGlmICggYnRuICkge1xuXHRcdFx0XHRidG4ucmVtb3ZlKCk7XG5cdFx0XHRcdGJ0biA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICggYnRuICkge1xuXHRcdFx0YnRuLnJlbW92ZUNsYXNzKCBcInVpLWJ0bi1sZWZ0IHVpLWJ0bi1yaWdodFwiICkuYWRkQ2xhc3MoIFwidWktYnRuLVwiICsgbG9jYXRpb24gKTtcblx0XHRcdGlmICggdGV4dCApIHtcblx0XHRcdFx0YnRuLnRleHQoIHRleHQgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZHN0ID0gdGhpcy5faW5uZXIuZmluZCggXCI6anFtRGF0YShyb2xlPSdoZWFkZXInKVwiICkuZmlyc3QoKTtcblx0XHRcdGJ0biA9ICQoIFwiPGE+PC9hPlwiLCB7XG5cdFx0XHRcdFx0XCJyb2xlXCI6IFwiYnV0dG9uXCIsXG5cdFx0XHRcdFx0XCJocmVmXCI6IFwiI1wiLFxuXHRcdFx0XHRcdFwiY2xhc3NcIjogXCJ1aS1idG4gdWktY29ybmVyLWFsbCB1aS1pY29uLWRlbGV0ZSB1aS1idG4taWNvbi1ub3RleHQgdWktYnRuLVwiICsgbG9jYXRpb25cblx0XHRcdFx0fSlcblx0XHRcdFx0LnRleHQoIHRleHQgfHwgdGhpcy5vcHRpb25zLmNsb3NlQnRuVGV4dCB8fCBcIlwiIClcblx0XHRcdFx0LnByZXBlbmRUbyggZHN0ICk7XG5cdFx0XHR0aGlzLl9vbiggYnRuLCB7IGNsaWNrOiBcImNsb3NlXCIgfSApO1xuXHRcdH1cblxuXHRcdHRoaXMuX2hlYWRlckNsb3NlQnV0dG9uID0gYnRuO1xuXHR9LFxuXG5cdC8vIENsb3NlIG1ldGhvZCBnb2VzIGJhY2sgaW4gaGlzdG9yeVxuXHRjbG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhpc3QgPSAkLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5O1xuXG5cdFx0aWYgKCB0aGlzLl9pc0Nsb3NlYWJsZSApIHtcblx0XHRcdHRoaXMuX2lzQ2xvc2VhYmxlID0gZmFsc2U7XG5cdFx0XHQvLyBJZiB0aGUgaGFzaCBsaXN0ZW5pbmcgaXMgZW5hYmxlZCBhbmQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByZWNlZGluZyBoaXN0b3J5XG5cdFx0XHQvLyBlbnRyeSBpdCdzIG9rIHRvIGdvIGJhY2suIEluaXRpYWwgcGFnZXMgd2l0aCB0aGUgZGlhbG9nIGhhc2ggc3RhdGUgYXJlIGFuIGV4YW1wbGVcblx0XHRcdC8vIHdoZXJlIHRoZSBzdGFjayBjaGVjayBpcyBuZWNlc3Nhcnlcblx0XHRcdGlmICggJC5tb2JpbGUuaGFzaExpc3RlbmluZ0VuYWJsZWQgJiYgaGlzdC5hY3RpdmVJbmRleCA+IDAgKSB7XG5cdFx0XHRcdCQubW9iaWxlLmJhY2soKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQubW9iaWxlLnBhZ2VDb250YWluZXIucGFnZWNvbnRhaW5lciggXCJiYWNrXCIgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG59KSggalF1ZXJ5LCB0aGlzICk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgckluaXRpYWxMZXR0ZXIgPSAvKFtBLVpdKS9nLFxuXG5cdC8vIENvbnN0cnVjdCBpY29ucG9zIGNsYXNzIGZyb20gaWNvbnBvcyB2YWx1ZVxuXHRpY29ucG9zQ2xhc3MgPSBmdW5jdGlvbiggaWNvbnBvcyApIHtcblx0XHRyZXR1cm4gKCBcInVpLWJ0bi1pY29uLVwiICsgKCBpY29ucG9zID09PSBudWxsID8gXCJsZWZ0XCIgOiBpY29ucG9zICkgKTtcblx0fTtcblxuJC53aWRnZXQoIFwibW9iaWxlLmNvbGxhcHNpYmxlXCIsIHtcblx0b3B0aW9uczoge1xuXHRcdGVuaGFuY2VkOiBmYWxzZSxcblx0XHRleHBhbmRDdWVUZXh0OiBudWxsLFxuXHRcdGNvbGxhcHNlQ3VlVGV4dDogbnVsbCxcblx0XHRjb2xsYXBzZWQ6IHRydWUsXG5cdFx0aGVhZGluZzogXCJoMSxoMixoMyxoNCxoNSxoNixsZWdlbmRcIixcblx0XHRjb2xsYXBzZWRJY29uOiBudWxsLFxuXHRcdGV4cGFuZGVkSWNvbjogbnVsbCxcblx0XHRpY29ucG9zOiBudWxsLFxuXHRcdHRoZW1lOiBudWxsLFxuXHRcdGNvbnRlbnRUaGVtZTogbnVsbCxcblx0XHRpbnNldDogbnVsbCxcblx0XHRjb3JuZXJzOiBudWxsLFxuXHRcdG1pbmk6IG51bGxcblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSA9IHRoaXMuZWxlbWVudCxcblx0XHRcdHVpID0ge1xuXHRcdFx0XHRhY2NvcmRpb246IGVsZW1cblx0XHRcdFx0XHQuY2xvc2VzdCggXCI6anFtRGF0YShyb2xlPSdjb2xsYXBzaWJsZS1zZXQnKSxcIiArXG5cdFx0XHRcdFx0XHRcIjpqcW1EYXRhKHJvbGU9J2NvbGxhcHNpYmxlc2V0JylcIiArXG5cdFx0XHRcdFx0XHQoICQubW9iaWxlLmNvbGxhcHNpYmxlc2V0ID8gXCIsIDptb2JpbGUtY29sbGFwc2libGVzZXRcIiA6XG5cdFx0XHRcdFx0XHRcdFwiXCIgKSApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWNvbGxhcHNpYmxlLXNldFwiIClcblx0XHRcdH07XG5cblx0XHR0aGlzLl91aSA9IHVpO1xuXHRcdHRoaXMuX3JlbmRlcmVkT3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnMoIHRoaXMub3B0aW9ucyApO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZW5oYW5jZWQgKSB7XG5cdFx0XHR1aS5oZWFkaW5nID0gJCggXCIudWktY29sbGFwc2libGUtaGVhZGluZ1wiLCB0aGlzLmVsZW1lbnRbIDAgXSApO1xuXHRcdFx0dWkuY29udGVudCA9IHVpLmhlYWRpbmcubmV4dCgpO1xuXHRcdFx0dWkuYW5jaG9yID0gJCggXCJhXCIsIHVpLmhlYWRpbmdbIDAgXSApLmZpcnN0KCk7XG5cdFx0XHR1aS5zdGF0dXMgPSB1aS5hbmNob3IuY2hpbGRyZW4oIFwiLnVpLWNvbGxhcHNpYmxlLWhlYWRpbmctc3RhdHVzXCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZW5oYW5jZSggZWxlbSwgdWkgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9vbiggdWkuaGVhZGluZywge1xuXHRcdFx0XCJ0YXBcIjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHVpLmhlYWRpbmcuZmluZCggXCJhXCIgKS5maXJzdCgpLmFkZENsYXNzKCAkLm1vYmlsZS5hY3RpdmVCdG5DbGFzcyApO1xuXHRcdFx0fSxcblxuXHRcdFx0XCJjbGlja1wiOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX2hhbmRsZUV4cGFuZENvbGxhcHNlKCAhdWkuaGVhZGluZy5oYXNDbGFzcyggXCJ1aS1jb2xsYXBzaWJsZS1oZWFkaW5nLWNvbGxhcHNlZFwiICkgKTtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0Ly8gQWRqdXN0IHRoZSBrZXlzIGluc2lkZSBvcHRpb25zIGZvciBpbmhlcml0ZWQgdmFsdWVzXG5cdF9nZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIga2V5LFxuXHRcdFx0YWNjb3JkaW9uID0gdGhpcy5fdWkuYWNjb3JkaW9uLFxuXHRcdFx0YWNjb3JkaW9uV2lkZ2V0ID0gdGhpcy5fdWkuYWNjb3JkaW9uV2lkZ2V0O1xuXG5cdFx0Ly8gQ29weSBvcHRpb25zXG5cdFx0b3B0aW9ucyA9ICQuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdFx0aWYgKCBhY2NvcmRpb24ubGVuZ3RoICYmICFhY2NvcmRpb25XaWRnZXQgKSB7XG5cdFx0XHR0aGlzLl91aS5hY2NvcmRpb25XaWRnZXQgPVxuXHRcdFx0YWNjb3JkaW9uV2lkZ2V0ID0gYWNjb3JkaW9uLmRhdGEoIFwibW9iaWxlLWNvbGxhcHNpYmxlc2V0XCIgKTtcblx0XHR9XG5cblx0XHRmb3IgKCBrZXkgaW4gb3B0aW9ucyApIHtcblxuXHRcdFx0Ly8gUmV0cmlldmUgdGhlIG9wdGlvbiB2YWx1ZSBmaXJzdCBmcm9tIHRoZSBvcHRpb25zIG9iamVjdCBwYXNzZWQgaW4gYW5kLCBpZlxuXHRcdFx0Ly8gbnVsbCwgZnJvbSB0aGUgcGFyZW50IGFjY29yZGlvbiBvciwgaWYgdGhhdCdzIG51bGwgdG9vLCBvciBpZiB0aGVyZSdzIG5vXG5cdFx0XHQvLyBwYXJlbnQgYWNjb3JkaW9uLCB0aGVuIGZyb20gdGhlIGRlZmF1bHRzLlxuXHRcdFx0b3B0aW9uc1sga2V5IF0gPVxuXHRcdFx0XHQoIG9wdGlvbnNbIGtleSBdICE9IG51bGwgKSA/IG9wdGlvbnNbIGtleSBdIDpcblx0XHRcdFx0KCBhY2NvcmRpb25XaWRnZXQgKSA/IGFjY29yZGlvbldpZGdldC5vcHRpb25zWyBrZXkgXSA6XG5cdFx0XHRcdGFjY29yZGlvbi5sZW5ndGggPyAkLm1vYmlsZS5nZXRBdHRyaWJ1dGUoIGFjY29yZGlvblsgMCBdLFxuXHRcdFx0XHRcdGtleS5yZXBsYWNlKCBySW5pdGlhbExldHRlciwgXCItJDFcIiApLnRvTG93ZXJDYXNlKCkgKTpcblx0XHRcdFx0bnVsbDtcblxuXHRcdFx0aWYgKCBudWxsID09IG9wdGlvbnNbIGtleSBdICkge1xuXHRcdFx0XHRvcHRpb25zWyBrZXkgXSA9ICQubW9iaWxlLmNvbGxhcHNpYmxlLmRlZmF1bHRzWyBrZXkgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fSxcblxuXHRfdGhlbWVDbGFzc0Zyb21PcHRpb246IGZ1bmN0aW9uKCBwcmVmaXgsIHZhbHVlICkge1xuXHRcdHJldHVybiAoIHZhbHVlID8gKCB2YWx1ZSA9PT0gXCJub25lXCIgPyBcIlwiIDogcHJlZml4ICsgdmFsdWUgKSA6IFwiXCIgKTtcblx0fSxcblxuXHRfZW5oYW5jZTogZnVuY3Rpb24oIGVsZW0sIHVpICkge1xuXHRcdHZhciBpY29uY2xhc3MsXG5cdFx0XHRvcHRzID0gdGhpcy5fcmVuZGVyZWRPcHRpb25zLFxuXHRcdFx0Y29udGVudFRoZW1lQ2xhc3MgPSB0aGlzLl90aGVtZUNsYXNzRnJvbU9wdGlvbiggXCJ1aS1ib2R5LVwiLCBvcHRzLmNvbnRlbnRUaGVtZSApO1xuXG5cdFx0ZWxlbS5hZGRDbGFzcyggXCJ1aS1jb2xsYXBzaWJsZSBcIiArXG5cdFx0XHQoIG9wdHMuaW5zZXQgPyBcInVpLWNvbGxhcHNpYmxlLWluc2V0IFwiIDogXCJcIiApICtcblx0XHRcdCggb3B0cy5pbnNldCAmJiBvcHRzLmNvcm5lcnMgPyBcInVpLWNvcm5lci1hbGwgXCIgOiBcIlwiICkgK1xuXHRcdFx0KCBjb250ZW50VGhlbWVDbGFzcyA/IFwidWktY29sbGFwc2libGUtdGhlbWVkLWNvbnRlbnQgXCIgOiBcIlwiICkgKTtcblx0XHR1aS5vcmlnaW5hbEhlYWRpbmcgPSBlbGVtLmNoaWxkcmVuKCB0aGlzLm9wdGlvbnMuaGVhZGluZyApLmZpcnN0KCksXG5cdFx0dWkuY29udGVudCA9IGVsZW1cblx0XHRcdC53cmFwSW5uZXIoIFwiPGRpdiBcIiArXG5cdFx0XHRcdFwiY2xhc3M9J3VpLWNvbGxhcHNpYmxlLWNvbnRlbnQgXCIgK1xuXHRcdFx0XHRjb250ZW50VGhlbWVDbGFzcyArIFwiJz48L2Rpdj5cIiApXG5cdFx0XHQuY2hpbGRyZW4oIFwiLnVpLWNvbGxhcHNpYmxlLWNvbnRlbnRcIiApLFxuXHRcdHVpLmhlYWRpbmcgPSB1aS5vcmlnaW5hbEhlYWRpbmc7XG5cblx0XHQvLyBSZXBsYWNlIGNvbGxhcHNpYmxlSGVhZGluZyBpZiBpdCdzIGEgbGVnZW5kXG5cdFx0aWYgKCB1aS5oZWFkaW5nLmlzKCBcImxlZ2VuZFwiICkgKSB7XG5cdFx0XHR1aS5oZWFkaW5nID0gJCggXCI8ZGl2IHJvbGU9J2hlYWRpbmcnPlwiKyB1aS5oZWFkaW5nLmh0bWwoKSArXCI8L2Rpdj5cIiApO1xuXHRcdFx0dWkucGxhY2Vob2xkZXIgPSAkKCBcIjxkaXY+PCEtLSBwbGFjZWhvbGRlciBmb3IgbGVnZW5kIC0tPjwvZGl2PlwiICkuaW5zZXJ0QmVmb3JlKCB1aS5vcmlnaW5hbEhlYWRpbmcgKTtcblx0XHRcdHVpLm9yaWdpbmFsSGVhZGluZy5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRpY29uY2xhc3MgPSAoIG9wdHMuY29sbGFwc2VkID8gKCBvcHRzLmNvbGxhcHNlZEljb24gPyBcInVpLWljb24tXCIgKyBvcHRzLmNvbGxhcHNlZEljb24gOiBcIlwiICk6XG5cdFx0XHQoIG9wdHMuZXhwYW5kZWRJY29uID8gXCJ1aS1pY29uLVwiICsgb3B0cy5leHBhbmRlZEljb24gOiBcIlwiICkgKTtcblxuXHRcdHVpLnN0YXR1cyA9ICQoIFwiPHNwYW4gY2xhc3M9J3VpLWNvbGxhcHNpYmxlLWhlYWRpbmctc3RhdHVzJz48L3NwYW4+XCIgKTtcblx0XHR1aS5hbmNob3IgPSB1aS5oZWFkaW5nXG5cdFx0XHQuZGV0YWNoKClcblx0XHRcdC8vbW9kaWZ5IG1hcmt1cCAmIGF0dHJpYnV0ZXNcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1jb2xsYXBzaWJsZS1oZWFkaW5nXCIgKVxuXHRcdFx0LmFwcGVuZCggdWkuc3RhdHVzIClcblx0XHRcdC53cmFwSW5uZXIoIFwiPGEgaHJlZj0nIycgY2xhc3M9J3VpLWNvbGxhcHNpYmxlLWhlYWRpbmctdG9nZ2xlJz48L2E+XCIgKVxuXHRcdFx0LmZpbmQoIFwiYVwiIClcblx0XHRcdFx0LmZpcnN0KClcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWJ0biBcIiArXG5cdFx0XHRcdFx0KCBpY29uY2xhc3MgPyBpY29uY2xhc3MgKyBcIiBcIiA6IFwiXCIgKSArXG5cdFx0XHRcdFx0KCBpY29uY2xhc3MgPyBpY29ucG9zQ2xhc3MoIG9wdHMuaWNvbnBvcyApICtcblx0XHRcdFx0XHRcdFwiIFwiIDogXCJcIiApICtcblx0XHRcdFx0XHR0aGlzLl90aGVtZUNsYXNzRnJvbU9wdGlvbiggXCJ1aS1idG4tXCIsIG9wdHMudGhlbWUgKSArIFwiIFwiICtcblx0XHRcdFx0XHQoIG9wdHMubWluaSA/IFwidWktbWluaSBcIiA6IFwiXCIgKSApO1xuXG5cdFx0Ly9kcm9wIGhlYWRpbmcgaW4gYmVmb3JlIGNvbnRlbnRcblx0XHR1aS5oZWFkaW5nLmluc2VydEJlZm9yZSggdWkuY29udGVudCApO1xuXG5cdFx0dGhpcy5faGFuZGxlRXhwYW5kQ29sbGFwc2UoIHRoaXMub3B0aW9ucy5jb2xsYXBzZWQgKTtcblxuXHRcdHJldHVybiB1aTtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9hcHBseU9wdGlvbnMoIHRoaXMub3B0aW9ucyApO1xuXHRcdHRoaXMuX3JlbmRlcmVkT3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnMoIHRoaXMub3B0aW9ucyApO1xuXHR9LFxuXG5cdF9hcHBseU9wdGlvbnM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBpc0NvbGxhcHNlZCwgbmV3VGhlbWUsIG9sZFRoZW1lLCBoYXNDb3JuZXJzLCBoYXNJY29uLFxuXHRcdFx0ZWxlbSA9IHRoaXMuZWxlbWVudCxcblx0XHRcdGN1cnJlbnRPcHRzID0gdGhpcy5fcmVuZGVyZWRPcHRpb25zLFxuXHRcdFx0dWkgPSB0aGlzLl91aSxcblx0XHRcdGFuY2hvciA9IHVpLmFuY2hvcixcblx0XHRcdHN0YXR1cyA9IHVpLnN0YXR1cyxcblx0XHRcdG9wdHMgPSB0aGlzLl9nZXRPcHRpb25zKCBvcHRpb25zICk7XG5cblx0XHQvLyBGaXJzdCBhbmQgZm9yZW1vc3Qgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIGNvbGxhcHNpYmxlIGlzIGluIHRoZSBwcm9wZXJcblx0XHQvLyBzdGF0ZSwgaW4gY2FzZSBzb21lYm9keSBkZWNpZGVkIHRvIGNoYW5nZSB0aGUgY29sbGFwc2VkIG9wdGlvbiBhdCB0aGVcblx0XHQvLyBzYW1lIHRpbWUgYXMgYW5vdGhlciBvcHRpb25cblx0XHRpZiAoIG9wdGlvbnMuY29sbGFwc2VkICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVFeHBhbmRDb2xsYXBzZSggb3B0aW9ucy5jb2xsYXBzZWQgKTtcblx0XHR9XG5cblx0XHRpc0NvbGxhcHNlZCA9IGVsZW0uaGFzQ2xhc3MoIFwidWktY29sbGFwc2libGUtY29sbGFwc2VkXCIgKTtcblxuXHRcdC8vIFdlIG9ubHkgbmVlZCB0byBhcHBseSB0aGUgY3VlIHRleHQgZm9yIHRoZSBjdXJyZW50IHN0YXRlIHJpZ2h0IGF3YXkuXG5cdFx0Ly8gVGhlIGN1ZSB0ZXh0IGZvciB0aGUgYWx0ZXJuYXRlIHN0YXRlIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBvcHRpb25zXG5cdFx0Ly8gYW5kIGFwcGxpZWQgdGhlIG5leHQgdGltZSB0aGUgY29sbGFwc2libGUncyBzdGF0ZSBpcyB0b2dnbGVkXG5cdFx0aWYgKCBpc0NvbGxhcHNlZCApIHtcblx0XHRcdGlmICggb3B0cy5leHBhbmRDdWVUZXh0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHN0YXR1cy50ZXh0KCBvcHRzLmV4cGFuZEN1ZVRleHQgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBvcHRzLmNvbGxhcHNlQ3VlVGV4dCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRzdGF0dXMudGV4dCggb3B0cy5jb2xsYXBzZUN1ZVRleHQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBVcGRhdGUgaWNvblxuXG5cdFx0Ly8gSXMgaXQgc3VwcG9zZWQgdG8gaGF2ZSBhbiBpY29uP1xuXHRcdGhhc0ljb24gPVxuXG5cdFx0XHQvLyBJZiB0aGUgY29sbGFwc2VkSWNvbiBpcyBiZWluZyBzZXQsIGNvbnN1bHQgdGhhdFxuXHRcdFx0KCBvcHRzLmNvbGxhcHNlZEljb24gIT09IHVuZGVmaW5lZCA/IG9wdHMuY29sbGFwc2VkSWNvbiAhPT0gZmFsc2UgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBjb25zdWx0IHRoZSBleGlzdGluZyBvcHRpb24gdmFsdWVcblx0XHRcdFx0Y3VycmVudE9wdHMuY29sbGFwc2VkSWNvbiAhPT0gZmFsc2UgKTtcblxuXG5cdFx0Ly8gSWYgYW55IGljb24tcmVsYXRlZCBvcHRpb25zIGhhdmUgY2hhbmdlZCwgbWFrZSBzdXJlIHRoZSBuZXcgaWNvblxuXHRcdC8vIHN0YXRlIGlzIHJlZmxlY3RlZCBieSBmaXJzdCByZW1vdmluZyBhbGwgaWNvbi1yZWxhdGVkIGNsYXNzZXNcblx0XHQvLyByZWZsZWN0aW5nIHRoZSBjdXJyZW50IHN0YXRlIGFuZCB0aGVuIGFkZGluZyBhbGwgaWNvbi1yZWxhdGVkXG5cdFx0Ly8gY2xhc3NlcyBmb3IgdGhlIG5ldyBzdGF0ZVxuXHRcdGlmICggISggb3B0cy5pY29ucG9zID09PSB1bmRlZmluZWQgJiZcblx0XHRcdG9wdHMuY29sbGFwc2VkSWNvbiA9PT0gdW5kZWZpbmVkICYmXG5cdFx0XHRvcHRzLmV4cGFuZGVkSWNvbiA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY3VycmVudCBpY29uLXJlbGF0ZWQgY2xhc3Nlc1xuXHRcdFx0YW5jaG9yLnJlbW92ZUNsYXNzKCBbIGljb25wb3NDbGFzcyggY3VycmVudE9wdHMuaWNvbnBvcyApIF1cblx0XHRcdFx0LmNvbmNhdCggKCBjdXJyZW50T3B0cy5leHBhbmRlZEljb24gP1xuXHRcdFx0XHRcdFsgXCJ1aS1pY29uLVwiICsgY3VycmVudE9wdHMuZXhwYW5kZWRJY29uIF0gOiBbXSApIClcblx0XHRcdFx0LmNvbmNhdCggKCBjdXJyZW50T3B0cy5jb2xsYXBzZWRJY29uID9cblx0XHRcdFx0XHRbIFwidWktaWNvbi1cIiArIGN1cnJlbnRPcHRzLmNvbGxhcHNlZEljb24gXSA6IFtdICkgKVxuXHRcdFx0XHQuam9pbiggXCIgXCIgKSApO1xuXG5cdFx0XHQvLyBBZGQgbmV3IGNsYXNzZXMgaWYgYW4gaWNvbiBpcyBzdXBwb3NlZCB0byBiZSBwcmVzZW50XG5cdFx0XHRpZiAoIGhhc0ljb24gKSB7XG5cdFx0XHRcdGFuY2hvci5hZGRDbGFzcyhcblx0XHRcdFx0XHRbIGljb25wb3NDbGFzcyggb3B0cy5pY29ucG9zICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdFx0b3B0cy5pY29ucG9zIDogY3VycmVudE9wdHMuaWNvbnBvcyApIF1cblx0XHRcdFx0XHRcdC5jb25jYXQoIGlzQ29sbGFwc2VkID9cblx0XHRcdFx0XHRcdFx0WyBcInVpLWljb24tXCIgKyAoIG9wdHMuY29sbGFwc2VkSWNvbiAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0XHRcdFx0XHRvcHRzLmNvbGxhcHNlZEljb24gOlxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRPcHRzLmNvbGxhcHNlZEljb24gKSBdIDpcblx0XHRcdFx0XHRcdFx0WyBcInVpLWljb24tXCIgKyAoIG9wdHMuZXhwYW5kZWRJY29uICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdFx0XHRcdG9wdHMuZXhwYW5kZWRJY29uIDpcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50T3B0cy5leHBhbmRlZEljb24gKSBdIClcblx0XHRcdFx0XHRcdC5qb2luKCBcIiBcIiApICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRzLnRoZW1lICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRvbGRUaGVtZSA9IHRoaXMuX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKCBcInVpLWJ0bi1cIiwgY3VycmVudE9wdHMudGhlbWUgKTtcblx0XHRcdG5ld1RoZW1lID0gdGhpcy5fdGhlbWVDbGFzc0Zyb21PcHRpb24oIFwidWktYnRuLVwiLCBvcHRzLnRoZW1lICk7XG5cdFx0XHRhbmNob3IucmVtb3ZlQ2xhc3MoIG9sZFRoZW1lICkuYWRkQ2xhc3MoIG5ld1RoZW1lICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRzLmNvbnRlbnRUaGVtZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0b2xkVGhlbWUgPSB0aGlzLl90aGVtZUNsYXNzRnJvbU9wdGlvbiggXCJ1aS1ib2R5LVwiLFxuXHRcdFx0XHRjdXJyZW50T3B0cy5jb250ZW50VGhlbWUgKTtcblx0XHRcdG5ld1RoZW1lID0gdGhpcy5fdGhlbWVDbGFzc0Zyb21PcHRpb24oIFwidWktYm9keS1cIixcblx0XHRcdFx0b3B0cy5jb250ZW50VGhlbWUgKTtcblx0XHRcdHVpLmNvbnRlbnQucmVtb3ZlQ2xhc3MoIG9sZFRoZW1lICkuYWRkQ2xhc3MoIG5ld1RoZW1lICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRzLmluc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRlbGVtLnRvZ2dsZUNsYXNzKCBcInVpLWNvbGxhcHNpYmxlLWluc2V0XCIsIG9wdHMuaW5zZXQgKTtcblx0XHRcdGhhc0Nvcm5lcnMgPSAhISggb3B0cy5pbnNldCAmJiAoIG9wdHMuY29ybmVycyB8fCBjdXJyZW50T3B0cy5jb3JuZXJzICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdHMuY29ybmVycyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aGFzQ29ybmVycyA9ICEhKCBvcHRzLmNvcm5lcnMgJiYgKCBvcHRzLmluc2V0IHx8IGN1cnJlbnRPcHRzLmluc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhhc0Nvcm5lcnMgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGVsZW0udG9nZ2xlQ2xhc3MoIFwidWktY29ybmVyLWFsbFwiLCBoYXNDb3JuZXJzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRzLm1pbmkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGFuY2hvci50b2dnbGVDbGFzcyggXCJ1aS1taW5pXCIsIG9wdHMubWluaSApO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dGhpcy5fYXBwbHlPcHRpb25zKCBvcHRpb25zICk7XG5cdFx0dGhpcy5fc3VwZXIoIG9wdGlvbnMgKTtcblx0XHR0aGlzLl9yZW5kZXJlZE9wdGlvbnMgPSB0aGlzLl9nZXRPcHRpb25zKCB0aGlzLm9wdGlvbnMgKTtcblx0fSxcblxuXHRfaGFuZGxlRXhwYW5kQ29sbGFwc2U6IGZ1bmN0aW9uKCBpc0NvbGxhcHNlICkge1xuXHRcdHZhciBvcHRzID0gdGhpcy5fcmVuZGVyZWRPcHRpb25zLFxuXHRcdFx0dWkgPSB0aGlzLl91aTtcblxuXHRcdHVpLnN0YXR1cy50ZXh0KCBpc0NvbGxhcHNlID8gb3B0cy5leHBhbmRDdWVUZXh0IDogb3B0cy5jb2xsYXBzZUN1ZVRleHQgKTtcblx0XHR1aS5oZWFkaW5nXG5cdFx0XHQudG9nZ2xlQ2xhc3MoIFwidWktY29sbGFwc2libGUtaGVhZGluZy1jb2xsYXBzZWRcIiwgaXNDb2xsYXBzZSApXG5cdFx0XHQuZmluZCggXCJhXCIgKS5maXJzdCgpXG5cdFx0XHQudG9nZ2xlQ2xhc3MoIFwidWktaWNvbi1cIiArIG9wdHMuZXhwYW5kZWRJY29uLCAhaXNDb2xsYXBzZSApXG5cblx0XHRcdC8vIGxvZ2ljIG9yIGNhdXNlIHNhbWUgaWNvbiBmb3IgZXhwYW5kZWQvY29sbGFwc2VkIHN0YXRlIHdvdWxkIHJlbW92ZSB0aGUgdWktaWNvbi1jbGFzc1xuXHRcdFx0LnRvZ2dsZUNsYXNzKCBcInVpLWljb24tXCIgKyBvcHRzLmNvbGxhcHNlZEljb24sICggaXNDb2xsYXBzZSB8fCBvcHRzLmV4cGFuZGVkSWNvbiA9PT0gb3B0cy5jb2xsYXBzZWRJY29uICkgKVxuXHRcdFx0LnJlbW92ZUNsYXNzKCAkLm1vYmlsZS5hY3RpdmVCdG5DbGFzcyApO1xuXG5cdFx0dGhpcy5lbGVtZW50LnRvZ2dsZUNsYXNzKCBcInVpLWNvbGxhcHNpYmxlLWNvbGxhcHNlZFwiLCBpc0NvbGxhcHNlICk7XG5cdFx0dWkuY29udGVudFxuXHRcdFx0LnRvZ2dsZUNsYXNzKCBcInVpLWNvbGxhcHNpYmxlLWNvbnRlbnQtY29sbGFwc2VkXCIsIGlzQ29sbGFwc2UgKVxuXHRcdFx0LmF0dHIoIFwiYXJpYS1oaWRkZW5cIiwgaXNDb2xsYXBzZSApXG5cdFx0XHQudHJpZ2dlciggXCJ1cGRhdGVsYXlvdXRcIiApO1xuXHRcdHRoaXMub3B0aW9ucy5jb2xsYXBzZWQgPSBpc0NvbGxhcHNlO1xuXHRcdHRoaXMuX3RyaWdnZXIoIGlzQ29sbGFwc2UgPyBcImNvbGxhcHNlXCIgOiBcImV4cGFuZFwiICk7XG5cdH0sXG5cblx0ZXhwYW5kOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9oYW5kbGVFeHBhbmRDb2xsYXBzZSggZmFsc2UgKTtcblx0fSxcblxuXHRjb2xsYXBzZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5faGFuZGxlRXhwYW5kQ29sbGFwc2UoIHRydWUgKTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHVpID0gdGhpcy5fdWksXG5cdFx0XHRvcHRzID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKCBvcHRzLmVuaGFuY2VkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdWkucGxhY2Vob2xkZXIgKSB7XG5cdFx0XHR1aS5vcmlnaW5hbEhlYWRpbmcuaW5zZXJ0QmVmb3JlKCB1aS5wbGFjZWhvbGRlciApO1xuXHRcdFx0dWkucGxhY2Vob2xkZXIucmVtb3ZlKCk7XG5cdFx0XHR1aS5oZWFkaW5nLnJlbW92ZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR1aS5zdGF0dXMucmVtb3ZlKCk7XG5cdFx0XHR1aS5oZWFkaW5nXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1jb2xsYXBzaWJsZS1oZWFkaW5nIHVpLWNvbGxhcHNpYmxlLWhlYWRpbmctY29sbGFwc2VkXCIgKVxuXHRcdFx0XHQuY2hpbGRyZW4oKVxuXHRcdFx0XHRcdC5jb250ZW50cygpXG5cdFx0XHRcdFx0XHQudW53cmFwKCk7XG5cdFx0fVxuXG5cdFx0dWkuYW5jaG9yLmNvbnRlbnRzKCkudW53cmFwKCk7XG5cdFx0dWkuY29udGVudC5jb250ZW50cygpLnVud3JhcCgpO1xuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWNvbGxhcHNpYmxlIHVpLWNvbGxhcHNpYmxlLWNvbGxhcHNlZCBcIiArXG5cdFx0XHRcdFwidWktY29sbGFwc2libGUtdGhlbWVkLWNvbnRlbnQgdWktY29sbGFwc2libGUtaW5zZXQgdWktY29ybmVyLWFsbFwiICk7XG5cdH1cbn0pO1xuXG4vLyBEZWZhdWx0cyB0byBiZSB1c2VkIGJ5IGFsbCBpbnN0YW5jZXMgb2YgY29sbGFwc2libGUgaWYgcGVyLWluc3RhbmNlIHZhbHVlc1xuLy8gYXJlIHVuc2V0IG9yIGlmIG5vdGhpbmcgaXMgc3BlY2lmaWVkIGJ5IHdheSBvZiBpbmhlcml0YW5jZSBmcm9tIGFuIGFjY29yZGlvbi5cbi8vIE5vdGUgdGhhdCB0aGlzIGhhc2ggZG9lcyBub3QgY29udGFpbiBvcHRpb25zIFwiY29sbGFwc2VkXCIgb3IgXCJoZWFkaW5nXCIsXG4vLyBiZWNhdXNlIHRob3NlIGFyZSBub3QgaW5oZXJpdGFibGUuXG4kLm1vYmlsZS5jb2xsYXBzaWJsZS5kZWZhdWx0cyA9IHtcblx0ZXhwYW5kQ3VlVGV4dDogXCIgY2xpY2sgdG8gZXhwYW5kIGNvbnRlbnRzXCIsXG5cdGNvbGxhcHNlQ3VlVGV4dDogXCIgY2xpY2sgdG8gY29sbGFwc2UgY29udGVudHNcIixcblx0Y29sbGFwc2VkSWNvbjogXCJwbHVzXCIsXG5cdGNvbnRlbnRUaGVtZTogXCJpbmhlcml0XCIsXG5cdGV4cGFuZGVkSWNvbjogXCJtaW51c1wiLFxuXHRpY29ucG9zOiBcImxlZnRcIixcblx0aW5zZXQ6IHRydWUsXG5cdGNvcm5lcnM6IHRydWUsXG5cdHRoZW1lOiBcImluaGVyaXRcIixcblx0bWluaTogZmFsc2Vcbn07XG5cbn0pKCBqUXVlcnkgKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbnZhciB1aVNjcmVlbkhpZGRlblJlZ2V4ID0gL1xcYnVpLXNjcmVlbi1oaWRkZW5cXGIvO1xuZnVuY3Rpb24gbm9IaWRkZW5DbGFzcyggZWxlbWVudHMgKSB7XG5cdHZhciBpbmRleCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGgsXG5cdFx0cmVzdWx0ID0gW107XG5cblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICFlbGVtZW50c1sgaW5kZXggXS5jbGFzc05hbWUubWF0Y2goIHVpU2NyZWVuSGlkZGVuUmVnZXggKSApIHtcblx0XHRcdHJlc3VsdC5wdXNoKCBlbGVtZW50c1sgaW5kZXggXSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiAkKCByZXN1bHQgKTtcbn1cblxuJC5tb2JpbGUuYmVoYXZpb3JzLmFkZEZpcnN0TGFzdENsYXNzZXMgPSB7XG5cdF9nZXRWaXNpYmxlczogZnVuY3Rpb24oICRlbHMsIGNyZWF0ZSApIHtcblx0XHR2YXIgdmlzaWJsZXM7XG5cblx0XHRpZiAoIGNyZWF0ZSApIHtcblx0XHRcdHZpc2libGVzID0gbm9IaWRkZW5DbGFzcyggJGVscyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2aXNpYmxlcyA9ICRlbHMuZmlsdGVyKCBcIjp2aXNpYmxlXCIgKTtcblx0XHRcdGlmICggdmlzaWJsZXMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHR2aXNpYmxlcyA9IG5vSGlkZGVuQ2xhc3MoICRlbHMgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmlzaWJsZXM7XG5cdH0sXG5cblx0X2FkZEZpcnN0TGFzdENsYXNzZXM6IGZ1bmN0aW9uKCAkZWxzLCAkdmlzaWJsZXMsIGNyZWF0ZSApIHtcblx0XHQkZWxzLnJlbW92ZUNsYXNzKCBcInVpLWZpcnN0LWNoaWxkIHVpLWxhc3QtY2hpbGRcIiApO1xuXHRcdCR2aXNpYmxlcy5lcSggMCApLmFkZENsYXNzKCBcInVpLWZpcnN0LWNoaWxkXCIgKS5lbmQoKS5sYXN0KCkuYWRkQ2xhc3MoIFwidWktbGFzdC1jaGlsZFwiICk7XG5cdFx0aWYgKCAhY3JlYXRlICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIFwidXBkYXRlbGF5b3V0XCIgKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZUZpcnN0TGFzdENsYXNzZXM6IGZ1bmN0aW9uKCAkZWxzICkge1xuXHRcdCRlbHMucmVtb3ZlQ2xhc3MoIFwidWktZmlyc3QtY2hpbGQgdWktbGFzdC1jaGlsZFwiICk7XG5cdH1cbn07XG5cbn0pKCBqUXVlcnkgKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbnZhciBjaGlsZENvbGxhcHNpYmxlc1NlbGVjdG9yID0gXCI6bW9iaWxlLWNvbGxhcHNpYmxlLCBcIiArICQubW9iaWxlLmNvbGxhcHNpYmxlLmluaXRTZWxlY3RvcjtcblxuJC53aWRnZXQoIFwibW9iaWxlLmNvbGxhcHNpYmxlc2V0XCIsICQuZXh0ZW5kKCB7XG5cblx0Ly8gVGhlIGluaXRTZWxlY3RvciBpcyBkZXByZWNhdGVkIGFzIG9mIDEuNC4wLiBJbiAxLjUuMCB3ZSB3aWxsIHVzZVxuXHQvLyA6anFtRGF0YShyb2xlPSdjb2xsYXBzaWJsZXNldCcpIHdoaWNoIHdpbGwgYWxsb3cgdXMgdG8gZ2V0IHJpZCBvZiB0aGUgbGluZVxuXHQvLyBiZWxvdyBhbHRvZ2V0aGVyLCBiZWNhdXNlIHRoZSBhdXRvaW5pdCB3aWxsIGdlbmVyYXRlIHN1Y2ggYW4gaW5pdFNlbGVjdG9yXG5cdGluaXRTZWxlY3RvcjogXCI6anFtRGF0YShyb2xlPSdjb2xsYXBzaWJsZS1zZXQnKSw6anFtRGF0YShyb2xlPSdjb2xsYXBzaWJsZXNldCcpXCIsXG5cblx0b3B0aW9uczogJC5leHRlbmQoIHtcblx0XHRlbmhhbmNlZDogZmFsc2Vcblx0fSwgJC5tb2JpbGUuY29sbGFwc2libGUuZGVmYXVsdHMgKSxcblxuXHRfaGFuZGxlQ29sbGFwc2libGVFeHBhbmQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgY2xvc2VzdENvbGxhcHNpYmxlID0gJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggXCIudWktY29sbGFwc2libGVcIiApO1xuXG5cdFx0aWYgKCBjbG9zZXN0Q29sbGFwc2libGUucGFyZW50KCkuaXMoIFwiOm1vYmlsZS1jb2xsYXBzaWJsZXNldCwgOmpxbURhdGEocm9sZT0nY29sbGFwc2libGUtc2V0JylcIiApICkge1xuXHRcdFx0Y2xvc2VzdENvbGxhcHNpYmxlXG5cdFx0XHRcdC5zaWJsaW5ncyggXCIudWktY29sbGFwc2libGU6bm90KC51aS1jb2xsYXBzaWJsZS1jb2xsYXBzZWQpXCIgKVxuXHRcdFx0XHQuY29sbGFwc2libGUoIFwiY29sbGFwc2VcIiApO1xuXHRcdH1cblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSA9IHRoaXMuZWxlbWVudCxcblx0XHRcdG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHQkLmV4dGVuZCggdGhpcywge1xuXHRcdFx0X2NsYXNzZXM6IFwiXCJcblx0XHR9KTtcblxuXHRcdGlmICggIW9wdHMuZW5oYW5jZWQgKSB7XG5cdFx0XHRlbGVtLmFkZENsYXNzKCBcInVpLWNvbGxhcHNpYmxlLXNldCBcIiArXG5cdFx0XHRcdHRoaXMuX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKCBcInVpLWdyb3VwLXRoZW1lLVwiLCBvcHRzLnRoZW1lICkgKyBcIiBcIiArXG5cdFx0XHRcdCggb3B0cy5jb3JuZXJzICYmIG9wdHMuaW5zZXQgPyBcInVpLWNvcm5lci1hbGwgXCIgOiBcIlwiICkgKTtcblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCAkLm1vYmlsZS5jb2xsYXBzaWJsZS5pbml0U2VsZWN0b3IgKS5jb2xsYXBzaWJsZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX29uKCBlbGVtLCB7IGNvbGxhcHNpYmxlZXhwYW5kOiBcIl9oYW5kbGVDb2xsYXBzaWJsZUV4cGFuZFwiIH0gKTtcblx0fSxcblxuXHRfdGhlbWVDbGFzc0Zyb21PcHRpb246IGZ1bmN0aW9uKCBwcmVmaXgsIHZhbHVlICkge1xuXHRcdHJldHVybiAoIHZhbHVlID8gKCB2YWx1ZSA9PT0gXCJub25lXCIgPyBcIlwiIDogcHJlZml4ICsgdmFsdWUgKSA6IFwiXCIgKTtcblx0fSxcblxuXHRfaW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcmVmcmVzaCggdHJ1ZSApO1xuXG5cdFx0Ly8gQmVjYXVzZSB0aGUgY29ybmVycyBhcmUgaGFuZGxlZCBieSB0aGUgY29sbGFwc2libGUgaXRzZWxmIGFuZCB0aGUgZGVmYXVsdCBzdGF0ZSBpcyBjb2xsYXBzZWRcblx0XHQvLyBUaGF0IHdhcyBjYXVzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5LW1vYmlsZS9pc3N1ZXMvNDExNlxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LmNoaWxkcmVuKCBjaGlsZENvbGxhcHNpYmxlc1NlbGVjdG9yIClcblx0XHRcdC5maWx0ZXIoIFwiOmpxbURhdGEoY29sbGFwc2VkPSdmYWxzZScpXCIgKVxuXHRcdFx0LmNvbGxhcHNpYmxlKCBcImV4cGFuZFwiICk7XG5cdH0sXG5cblx0X3NldE9wdGlvbnM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciByZXQsIGhhc0Nvcm5lcnMsXG5cdFx0XHRlbGVtID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0dGhlbWVDbGFzcyA9IHRoaXMuX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKCBcInVpLWdyb3VwLXRoZW1lLVwiLCBvcHRpb25zLnRoZW1lICk7XG5cblx0XHRpZiAoIHRoZW1lQ2xhc3MgKSB7XG5cdFx0XHRlbGVtXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggdGhpcy5fdGhlbWVDbGFzc0Zyb21PcHRpb24oIFwidWktZ3JvdXAtdGhlbWUtXCIsIHRoaXMub3B0aW9ucy50aGVtZSApIClcblx0XHRcdFx0LmFkZENsYXNzKCB0aGVtZUNsYXNzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLmluc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRoYXNDb3JuZXJzID0gISEoIG9wdGlvbnMuaW5zZXQgJiYgKCBvcHRpb25zLmNvcm5lcnMgfHwgdGhpcy5vcHRpb25zLmNvcm5lcnMgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy5jb3JuZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRoYXNDb3JuZXJzID0gISEoIG9wdGlvbnMuY29ybmVycyAmJiAoIG9wdGlvbnMuaW5zZXQgfHwgdGhpcy5vcHRpb25zLmluc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhhc0Nvcm5lcnMgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGVsZW0udG9nZ2xlQ2xhc3MoIFwidWktY29ybmVyLWFsbFwiLCBoYXNDb3JuZXJzICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5fc3VwZXIoIG9wdGlvbnMgKTtcblx0XHR0aGlzLmVsZW1lbnQuY2hpbGRyZW4oIFwiOm1vYmlsZS1jb2xsYXBzaWJsZVwiICkuY29sbGFwc2libGUoIFwicmVmcmVzaFwiICk7XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsID0gdGhpcy5lbGVtZW50O1xuXG5cdFx0dGhpcy5fcmVtb3ZlRmlyc3RMYXN0Q2xhc3NlcyggZWwuY2hpbGRyZW4oIGNoaWxkQ29sbGFwc2libGVzU2VsZWN0b3IgKSApO1xuXHRcdGVsXG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktY29sbGFwc2libGUtc2V0IHVpLWNvcm5lci1hbGwgXCIgK1xuXHRcdFx0XHR0aGlzLl90aGVtZUNsYXNzRnJvbU9wdGlvbiggXCJ1aS1ncm91cC10aGVtZS1cIiwgdGhpcy5vcHRpb25zLnRoZW1lICkgKVxuXHRcdFx0LmNoaWxkcmVuKCBcIjptb2JpbGUtY29sbGFwc2libGVcIiApXG5cdFx0XHQuY29sbGFwc2libGUoIFwiZGVzdHJveVwiICk7XG5cdH0sXG5cblx0X3JlZnJlc2g6IGZ1bmN0aW9uKCBjcmVhdGUgKSB7XG5cdFx0dmFyIGNvbGxhcHNpYmxlc0luU2V0ID0gdGhpcy5lbGVtZW50LmNoaWxkcmVuKCBjaGlsZENvbGxhcHNpYmxlc1NlbGVjdG9yICk7XG5cblx0XHR0aGlzLmVsZW1lbnQuZmluZCggJC5tb2JpbGUuY29sbGFwc2libGUuaW5pdFNlbGVjdG9yICkubm90KCBcIi51aS1jb2xsYXBzaWJsZVwiICkuY29sbGFwc2libGUoKTtcblxuXHRcdHRoaXMuX2FkZEZpcnN0TGFzdENsYXNzZXMoIGNvbGxhcHNpYmxlc0luU2V0LCB0aGlzLl9nZXRWaXNpYmxlcyggY29sbGFwc2libGVzSW5TZXQsIGNyZWF0ZSApLCBjcmVhdGUgKTtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9yZWZyZXNoKCBmYWxzZSApO1xuXHR9XG59LCAkLm1vYmlsZS5iZWhhdmlvcnMuYWRkRmlyc3RMYXN0Q2xhc3NlcyApICk7XG5cbn0pKCBqUXVlcnkgKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbi8vIERlcHJlY2F0ZWQgaW4gMS40XG4kLmZuLmZpZWxkY29udGFpbiA9IGZ1bmN0aW9uKC8qIG9wdGlvbnMgKi8pIHtcblx0cmV0dXJuIHRoaXMuYWRkQ2xhc3MoIFwidWktZmllbGQtY29udGFpblwiICk7XG59O1xuXG59KSggalF1ZXJ5ICk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLmZuLmdyaWQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblxuXHRcdHZhciAkdGhpcyA9ICQoIHRoaXMgKSxcblx0XHRcdG8gPSAkLmV4dGVuZCh7XG5cdFx0XHRcdGdyaWQ6IG51bGxcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdCRraWRzID0gJHRoaXMuY2hpbGRyZW4oKSxcblx0XHRcdGdyaWRDb2xzID0geyBzb2xvOjEsIGE6MiwgYjozLCBjOjQsIGQ6NSB9LFxuXHRcdFx0Z3JpZCA9IG8uZ3JpZCxcblx0XHRcdGl0ZXJhdG9yLFxuXHRcdFx0bGV0dGVyO1xuXG5cdFx0XHRpZiAoICFncmlkICkge1xuXHRcdFx0XHRpZiAoICRraWRzLmxlbmd0aCA8PSA1ICkge1xuXHRcdFx0XHRcdGZvciAoIGxldHRlciBpbiBncmlkQ29scyApIHtcblx0XHRcdFx0XHRcdGlmICggZ3JpZENvbHNbIGxldHRlciBdID09PSAka2lkcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdGdyaWQgPSBsZXR0ZXI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGdyaWQgPSBcImFcIjtcblx0XHRcdFx0XHQkdGhpcy5hZGRDbGFzcyggXCJ1aS1ncmlkLWR1b1wiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGl0ZXJhdG9yID0gZ3JpZENvbHNbZ3JpZF07XG5cblx0XHQkdGhpcy5hZGRDbGFzcyggXCJ1aS1ncmlkLVwiICsgZ3JpZCApO1xuXG5cdFx0JGtpZHMuZmlsdGVyKCBcIjpudGgtY2hpbGQoXCIgKyBpdGVyYXRvciArIFwibisxKVwiICkuYWRkQ2xhc3MoIFwidWktYmxvY2stYVwiICk7XG5cblx0XHRpZiAoIGl0ZXJhdG9yID4gMSApIHtcblx0XHRcdCRraWRzLmZpbHRlciggXCI6bnRoLWNoaWxkKFwiICsgaXRlcmF0b3IgKyBcIm4rMilcIiApLmFkZENsYXNzKCBcInVpLWJsb2NrLWJcIiApO1xuXHRcdH1cblx0XHRpZiAoIGl0ZXJhdG9yID4gMiApIHtcblx0XHRcdCRraWRzLmZpbHRlciggXCI6bnRoLWNoaWxkKFwiICsgaXRlcmF0b3IgKyBcIm4rMylcIiApLmFkZENsYXNzKCBcInVpLWJsb2NrLWNcIiApO1xuXHRcdH1cblx0XHRpZiAoIGl0ZXJhdG9yID4gMyApIHtcblx0XHRcdCRraWRzLmZpbHRlciggXCI6bnRoLWNoaWxkKFwiICsgaXRlcmF0b3IgKyBcIm4rNClcIiApLmFkZENsYXNzKCBcInVpLWJsb2NrLWRcIiApO1xuXHRcdH1cblx0XHRpZiAoIGl0ZXJhdG9yID4gNCApIHtcblx0XHRcdCRraWRzLmZpbHRlciggXCI6bnRoLWNoaWxkKFwiICsgaXRlcmF0b3IgKyBcIm4rNSlcIiApLmFkZENsYXNzKCBcInVpLWJsb2NrLWVcIiApO1xuXHRcdH1cblx0fSk7XG59O1xufSkoIGpRdWVyeSApO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoIFwibW9iaWxlLm5hdmJhclwiLCB7XG5cdG9wdGlvbnM6IHtcblx0XHRpY29ucG9zOiBcInRvcFwiLFxuXHRcdGdyaWQ6IG51bGxcblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciAkbmF2YmFyID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0JG5hdmJ0bnMgPSAkbmF2YmFyLmZpbmQoIFwiYVwiICksXG5cdFx0XHRpY29ucG9zID0gJG5hdmJ0bnMuZmlsdGVyKCBcIjpqcW1EYXRhKGljb24pXCIgKS5sZW5ndGggPyB0aGlzLm9wdGlvbnMuaWNvbnBvcyA6IHVuZGVmaW5lZDtcblxuXHRcdCRuYXZiYXIuYWRkQ2xhc3MoIFwidWktbmF2YmFyXCIgKVxuXHRcdFx0LmF0dHIoIFwicm9sZVwiLCBcIm5hdmlnYXRpb25cIiApXG5cdFx0XHQuZmluZCggXCJ1bFwiIClcblx0XHRcdC5qcW1FbmhhbmNlYWJsZSgpXG5cdFx0XHQuZ3JpZCh7IGdyaWQ6IHRoaXMub3B0aW9ucy5ncmlkIH0pO1xuXG5cdFx0JG5hdmJ0bnNcblx0XHRcdC5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGljb24gPSAkLm1vYmlsZS5nZXRBdHRyaWJ1dGUoIHRoaXMsIFwiaWNvblwiICksXG5cdFx0XHRcdFx0dGhlbWUgPSAkLm1vYmlsZS5nZXRBdHRyaWJ1dGUoIHRoaXMsIFwidGhlbWVcIiApLFxuXHRcdFx0XHRcdGNsYXNzZXMgPSBcInVpLWJ0blwiO1xuXG5cdFx0XHRcdGlmICggdGhlbWUgKSB7XG5cdFx0XHRcdFx0Y2xhc3NlcyArPSBcIiB1aS1idG4tXCIgKyB0aGVtZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGljb24gKSB7XG5cdFx0XHRcdFx0Y2xhc3NlcyArPSBcIiB1aS1pY29uLVwiICsgaWNvbiArIFwiIHVpLWJ0bi1pY29uLVwiICsgaWNvbnBvcztcblx0XHRcdFx0fVxuXHRcdFx0XHQkKCB0aGlzICkuYWRkQ2xhc3MoIGNsYXNzZXMgKTtcblx0XHRcdH0pO1xuXG5cdFx0JG5hdmJhci5kZWxlZ2F0ZSggXCJhXCIsIFwidmNsaWNrXCIsIGZ1bmN0aW9uKCAvKiBldmVudCAqLyApIHtcblx0XHRcdHZhciBhY3RpdmVCdG4gPSAkKCB0aGlzICk7XG5cblx0XHRcdGlmICggISggYWN0aXZlQnRuLmhhc0NsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIgKSB8fFxuXG5cdFx0XHRcdC8vIERFUFJFQ0FURUQgYXMgb2YgMS40LjAgLSByZW1vdmUgYWZ0ZXIgMS40LjAgcmVsZWFzZVxuXHRcdFx0XHQvLyBvbmx5IHVpLXN0YXRlLWRpc2FibGVkIHNob3VsZCBiZSBwcmVzZW50IHRoZXJlYWZ0ZXJcblx0XHRcdFx0YWN0aXZlQnRuLmhhc0NsYXNzKCBcInVpLWRpc2FibGVkXCIgKSB8fFxuXHRcdFx0XHRhY3RpdmVCdG4uaGFzQ2xhc3MoICQubW9iaWxlLmFjdGl2ZUJ0bkNsYXNzICkgKSApIHtcblxuXHRcdFx0XHQkbmF2YnRucy5yZW1vdmVDbGFzcyggJC5tb2JpbGUuYWN0aXZlQnRuQ2xhc3MgKTtcblx0XHRcdFx0YWN0aXZlQnRuLmFkZENsYXNzKCAkLm1vYmlsZS5hY3RpdmVCdG5DbGFzcyApO1xuXG5cdFx0XHRcdC8vIFRoZSBjb2RlIGJlbG93IGlzIGEgd29ya2Fyb3VuZCB0byBmaXggIzExODFcblx0XHRcdFx0JCggZG9jdW1lbnQgKS5vbmUoIFwicGFnZWhpZGVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0YWN0aXZlQnRuLnJlbW92ZUNsYXNzKCAkLm1vYmlsZS5hY3RpdmVCdG5DbGFzcyApO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEJ1dHRvbnMgaW4gdGhlIG5hdmJhciB3aXRoIHVpLXN0YXRlLXBlcnNpc3QgY2xhc3Mgc2hvdWxkIHJlZ2FpbiB0aGVpciBhY3RpdmUgc3RhdGUgYmVmb3JlIHBhZ2Ugc2hvd1xuXHRcdCRuYXZiYXIuY2xvc2VzdCggXCIudWktcGFnZVwiICkuYmluZCggXCJwYWdlYmVmb3Jlc2hvd1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdCRuYXZidG5zLmZpbHRlciggXCIudWktc3RhdGUtcGVyc2lzdFwiICkuYWRkQ2xhc3MoICQubW9iaWxlLmFjdGl2ZUJ0bkNsYXNzICk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG59KSggalF1ZXJ5ICk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgZ2V0QXR0ciA9ICQubW9iaWxlLmdldEF0dHJpYnV0ZTtcblxuJC53aWRnZXQoIFwibW9iaWxlLmxpc3R2aWV3XCIsICQuZXh0ZW5kKCB7XG5cblx0b3B0aW9uczoge1xuXHRcdHRoZW1lOiBudWxsLFxuXHRcdGNvdW50VGhlbWU6IG51bGwsIC8qIERlcHJlY2F0ZWQgaW4gMS40ICovXG5cdFx0ZGl2aWRlclRoZW1lOiBudWxsLFxuXHRcdGljb246IFwiY2FyYXQtclwiLFxuXHRcdHNwbGl0SWNvbjogXCJjYXJhdC1yXCIsXG5cdFx0c3BsaXRUaGVtZTogbnVsbCxcblx0XHRjb3JuZXJzOiB0cnVlLFxuXHRcdHNoYWRvdzogdHJ1ZSxcblx0XHRpbnNldDogZmFsc2Vcblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdCA9IHRoaXMsXG5cdFx0XHRsaXN0dmlld0NsYXNzZXMgPSBcIlwiO1xuXG5cdFx0bGlzdHZpZXdDbGFzc2VzICs9IHQub3B0aW9ucy5pbnNldCA/IFwiIHVpLWxpc3R2aWV3LWluc2V0XCIgOiBcIlwiO1xuXG5cdFx0aWYgKCAhIXQub3B0aW9ucy5pbnNldCApIHtcblx0XHRcdGxpc3R2aWV3Q2xhc3NlcyArPSB0Lm9wdGlvbnMuY29ybmVycyA/IFwiIHVpLWNvcm5lci1hbGxcIiA6IFwiXCI7XG5cdFx0XHRsaXN0dmlld0NsYXNzZXMgKz0gdC5vcHRpb25zLnNoYWRvdyA/IFwiIHVpLXNoYWRvd1wiIDogXCJcIjtcblx0XHR9XG5cblx0XHQvLyBjcmVhdGUgbGlzdHZpZXcgbWFya3VwXG5cdFx0dC5lbGVtZW50LmFkZENsYXNzKCBcIiB1aS1saXN0dmlld1wiICsgbGlzdHZpZXdDbGFzc2VzICk7XG5cblx0XHR0LnJlZnJlc2goIHRydWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBSZW1vdmUgaW4gMS41XG5cdF9maW5kRmlyc3RFbGVtZW50QnlUYWdOYW1lOiBmdW5jdGlvbiggZWxlLCBuZXh0UHJvcCwgbGNOYW1lLCB1Y05hbWUgKSB7XG5cdFx0dmFyIGRpY3QgPSB7fTtcblx0XHRkaWN0WyBsY05hbWUgXSA9IGRpY3RbIHVjTmFtZSBdID0gdHJ1ZTtcblx0XHR3aGlsZSAoIGVsZSApIHtcblx0XHRcdGlmICggZGljdFsgZWxlLm5vZGVOYW1lIF0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGU7XG5cdFx0XHR9XG5cdFx0XHRlbGUgPSBlbGVbIG5leHRQcm9wIF07XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXHQvLyBUT0RPOiBSZW1vdmUgaW4gMS41XG5cdF9hZGRUaHVtYkNsYXNzZXM6IGZ1bmN0aW9uKCBjb250YWluZXJzICkge1xuXHRcdHZhciBpLCBpbWcsIGxlbiA9IGNvbnRhaW5lcnMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpbWcgPSAkKCB0aGlzLl9maW5kRmlyc3RFbGVtZW50QnlUYWdOYW1lKCBjb250YWluZXJzWyBpIF0uZmlyc3RDaGlsZCwgXCJuZXh0U2libGluZ1wiLCBcImltZ1wiLCBcIklNR1wiICkgKTtcblx0XHRcdGlmICggaW1nLmxlbmd0aCApIHtcblx0XHRcdFx0JCggdGhpcy5fZmluZEZpcnN0RWxlbWVudEJ5VGFnTmFtZSggaW1nWyAwIF0ucGFyZW50Tm9kZSwgXCJwYXJlbnROb2RlXCIsIFwibGlcIiwgXCJMSVwiICkgKS5hZGRDbGFzcyggaW1nLmhhc0NsYXNzKCBcInVpLWxpLWljb25cIiApID8gXCJ1aS1saS1oYXMtaWNvblwiIDogXCJ1aS1saS1oYXMtdGh1bWJcIiApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZ2V0Q2hpbGRyZW5CeVRhZ05hbWU6IGZ1bmN0aW9uKCBlbGUsIGxjTmFtZSwgdWNOYW1lICkge1xuXHRcdHZhciByZXN1bHRzID0gW10sXG5cdFx0XHRkaWN0ID0ge307XG5cdFx0ZGljdFsgbGNOYW1lIF0gPSBkaWN0WyB1Y05hbWUgXSA9IHRydWU7XG5cdFx0ZWxlID0gZWxlLmZpcnN0Q2hpbGQ7XG5cdFx0d2hpbGUgKCBlbGUgKSB7XG5cdFx0XHRpZiAoIGRpY3RbIGVsZS5ub2RlTmFtZSBdICkge1xuXHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxlID0gZWxlLm5leHRTaWJsaW5nO1xuXHRcdH1cblx0XHRyZXR1cm4gJCggcmVzdWx0cyApO1xuXHR9LFxuXG5cdF9iZWZvcmVMaXN0dmlld1JlZnJlc2g6ICQubm9vcCxcblx0X2FmdGVyTGlzdHZpZXdSZWZyZXNoOiAkLm5vb3AsXG5cblx0cmVmcmVzaDogZnVuY3Rpb24oIGNyZWF0ZSApIHtcblx0XHR2YXIgYnV0dG9uQ2xhc3MsIHBvcywgbnVtbGksIGl0ZW0sIGl0ZW1DbGFzcywgaXRlbVRoZW1lLCBpdGVtSWNvbiwgaWNvbiwgYSxcblx0XHRcdGlzRGl2aWRlciwgc3RhcnRDb3VudCwgbmV3U3RhcnRDb3VudCwgdmFsdWUsIGxhc3QsIHNwbGl0dGhlbWUsIHNwbGl0VGhlbWVDbGFzcywgc3BsaXRpY29uLFxuXHRcdFx0YWx0QnV0dG9uQ2xhc3MsIGRpdmlkZXJUaGVtZSwgbGksXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0JGxpc3QgPSB0aGlzLmVsZW1lbnQsXG5cdFx0XHRvbCA9ICEhJC5ub2RlTmFtZSggJGxpc3RbIDAgXSwgXCJvbFwiICksXG5cdFx0XHRzdGFydCA9ICRsaXN0LmF0dHIoIFwic3RhcnRcIiApLFxuXHRcdFx0aXRlbUNsYXNzRGljdCA9IHt9LFxuXHRcdFx0Y291bnRCdWJibGVzID0gJGxpc3QuZmluZCggXCIudWktbGktY291bnRcIiApLFxuXHRcdFx0Y291bnRUaGVtZSA9IGdldEF0dHIoICRsaXN0WyAwIF0sIFwiY291bnR0aGVtZVwiICkgfHwgdGhpcy5vcHRpb25zLmNvdW50VGhlbWUsXG5cdFx0XHRjb3VudFRoZW1lQ2xhc3MgPSBjb3VudFRoZW1lID8gXCJ1aS1ib2R5LVwiICsgY291bnRUaGVtZSA6IFwidWktYm9keS1pbmhlcml0XCI7XG5cblx0XHRpZiAoIG8udGhlbWUgKSB7XG5cdFx0XHQkbGlzdC5hZGRDbGFzcyggXCJ1aS1ncm91cC10aGVtZS1cIiArIG8udGhlbWUgKTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiBhIHN0YXJ0IGF0dHJpYnV0ZSBoYXMgYmVlbiBzZXQgd2hpbGUgdGFraW5nIGEgdmFsdWUgb2YgMCBpbnRvIGFjY291bnRcblx0XHRpZiAoIG9sICYmICggc3RhcnQgfHwgc3RhcnQgPT09IDAgKSApIHtcblx0XHRcdHN0YXJ0Q291bnQgPSBwYXJzZUludCggc3RhcnQsIDEwICkgLSAxO1xuXHRcdFx0JGxpc3QuY3NzKCBcImNvdW50ZXItcmVzZXRcIiwgXCJsaXN0bnVtYmVyaW5nIFwiICsgc3RhcnRDb3VudCApO1xuXHRcdH1cblxuXHRcdHRoaXMuX2JlZm9yZUxpc3R2aWV3UmVmcmVzaCgpO1xuXG5cdFx0bGkgPSB0aGlzLl9nZXRDaGlsZHJlbkJ5VGFnTmFtZSggJGxpc3RbIDAgXSwgXCJsaVwiLCBcIkxJXCIgKTtcblxuXHRcdGZvciAoIHBvcyA9IDAsIG51bWxpID0gbGkubGVuZ3RoOyBwb3MgPCBudW1saTsgcG9zKysgKSB7XG5cdFx0XHRpdGVtID0gbGkuZXEoIHBvcyApO1xuXHRcdFx0aXRlbUNsYXNzID0gXCJcIjtcblxuXHRcdFx0aWYgKCBjcmVhdGUgfHwgaXRlbVsgMCBdLmNsYXNzTmFtZS5zZWFyY2goIC9cXGJ1aS1saS1zdGF0aWNcXGJ8XFxidWktbGktZGl2aWRlclxcYi8gKSA8IDAgKSB7XG5cdFx0XHRcdGEgPSB0aGlzLl9nZXRDaGlsZHJlbkJ5VGFnTmFtZSggaXRlbVsgMCBdLCBcImFcIiwgXCJBXCIgKTtcblx0XHRcdFx0aXNEaXZpZGVyID0gKCBnZXRBdHRyKCBpdGVtWyAwIF0sIFwicm9sZVwiICkgPT09IFwibGlzdC1kaXZpZGVyXCIgKTtcblx0XHRcdFx0dmFsdWUgPSBpdGVtLmF0dHIoIFwidmFsdWVcIiApO1xuXHRcdFx0XHRpdGVtVGhlbWUgPSBnZXRBdHRyKCBpdGVtWyAwIF0sIFwidGhlbWVcIiApO1xuXG5cdFx0XHRcdGlmICggYS5sZW5ndGggJiYgYVsgMCBdLmNsYXNzTmFtZS5zZWFyY2goIC9cXGJ1aS1idG5cXGIvICkgPCAwICYmICFpc0RpdmlkZXIgKSB7XG5cdFx0XHRcdFx0aXRlbUljb24gPSBnZXRBdHRyKCBpdGVtWyAwIF0sIFwiaWNvblwiICk7XG5cdFx0XHRcdFx0aWNvbiA9ICggaXRlbUljb24gPT09IGZhbHNlICkgPyBmYWxzZSA6ICggaXRlbUljb24gfHwgby5pY29uICk7XG5cblx0XHRcdFx0XHQvLyBUT0RPOiBSZW1vdmUgaW4gMS41IHRvZ2V0aGVyIHdpdGggbGlua3MuanMgKGxpbmtzLmpzIC8gLnVpLWxpbmsgZGVwcmVjYXRlZCBpbiAxLjQpXG5cdFx0XHRcdFx0YS5yZW1vdmVDbGFzcyggXCJ1aS1saW5rXCIgKTtcblxuXHRcdFx0XHRcdGJ1dHRvbkNsYXNzID0gXCJ1aS1idG5cIjtcblxuXHRcdFx0XHRcdGlmICggaXRlbVRoZW1lICkge1xuXHRcdFx0XHRcdFx0YnV0dG9uQ2xhc3MgKz0gXCIgdWktYnRuLVwiICsgaXRlbVRoZW1lO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggYS5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRcdFx0aXRlbUNsYXNzID0gXCJ1aS1saS1oYXMtYWx0XCI7XG5cblx0XHRcdFx0XHRcdGxhc3QgPSBhLmxhc3QoKTtcblx0XHRcdFx0XHRcdHNwbGl0dGhlbWUgPSBnZXRBdHRyKCBsYXN0WyAwIF0sIFwidGhlbWVcIiApIHx8IG8uc3BsaXRUaGVtZSB8fCBnZXRBdHRyKCBpdGVtWyAwIF0sIFwidGhlbWVcIiwgdHJ1ZSApO1xuXHRcdFx0XHRcdFx0c3BsaXRUaGVtZUNsYXNzID0gc3BsaXR0aGVtZSA/IFwiIHVpLWJ0bi1cIiArIHNwbGl0dGhlbWUgOiBcIlwiO1xuXHRcdFx0XHRcdFx0c3BsaXRpY29uID0gZ2V0QXR0ciggbGFzdFsgMCBdLCBcImljb25cIiApIHx8IGdldEF0dHIoIGl0ZW1bIDAgXSwgXCJpY29uXCIgKSB8fCBvLnNwbGl0SWNvbjtcblx0XHRcdFx0XHRcdGFsdEJ1dHRvbkNsYXNzID0gXCJ1aS1idG4gdWktYnRuLWljb24tbm90ZXh0IHVpLWljb24tXCIgKyBzcGxpdGljb24gKyBzcGxpdFRoZW1lQ2xhc3M7XG5cblx0XHRcdFx0XHRcdGxhc3Rcblx0XHRcdFx0XHRcdFx0LmF0dHIoIFwidGl0bGVcIiwgJC50cmltKCBsYXN0LmdldEVuY29kZWRUZXh0KCkgKSApXG5cdFx0XHRcdFx0XHRcdC5hZGRDbGFzcyggYWx0QnV0dG9uQ2xhc3MgKVxuXHRcdFx0XHRcdFx0XHQuZW1wdHkoKTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVkdWNlIHRvIHRoZSBmaXJzdCBhbmNob3IsIGJlY2F1c2Ugb25seSB0aGUgZmlyc3QgZ2V0cyB0aGUgYnV0dG9uQ2xhc3Ncblx0XHRcdFx0XHRcdGEgPSBhLmZpcnN0KCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggaWNvbiApIHtcblx0XHRcdFx0XHRcdGJ1dHRvbkNsYXNzICs9IFwiIHVpLWJ0bi1pY29uLXJpZ2h0IHVpLWljb24tXCIgKyBpY29uO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEFwcGx5IGJ1dHRvbkNsYXNzIHRvIHRoZSAoZmlyc3QpIGFuY2hvclxuXHRcdFx0XHRcdGEuYWRkQ2xhc3MoIGJ1dHRvbkNsYXNzICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGlzRGl2aWRlciApIHtcblx0XHRcdFx0XHRkaXZpZGVyVGhlbWUgPSAoIGdldEF0dHIoIGl0ZW1bIDAgXSwgXCJ0aGVtZVwiICkgfHwgby5kaXZpZGVyVGhlbWUgfHwgby50aGVtZSApO1xuXG5cdFx0XHRcdFx0aXRlbUNsYXNzID0gXCJ1aS1saS1kaXZpZGVyIHVpLWJhci1cIiArICggZGl2aWRlclRoZW1lID8gZGl2aWRlclRoZW1lIDogXCJpbmhlcml0XCIgKTtcblxuXHRcdFx0XHRcdGl0ZW0uYXR0ciggXCJyb2xlXCIsIFwiaGVhZGluZ1wiICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGEubGVuZ3RoIDw9IDAgKSB7XG5cdFx0XHRcdFx0aXRlbUNsYXNzID0gXCJ1aS1saS1zdGF0aWMgdWktYm9keS1cIiArICggaXRlbVRoZW1lID8gaXRlbVRoZW1lIDogXCJpbmhlcml0XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9sICYmIHZhbHVlICkge1xuXHRcdFx0XHRcdG5ld1N0YXJ0Q291bnQgPSBwYXJzZUludCggdmFsdWUgLCAxMCApIC0gMTtcblxuXHRcdFx0XHRcdGl0ZW0uY3NzKCBcImNvdW50ZXItcmVzZXRcIiwgXCJsaXN0bnVtYmVyaW5nIFwiICsgbmV3U3RhcnRDb3VudCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluc3RlYWQgb2Ygc2V0dGluZyBpdGVtIGNsYXNzIGRpcmVjdGx5IG9uIHRoZSBsaXN0IGl0ZW1cblx0XHRcdC8vIGF0IHRoaXMgcG9pbnQgaW4gdGltZSwgcHVzaCB0aGUgaXRlbSBpbnRvIGEgZGljdGlvbmFyeVxuXHRcdFx0Ly8gdGhhdCB0ZWxscyB1cyB3aGF0IGNsYXNzIHRvIHNldCBvbiBpdCBzbyB3ZSBjYW4gZG8gdGhpcyBhZnRlciB0aGlzXG5cdFx0XHQvLyBwcm9jZXNzaW5nIGxvb3AgaXMgZmluaXNoZWQuXG5cblx0XHRcdGlmICggIWl0ZW1DbGFzc0RpY3RbIGl0ZW1DbGFzcyBdICkge1xuXHRcdFx0XHRpdGVtQ2xhc3NEaWN0WyBpdGVtQ2xhc3MgXSA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHRpdGVtQ2xhc3NEaWN0WyBpdGVtQ2xhc3MgXS5wdXNoKCBpdGVtWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGFwcHJvcHJpYXRlIGxpc3R2aWV3IGl0ZW0gY2xhc3NlcyBvbiBlYWNoIGxpc3QgaXRlbS5cblx0XHQvLyBUaGUgbWFpbiByZWFzb24gd2UgZGlkbid0IGRvIHRoaXNcblx0XHQvLyBpbiB0aGUgZm9yLWxvb3AgYWJvdmUgaXMgYmVjYXVzZSB3ZSBjYW4gZWxpbWluYXRlIHBlci1pdGVtIGZ1bmN0aW9uIG92ZXJoZWFkXG5cdFx0Ly8gYnkgY2FsbGluZyBhZGRDbGFzcygpIGFuZCBjaGlsZHJlbigpIG9uY2Ugb3IgdHdpY2UgYWZ0ZXJ3YXJkcy4gVGhpc1xuXHRcdC8vIGNhbiBnaXZlIHVzIGEgc2lnbmlmaWNhbnQgYm9vc3Qgb24gcGxhdGZvcm1zIGxpa2UgV1A3LjUuXG5cblx0XHRmb3IgKCBpdGVtQ2xhc3MgaW4gaXRlbUNsYXNzRGljdCApIHtcblx0XHRcdCQoIGl0ZW1DbGFzc0RpY3RbIGl0ZW1DbGFzcyBdICkuYWRkQ2xhc3MoIGl0ZW1DbGFzcyApO1xuXHRcdH1cblxuXHRcdGNvdW50QnViYmxlcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdCQoIHRoaXMgKS5jbG9zZXN0KCBcImxpXCIgKS5hZGRDbGFzcyggXCJ1aS1saS1oYXMtY291bnRcIiApO1xuXHRcdH0pO1xuXHRcdGlmICggY291bnRUaGVtZUNsYXNzICkge1xuXHRcdFx0Y291bnRCdWJibGVzLm5vdCggXCJbY2xhc3MqPSd1aS1ib2R5LSddXCIgKS5hZGRDbGFzcyggY291bnRUaGVtZUNsYXNzICk7XG5cdFx0fVxuXG5cdFx0Ly8gRGVwcmVjYXRlZCBpbiAxLjQuIEZyb20gMS41IHlvdSBoYXZlIHRvIGFkZCBjbGFzcyB1aS1saS1oYXMtdGh1bWIgb3IgdWktbGktaGFzLWljb24gdG8gdGhlIExJLlxuXHRcdHRoaXMuX2FkZFRodW1iQ2xhc3NlcyggbGkgKTtcblx0XHR0aGlzLl9hZGRUaHVtYkNsYXNzZXMoIGxpLmZpbmQoIFwiLnVpLWJ0blwiICkgKTtcblxuXHRcdHRoaXMuX2FmdGVyTGlzdHZpZXdSZWZyZXNoKCk7XG5cblx0XHR0aGlzLl9hZGRGaXJzdExhc3RDbGFzc2VzKCBsaSwgdGhpcy5fZ2V0VmlzaWJsZXMoIGxpLCBjcmVhdGUgKSwgY3JlYXRlICk7XG5cdH1cbn0sICQubW9iaWxlLmJlaGF2aW9ycy5hZGRGaXJzdExhc3RDbGFzc2VzICkgKTtcblxufSkoIGpRdWVyeSApO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuZnVuY3Rpb24gZGVmYXVsdEF1dG9kaXZpZGVyc1NlbGVjdG9yKCBlbHQgKSB7XG5cdC8vIGxvb2sgZm9yIHRoZSB0ZXh0IGluIHRoZSBnaXZlbiBlbGVtZW50XG5cdHZhciB0ZXh0ID0gJC50cmltKCBlbHQudGV4dCgpICkgfHwgbnVsbDtcblxuXHRpZiAoICF0ZXh0ICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gY3JlYXRlIHRoZSB0ZXh0IGZvciB0aGUgZGl2aWRlciAoZmlyc3QgdXBwZXJjYXNlZCBsZXR0ZXIpXG5cdHRleHQgPSB0ZXh0LnNsaWNlKCAwLCAxICkudG9VcHBlckNhc2UoKTtcblxuXHRyZXR1cm4gdGV4dDtcbn1cblxuJC53aWRnZXQoIFwibW9iaWxlLmxpc3R2aWV3XCIsICQubW9iaWxlLmxpc3R2aWV3LCB7XG5cdG9wdGlvbnM6IHtcblx0XHRhdXRvZGl2aWRlcnM6IGZhbHNlLFxuXHRcdGF1dG9kaXZpZGVyc1NlbGVjdG9yOiBkZWZhdWx0QXV0b2RpdmlkZXJzU2VsZWN0b3Jcblx0fSxcblxuXHRfYmVmb3JlTGlzdHZpZXdSZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5hdXRvZGl2aWRlcnMgKSB7XG5cdFx0XHR0aGlzLl9yZXBsYWNlRGl2aWRlcnMoKTtcblx0XHRcdHRoaXMuX3N1cGVyQXBwbHkoIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fSxcblxuXHRfcmVwbGFjZURpdmlkZXJzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaSwgbGlzLCBsaSwgZGl2aWRlclRleHQsXG5cdFx0XHRsYXN0RGl2aWRlclRleHQgPSBudWxsLFxuXHRcdFx0bGlzdCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdGRpdmlkZXI7XG5cblx0XHRsaXN0LmNoaWxkcmVuKCBcImxpOmpxbURhdGEocm9sZT0nbGlzdC1kaXZpZGVyJylcIiApLnJlbW92ZSgpO1xuXG5cdFx0bGlzID0gbGlzdC5jaGlsZHJlbiggXCJsaVwiICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxpcy5sZW5ndGggOyBpKysgKSB7XG5cdFx0XHRsaSA9IGxpc1sgaSBdO1xuXHRcdFx0ZGl2aWRlclRleHQgPSB0aGlzLm9wdGlvbnMuYXV0b2RpdmlkZXJzU2VsZWN0b3IoICQoIGxpICkgKTtcblxuXHRcdFx0aWYgKCBkaXZpZGVyVGV4dCAmJiBsYXN0RGl2aWRlclRleHQgIT09IGRpdmlkZXJUZXh0ICkge1xuXHRcdFx0XHRkaXZpZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJsaVwiICk7XG5cdFx0XHRcdGRpdmlkZXIuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCBkaXZpZGVyVGV4dCApICk7XG5cdFx0XHRcdGRpdmlkZXIuc2V0QXR0cmlidXRlKCBcImRhdGEtXCIgKyAkLm1vYmlsZS5ucyArIFwicm9sZVwiLCBcImxpc3QtZGl2aWRlclwiICk7XG5cdFx0XHRcdGxpLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBkaXZpZGVyLCBsaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRsYXN0RGl2aWRlclRleHQgPSBkaXZpZGVyVGV4dDtcblx0XHR9XG5cdH1cbn0pO1xuXG59KSggalF1ZXJ5ICk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgcmRpdmlkZXIgPSAvKF58XFxzKXVpLWxpLWRpdmlkZXIoJHxcXHMpLyxcblx0cmhpZGRlbiA9IC8oXnxcXHMpdWktc2NyZWVuLWhpZGRlbigkfFxccykvO1xuXG4kLndpZGdldCggXCJtb2JpbGUubGlzdHZpZXdcIiwgJC5tb2JpbGUubGlzdHZpZXcsIHtcblx0b3B0aW9uczoge1xuXHRcdGhpZGVEaXZpZGVyczogZmFsc2Vcblx0fSxcblxuXHRfYWZ0ZXJMaXN0dmlld1JlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpdGVtcywgaWR4LCBpdGVtLCBoaWRlRGl2aWRlciA9IHRydWU7XG5cblx0XHR0aGlzLl9zdXBlckFwcGx5KCBhcmd1bWVudHMgKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmhpZGVEaXZpZGVycyApIHtcblx0XHRcdGl0ZW1zID0gdGhpcy5fZ2V0Q2hpbGRyZW5CeVRhZ05hbWUoIHRoaXMuZWxlbWVudFsgMCBdLCBcImxpXCIsIFwiTElcIiApO1xuXHRcdFx0Zm9yICggaWR4ID0gaXRlbXMubGVuZ3RoIC0gMSA7IGlkeCA+IC0xIDsgaWR4LS0gKSB7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtc1sgaWR4IF07XG5cdFx0XHRcdGlmICggaXRlbS5jbGFzc05hbWUubWF0Y2goIHJkaXZpZGVyICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBoaWRlRGl2aWRlciApIHtcblx0XHRcdFx0XHRcdGl0ZW0uY2xhc3NOYW1lID0gaXRlbS5jbGFzc05hbWUgKyBcIiB1aS1zY3JlZW4taGlkZGVuXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGhpZGVEaXZpZGVyID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoICFpdGVtLmNsYXNzTmFtZS5tYXRjaCggcmhpZGRlbiApICkge1xuXHRcdFx0XHRcdFx0aGlkZURpdmlkZXIgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG59KSggalF1ZXJ5ICk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLm1vYmlsZS5ub2pzID0gZnVuY3Rpb24oIHRhcmdldCApIHtcblx0JCggXCI6anFtRGF0YShyb2xlPSdub2pzJylcIiwgdGFyZ2V0ICkuYWRkQ2xhc3MoIFwidWktbm9qc1wiICk7XG59O1xuXG59KSggalF1ZXJ5ICk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLm1vYmlsZS5iZWhhdmlvcnMuZm9ybVJlc2V0ID0ge1xuXHRfaGFuZGxlRm9ybVJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9vbiggdGhpcy5lbGVtZW50LmNsb3Nlc3QoIFwiZm9ybVwiICksIHtcblx0XHRcdHJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5fZGVsYXkoIFwiX3Jlc2V0XCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufTtcblxufSkoIGpRdWVyeSApO1xuXG4vKlxuKiBcImNoZWNrYm94cmFkaW9cIiBwbHVnaW5cbiovXG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgZXNjYXBlSWQgPSAkLm1vYmlsZS5wYXRoLmhhc2hUb1NlbGVjdG9yO1xuXG4kLndpZGdldCggXCJtb2JpbGUuY2hlY2tib3hyYWRpb1wiLCAkLmV4dGVuZCgge1xuXG5cdGluaXRTZWxlY3RvcjogXCJpbnB1dDpub3QoIDpqcW1EYXRhKHJvbGU9J2ZsaXBzd2l0Y2gnICkgKVt0eXBlPSdjaGVja2JveCddLGlucHV0W3R5cGU9J3JhZGlvJ106bm90KCA6anFtRGF0YShyb2xlPSdmbGlwc3dpdGNoJyApKVwiLFxuXG5cdG9wdGlvbnM6IHtcblx0XHR0aGVtZTogXCJpbmhlcml0XCIsXG5cdFx0bWluaTogZmFsc2UsXG5cdFx0d3JhcHBlckNsYXNzOiBudWxsLFxuXHRcdGVuaGFuY2VkOiBmYWxzZSxcblx0XHRpY29ucG9zOiBcImxlZnRcIlxuXG5cdH0sXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpbnB1dCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRpbmhlcml0QXR0ciA9IGZ1bmN0aW9uKCBpbnB1dCwgZGF0YUF0dHIgKSB7XG5cdFx0XHRcdHJldHVybiBpbnB1dC5qcW1EYXRhKCBkYXRhQXR0ciApIHx8XG5cdFx0XHRcdFx0aW5wdXQuY2xvc2VzdCggXCJmb3JtLCBmaWVsZHNldFwiICkuanFtRGF0YSggZGF0YUF0dHIgKTtcblx0XHRcdH0sXG5cdFx0XHRsYWJlbCA9IHRoaXMub3B0aW9ucy5lbmhhbmNlZCA/XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlbGVtZW50OiB0aGlzLmVsZW1lbnQuc2libGluZ3MoIFwibGFiZWxcIiApLFxuXHRcdFx0XHRcdGlzUGFyZW50OiBmYWxzZVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0dGhpcy5fZmluZExhYmVsKCksXG5cdFx0XHRpbnB1dHR5cGUgPSBpbnB1dFswXS50eXBlLFxuXHRcdFx0Y2hlY2tlZENsYXNzID0gXCJ1aS1cIiArIGlucHV0dHlwZSArIFwiLW9uXCIsXG5cdFx0XHR1bmNoZWNrZWRDbGFzcyA9IFwidWktXCIgKyBpbnB1dHR5cGUgKyBcIi1vZmZcIjtcblxuXHRcdGlmICggaW5wdXR0eXBlICE9PSBcImNoZWNrYm94XCIgJiYgaW5wdXR0eXBlICE9PSBcInJhZGlvXCIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmVsZW1lbnRbMF0uZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdG8uaWNvbnBvcyA9IGluaGVyaXRBdHRyKCBpbnB1dCwgXCJpY29ucG9zXCIgKSB8fFxuXHRcdFx0bGFiZWwuZWxlbWVudC5hdHRyKCBcImRhdGEtXCIgKyAkLm1vYmlsZS5ucyArIFwiaWNvbnBvc1wiICkgfHwgby5pY29ucG9zLFxuXG5cdFx0Ly8gRXN0YWJsaXNoIG9wdGlvbnNcblx0XHRvLm1pbmkgPSBpbmhlcml0QXR0ciggaW5wdXQsIFwibWluaVwiICkgfHwgby5taW5pO1xuXG5cdFx0Ly8gRXhwb3NlIGZvciBvdGhlciBtZXRob2RzXG5cdFx0JC5leHRlbmQoIHRoaXMsIHtcblx0XHRcdGlucHV0OiBpbnB1dCxcblx0XHRcdGxhYmVsOiBsYWJlbC5lbGVtZW50LFxuXHRcdFx0bGFiZWxJc1BhcmVudDogbGFiZWwuaXNQYXJlbnQsXG5cdFx0XHRpbnB1dHR5cGU6IGlucHV0dHlwZSxcblx0XHRcdGNoZWNrZWRDbGFzczogY2hlY2tlZENsYXNzLFxuXHRcdFx0dW5jaGVja2VkQ2xhc3M6IHVuY2hlY2tlZENsYXNzXG5cdFx0fSk7XG5cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZW5oYW5jZWQgKSB7XG5cdFx0XHR0aGlzLl9lbmhhbmNlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fb24oIGxhYmVsLmVsZW1lbnQsIHtcblx0XHRcdHZtb3VzZW92ZXI6IFwiX2hhbmRsZUxhYmVsVk1vdXNlT3ZlclwiLFxuXHRcdFx0dmNsaWNrOiBcIl9oYW5kbGVMYWJlbFZDbGlja1wiXG5cdFx0fSk7XG5cblx0XHR0aGlzLl9vbiggaW5wdXQsIHtcblx0XHRcdHZtb3VzZWRvd246IFwiX2NhY2hlVmFsc1wiLFxuXHRcdFx0dmNsaWNrOiBcIl9oYW5kbGVJbnB1dFZDbGlja1wiLFxuXHRcdFx0Zm9jdXM6IFwiX2hhbmRsZUlucHV0Rm9jdXNcIixcblx0XHRcdGJsdXI6IFwiX2hhbmRsZUlucHV0Qmx1clwiXG5cdFx0fSk7XG5cblx0XHR0aGlzLl9oYW5kbGVGb3JtUmVzZXQoKTtcblx0XHR0aGlzLnJlZnJlc2goKTtcblx0fSxcblxuXHRfZmluZExhYmVsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFyZW50TGFiZWwsIGxhYmVsLCBpc1BhcmVudCxcblx0XHRcdGlucHV0ID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0bGFiZWxzTGlzdCA9IGlucHV0WyAwIF0ubGFiZWxzO1xuXG5cdFx0aWYoIGxhYmVsc0xpc3QgJiYgbGFiZWxzTGlzdC5sZW5ndGggPiAwICkge1xuXHRcdFx0bGFiZWwgPSAkKCBsYWJlbHNMaXN0WyAwIF0gKTtcblx0XHRcdGlzUGFyZW50ID0gJC5jb250YWlucyggbGFiZWxbIDAgXSwgaW5wdXRbIDAgXSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXJlbnRMYWJlbCA9IGlucHV0LmNsb3Nlc3QoIFwibGFiZWxcIiApO1xuXHRcdFx0aXNQYXJlbnQgPSAoIHBhcmVudExhYmVsLmxlbmd0aCA+IDAgKTtcblxuXHRcdFx0Ly8gTk9URTogV2luZG93cyBQaG9uZSBjb3VsZCBub3QgZmluZCB0aGUgbGFiZWwgdGhyb3VnaCBhIHNlbGVjdG9yXG5cdFx0XHQvLyBmaWx0ZXIgd29ya3MgdGhvdWdoLlxuXHRcdFx0bGFiZWwgPSBpc1BhcmVudCA/IHBhcmVudExhYmVsIDpcblx0XHRcdFx0JCggdGhpcy5kb2N1bWVudFsgMCBdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImxhYmVsXCIgKSApXG5cdFx0XHRcdFx0LmZpbHRlciggXCJbZm9yPSdcIiArIGVzY2FwZUlkKCBpbnB1dFsgMCBdLmlkICkgKyBcIiddXCIgKVxuXHRcdFx0XHRcdC5maXJzdCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRlbGVtZW50OiBsYWJlbCxcblx0XHRcdGlzUGFyZW50OiBpc1BhcmVudFxuXHRcdH07XG5cdH0sXG5cblx0X2VuaGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMubGFiZWwuYWRkQ2xhc3MoIFwidWktYnRuIHVpLWNvcm5lci1hbGxcIik7XG5cblx0XHRpZiAoIHRoaXMubGFiZWxJc1BhcmVudCApIHtcblx0XHRcdHRoaXMuaW5wdXQuYWRkKCB0aGlzLmxhYmVsICkud3JhcEFsbCggdGhpcy5fd3JhcHBlcigpICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vdGhpcy5lbGVtZW50LnJlcGxhY2VXaXRoKCB0aGlzLmlucHV0LmFkZCggdGhpcy5sYWJlbCApLndyYXBBbGwoIHRoaXMuX3dyYXBwZXIoKSApICk7XG5cdFx0XHR0aGlzLmVsZW1lbnQud3JhcCggdGhpcy5fd3JhcHBlcigpICk7XG5cdFx0XHR0aGlzLmVsZW1lbnQucGFyZW50KCkucHJlcGVuZCggdGhpcy5sYWJlbCApO1xuXHRcdH1cblxuXHRcdC8vIFdyYXAgdGhlIGlucHV0ICsgbGFiZWwgaW4gYSBkaXZcblxuXHRcdHRoaXMuX3NldE9wdGlvbnMoe1xuXHRcdFx0XCJ0aGVtZVwiOiB0aGlzLm9wdGlvbnMudGhlbWUsXG5cdFx0XHRcImljb25wb3NcIjogdGhpcy5vcHRpb25zLmljb25wb3MsXG5cdFx0XHRcIm1pbmlcIjogdGhpcy5vcHRpb25zLm1pbmlcblx0XHR9KTtcblxuXHR9LFxuXG5cdF93cmFwcGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJCggXCI8ZGl2IGNsYXNzPSdcIiAgK1xuXHRcdFx0KCB0aGlzLm9wdGlvbnMud3JhcHBlckNsYXNzID8gdGhpcy5vcHRpb25zLndyYXBwZXJDbGFzcyA6IFwiXCIgKSArXG5cdFx0XHRcIiB1aS1cIiArIHRoaXMuaW5wdXR0eXBlICtcblx0XHRcdCggdGhpcy5vcHRpb25zLmRpc2FibGVkID8gXCIgdWktc3RhdGUtZGlzYWJsZWRcIiA6IFwiXCIgKSArIFwiJyA+PC9kaXY+XCIgKTtcblx0fSxcblxuXHRfaGFuZGxlSW5wdXRGb2N1czogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5sYWJlbC5hZGRDbGFzcyggJC5tb2JpbGUuZm9jdXNDbGFzcyApO1xuXHR9LFxuXG5cdF9oYW5kbGVJbnB1dEJsdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMubGFiZWwucmVtb3ZlQ2xhc3MoICQubW9iaWxlLmZvY3VzQ2xhc3MgKTtcblx0fSxcblxuXHRfaGFuZGxlSW5wdXRWQ2xpY2s6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIEFkZHMgY2hlY2tlZCBhdHRyaWJ1dGUgdG8gY2hlY2tlZCBpbnB1dCB3aGVuIGtleWJvYXJkIGlzIHVzZWRcblx0XHR0aGlzLmVsZW1lbnQucHJvcCggXCJjaGVja2VkXCIsIHRoaXMuZWxlbWVudC5pcyggXCI6Y2hlY2tlZFwiICkgKTtcblx0XHR0aGlzLl9nZXRJbnB1dFNldCgpLm5vdCggdGhpcy5lbGVtZW50ICkucHJvcCggXCJjaGVja2VkXCIsIGZhbHNlICk7XG5cdFx0dGhpcy5fdXBkYXRlQWxsKCB0cnVlICk7XG5cdH0sXG5cblx0X2hhbmRsZUxhYmVsVk1vdXNlT3ZlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggdGhpcy5sYWJlbC5wYXJlbnQoKS5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSB7XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZUxhYmVsVkNsaWNrOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGlucHV0ID0gdGhpcy5lbGVtZW50O1xuXG5cdFx0aWYgKCBpbnB1dC5pcyggXCI6ZGlzYWJsZWRcIiApICkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9jYWNoZVZhbHMoKTtcblxuXHRcdGlucHV0LnByb3AoIFwiY2hlY2tlZFwiLCB0aGlzLmlucHV0dHlwZSA9PT0gXCJyYWRpb1wiICYmIHRydWUgfHwgIWlucHV0LnByb3AoIFwiY2hlY2tlZFwiICkgKTtcblxuXHRcdC8vIHRyaWdnZXIgY2xpY2sgaGFuZGxlcidzIGJvdW5kIGRpcmVjdGx5IHRvIHRoZSBpbnB1dCBhcyBhIHN1YnN0aXR1dGUgZm9yXG5cdFx0Ly8gaG93IGxhYmVsIGNsaWNrcyBiZWhhdmUgbm9ybWFsbHkgaW4gdGhlIGJyb3dzZXJzXG5cdFx0Ly8gVE9ETzogaXQgd291bGQgYmUgbmljZSB0byBsZXQgdGhlIGJyb3dzZXIncyBoYW5kbGUgdGhlIGNsaWNrcyBhbmQgcGFzcyB0aGVtXG5cdFx0Ly8gICAgICAgdGhyb3VnaCB0byB0aGUgYXNzb2NpYXRlIGlucHV0LiB3ZSBjYW4gc3dhbGxvdyB0aGF0IGNsaWNrIGF0IHRoZSBwYXJlbnRcblx0XHQvLyAgICAgICB3cmFwcGVyIGVsZW1lbnQgbGV2ZWxcblx0XHRpbnB1dC50cmlnZ2VySGFuZGxlciggXCJjbGlja1wiICk7XG5cblx0XHQvLyBJbnB1dCBzZXQgZm9yIGNvbW1vbiByYWRpbyBidXR0b25zIHdpbGwgY29udGFpbiBhbGwgdGhlIHJhZGlvXG5cdFx0Ly8gYnV0dG9ucywgYnV0IHdpbGwgbm90IGZvciBjaGVja2JveGVzLiBjbGVhcmluZyB0aGUgY2hlY2tlZCBzdGF0dXNcblx0XHQvLyBvZiBvdGhlciByYWRpb3MgZW5zdXJlcyB0aGUgYWN0aXZlIGJ1dHRvbiBzdGF0ZSBpcyBhcHBsaWVkIHByb3Blcmx5XG5cdFx0dGhpcy5fZ2V0SW5wdXRTZXQoKS5ub3QoIGlucHV0ICkucHJvcCggXCJjaGVja2VkXCIsIGZhbHNlICk7XG5cblx0XHR0aGlzLl91cGRhdGVBbGwoKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X2NhY2hlVmFsczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fZ2V0SW5wdXRTZXQoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdCQoIHRoaXMgKS5hdHRyKFwiZGF0YS1cIiArICQubW9iaWxlLm5zICsgXCJjYWNoZVZhbFwiLCB0aGlzLmNoZWNrZWQgKTtcblx0XHR9KTtcblx0fSxcblxuXHQvLyBSZXR1cm5zIHRob3NlIHJhZGlvIGJ1dHRvbnMgdGhhdCBhcmUgc3VwcG9zZWQgdG8gYmUgaW4gdGhlIHNhbWUgZ3JvdXAgYXNcblx0Ly8gdGhpcyByYWRpbyBidXR0b24uIEluIHRoZSBjYXNlIG9mIGEgY2hlY2tib3ggb3IgYSByYWRpbyBsYWNraW5nIGEgbmFtZVxuXHQvLyBhdHRyaWJ1dGUsIGl0IHJldHVybnMgdGhpcy5lbGVtZW50LlxuXHRfZ2V0SW5wdXRTZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxlY3RvciwgZm9ybUlkLFxuXHRcdFx0cmFkaW8gPSB0aGlzLmVsZW1lbnRbIDAgXSxcblx0XHRcdG5hbWUgPSByYWRpby5uYW1lLFxuXHRcdFx0Zm9ybSA9IHJhZGlvLmZvcm0sXG5cdFx0XHRkb2MgPSB0aGlzLmVsZW1lbnQucGFyZW50cygpLmxhc3QoKS5nZXQoIDAgKSxcblxuXHRcdFx0Ly8gQSByYWRpbyBpcyBhbHdheXMgYSBtZW1iZXIgb2YgaXRzIG93biBncm91cFxuXHRcdFx0cmFkaW9zID0gdGhpcy5lbGVtZW50O1xuXG5cdFx0Ly8gT25seSBzdGFydCBydW5uaW5nIHNlbGVjdG9ycyBpZiB0aGlzIGlzIGFuIGF0dGFjaGVkIHJhZGlvIGJ1dHRvbiB3aXRoIGEgbmFtZVxuXHRcdGlmICggbmFtZSAmJiB0aGlzLmlucHV0dHlwZSA9PT0gXCJyYWRpb1wiICYmIGRvYyApIHtcblx0XHRcdHNlbGVjdG9yID0gXCJpbnB1dFt0eXBlPSdyYWRpbyddW25hbWU9J1wiICsgZXNjYXBlSWQoIG5hbWUgKSArIFwiJ11cIjtcblxuXHRcdFx0Ly8gSWYgd2UncmUgaW5zaWRlIGEgZm9ybVxuXHRcdFx0aWYgKCBmb3JtICkge1xuXHRcdFx0XHRmb3JtSWQgPSBmb3JtLmdldEF0dHJpYnV0ZSggXCJpZFwiICk7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGZvcm0gaGFzIGFuIElELCBjb2xsZWN0IHJhZGlvcyBzY2F0dGVyZWQgdGhyb3VnaHQgdGhlIGRvY3VtZW50IHdoaWNoXG5cdFx0XHRcdC8vIG5ldmVydGhlbGVzcyBhcmUgcGFydCBvZiB0aGUgZm9ybSBieSB3YXkgb2YgdGhlIHZhbHVlIG9mIHRoZWlyIGZvcm0gYXR0cmlidXRlXG5cdFx0XHRcdGlmICggZm9ybUlkICkge1xuXHRcdFx0XHRcdHJhZGlvcyA9ICQoIHNlbGVjdG9yICsgXCJbZm9ybT0nXCIgKyBlc2NhcGVJZCggZm9ybUlkICkgKyBcIiddXCIsIGRvYyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWxzbyBhZGQgdG8gdGhvc2UgdGhlIHJhZGlvcyBpbiB0aGUgZm9ybSBpdHNlbGZcblx0XHRcdFx0cmFkaW9zID0gJCggZm9ybSApLmZpbmQoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdC8vIFNvbWUgcmFkaW9zIGluc2lkZSB0aGUgZm9ybSBtYXkgYmVsb25nIHRvIHNvbWUgb3RoZXIgZm9ybSBieSB2aXJ0dWUgb2Zcblx0XHRcdFx0XHQvLyBoYXZpbmcgYSBmb3JtIGF0dHJpYnV0ZSBkZWZpbmVkIG9uIHRoZW0sIHNvIHdlIG11c3QgZmlsdGVyIHRoZW0gb3V0IGhlcmVcblx0XHRcdFx0XHRyZXR1cm4gKCB0aGlzLmZvcm0gPT09IGZvcm0gKTtcblx0XHRcdFx0fSkuYWRkKCByYWRpb3MgKTtcblxuXHRcdFx0Ly8gSWYgd2UncmUgb3V0c2lkZSBhIGZvcm1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gQ29sbGVjdCBhbGwgdGhvc2UgcmFkaW9zIHdoaWNoIGFyZSBhbHNvIG91dHNpZGUgb2YgYSBmb3JtIGFuZCBtYXRjaCBvdXIgbmFtZVxuXHRcdFx0XHRyYWRpb3MgPSAkKCBzZWxlY3RvciwgZG9jICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gIXRoaXMuZm9ybTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByYWRpb3M7XG5cdH0sXG5cblx0X3VwZGF0ZUFsbDogZnVuY3Rpb24oIGNoYW5nZVRyaWdnZXJlZCApIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHR0aGlzLl9nZXRJbnB1dFNldCgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyICR0aGlzID0gJCggdGhpcyApO1xuXG5cdFx0XHRpZiAoICggdGhpcy5jaGVja2VkIHx8IHNlbGYuaW5wdXR0eXBlID09PSBcImNoZWNrYm94XCIgKSAmJiAhY2hhbmdlVHJpZ2dlcmVkICkge1xuXHRcdFx0XHQkdGhpcy50cmlnZ2VyKCBcImNoYW5nZVwiICk7XG5cdFx0XHR9XG5cdFx0fSlcblx0XHQuY2hlY2tib3hyYWRpbyggXCJyZWZyZXNoXCIgKTtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVmcmVzaCgpO1xuXHR9LFxuXG5cdC8vIElzIHRoZSB3aWRnZXQgc3VwcG9zZWQgdG8gZGlzcGxheSBhbiBpY29uP1xuXHRfaGFzSWNvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvbnRyb2xncm91cCwgY29udHJvbGdyb3VwV2lkZ2V0LFxuXHRcdFx0Y29udHJvbGdyb3VwQ29uc3RydWN0b3IgPSAkLm1vYmlsZS5jb250cm9sZ3JvdXA7XG5cblx0XHQvLyBJZiB0aGUgY29udHJvbGdyb3VwIHdpZGdldCBpcyBkZWZpbmVkIC4uLlxuXHRcdGlmICggY29udHJvbGdyb3VwQ29uc3RydWN0b3IgKSB7XG5cdFx0XHRjb250cm9sZ3JvdXAgPSB0aGlzLmVsZW1lbnQuY2xvc2VzdChcblx0XHRcdFx0XCI6bW9iaWxlLWNvbnRyb2xncm91cCxcIiArXG5cdFx0XHRcdGNvbnRyb2xncm91cENvbnN0cnVjdG9yLnByb3RvdHlwZS5pbml0U2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gLi4uIGFuZCB0aGUgY2hlY2tib3ggaXMgaW4gYSBjb250cm9sZ3JvdXAgLi4uXG5cdFx0XHRpZiAoIGNvbnRyb2xncm91cC5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdC8vIC4uLiBsb29rIGZvciBhIGNvbnRyb2xncm91cCB3aWRnZXQgaW5zdGFuY2UsIGFuZCAuLi5cblx0XHRcdFx0Y29udHJvbGdyb3VwV2lkZ2V0ID0gJC5kYXRhKCBjb250cm9sZ3JvdXBbIDAgXSwgXCJtb2JpbGUtY29udHJvbGdyb3VwXCIgKTtcblxuXHRcdFx0XHQvLyAuLi4gaWYgZm91bmQsIGRlY2lkZSBiYXNlZCBvbiB0aGUgb3B0aW9uIHZhbHVlLCAuLi5cblx0XHRcdFx0cmV0dXJuICggKCBjb250cm9sZ3JvdXBXaWRnZXQgPyBjb250cm9sZ3JvdXBXaWRnZXQub3B0aW9ucy50eXBlIDpcblxuXHRcdFx0XHRcdC8vIC4uLiBvdGhlcndpc2UgZGVjaWRlIGJhc2VkIG9uIHRoZSBcInR5cGVcIiBkYXRhIGF0dHJpYnV0ZS5cblx0XHRcdFx0XHRjb250cm9sZ3JvdXAuYXR0ciggXCJkYXRhLVwiICsgJC5tb2JpbGUubnMgKyBcInR5cGVcIiApICkgIT09IFwiaG9yaXpvbnRhbFwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTm9ybWFsbHksIHRoZSB3aWRnZXQgZGlzcGxheXMgYW4gaWNvbi5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzSWNvbiA9IHRoaXMuX2hhc0ljb24oKSxcblx0XHRcdGlzQ2hlY2tlZCA9IHRoaXMuZWxlbWVudFsgMCBdLmNoZWNrZWQsXG5cdFx0XHRhY3RpdmUgPSAkLm1vYmlsZS5hY3RpdmVCdG5DbGFzcyxcblx0XHRcdGljb25wb3NDbGFzcyA9IFwidWktYnRuLWljb24tXCIgKyB0aGlzLm9wdGlvbnMuaWNvbnBvcyxcblx0XHRcdGFkZENsYXNzZXMgPSBbXSxcblx0XHRcdHJlbW92ZUNsYXNzZXMgPSBbXTtcblxuXHRcdGlmICggaGFzSWNvbiApIHtcblx0XHRcdHJlbW92ZUNsYXNzZXMucHVzaCggYWN0aXZlICk7XG5cdFx0XHRhZGRDbGFzc2VzLnB1c2goIGljb25wb3NDbGFzcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmVDbGFzc2VzLnB1c2goIGljb25wb3NDbGFzcyApO1xuXHRcdFx0KCBpc0NoZWNrZWQgPyBhZGRDbGFzc2VzIDogcmVtb3ZlQ2xhc3NlcyApLnB1c2goIGFjdGl2ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaXNDaGVja2VkICkge1xuXHRcdFx0YWRkQ2xhc3Nlcy5wdXNoKCB0aGlzLmNoZWNrZWRDbGFzcyApO1xuXHRcdFx0cmVtb3ZlQ2xhc3Nlcy5wdXNoKCB0aGlzLnVuY2hlY2tlZENsYXNzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFkZENsYXNzZXMucHVzaCggdGhpcy51bmNoZWNrZWRDbGFzcyApO1xuXHRcdFx0cmVtb3ZlQ2xhc3Nlcy5wdXNoKCB0aGlzLmNoZWNrZWRDbGFzcyApO1xuXHRcdH1cblxuXHRcdHRoaXMubGFiZWxcblx0XHRcdC5hZGRDbGFzcyggYWRkQ2xhc3Nlcy5qb2luKCBcIiBcIiApIClcblx0XHRcdC5yZW1vdmVDbGFzcyggcmVtb3ZlQ2xhc3Nlcy5qb2luKCBcIiBcIiApICk7XG5cdH0sXG5cblx0d2lkZ2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5sYWJlbC5wYXJlbnQoKTtcblx0fSxcblxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGxhYmVsID0gdGhpcy5sYWJlbCxcblx0XHRcdGN1cnJlbnRPcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0b3V0ZXIgPSB0aGlzLndpZGdldCgpLFxuXHRcdFx0aGFzSWNvbiA9IHRoaXMuX2hhc0ljb24oKTtcblxuXHRcdGlmICggb3B0aW9ucy5kaXNhYmxlZCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5pbnB1dC5wcm9wKCBcImRpc2FibGVkXCIsICEhb3B0aW9ucy5kaXNhYmxlZCApO1xuXHRcdFx0b3V0ZXIudG9nZ2xlQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiwgISFvcHRpb25zLmRpc2FibGVkICk7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5taW5pICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRvdXRlci50b2dnbGVDbGFzcyggXCJ1aS1taW5pXCIsICEhb3B0aW9ucy5taW5pICk7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy50aGVtZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0bGFiZWxcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWJ0bi1cIiArIGN1cnJlbnRPcHRpb25zLnRoZW1lIClcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWJ0bi1cIiArIG9wdGlvbnMudGhlbWUgKTtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLndyYXBwZXJDbGFzcyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0b3V0ZXJcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBjdXJyZW50T3B0aW9ucy53cmFwcGVyQ2xhc3MgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIG9wdGlvbnMud3JhcHBlckNsYXNzICk7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5pY29ucG9zICE9PSB1bmRlZmluZWQgJiYgaGFzSWNvbiApIHtcblx0XHRcdGxhYmVsLnJlbW92ZUNsYXNzKCBcInVpLWJ0bi1pY29uLVwiICsgY3VycmVudE9wdGlvbnMuaWNvbnBvcyApLmFkZENsYXNzKCBcInVpLWJ0bi1pY29uLVwiICsgb3B0aW9ucy5pY29ucG9zICk7XG5cdFx0fSBlbHNlIGlmICggIWhhc0ljb24gKSB7XG5cdFx0XHRsYWJlbC5yZW1vdmVDbGFzcyggXCJ1aS1idG4taWNvbi1cIiArIGN1cnJlbnRPcHRpb25zLmljb25wb3MgKTtcblx0XHR9XG5cdFx0dGhpcy5fc3VwZXIoIG9wdGlvbnMgKTtcblx0fVxuXG59LCAkLm1vYmlsZS5iZWhhdmlvcnMuZm9ybVJlc2V0ICkgKTtcblxufSkoIGpRdWVyeSApO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoIFwibW9iaWxlLmJ1dHRvblwiLCB7XG5cblx0aW5pdFNlbGVjdG9yOiBcImlucHV0W3R5cGU9J2J1dHRvbiddLCBpbnB1dFt0eXBlPSdzdWJtaXQnXSwgaW5wdXRbdHlwZT0ncmVzZXQnXVwiLFxuXG5cdG9wdGlvbnM6IHtcblx0XHR0aGVtZTogbnVsbCxcblx0XHRpY29uOiBudWxsLFxuXHRcdGljb25wb3M6IFwibGVmdFwiLFxuXHRcdGljb25zaGFkb3c6IGZhbHNlLCAvKiBUT0RPOiBEZXByZWNhdGVkIGluIDEuNCwgcmVtb3ZlIGluIDEuNS4gKi9cblx0XHRjb3JuZXJzOiB0cnVlLFxuXHRcdHNoYWRvdzogdHJ1ZSxcblx0XHRpbmxpbmU6IG51bGwsXG5cdFx0bWluaTogbnVsbCxcblx0XHR3cmFwcGVyQ2xhc3M6IG51bGwsXG5cdFx0ZW5oYW5jZWQ6IGZhbHNlXG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cblx0XHRpZiAoIHRoaXMuZWxlbWVudC5pcyggXCI6ZGlzYWJsZWRcIiApICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLmRpc2FibGVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZW5oYW5jZWQgKSB7XG5cdFx0XHR0aGlzLl9lbmhhbmNlKCk7XG5cdFx0fVxuXG5cdFx0JC5leHRlbmQoIHRoaXMsIHtcblx0XHRcdHdyYXBwZXI6IHRoaXMuZWxlbWVudC5wYXJlbnQoKVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fb24oIHtcblx0XHRcdGZvY3VzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy53aWRnZXQoKS5hZGRDbGFzcyggJC5tb2JpbGUuZm9jdXNDbGFzcyApO1xuXHRcdFx0fSxcblxuXHRcdFx0Ymx1cjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMud2lkZ2V0KCkucmVtb3ZlQ2xhc3MoICQubW9iaWxlLmZvY3VzQ2xhc3MgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMucmVmcmVzaCggdHJ1ZSApO1xuXHR9LFxuXG5cdF9lbmhhbmNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQud3JhcCggdGhpcy5fYnV0dG9uKCkgKTtcblx0fSxcblxuXHRfYnV0dG9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGljb25DbGFzc2VzID0gdGhpcy5fZ2V0SWNvbkNsYXNzZXMoIHRoaXMub3B0aW9ucyApO1xuXG5cdFx0cmV0dXJuICQoXCI8ZGl2IGNsYXNzPSd1aS1idG4gdWktaW5wdXQtYnRuXCIgK1xuXHRcdFx0KCBvcHRpb25zLndyYXBwZXJDbGFzcyA/IFwiIFwiICsgb3B0aW9ucy53cmFwcGVyQ2xhc3MgOiBcIlwiICkgK1xuXHRcdFx0KCBvcHRpb25zLnRoZW1lID8gXCIgdWktYnRuLVwiICsgb3B0aW9ucy50aGVtZSA6IFwiXCIgKSArXG5cdFx0XHQoIG9wdGlvbnMuY29ybmVycyA/IFwiIHVpLWNvcm5lci1hbGxcIiA6IFwiXCIgKSArXG5cdFx0XHQoIG9wdGlvbnMuc2hhZG93ID8gXCIgdWktc2hhZG93XCIgOiBcIlwiICkgK1xuXHRcdFx0KCBvcHRpb25zLmlubGluZSA/IFwiIHVpLWJ0bi1pbmxpbmVcIiA6IFwiXCIgKSArXG5cdFx0XHQoIG9wdGlvbnMubWluaSA/IFwiIHVpLW1pbmlcIiA6IFwiXCIgKSArXG5cdFx0XHQoIG9wdGlvbnMuZGlzYWJsZWQgPyBcIiB1aS1zdGF0ZS1kaXNhYmxlZFwiIDogXCJcIiApICtcblx0XHRcdCggaWNvbkNsYXNzZXMgPyAoIFwiIFwiICsgaWNvbkNsYXNzZXMgKSA6IFwiXCIgKSArXG5cdFx0XHRcIicgPlwiICsgdGhpcy5lbGVtZW50LnZhbCgpICsgXCI8L2Rpdj5cIiApO1xuXHR9LFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMud3JhcHBlcjtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKCB0aGlzLmJ1dHRvbiApO1xuXHRcdFx0dGhpcy5idXR0b24ucmVtb3ZlKCk7XG5cdH0sXG5cblx0X2dldEljb25DbGFzc2VzOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRyZXR1cm4gKCBvcHRpb25zLmljb24gPyAoIFwidWktaWNvbi1cIiArIG9wdGlvbnMuaWNvbiArXG5cdFx0XHQoIG9wdGlvbnMuaWNvbnNoYWRvdyA/IFwiIHVpLXNoYWRvdy1pY29uXCIgOiBcIlwiICkgKyAvKiBUT0RPOiBEZXByZWNhdGVkIGluIDEuNCwgcmVtb3ZlIGluIDEuNS4gKi9cblx0XHRcdFwiIHVpLWJ0bi1pY29uLVwiICsgb3B0aW9ucy5pY29ucG9zICkgOiBcIlwiICk7XG5cdH0sXG5cblx0X3NldE9wdGlvbnM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBvdXRlciA9IHRoaXMud2lkZ2V0KCk7XG5cblx0XHRpZiAoIG9wdGlvbnMudGhlbWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG91dGVyXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggdGhpcy5vcHRpb25zLnRoZW1lIClcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWJ0bi1cIiArIG9wdGlvbnMudGhlbWUgKTtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmNvcm5lcnMgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG91dGVyLnRvZ2dsZUNsYXNzKCBcInVpLWNvcm5lci1hbGxcIiwgb3B0aW9ucy5jb3JuZXJzICk7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5zaGFkb3cgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG91dGVyLnRvZ2dsZUNsYXNzKCBcInVpLXNoYWRvd1wiLCBvcHRpb25zLnNoYWRvdyApO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMuaW5saW5lICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRvdXRlci50b2dnbGVDbGFzcyggXCJ1aS1idG4taW5saW5lXCIsIG9wdGlvbnMuaW5saW5lICk7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5taW5pICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRvdXRlci50b2dnbGVDbGFzcyggXCJ1aS1taW5pXCIsIG9wdGlvbnMubWluaSApO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuZWxlbWVudC5wcm9wKCBcImRpc2FibGVkXCIsIG9wdGlvbnMuZGlzYWJsZWQgKTtcblx0XHRcdG91dGVyLnRvZ2dsZUNsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIsIG9wdGlvbnMuZGlzYWJsZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMuaWNvbiAhPT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdG9wdGlvbnMuaWNvbnNoYWRvdyAhPT0gdW5kZWZpbmVkIHx8IC8qIFRPRE86IERlcHJlY2F0ZWQgaW4gMS40LCByZW1vdmUgaW4gMS41LiAqL1xuXHRcdFx0XHRvcHRpb25zLmljb25wb3MgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG91dGVyXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggdGhpcy5fZ2V0SWNvbkNsYXNzZXMoIHRoaXMub3B0aW9ucyApIClcblx0XHRcdFx0LmFkZENsYXNzKCB0aGlzLl9nZXRJY29uQ2xhc3Nlcyhcblx0XHRcdFx0XHQkLmV4dGVuZCgge30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyApICkgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdXBlciggb3B0aW9ucyApO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKCBjcmVhdGUgKSB7XG5cdFx0dmFyIG9yaWdpbmFsRWxlbWVudCxcblx0XHRcdGlzRGlzYWJsZWQgPSB0aGlzLmVsZW1lbnQucHJvcCggXCJkaXNhYmxlZFwiICk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5pY29uICYmIHRoaXMub3B0aW9ucy5pY29ucG9zID09PSBcIm5vdGV4dFwiICYmIHRoaXMuZWxlbWVudC5hdHRyKCBcInRpdGxlXCIgKSApIHtcblx0XHRcdHRoaXMuZWxlbWVudC5hdHRyKCBcInRpdGxlXCIsIHRoaXMuZWxlbWVudC52YWwoKSApO1xuXHRcdH1cblx0XHRpZiAoICFjcmVhdGUgKSB7XG5cdFx0XHRvcmlnaW5hbEVsZW1lbnQgPSB0aGlzLmVsZW1lbnQuZGV0YWNoKCk7XG5cdFx0XHQkKCB0aGlzLndyYXBwZXIgKS50ZXh0KCB0aGlzLmVsZW1lbnQudmFsKCkgKS5hcHBlbmQoIG9yaWdpbmFsRWxlbWVudCApO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCAhPT0gaXNEaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX3NldE9wdGlvbnMoeyBkaXNhYmxlZDogaXNEaXNhYmxlZCB9KTtcblx0XHR9XG5cdH1cbn0pO1xuXG59KSggalF1ZXJ5ICk7XG5cbihmdW5jdGlvbiggJCApIHtcblx0dmFyXHRtZXRhID0gJCggXCJtZXRhW25hbWU9dmlld3BvcnRdXCIgKSxcblx0XHRpbml0aWFsQ29udGVudCA9IG1ldGEuYXR0ciggXCJjb250ZW50XCIgKSxcblx0XHRkaXNhYmxlZFpvb20gPSBpbml0aWFsQ29udGVudCArIFwiLG1heGltdW0tc2NhbGU9MSwgdXNlci1zY2FsYWJsZT1ub1wiLFxuXHRcdGVuYWJsZWRab29tID0gaW5pdGlhbENvbnRlbnQgKyBcIixtYXhpbXVtLXNjYWxlPTEwLCB1c2VyLXNjYWxhYmxlPXllc1wiLFxuXHRcdGRpc2FibGVkSW5pdGlhbGx5ID0gLyh1c2VyLXNjYWxhYmxlW1xcc10qPVtcXHNdKm5vKXwobWF4aW11bS1zY2FsZVtcXHNdKj1bXFxzXSoxKVskLFxcc10vLnRlc3QoIGluaXRpYWxDb250ZW50ICk7XG5cblx0JC5tb2JpbGUuem9vbSA9ICQuZXh0ZW5kKCB7fSwge1xuXHRcdGVuYWJsZWQ6ICFkaXNhYmxlZEluaXRpYWxseSxcblx0XHRsb2NrZWQ6IGZhbHNlLFxuXHRcdGRpc2FibGU6IGZ1bmN0aW9uKCBsb2NrICkge1xuXHRcdFx0aWYgKCAhZGlzYWJsZWRJbml0aWFsbHkgJiYgISQubW9iaWxlLnpvb20ubG9ja2VkICkge1xuXHRcdFx0XHRtZXRhLmF0dHIoIFwiY29udGVudFwiLCBkaXNhYmxlZFpvb20gKTtcblx0XHRcdFx0JC5tb2JpbGUuem9vbS5lbmFibGVkID0gZmFsc2U7XG5cdFx0XHRcdCQubW9iaWxlLnpvb20ubG9ja2VkID0gbG9jayB8fCBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGVuYWJsZTogZnVuY3Rpb24oIHVubG9jayApIHtcblx0XHRcdGlmICggIWRpc2FibGVkSW5pdGlhbGx5ICYmICggISQubW9iaWxlLnpvb20ubG9ja2VkIHx8IHVubG9jayA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRtZXRhLmF0dHIoIFwiY29udGVudFwiLCBlbmFibGVkWm9vbSApO1xuXHRcdFx0XHQkLm1vYmlsZS56b29tLmVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0XHQkLm1vYmlsZS56b29tLmxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cmVzdG9yZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFkaXNhYmxlZEluaXRpYWxseSApIHtcblx0XHRcdFx0bWV0YS5hdHRyKCBcImNvbnRlbnRcIiwgaW5pdGlhbENvbnRlbnQgKTtcblx0XHRcdFx0JC5tb2JpbGUuem9vbS5lbmFibGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG59KCBqUXVlcnkgKSk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLndpZGdldCggXCJtb2JpbGUudGV4dGlucHV0XCIsIHtcblx0aW5pdFNlbGVjdG9yOiBcImlucHV0W3R5cGU9J3RleHQnXSxcIiArXG5cdFx0XCJpbnB1dFt0eXBlPSdzZWFyY2gnXSxcIiArXG5cdFx0XCI6anFtRGF0YSh0eXBlPSdzZWFyY2gnKSxcIiArXG5cdFx0XCJpbnB1dFt0eXBlPSdudW1iZXInXSxcIiArXG5cdFx0XCI6anFtRGF0YSh0eXBlPSdudW1iZXInKSxcIiArXG5cdFx0XCJpbnB1dFt0eXBlPSdwYXNzd29yZCddLFwiICtcblx0XHRcImlucHV0W3R5cGU9J2VtYWlsJ10sXCIgK1xuXHRcdFwiaW5wdXRbdHlwZT0ndXJsJ10sXCIgK1xuXHRcdFwiaW5wdXRbdHlwZT0ndGVsJ10sXCIgK1xuXHRcdFwidGV4dGFyZWEsXCIgK1xuXHRcdFwiaW5wdXRbdHlwZT0ndGltZSddLFwiICtcblx0XHRcImlucHV0W3R5cGU9J2RhdGUnXSxcIiArXG5cdFx0XCJpbnB1dFt0eXBlPSdtb250aCddLFwiICtcblx0XHRcImlucHV0W3R5cGU9J3dlZWsnXSxcIiArXG5cdFx0XCJpbnB1dFt0eXBlPSdkYXRldGltZSddLFwiICtcblx0XHRcImlucHV0W3R5cGU9J2RhdGV0aW1lLWxvY2FsJ10sXCIgK1xuXHRcdFwiaW5wdXRbdHlwZT0nY29sb3InXSxcIiArXG5cdFx0XCJpbnB1dDpub3QoW3R5cGVdKSxcIiArXG5cdFx0XCJpbnB1dFt0eXBlPSdmaWxlJ11cIixcblxuXHRvcHRpb25zOiB7XG5cdFx0dGhlbWU6IG51bGwsXG5cdFx0Y29ybmVyczogdHJ1ZSxcblx0XHRtaW5pOiBmYWxzZSxcblx0XHQvLyBUaGlzIG9wdGlvbiBkZWZhdWx0cyB0byB0cnVlIG9uIGlPUyBkZXZpY2VzLlxuXHRcdHByZXZlbnRGb2N1c1pvb206IC9pUGhvbmV8aVBhZHxpUG9kLy50ZXN0KCBuYXZpZ2F0b3IucGxhdGZvcm0gKSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIFwiQXBwbGVXZWJLaXRcIiApID4gLTEsXG5cdFx0d3JhcHBlckNsYXNzOiBcIlwiLFxuXHRcdGVuaGFuY2VkOiBmYWxzZVxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRpc1NlYXJjaCA9IHRoaXMuZWxlbWVudC5pcyggXCJbdHlwZT0nc2VhcmNoJ10sIDpqcW1EYXRhKHR5cGU9J3NlYXJjaCcpXCIgKSxcblx0XHRcdGlzVGV4dGFyZWEgPSB0aGlzLmVsZW1lbnRbIDAgXS50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIsXG5cdFx0XHRpc1JhbmdlID0gdGhpcy5lbGVtZW50LmlzKCBcIltkYXRhLVwiICsgKCAkLm1vYmlsZS5ucyB8fCBcIlwiICkgKyBcInR5cGU9J3JhbmdlJ11cIiApLFxuXHRcdFx0aW5wdXROZWVkc1dyYXAgPSAoICh0aGlzLmVsZW1lbnQuaXMoIFwiaW5wdXRcIiApIHx8XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5pcyggXCJbZGF0YS1cIiArICggJC5tb2JpbGUubnMgfHwgXCJcIiApICsgXCJ0eXBlPSdzZWFyY2gnXVwiICkgKSAmJlxuXHRcdFx0XHRcdCFpc1JhbmdlICk7XG5cblx0XHRpZiAoIHRoaXMuZWxlbWVudC5wcm9wKCBcImRpc2FibGVkXCIgKSApIHtcblx0XHRcdG9wdGlvbnMuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdCQuZXh0ZW5kKCB0aGlzLCB7XG5cdFx0XHRjbGFzc2VzOiB0aGlzLl9jbGFzc2VzRnJvbU9wdGlvbnMoKSxcblx0XHRcdGlzU2VhcmNoOiBpc1NlYXJjaCxcblx0XHRcdGlzVGV4dGFyZWE6IGlzVGV4dGFyZWEsXG5cdFx0XHRpc1JhbmdlOiBpc1JhbmdlLFxuXHRcdFx0aW5wdXROZWVkc1dyYXA6IGlucHV0TmVlZHNXcmFwXG5cdFx0fSk7XG5cblx0XHR0aGlzLl9hdXRvQ29ycmVjdCgpO1xuXG5cdFx0aWYgKCAhb3B0aW9ucy5lbmhhbmNlZCApIHtcblx0XHRcdHRoaXMuX2VuaGFuY2UoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9vbigge1xuXHRcdFx0XCJmb2N1c1wiOiBcIl9oYW5kbGVGb2N1c1wiLFxuXHRcdFx0XCJibHVyXCI6IFwiX2hhbmRsZUJsdXJcIlxuXHRcdH0pO1xuXG5cdH0sXG5cblx0cmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zZXRPcHRpb25zKHtcblx0XHRcdFwiZGlzYWJsZWRcIiA6IHRoaXMuZWxlbWVudC5pcyggXCI6ZGlzYWJsZWRcIiApXG5cdFx0fSk7XG5cdH0sXG5cblx0X2VuaGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtZW50Q2xhc3NlcyA9IFtdO1xuXG5cdFx0aWYgKCB0aGlzLmlzVGV4dGFyZWEgKSB7XG5cdFx0XHRlbGVtZW50Q2xhc3Nlcy5wdXNoKCBcInVpLWlucHV0LXRleHRcIiApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5pc1RleHRhcmVhIHx8IHRoaXMuaXNSYW5nZSApIHtcblx0XHRcdGVsZW1lbnRDbGFzc2VzLnB1c2goIFwidWktc2hhZG93LWluc2V0XCIgKTtcblx0XHR9XG5cblx0XHQvL1wic2VhcmNoXCIgYW5kIFwidGV4dFwiIGlucHV0IHdpZGdldHNcblx0XHRpZiAoIHRoaXMuaW5wdXROZWVkc1dyYXAgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQud3JhcCggdGhpcy5fd3JhcCgpICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW1lbnRDbGFzc2VzID0gZWxlbWVudENsYXNzZXMuY29uY2F0KCB0aGlzLmNsYXNzZXMgKTtcblx0XHR9XG5cblx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoIGVsZW1lbnRDbGFzc2VzLmpvaW4oIFwiIFwiICkgKTtcblx0fSxcblxuXHR3aWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAoIHRoaXMuaW5wdXROZWVkc1dyYXAgKSA/IHRoaXMuZWxlbWVudC5wYXJlbnQoKSA6IHRoaXMuZWxlbWVudDtcblx0fSxcblxuXHRfY2xhc3Nlc0Zyb21PcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGNsYXNzZXMgPSBbXTtcblxuXHRcdGNsYXNzZXMucHVzaCggXCJ1aS1ib2R5LVwiICsgKCAoIG9wdGlvbnMudGhlbWUgPT09IG51bGwgKSA/IFwiaW5oZXJpdFwiIDogb3B0aW9ucy50aGVtZSApICk7XG5cdFx0aWYgKCBvcHRpb25zLmNvcm5lcnMgKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goIFwidWktY29ybmVyLWFsbFwiICk7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5taW5pICkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCBcInVpLW1pbmlcIiApO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goIFwidWktc3RhdGUtZGlzYWJsZWRcIiApO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMud3JhcHBlckNsYXNzICkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCBvcHRpb25zLndyYXBwZXJDbGFzcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzO1xuXHR9LFxuXG5cdF93cmFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJCggXCI8ZGl2IGNsYXNzPSdcIiArXG5cdFx0XHQoIHRoaXMuaXNTZWFyY2ggPyBcInVpLWlucHV0LXNlYXJjaCBcIiA6IFwidWktaW5wdXQtdGV4dCBcIiApICtcblx0XHRcdHRoaXMuY2xhc3Nlcy5qb2luKCBcIiBcIiApICsgXCIgXCIgK1xuXHRcdFx0XCJ1aS1zaGFkb3ctaW5zZXQnPjwvZGl2PlwiICk7XG5cdH0sXG5cblx0X2F1dG9Db3JyZWN0OiBmdW5jdGlvbigpIHtcblx0XHQvLyBYWFg6IFRlbXBvcmFyeSB3b3JrYXJvdW5kIGZvciBpc3N1ZSA3ODUgKEFwcGxlIGJ1ZyA4OTEwNTg5KS5cblx0XHQvLyAgICAgIFR1cm4gb2ZmIGF1dG9jb3JyZWN0IGFuZCBhdXRvY29tcGxldGUgb24gbm9uLWlPUyA1IGRldmljZXNcblx0XHQvLyAgICAgIHNpbmNlIHRoZSBwb3B1cCB0aGV5IHVzZSBjYW4ndCBiZSBkaXNtaXNzZWQgYnkgdGhlIHVzZXIuIE5vdGVcblx0XHQvLyAgICAgIHRoYXQgd2UgdGVzdCBmb3IgdGhlIHByZXNlbmNlIG9mIHRoZSBmZWF0dXJlIGJ5IGxvb2tpbmcgZm9yXG5cdFx0Ly8gICAgICB0aGUgYXV0b2NvcnJlY3QgcHJvcGVydHkgb24gdGhlIGlucHV0IGVsZW1lbnQuIFdlIGN1cnJlbnRseVxuXHRcdC8vICAgICAgaGF2ZSBubyB0ZXN0IGZvciBpT1MgNSBvciBuZXdlciBzbyB3ZSdyZSB0ZW1wb3JhcmlseSB1c2luZ1xuXHRcdC8vICAgICAgdGhlIHRvdWNoT3ZlcmZsb3cgc3VwcG9ydCBmbGFnIGZvciBqUU0gMS4wLiBZZXMsIEkgZmVlbCBkaXJ0eS5cblx0XHQvLyAgICAgIC0gamJsYXNcblx0XHRpZiAoIHR5cGVvZiB0aGlzLmVsZW1lbnRbMF0uYXV0b2NvcnJlY3QgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdCEkLnN1cHBvcnQudG91Y2hPdmVyZmxvdyApIHtcblxuXHRcdFx0Ly8gU2V0IHRoZSBhdHRyaWJ1dGUgaW5zdGVhZCBvZiB0aGUgcHJvcGVydHkganVzdCBpbiBjYXNlIHRoZXJlXG5cdFx0XHQvLyBpcyBjb2RlIHRoYXQgYXR0ZW1wdHMgdG8gbWFrZSBtb2RpZmljYXRpb25zIHZpYSBIVE1MLlxuXHRcdFx0dGhpcy5lbGVtZW50WzBdLnNldEF0dHJpYnV0ZSggXCJhdXRvY29ycmVjdFwiLCBcIm9mZlwiICk7XG5cdFx0XHR0aGlzLmVsZW1lbnRbMF0uc2V0QXR0cmlidXRlKCBcImF1dG9jb21wbGV0ZVwiLCBcIm9mZlwiICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVCbHVyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLndpZGdldCgpLnJlbW92ZUNsYXNzKCAkLm1vYmlsZS5mb2N1c0NsYXNzICk7XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMucHJldmVudEZvY3VzWm9vbSApIHtcblx0XHRcdCQubW9iaWxlLnpvb20uZW5hYmxlKCB0cnVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVGb2N1czogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gSW4gbWFueSBzaXR1YXRpb25zLCBpT1Mgd2lsbCB6b29tIGludG8gdGhlIGlucHV0IHVwb24gdGFwLCB0aGlzXG5cdFx0Ly8gcHJldmVudHMgdGhhdCBmcm9tIGhhcHBlbmluZ1xuXHRcdGlmICggdGhpcy5vcHRpb25zLnByZXZlbnRGb2N1c1pvb20gKSB7XG5cdFx0XHQkLm1vYmlsZS56b29tLmRpc2FibGUoIHRydWUgKTtcblx0XHR9XG5cdFx0dGhpcy53aWRnZXQoKS5hZGRDbGFzcyggJC5tb2JpbGUuZm9jdXNDbGFzcyApO1xuXHR9LFxuXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XG5cdFx0dmFyIG91dGVyID0gdGhpcy53aWRnZXQoKTtcblxuXHRcdHRoaXMuX3N1cGVyKCBvcHRpb25zICk7XG5cblx0XHRpZiAoICEoIG9wdGlvbnMuZGlzYWJsZWQgPT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0b3B0aW9ucy5taW5pID09PSB1bmRlZmluZWQgJiZcblx0XHRcdG9wdGlvbnMuY29ybmVycyA9PT0gdW5kZWZpbmVkICYmXG5cdFx0XHRvcHRpb25zLnRoZW1lID09PSB1bmRlZmluZWQgJiZcblx0XHRcdG9wdGlvbnMud3JhcHBlckNsYXNzID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0b3V0ZXIucmVtb3ZlQ2xhc3MoIHRoaXMuY2xhc3Nlcy5qb2luKCBcIiBcIiApICk7XG5cdFx0XHR0aGlzLmNsYXNzZXMgPSB0aGlzLl9jbGFzc2VzRnJvbU9wdGlvbnMoKTtcblx0XHRcdG91dGVyLmFkZENsYXNzKCB0aGlzLmNsYXNzZXMuam9pbiggXCIgXCIgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy5kaXNhYmxlZCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LnByb3AoIFwiZGlzYWJsZWRcIiwgISFvcHRpb25zLmRpc2FibGVkICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5lbmhhbmNlZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmlucHV0TmVlZHNXcmFwICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LnVud3JhcCgpO1xuXHRcdH1cblx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoIFwidWktaW5wdXQtdGV4dCBcIiArIHRoaXMuY2xhc3Nlcy5qb2luKCBcIiBcIiApICk7XG5cdH1cbn0pO1xuXG59KSggalF1ZXJ5ICk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLndpZGdldCggXCJtb2JpbGUuc2xpZGVyXCIsICQuZXh0ZW5kKCB7XG5cdGluaXRTZWxlY3RvcjogXCJpbnB1dFt0eXBlPSdyYW5nZSddLCA6anFtRGF0YSh0eXBlPSdyYW5nZScpLCA6anFtRGF0YShyb2xlPSdzbGlkZXInKVwiLFxuXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcInNsaWRlXCIsXG5cblx0b3B0aW9uczoge1xuXHRcdHRoZW1lOiBudWxsLFxuXHRcdHRyYWNrVGhlbWU6IG51bGwsXG5cdFx0Y29ybmVyczogdHJ1ZSxcblx0XHRtaW5pOiBmYWxzZSxcblx0XHRoaWdobGlnaHQ6IGZhbHNlXG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cblx0XHQvLyBUT0RPOiBFYWNoIG9mIHRoZXNlIHNob3VsZCBoYXZlIGNvbW1lbnRzIGV4cGxhaW4gd2hhdCB0aGV5J3JlIGZvclxuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdGNvbnRyb2wgPSB0aGlzLmVsZW1lbnQsXG5cdFx0XHR0cmFja1RoZW1lID0gdGhpcy5vcHRpb25zLnRyYWNrVGhlbWUgfHwgJC5tb2JpbGUuZ2V0QXR0cmlidXRlKCBjb250cm9sWyAwIF0sIFwidGhlbWVcIiApLFxuXHRcdFx0dHJhY2tUaGVtZUNsYXNzID0gdHJhY2tUaGVtZSA/IFwiIHVpLWJhci1cIiArIHRyYWNrVGhlbWUgOiBcIiB1aS1iYXItaW5oZXJpdFwiLFxuXHRcdFx0Y29ybmVyQ2xhc3MgPSAoIHRoaXMub3B0aW9ucy5jb3JuZXJzIHx8IGNvbnRyb2wuanFtRGF0YSggXCJjb3JuZXJzXCIgKSApID8gXCIgdWktY29ybmVyLWFsbFwiIDogXCJcIixcblx0XHRcdG1pbmlDbGFzcyA9ICggdGhpcy5vcHRpb25zLm1pbmkgfHwgY29udHJvbC5qcW1EYXRhKCBcIm1pbmlcIiApICkgPyBcIiB1aS1taW5pXCIgOiBcIlwiLFxuXHRcdFx0Y1R5cGUgPSBjb250cm9sWyAwIF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdGlzVG9nZ2xlU3dpdGNoID0gKCBjVHlwZSA9PT0gXCJzZWxlY3RcIiApLFxuXHRcdFx0aXNSYW5nZXNsaWRlciA9IGNvbnRyb2wucGFyZW50KCkuaXMoIFwiOmpxbURhdGEocm9sZT0ncmFuZ2VzbGlkZXInKVwiICksXG5cdFx0XHRzZWxlY3RDbGFzcyA9ICggaXNUb2dnbGVTd2l0Y2ggKSA/IFwidWktc2xpZGVyLXN3aXRjaFwiIDogXCJcIixcblx0XHRcdGNvbnRyb2xJRCA9IGNvbnRyb2wuYXR0ciggXCJpZFwiICksXG5cdFx0XHQkbGFiZWwgPSAkKCBcIltmb3I9J1wiICsgY29udHJvbElEICsgXCInXVwiICksXG5cdFx0XHRsYWJlbElEID0gJGxhYmVsLmF0dHIoIFwiaWRcIiApIHx8IGNvbnRyb2xJRCArIFwiLWxhYmVsXCIsXG5cdFx0XHRtaW4gPSAhaXNUb2dnbGVTd2l0Y2ggPyBwYXJzZUZsb2F0KCBjb250cm9sLmF0dHIoIFwibWluXCIgKSApIDogMCxcblx0XHRcdG1heCA9ICAhaXNUb2dnbGVTd2l0Y2ggPyBwYXJzZUZsb2F0KCBjb250cm9sLmF0dHIoIFwibWF4XCIgKSApIDogY29udHJvbC5maW5kKCBcIm9wdGlvblwiICkubGVuZ3RoLTEsXG5cdFx0XHRzdGVwID0gd2luZG93LnBhcnNlRmxvYXQoIGNvbnRyb2wuYXR0ciggXCJzdGVwXCIgKSB8fCAxICksXG5cdFx0XHRkb21IYW5kbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApLFxuXHRcdFx0aGFuZGxlID0gJCggZG9tSGFuZGxlICksXG5cdFx0XHRkb21TbGlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0XHRzbGlkZXIgPSAkKCBkb21TbGlkZXIgKSxcblx0XHRcdHZhbHVlYmcgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ICYmICFpc1RvZ2dsZVN3aXRjaCA/IChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGJnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXHRcdFx0XHRiZy5jbGFzc05hbWUgPSBcInVpLXNsaWRlci1iZyBcIiArICQubW9iaWxlLmFjdGl2ZUJ0bkNsYXNzO1xuXHRcdFx0XHRyZXR1cm4gJCggYmcgKS5wcmVwZW5kVG8oIHNsaWRlciApO1xuXHRcdFx0fSkoKSA6IGZhbHNlLFxuXHRcdFx0b3B0aW9ucyxcblx0XHRcdHdyYXBwZXIsXG5cdFx0XHRqLCBsZW5ndGgsXG5cdFx0XHRpLCBvcHRpb25zQ291bnQsIG9yaWdUYWJJbmRleCxcblx0XHRcdHNpZGUsIGFjdGl2ZUNsYXNzLCBzbGlkZXJJbWc7XG5cblx0XHQkbGFiZWwuYXR0ciggXCJpZFwiLCBsYWJlbElEICk7XG5cdFx0dGhpcy5pc1RvZ2dsZVN3aXRjaCA9IGlzVG9nZ2xlU3dpdGNoO1xuXG5cdFx0ZG9tSGFuZGxlLnNldEF0dHJpYnV0ZSggXCJocmVmXCIsIFwiI1wiICk7XG5cdFx0ZG9tU2xpZGVyLnNldEF0dHJpYnV0ZSggXCJyb2xlXCIsIFwiYXBwbGljYXRpb25cIiApO1xuXHRcdGRvbVNsaWRlci5jbGFzc05hbWUgPSBbIHRoaXMuaXNUb2dnbGVTd2l0Y2ggPyBcInVpLXNsaWRlciB1aS1zbGlkZXItdHJhY2sgdWktc2hhZG93LWluc2V0IFwiIDogXCJ1aS1zbGlkZXItdHJhY2sgdWktc2hhZG93LWluc2V0IFwiLCBzZWxlY3RDbGFzcywgdHJhY2tUaGVtZUNsYXNzLCBjb3JuZXJDbGFzcywgbWluaUNsYXNzIF0uam9pbiggXCJcIiApO1xuXHRcdGRvbUhhbmRsZS5jbGFzc05hbWUgPSBcInVpLXNsaWRlci1oYW5kbGVcIjtcblx0XHRkb21TbGlkZXIuYXBwZW5kQ2hpbGQoIGRvbUhhbmRsZSApO1xuXG5cdFx0aGFuZGxlLmF0dHIoe1xuXHRcdFx0XCJyb2xlXCI6IFwic2xpZGVyXCIsXG5cdFx0XHRcImFyaWEtdmFsdWVtaW5cIjogbWluLFxuXHRcdFx0XCJhcmlhLXZhbHVlbWF4XCI6IG1heCxcblx0XHRcdFwiYXJpYS12YWx1ZW5vd1wiOiB0aGlzLl92YWx1ZSgpLFxuXHRcdFx0XCJhcmlhLXZhbHVldGV4dFwiOiB0aGlzLl92YWx1ZSgpLFxuXHRcdFx0XCJ0aXRsZVwiOiB0aGlzLl92YWx1ZSgpLFxuXHRcdFx0XCJhcmlhLWxhYmVsbGVkYnlcIjogbGFiZWxJRFxuXHRcdH0pO1xuXG5cdFx0JC5leHRlbmQoIHRoaXMsIHtcblx0XHRcdHNsaWRlcjogc2xpZGVyLFxuXHRcdFx0aGFuZGxlOiBoYW5kbGUsXG5cdFx0XHRjb250cm9sOiBjb250cm9sLFxuXHRcdFx0dHlwZTogY1R5cGUsXG5cdFx0XHRzdGVwOiBzdGVwLFxuXHRcdFx0bWF4OiBtYXgsXG5cdFx0XHRtaW46IG1pbixcblx0XHRcdHZhbHVlYmc6IHZhbHVlYmcsXG5cdFx0XHRpc1Jhbmdlc2xpZGVyOiBpc1Jhbmdlc2xpZGVyLFxuXHRcdFx0ZHJhZ2dpbmc6IGZhbHNlLFxuXHRcdFx0YmVmb3JlU3RhcnQ6IG51bGwsXG5cdFx0XHR1c2VyTW9kaWZpZWQ6IGZhbHNlLFxuXHRcdFx0bW91c2VNb3ZlZDogZmFsc2Vcblx0XHR9KTtcblxuXHRcdGlmICggaXNUb2dnbGVTd2l0Y2ggKSB7XG5cdFx0XHQvLyBUT0RPOiByZXN0b3JlIG9yaWdpbmFsIHRhYmluZGV4IChpZiBhbnkpIGluIGEgZGVzdHJveSBtZXRob2Rcblx0XHRcdG9yaWdUYWJJbmRleCA9IGNvbnRyb2wuYXR0ciggXCJ0YWJpbmRleFwiICk7XG5cdFx0XHRpZiAoIG9yaWdUYWJJbmRleCApIHtcblx0XHRcdFx0aGFuZGxlLmF0dHIoIFwidGFiaW5kZXhcIiwgb3JpZ1RhYkluZGV4ICk7XG5cdFx0XHR9XG5cdFx0XHRjb250cm9sLmF0dHIoIFwidGFiaW5kZXhcIiwgXCItMVwiICkuZm9jdXMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5ibHVyKCk7XG5cdFx0XHRcdGhhbmRsZS5mb2N1cygpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cdFx0XHR3cmFwcGVyLmNsYXNzTmFtZSA9IFwidWktc2xpZGVyLWlubmVyb2Zmc2V0XCI7XG5cblx0XHRcdGZvciAoIGogPSAwLCBsZW5ndGggPSBkb21TbGlkZXIuY2hpbGROb2Rlcy5sZW5ndGg7IGogPCBsZW5ndGg7IGorKyApIHtcblx0XHRcdFx0d3JhcHBlci5hcHBlbmRDaGlsZCggZG9tU2xpZGVyLmNoaWxkTm9kZXNbal0gKTtcblx0XHRcdH1cblxuXHRcdFx0ZG9tU2xpZGVyLmFwcGVuZENoaWxkKCB3cmFwcGVyICk7XG5cblx0XHRcdC8vIHNsaWRlci53cmFwSW5uZXIoIFwiPGRpdiBjbGFzcz0ndWktc2xpZGVyLWlubmVyb2Zmc2V0Jz48L2Rpdj5cIiApO1xuXG5cdFx0XHQvLyBtYWtlIHRoZSBoYW5kbGUgbW92ZSB3aXRoIGEgc21vb3RoIHRyYW5zaXRpb25cblx0XHRcdGhhbmRsZS5hZGRDbGFzcyggXCJ1aS1zbGlkZXItaGFuZGxlLXNuYXBwaW5nXCIgKTtcblxuXHRcdFx0b3B0aW9ucyA9IGNvbnRyb2wuZmluZCggXCJvcHRpb25cIiApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgb3B0aW9uc0NvdW50ID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBvcHRpb25zQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0c2lkZSA9ICFpID8gXCJiXCIgOiBcImFcIjtcblx0XHRcdFx0YWN0aXZlQ2xhc3MgPSAhaSA/IFwiXCIgOiBcIiBcIiArICQubW9iaWxlLmFjdGl2ZUJ0bkNsYXNzO1xuXHRcdFx0XHRzbGlkZXJJbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNwYW5cIiApO1xuXG5cdFx0XHRcdHNsaWRlckltZy5jbGFzc05hbWUgPSBbIFwidWktc2xpZGVyLWxhYmVsIHVpLXNsaWRlci1sYWJlbC1cIiwgc2lkZSwgYWN0aXZlQ2xhc3MgXS5qb2luKCBcIlwiICk7XG5cdFx0XHRcdHNsaWRlckltZy5zZXRBdHRyaWJ1dGUoIFwicm9sZVwiLCBcImltZ1wiICk7XG5cdFx0XHRcdHNsaWRlckltZy5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIG9wdGlvbnNbaV0uaW5uZXJIVE1MICkgKTtcblx0XHRcdFx0JCggc2xpZGVySW1nICkucHJlcGVuZFRvKCBzbGlkZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZi5fbGFiZWxzID0gJCggXCIudWktc2xpZGVyLWxhYmVsXCIsIHNsaWRlciApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbW9uaXRvciB0aGUgaW5wdXQgZm9yIHVwZGF0ZWQgdmFsdWVzXG5cdFx0Y29udHJvbC5hZGRDbGFzcyggaXNUb2dnbGVTd2l0Y2ggPyBcInVpLXNsaWRlci1zd2l0Y2hcIiA6IFwidWktc2xpZGVyLWlucHV0XCIgKTtcblxuXHRcdHRoaXMuX29uKCBjb250cm9sLCB7XG5cdFx0XHRcImNoYW5nZVwiOiBcIl9jb250cm9sQ2hhbmdlXCIsXG5cdFx0XHRcImtleXVwXCI6IFwiX2NvbnRyb2xLZXl1cFwiLFxuXHRcdFx0XCJibHVyXCI6IFwiX2NvbnRyb2xCbHVyXCIsXG5cdFx0XHRcInZtb3VzZXVwXCI6IFwiX2NvbnRyb2xWTW91c2VVcFwiXG5cdFx0fSk7XG5cblx0XHRzbGlkZXIuYmluZCggXCJ2bW91c2Vkb3duXCIsICQucHJveHkoIHRoaXMuX3NsaWRlclZNb3VzZURvd24sIHRoaXMgKSApXG5cdFx0XHQuYmluZCggXCJ2Y2xpY2tcIiwgZmFsc2UgKTtcblxuXHRcdC8vIFdlIGhhdmUgdG8gaW5zdGFudGlhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0IGZvciB0aGUgdW5iaW5kIHRvIHdvcmsgcHJvcGVybHlcblx0XHQvLyBzaW5jZSB0aGUgbWV0aG9kIGl0c2VsZiBpcyBkZWZpbmVkIGluIHRoZSBwcm90b3R5cGUgKGNhdXNpbmcgaXQgdG8gdW5iaW5kIGV2ZXJ5dGhpbmcpXG5cdFx0dGhpcy5fb24oIGRvY3VtZW50LCB7IFwidm1vdXNlbW92ZVwiOiBcIl9wcmV2ZW50RG9jdW1lbnREcmFnXCIgfSk7XG5cdFx0dGhpcy5fb24oIHNsaWRlci5hZGQoIGRvY3VtZW50ICksIHsgXCJ2bW91c2V1cFwiOiBcIl9zbGlkZXJWTW91c2VVcFwiIH0pO1xuXG5cdFx0c2xpZGVyLmluc2VydEFmdGVyKCBjb250cm9sICk7XG5cblx0XHQvLyB3cmFwIGluIGEgZGl2IGZvciBzdHlsaW5nIHB1cnBvc2VzXG5cdFx0aWYgKCAhaXNUb2dnbGVTd2l0Y2ggJiYgIWlzUmFuZ2VzbGlkZXIgKSB7XG5cdFx0XHR3cmFwcGVyID0gdGhpcy5vcHRpb25zLm1pbmkgPyBcIjxkaXYgY2xhc3M9J3VpLXNsaWRlciB1aS1taW5pJz5cIiA6IFwiPGRpdiBjbGFzcz0ndWktc2xpZGVyJz5cIjtcblxuXHRcdFx0Y29udHJvbC5hZGQoIHNsaWRlciApLndyYXBBbGwoIHdyYXBwZXIgKTtcblx0XHR9XG5cblx0XHQvLyBiaW5kIHRoZSBoYW5kbGUgZXZlbnQgY2FsbGJhY2tzIGFuZCBzZXQgdGhlIGNvbnRleHQgdG8gdGhlIHdpZGdldCBpbnN0YW5jZVxuXHRcdHRoaXMuX29uKCB0aGlzLmhhbmRsZSwge1xuXHRcdFx0XCJ2bW91c2Vkb3duXCI6IFwiX2hhbmRsZVZNb3VzZURvd25cIixcblx0XHRcdFwia2V5ZG93blwiOiBcIl9oYW5kbGVLZXlkb3duXCIsXG5cdFx0XHRcImtleXVwXCI6IFwiX2hhbmRsZUtleXVwXCJcblx0XHR9KTtcblxuXHRcdHRoaXMuaGFuZGxlLmJpbmQoIFwidmNsaWNrXCIsIGZhbHNlICk7XG5cblx0XHR0aGlzLl9oYW5kbGVGb3JtUmVzZXQoKTtcblxuXHRcdHRoaXMucmVmcmVzaCggdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUgKTtcblx0fSxcblxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0aWYgKCBvcHRpb25zLnRoZW1lICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLl9zZXRUaGVtZSggb3B0aW9ucy50aGVtZSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50cmFja1RoZW1lICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLl9zZXRUcmFja1RoZW1lKCBvcHRpb25zLnRyYWNrVGhlbWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMuY29ybmVycyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5fc2V0Q29ybmVycyggb3B0aW9ucy5jb3JuZXJzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLm1pbmkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuX3NldE1pbmkoIG9wdGlvbnMubWluaSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy5oaWdobGlnaHQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuX3NldEhpZ2hsaWdodCggb3B0aW9ucy5oaWdobGlnaHQgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuX3NldERpc2FibGVkKCBvcHRpb25zLmRpc2FibGVkICk7XG5cdFx0fVxuXHRcdHRoaXMuX3N1cGVyKCBvcHRpb25zICk7XG5cdH0sXG5cblx0X2NvbnRyb2xDaGFuZ2U6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHQvLyBpZiB0aGUgdXNlciBkcmFnZ2VkIHRoZSBoYW5kbGUsIHRoZSBcImNoYW5nZVwiIGV2ZW50IHdhcyB0cmlnZ2VyZWQgZnJvbSBpbnNpZGUgcmVmcmVzaCgpOyBkb24ndCBjYWxsIHJlZnJlc2goKSBhZ2FpblxuXHRcdGlmICggdGhpcy5fdHJpZ2dlciggXCJjb250cm9sY2hhbmdlXCIsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLm1vdXNlTW92ZWQgKSB7XG5cdFx0XHR0aGlzLnJlZnJlc2goIHRoaXMuX3ZhbHVlKCksIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0X2NvbnRyb2xLZXl1cDogZnVuY3Rpb24oLyogZXZlbnQgKi8pIHsgLy8gbmVjZXNzYXJ5P1xuXHRcdHRoaXMucmVmcmVzaCggdGhpcy5fdmFsdWUoKSwgdHJ1ZSwgdHJ1ZSApO1xuXHR9LFxuXG5cdF9jb250cm9sQmx1cjogZnVuY3Rpb24oLyogZXZlbnQgKi8pIHtcblx0XHR0aGlzLnJlZnJlc2goIHRoaXMuX3ZhbHVlKCksIHRydWUgKTtcblx0fSxcblxuXHQvLyBpdCBhcHBlYXJzIHRoZSBjbGlja2luZyB0aGUgdXAgYW5kIGRvd24gYnV0dG9ucyBpbiBjaHJvbWUgb25cblx0Ly8gcmFuZ2UvbnVtYmVyIGlucHV0cyBkb2Vzbid0IHRyaWdnZXIgYSBjaGFuZ2UgdW50aWwgdGhlIGZpZWxkIGlzXG5cdC8vIGJsdXJyZWQuIEhlcmUgd2UgY2hlY2sgdGhpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQgYW5kIHJlZnJlc2hcblx0X2NvbnRyb2xWTW91c2VVcDogZnVuY3Rpb24oLyogZXZlbnQgKi8pIHtcblx0XHR0aGlzLl9jaGVja2VkUmVmcmVzaCgpO1xuXHR9LFxuXG5cdC8vIE5PVEUgZm9yY2UgZm9jdXMgb24gaGFuZGxlXG5cdF9oYW5kbGVWTW91c2VEb3duOiBmdW5jdGlvbigvKiBldmVudCAqLykge1xuXHRcdHRoaXMuaGFuZGxlLmZvY3VzKCk7XG5cdH0sXG5cblx0X2hhbmRsZUtleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgaW5kZXggPSB0aGlzLl92YWx1ZSgpO1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEluIGFsbCBjYXNlcyBwcmV2ZW50IHRoZSBkZWZhdWx0IGFuZCBtYXJrIHRoZSBoYW5kbGUgYXMgYWN0aXZlXG5cdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcblx0XHRcdGNhc2UgJC5tb2JpbGUua2V5Q29kZS5IT01FOlxuXHRcdFx0Y2FzZSAkLm1vYmlsZS5rZXlDb2RlLkVORDpcblx0XHRcdGNhc2UgJC5tb2JpbGUua2V5Q29kZS5QQUdFX1VQOlxuXHRcdFx0Y2FzZSAkLm1vYmlsZS5rZXlDb2RlLlBBR0VfRE9XTjpcblx0XHRcdGNhc2UgJC5tb2JpbGUua2V5Q29kZS5VUDpcblx0XHRcdGNhc2UgJC5tb2JpbGUua2V5Q29kZS5SSUdIVDpcblx0XHRcdGNhc2UgJC5tb2JpbGUua2V5Q29kZS5ET1dOOlxuXHRcdFx0Y2FzZSAkLm1vYmlsZS5rZXlDb2RlLkxFRlQ6XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0aWYgKCAhdGhpcy5fa2V5U2xpZGluZyApIHtcblx0XHRcdFx0XHR0aGlzLl9rZXlTbGlkaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLmhhbmRsZS5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApOyAvKiBUT0RPOiBXZSBkb24ndCB1c2UgdGhpcyBjbGFzcyBmb3Igc3R5bGluZy4gRG8gd2UgbmVlZCB0byBhZGQgaXQ/ICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHQvLyBtb3ZlIHRoZSBzbGlkZXIgYWNjb3JkaW5nIHRvIHRoZSBrZXlwcmVzc1xuXHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0XHRjYXNlICQubW9iaWxlLmtleUNvZGUuSE9NRTpcblx0XHRcdFx0dGhpcy5yZWZyZXNoKCB0aGlzLm1pbiApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJC5tb2JpbGUua2V5Q29kZS5FTkQ6XG5cdFx0XHRcdHRoaXMucmVmcmVzaCggdGhpcy5tYXggKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICQubW9iaWxlLmtleUNvZGUuUEFHRV9VUDpcblx0XHRcdGNhc2UgJC5tb2JpbGUua2V5Q29kZS5VUDpcblx0XHRcdGNhc2UgJC5tb2JpbGUua2V5Q29kZS5SSUdIVDpcblx0XHRcdFx0dGhpcy5yZWZyZXNoKCBpbmRleCArIHRoaXMuc3RlcCApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJC5tb2JpbGUua2V5Q29kZS5QQUdFX0RPV046XG5cdFx0XHRjYXNlICQubW9iaWxlLmtleUNvZGUuRE9XTjpcblx0XHRcdGNhc2UgJC5tb2JpbGUua2V5Q29kZS5MRUZUOlxuXHRcdFx0XHR0aGlzLnJlZnJlc2goIGluZGV4IC0gdGhpcy5zdGVwICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fSwgLy8gcmVtb3ZlIGFjdGl2ZSBtYXJrXG5cblx0X2hhbmRsZUtleXVwOiBmdW5jdGlvbigvKiBldmVudCAqLykge1xuXHRcdGlmICggdGhpcy5fa2V5U2xpZGluZyApIHtcblx0XHRcdHRoaXMuX2tleVNsaWRpbmcgPSBmYWxzZTtcblx0XHRcdHRoaXMuaGFuZGxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7IC8qIFNlZSBjb21tZW50IGFib3ZlLiAqL1xuXHRcdH1cblx0fSxcblxuXHRfc2xpZGVyVk1vdXNlRG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdC8vIE5PVEU6IHdlIGRvbid0IGRvIHRoaXMgaW4gcmVmcmVzaCBiZWNhdXNlIHdlIHN0aWxsIHdhbnQgdG9cblx0XHQvLyAgICAgICBzdXBwb3J0IHByb2dyYW1tYXRpYyBhbHRlcmF0aW9uIG9mIGRpc2FibGVkIGlucHV0c1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmRpc2FibGVkIHx8ICEoIGV2ZW50LndoaWNoID09PSAxIHx8IGV2ZW50LndoaWNoID09PSAwIHx8IGV2ZW50LndoaWNoID09PSB1bmRlZmluZWQgKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLl90cmlnZ2VyKCBcImJlZm9yZXN0YXJ0XCIsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHR0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcblx0XHR0aGlzLnVzZXJNb2RpZmllZCA9IGZhbHNlO1xuXHRcdHRoaXMubW91c2VNb3ZlZCA9IGZhbHNlO1xuXG5cdFx0aWYgKCB0aGlzLmlzVG9nZ2xlU3dpdGNoICkge1xuXHRcdFx0dGhpcy5iZWZvcmVTdGFydCA9IHRoaXMuZWxlbWVudFswXS5zZWxlY3RlZEluZGV4O1xuXHRcdH1cblxuXHRcdHRoaXMucmVmcmVzaCggZXZlbnQgKTtcblx0XHR0aGlzLl90cmlnZ2VyKCBcInN0YXJ0XCIgKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X3NsaWRlclZNb3VzZVVwOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMuZHJhZ2dpbmcgKSB7XG5cdFx0XHR0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cblx0XHRcdGlmICggdGhpcy5pc1RvZ2dsZVN3aXRjaCApIHtcblx0XHRcdFx0Ly8gbWFrZSB0aGUgaGFuZGxlIG1vdmUgd2l0aCBhIHNtb290aCB0cmFuc2l0aW9uXG5cdFx0XHRcdHRoaXMuaGFuZGxlLmFkZENsYXNzKCBcInVpLXNsaWRlci1oYW5kbGUtc25hcHBpbmdcIiApO1xuXG5cdFx0XHRcdGlmICggdGhpcy5tb3VzZU1vdmVkICkge1xuXHRcdFx0XHRcdC8vIHRoaXMgaXMgYSBkcmFnLCBjaGFuZ2UgdGhlIHZhbHVlIG9ubHkgaWYgdXNlciBkcmFnZ2VkIGVub3VnaFxuXHRcdFx0XHRcdGlmICggdGhpcy51c2VyTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlZnJlc2goIHRoaXMuYmVmb3JlU3RhcnQgPT09IDAgPyAxIDogMCApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlZnJlc2goIHRoaXMuYmVmb3JlU3RhcnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2xpY2ssIGNoYW5nZSB0aGUgdmFsdWVcblx0XHRcdFx0XHR0aGlzLnJlZnJlc2goIHRoaXMuYmVmb3JlU3RhcnQgPT09IDAgPyAxIDogMCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubW91c2VNb3ZlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJzdG9wXCIgKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0X3ByZXZlbnREb2N1bWVudERyYWc6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdC8vIE5PVEU6IHdlIGRvbid0IGRvIHRoaXMgaW4gcmVmcmVzaCBiZWNhdXNlIHdlIHN0aWxsIHdhbnQgdG9cblx0XHRcdC8vICAgICAgIHN1cHBvcnQgcHJvZ3JhbW1hdGljIGFsdGVyYXRpb24gb2YgZGlzYWJsZWQgaW5wdXRzXG5cdFx0XHRpZiAoIHRoaXMuX3RyaWdnZXIoIFwiZHJhZ1wiLCBldmVudCApID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZHJhZ2dpbmcgJiYgIXRoaXMub3B0aW9ucy5kaXNhYmxlZCApIHtcblxuXHRcdFx0XHQvLyB0aGlzLm1vdXNlTW92ZWQgbXVzdCBiZSB1cGRhdGVkIGJlZm9yZSByZWZyZXNoKCkgYmVjYXVzZSBpdCB3aWxsIGJlIHVzZWQgaW4gdGhlIGNvbnRyb2wgXCJjaGFuZ2VcIiBldmVudFxuXHRcdFx0XHR0aGlzLm1vdXNlTW92ZWQgPSB0cnVlO1xuXG5cdFx0XHRcdGlmICggdGhpcy5pc1RvZ2dsZVN3aXRjaCApIHtcblx0XHRcdFx0XHQvLyBtYWtlIHRoZSBoYW5kbGUgbW92ZSBpbiBzeW5jIHdpdGggdGhlIG1vdXNlXG5cdFx0XHRcdFx0dGhpcy5oYW5kbGUucmVtb3ZlQ2xhc3MoIFwidWktc2xpZGVyLWhhbmRsZS1zbmFwcGluZ1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnJlZnJlc2goIGV2ZW50ICk7XG5cblx0XHRcdFx0Ly8gb25seSBhZnRlciByZWZyZXNoKCkgeW91IGNhbiBjYWxjdWxhdGUgdGhpcy51c2VyTW9kaWZpZWRcblx0XHRcdFx0dGhpcy51c2VyTW9kaWZpZWQgPSB0aGlzLmJlZm9yZVN0YXJ0ICE9PSB0aGlzLmVsZW1lbnRbMF0uc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0X2NoZWNrZWRSZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMudmFsdWUgIT09IHRoaXMuX3ZhbHVlKCkgKSB7XG5cdFx0XHR0aGlzLnJlZnJlc2goIHRoaXMuX3ZhbHVlKCkgKTtcblx0XHR9XG5cdH0sXG5cblx0X3ZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIHRoaXMuaXNUb2dnbGVTd2l0Y2ggPyB0aGlzLmVsZW1lbnRbMF0uc2VsZWN0ZWRJbmRleCA6IHBhcnNlRmxvYXQoIHRoaXMuZWxlbWVudC52YWwoKSApIDtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVmcmVzaCggdW5kZWZpbmVkLCBmYWxzZSwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKCB2YWwsIGlzZnJvbUNvbnRyb2wsIHByZXZlbnRJbnB1dFVwZGF0ZSApIHtcblx0XHQvLyBOT1RFOiB3ZSBkb24ndCByZXR1cm4gaGVyZSBiZWNhdXNlIHdlIHdhbnQgdG8gc3VwcG9ydCBwcm9ncmFtbWF0aWNcblx0XHQvLyAgICAgICBhbHRlcmF0aW9uIG9mIHRoZSBpbnB1dCB2YWx1ZSwgd2hpY2ggc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGUgc2xpZGVyXG5cblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRwYXJlbnRUaGVtZSA9ICQubW9iaWxlLmdldEF0dHJpYnV0ZSggdGhpcy5lbGVtZW50WyAwIF0sIFwidGhlbWVcIiApLFxuXHRcdFx0dGhlbWUgPSB0aGlzLm9wdGlvbnMudGhlbWUgfHwgcGFyZW50VGhlbWUsXG5cdFx0XHR0aGVtZUNsYXNzID0gIHRoZW1lID8gXCIgdWktYnRuLVwiICsgdGhlbWUgOiBcIlwiLFxuXHRcdFx0dHJhY2tUaGVtZSA9IHRoaXMub3B0aW9ucy50cmFja1RoZW1lIHx8IHBhcmVudFRoZW1lLFxuXHRcdFx0dHJhY2tUaGVtZUNsYXNzID0gdHJhY2tUaGVtZSA/IFwiIHVpLWJhci1cIiArIHRyYWNrVGhlbWUgOiBcIiB1aS1iYXItaW5oZXJpdFwiLFxuXHRcdFx0Y29ybmVyQ2xhc3MgPSB0aGlzLm9wdGlvbnMuY29ybmVycyA/IFwiIHVpLWNvcm5lci1hbGxcIiA6IFwiXCIsXG5cdFx0XHRtaW5pQ2xhc3MgPSB0aGlzLm9wdGlvbnMubWluaSA/IFwiIHVpLW1pbmlcIiA6IFwiXCIsXG5cdFx0XHRsZWZ0LCB3aWR0aCwgZGF0YSwgdG9sLFxuXHRcdFx0cHhTdGVwLCBwZXJjZW50LFxuXHRcdFx0Y29udHJvbCwgaXNJbnB1dCwgb3B0aW9uRWxlbWVudHMsIG1pbiwgbWF4LCBzdGVwLFxuXHRcdFx0bmV3dmFsLCB2YWxNb2RTdGVwLCBhbGlnblZhbHVlLCBwZXJjZW50UGVyU3RlcCxcblx0XHRcdGhhbmRsZVBlcmNlbnQsIGFQZXJjZW50LCBiUGVyY2VudCxcblx0XHRcdHZhbHVlQ2hhbmdlZDtcblxuXHRcdHNlbGYuc2xpZGVyWzBdLmNsYXNzTmFtZSA9IFsgdGhpcy5pc1RvZ2dsZVN3aXRjaCA/IFwidWktc2xpZGVyIHVpLXNsaWRlci1zd2l0Y2ggdWktc2xpZGVyLXRyYWNrIHVpLXNoYWRvdy1pbnNldFwiIDogXCJ1aS1zbGlkZXItdHJhY2sgdWktc2hhZG93LWluc2V0XCIsIHRyYWNrVGhlbWVDbGFzcywgY29ybmVyQ2xhc3MsIG1pbmlDbGFzcyBdLmpvaW4oIFwiXCIgKTtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCB8fCB0aGlzLmVsZW1lbnQucHJvcCggXCJkaXNhYmxlZFwiICkgKSB7XG5cdFx0XHR0aGlzLmRpc2FibGUoKTtcblx0XHR9XG5cblx0XHQvLyBzZXQgdGhlIHN0b3JlZCB2YWx1ZSBmb3IgY29tcGFyaXNvbiBsYXRlclxuXHRcdHRoaXMudmFsdWUgPSB0aGlzLl92YWx1ZSgpO1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmhpZ2hsaWdodCAmJiAhdGhpcy5pc1RvZ2dsZVN3aXRjaCAmJiB0aGlzLnNsaWRlci5maW5kKCBcIi51aS1zbGlkZXItYmdcIiApLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHRoaXMudmFsdWViZyA9IChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGJnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXHRcdFx0XHRiZy5jbGFzc05hbWUgPSBcInVpLXNsaWRlci1iZyBcIiArICQubW9iaWxlLmFjdGl2ZUJ0bkNsYXNzO1xuXHRcdFx0XHRyZXR1cm4gJCggYmcgKS5wcmVwZW5kVG8oIHNlbGYuc2xpZGVyICk7XG5cdFx0XHR9KSgpO1xuXHRcdH1cblx0XHR0aGlzLmhhbmRsZS5hZGRDbGFzcyggXCJ1aS1idG5cIiArIHRoZW1lQ2xhc3MgKyBcIiB1aS1zaGFkb3dcIiApO1xuXG5cdFx0Y29udHJvbCA9IHRoaXMuZWxlbWVudDtcblx0XHRpc0lucHV0ID0gIXRoaXMuaXNUb2dnbGVTd2l0Y2g7XG5cdFx0b3B0aW9uRWxlbWVudHMgPSBpc0lucHV0ID8gW10gOiBjb250cm9sLmZpbmQoIFwib3B0aW9uXCIgKTtcblx0XHRtaW4gPSAgaXNJbnB1dCA/IHBhcnNlRmxvYXQoIGNvbnRyb2wuYXR0ciggXCJtaW5cIiApICkgOiAwO1xuXHRcdG1heCA9IGlzSW5wdXQgPyBwYXJzZUZsb2F0KCBjb250cm9sLmF0dHIoIFwibWF4XCIgKSApIDogb3B0aW9uRWxlbWVudHMubGVuZ3RoIC0gMTtcblx0XHRzdGVwID0gKCBpc0lucHV0ICYmIHBhcnNlRmxvYXQoIGNvbnRyb2wuYXR0ciggXCJzdGVwXCIgKSApID4gMCApID8gcGFyc2VGbG9hdCggY29udHJvbC5hdHRyKCBcInN0ZXBcIiApICkgOiAxO1xuXG5cdFx0aWYgKCB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0ZGF0YSA9IHZhbDtcblx0XHRcdC8vIGEgc2xpZ2h0IHRvbGVyYW5jZSBoZWxwZWQgZ2V0IHRvIHRoZSBlbmRzIG9mIHRoZSBzbGlkZXJcblx0XHRcdHRvbCA9IDg7XG5cblx0XHRcdGxlZnQgPSB0aGlzLnNsaWRlci5vZmZzZXQoKS5sZWZ0O1xuXHRcdFx0d2lkdGggPSB0aGlzLnNsaWRlci53aWR0aCgpO1xuXHRcdFx0cHhTdGVwID0gd2lkdGgvKChtYXgtbWluKS9zdGVwKTtcblx0XHRcdGlmICggIXRoaXMuZHJhZ2dpbmcgfHxcblx0XHRcdFx0XHRkYXRhLnBhZ2VYIDwgbGVmdCAtIHRvbCB8fFxuXHRcdFx0XHRcdGRhdGEucGFnZVggPiBsZWZ0ICsgd2lkdGggKyB0b2wgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggcHhTdGVwID4gMSApIHtcblx0XHRcdFx0cGVyY2VudCA9ICggKCBkYXRhLnBhZ2VYIC0gbGVmdCApIC8gd2lkdGggKSAqIDEwMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBlcmNlbnQgPSBNYXRoLnJvdW5kKCAoICggZGF0YS5wYWdlWCAtIGxlZnQgKSAvIHdpZHRoICkgKiAxMDAgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gaXNJbnB1dCA/IHBhcnNlRmxvYXQoIGNvbnRyb2wudmFsKCkgfHwgMCApIDogY29udHJvbFswXS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cGVyY2VudCA9ICggcGFyc2VGbG9hdCggdmFsICkgLSBtaW4gKSAvICggbWF4IC0gbWluICkgKiAxMDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc05hTiggcGVyY2VudCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5ld3ZhbCA9ICggcGVyY2VudCAvIDEwMCApICogKCBtYXggLSBtaW4gKSArIG1pbjtcblxuXHRcdC8vZnJvbSBqUXVlcnkgVUkgc2xpZGVyLCB0aGUgZm9sbG93aW5nIHNvdXJjZSB3aWxsIHJvdW5kIHRvIHRoZSBuZWFyZXN0IHN0ZXBcblx0XHR2YWxNb2RTdGVwID0gKCBuZXd2YWwgLSBtaW4gKSAlIHN0ZXA7XG5cdFx0YWxpZ25WYWx1ZSA9IG5ld3ZhbCAtIHZhbE1vZFN0ZXA7XG5cblx0XHRpZiAoIE1hdGguYWJzKCB2YWxNb2RTdGVwICkgKiAyID49IHN0ZXAgKSB7XG5cdFx0XHRhbGlnblZhbHVlICs9ICggdmFsTW9kU3RlcCA+IDAgKSA/IHN0ZXAgOiAoIC1zdGVwICk7XG5cdFx0fVxuXG5cdFx0cGVyY2VudFBlclN0ZXAgPSAxMDAvKChtYXgtbWluKS9zdGVwKTtcblx0XHQvLyBTaW5jZSBKYXZhU2NyaXB0IGhhcyBwcm9ibGVtcyB3aXRoIGxhcmdlIGZsb2F0cywgcm91bmRcblx0XHQvLyB0aGUgZmluYWwgdmFsdWUgdG8gNSBkaWdpdHMgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQgKHNlZSBqUXVlcnlVSTogIzQxMjQpXG5cdFx0bmV3dmFsID0gcGFyc2VGbG9hdCggYWxpZ25WYWx1ZS50b0ZpeGVkKDUpICk7XG5cblx0XHRpZiAoIHR5cGVvZiBweFN0ZXAgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRweFN0ZXAgPSB3aWR0aCAvICggKG1heC1taW4pIC8gc3RlcCApO1xuXHRcdH1cblx0XHRpZiAoIHB4U3RlcCA+IDEgJiYgaXNJbnB1dCApIHtcblx0XHRcdHBlcmNlbnQgPSAoIG5ld3ZhbCAtIG1pbiApICogcGVyY2VudFBlclN0ZXAgKiAoIDEgLyBzdGVwICk7XG5cdFx0fVxuXHRcdGlmICggcGVyY2VudCA8IDAgKSB7XG5cdFx0XHRwZXJjZW50ID0gMDtcblx0XHR9XG5cblx0XHRpZiAoIHBlcmNlbnQgPiAxMDAgKSB7XG5cdFx0XHRwZXJjZW50ID0gMTAwO1xuXHRcdH1cblxuXHRcdGlmICggbmV3dmFsIDwgbWluICkge1xuXHRcdFx0bmV3dmFsID0gbWluO1xuXHRcdH1cblxuXHRcdGlmICggbmV3dmFsID4gbWF4ICkge1xuXHRcdFx0bmV3dmFsID0gbWF4O1xuXHRcdH1cblxuXHRcdHRoaXMuaGFuZGxlLmNzcyggXCJsZWZ0XCIsIHBlcmNlbnQgKyBcIiVcIiApO1xuXG5cdFx0dGhpcy5oYW5kbGVbMF0uc2V0QXR0cmlidXRlKCBcImFyaWEtdmFsdWVub3dcIiwgaXNJbnB1dCA/IG5ld3ZhbCA6IG9wdGlvbkVsZW1lbnRzLmVxKCBuZXd2YWwgKS5hdHRyKCBcInZhbHVlXCIgKSApO1xuXG5cdFx0dGhpcy5oYW5kbGVbMF0uc2V0QXR0cmlidXRlKCBcImFyaWEtdmFsdWV0ZXh0XCIsIGlzSW5wdXQgPyBuZXd2YWwgOiBvcHRpb25FbGVtZW50cy5lcSggbmV3dmFsICkuZ2V0RW5jb2RlZFRleHQoKSApO1xuXG5cdFx0dGhpcy5oYW5kbGVbMF0uc2V0QXR0cmlidXRlKCBcInRpdGxlXCIsIGlzSW5wdXQgPyBuZXd2YWwgOiBvcHRpb25FbGVtZW50cy5lcSggbmV3dmFsICkuZ2V0RW5jb2RlZFRleHQoKSApO1xuXG5cdFx0aWYgKCB0aGlzLnZhbHVlYmcgKSB7XG5cdFx0XHR0aGlzLnZhbHVlYmcuY3NzKCBcIndpZHRoXCIsIHBlcmNlbnQgKyBcIiVcIiApO1xuXHRcdH1cblxuXHRcdC8vIGRyYWcgdGhlIGxhYmVsIHdpZHRoc1xuXHRcdGlmICggdGhpcy5fbGFiZWxzICkge1xuXHRcdFx0aGFuZGxlUGVyY2VudCA9IHRoaXMuaGFuZGxlLndpZHRoKCkgLyB0aGlzLnNsaWRlci53aWR0aCgpICogMTAwO1xuXHRcdFx0YVBlcmNlbnQgPSBwZXJjZW50ICYmIGhhbmRsZVBlcmNlbnQgKyAoIDEwMCAtIGhhbmRsZVBlcmNlbnQgKSAqIHBlcmNlbnQgLyAxMDA7XG5cdFx0XHRiUGVyY2VudCA9IHBlcmNlbnQgPT09IDEwMCA/IDAgOiBNYXRoLm1pbiggaGFuZGxlUGVyY2VudCArIDEwMCAtIGFQZXJjZW50LCAxMDAgKTtcblxuXHRcdFx0dGhpcy5fbGFiZWxzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBhYiA9ICQoIHRoaXMgKS5oYXNDbGFzcyggXCJ1aS1zbGlkZXItbGFiZWwtYVwiICk7XG5cdFx0XHRcdCQoIHRoaXMgKS53aWR0aCggKCBhYiA/IGFQZXJjZW50IDogYlBlcmNlbnQgICkgKyBcIiVcIiApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhcHJldmVudElucHV0VXBkYXRlICkge1xuXHRcdFx0dmFsdWVDaGFuZ2VkID0gZmFsc2U7XG5cblx0XHRcdC8vIHVwZGF0ZSBjb250cm9sXCJzIHZhbHVlXG5cdFx0XHRpZiAoIGlzSW5wdXQgKSB7XG5cdFx0XHRcdHZhbHVlQ2hhbmdlZCA9IGNvbnRyb2wudmFsKCkgIT09IG5ld3ZhbDtcblx0XHRcdFx0Y29udHJvbC52YWwoIG5ld3ZhbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsdWVDaGFuZ2VkID0gY29udHJvbFsgMCBdLnNlbGVjdGVkSW5kZXggIT09IG5ld3ZhbDtcblx0XHRcdFx0Y29udHJvbFsgMCBdLnNlbGVjdGVkSW5kZXggPSBuZXd2YWw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuX3RyaWdnZXIoIFwiYmVmb3JlY2hhbmdlXCIsIHZhbCApID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICggIWlzZnJvbUNvbnRyb2wgJiYgdmFsdWVDaGFuZ2VkICkge1xuXHRcdFx0XHRjb250cm9sLnRyaWdnZXIoIFwiY2hhbmdlXCIgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3NldEhpZ2hsaWdodDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhbHVlID0gISF2YWx1ZTtcblx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLmhpZ2hsaWdodCA9ICEhdmFsdWU7XG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnZhbHVlYmcgKSB7XG5cdFx0XHR0aGlzLnZhbHVlYmcucmVtb3ZlKCk7XG5cdFx0XHR0aGlzLnZhbHVlYmcgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFRoZW1lOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dGhpcy5oYW5kbGVcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1idG4tXCIgKyB0aGlzLm9wdGlvbnMudGhlbWUgKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLWJ0bi1cIiArIHZhbHVlICk7XG5cblx0XHR2YXIgY3VycmVudFRoZW1lID0gdGhpcy5vcHRpb25zLnRoZW1lID8gdGhpcy5vcHRpb25zLnRoZW1lIDogXCJpbmhlcml0XCIsXG5cdFx0XHRuZXdUaGVtZSA9IHZhbHVlID8gdmFsdWUgOiBcImluaGVyaXRcIjtcblxuXHRcdHRoaXMuY29udHJvbFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWJvZHktXCIgKyBjdXJyZW50VGhlbWUgKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLWJvZHktXCIgKyBuZXdUaGVtZSApO1xuXHR9LFxuXG5cdF9zZXRUcmFja1RoZW1lOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGN1cnJlbnRUcmFja1RoZW1lID0gdGhpcy5vcHRpb25zLnRyYWNrVGhlbWUgPyB0aGlzLm9wdGlvbnMudHJhY2tUaGVtZSA6IFwiaW5oZXJpdFwiLFxuXHRcdFx0bmV3VHJhY2tUaGVtZSA9IHZhbHVlID8gdmFsdWUgOiBcImluaGVyaXRcIjtcblxuXHRcdHRoaXMuc2xpZGVyXG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktYm9keS1cIiArIGN1cnJlbnRUcmFja1RoZW1lIClcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1ib2R5LVwiICsgbmV3VHJhY2tUaGVtZSApO1xuXHR9LFxuXG5cdF9zZXRNaW5pOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFsdWUgPSAhIXZhbHVlO1xuXHRcdGlmICggIXRoaXMuaXNUb2dnbGVTd2l0Y2ggJiYgIXRoaXMuaXNSYW5nZXNsaWRlciApIHtcblx0XHRcdHRoaXMuc2xpZGVyLnBhcmVudCgpLnRvZ2dsZUNsYXNzKCBcInVpLW1pbmlcIiwgdmFsdWUgKTtcblx0XHRcdHRoaXMuZWxlbWVudC50b2dnbGVDbGFzcyggXCJ1aS1taW5pXCIsIHZhbHVlICk7XG5cdFx0fVxuXHRcdHRoaXMuc2xpZGVyLnRvZ2dsZUNsYXNzKCBcInVpLW1pbmlcIiwgdmFsdWUgKTtcblx0fSxcblxuXHRfc2V0Q29ybmVyczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHRoaXMuc2xpZGVyLnRvZ2dsZUNsYXNzKCBcInVpLWNvcm5lci1hbGxcIiwgdmFsdWUgKTtcblxuXHRcdGlmICggIXRoaXMuaXNUb2dnbGVTd2l0Y2ggKSB7XG5cdFx0XHR0aGlzLmNvbnRyb2wudG9nZ2xlQ2xhc3MoIFwidWktY29ybmVyLWFsbFwiLCB2YWx1ZSApO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0RGlzYWJsZWQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YWx1ZSA9ICEhdmFsdWU7XG5cdFx0dGhpcy5lbGVtZW50LnByb3AoIFwiZGlzYWJsZWRcIiwgdmFsdWUgKTtcblx0XHR0aGlzLnNsaWRlclxuXHRcdFx0LnRvZ2dsZUNsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIsIHZhbHVlIClcblx0XHRcdC5hdHRyKCBcImFyaWEtZGlzYWJsZWRcIiwgdmFsdWUgKTtcblx0fVxuXG59LCAkLm1vYmlsZS5iZWhhdmlvcnMuZm9ybVJlc2V0ICkgKTtcblxufSkoIGpRdWVyeSApO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIHBvcHVwO1xuXG5mdW5jdGlvbiBnZXRQb3B1cCgpIHtcblx0aWYgKCAhcG9wdXAgKSB7XG5cdFx0cG9wdXAgPSAkKCBcIjxkaXY+PC9kaXY+XCIsIHtcblx0XHRcdFwiY2xhc3NcIjogXCJ1aS1zbGlkZXItcG9wdXAgdWktc2hhZG93IHVpLWNvcm5lci1hbGxcIlxuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBwb3B1cC5jbG9uZSgpO1xufVxuXG4kLndpZGdldCggXCJtb2JpbGUuc2xpZGVyXCIsICQubW9iaWxlLnNsaWRlciwge1xuXHRvcHRpb25zOiB7XG5cdFx0cG9wdXBFbmFibGVkOiBmYWxzZSxcblx0XHRzaG93VmFsdWU6IGZhbHNlXG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc3VwZXIoKTtcblxuXHRcdCQuZXh0ZW5kKCB0aGlzLCB7XG5cdFx0XHRfY3VycmVudFZhbHVlOiBudWxsLFxuXHRcdFx0X3BvcHVwOiBudWxsLFxuXHRcdFx0X3BvcHVwVmlzaWJsZTogZmFsc2Vcblx0XHR9KTtcblxuXHRcdHRoaXMuX3NldE9wdGlvbiggXCJwb3B1cEVuYWJsZWRcIiwgdGhpcy5vcHRpb25zLnBvcHVwRW5hYmxlZCApO1xuXG5cdFx0dGhpcy5fb24oIHRoaXMuaGFuZGxlLCB7IFwidm1vdXNlZG93blwiIDogXCJfc2hvd1BvcHVwXCIgfSApO1xuXHRcdHRoaXMuX29uKCB0aGlzLnNsaWRlci5hZGQoIHRoaXMuZG9jdW1lbnQgKSwgeyBcInZtb3VzZXVwXCIgOiBcIl9oaWRlUG9wdXBcIiB9ICk7XG5cdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uIHRoZSBwb3B1cCBjZW50ZXJlZCA1cHggYWJvdmUgdGhlIGhhbmRsZVxuXHRfcG9zaXRpb25Qb3B1cDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRzdE9mZnNldCA9IHRoaXMuaGFuZGxlLm9mZnNldCgpO1xuXG5cdFx0dGhpcy5fcG9wdXAub2Zmc2V0KCB7XG5cdFx0XHRsZWZ0OiBkc3RPZmZzZXQubGVmdCArICggdGhpcy5oYW5kbGUud2lkdGgoKSAtIHRoaXMuX3BvcHVwLndpZHRoKCkgKSAvIDIsXG5cdFx0XHR0b3A6IGRzdE9mZnNldC50b3AgLSB0aGlzLl9wb3B1cC5vdXRlckhlaWdodCgpIC0gNVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJzaG93VmFsdWVcIiApIHtcblx0XHRcdHRoaXMuaGFuZGxlLmh0bWwoIHZhbHVlICYmICF0aGlzLm9wdGlvbnMubWluaSA/IHRoaXMuX3ZhbHVlKCkgOiBcIlwiICk7XG5cdFx0fSBlbHNlIGlmICgga2V5ID09PSBcInBvcHVwRW5hYmxlZFwiICkge1xuXHRcdFx0aWYgKCB2YWx1ZSAmJiAhdGhpcy5fcG9wdXAgKSB7XG5cdFx0XHRcdHRoaXMuX3BvcHVwID0gZ2V0UG9wdXAoKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1ib2R5LVwiICsgKCB0aGlzLm9wdGlvbnMudGhlbWUgfHwgXCJhXCIgKSApXG5cdFx0XHRcdFx0LmhpZGUoKVxuXHRcdFx0XHRcdC5pbnNlcnRCZWZvcmUoIHRoaXMuZWxlbWVudCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBzaG93IHZhbHVlIG9uIHRoZSBoYW5kbGUgYW5kIGluIHBvcHVwXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3N1cGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdH0sXG5cblx0X3JlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zLCBuZXdWYWx1ZTtcblxuXHRcdGlmICggby5wb3B1cEVuYWJsZWQgKSB7XG5cdFx0XHQvLyByZW1vdmUgdGhlIHRpdGxlIGF0dHJpYnV0ZSBmcm9tIHRoZSBoYW5kbGUgKHdoaWNoIGlzXG5cdFx0XHQvLyByZXNwb25zaWJsZSBmb3IgdGhlIGFubm95aW5nIHRvb2x0aXApOyBOQiB3ZSBoYXZlXG5cdFx0XHQvLyB0byBkbyBpdCBoZXJlIGFzIHRoZSBqcW0gc2xpZGVyIHNldHMgaXQgZXZlcnkgdGltZVxuXHRcdFx0Ly8gdGhlIHNsaWRlcidzIHZhbHVlIGNoYW5nZXMgOihcblx0XHRcdHRoaXMuaGFuZGxlLnJlbW92ZUF0dHIoIFwidGl0bGVcIiApO1xuXHRcdH1cblxuXHRcdG5ld1ZhbHVlID0gdGhpcy5fdmFsdWUoKTtcblx0XHRpZiAoIG5ld1ZhbHVlID09PSB0aGlzLl9jdXJyZW50VmFsdWUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX2N1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuXG5cdFx0aWYgKCBvLnBvcHVwRW5hYmxlZCAmJiB0aGlzLl9wb3B1cCApIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9uUG9wdXAoKTtcblx0XHRcdHRoaXMuX3BvcHVwLmh0bWwoIG5ld1ZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvLnNob3dWYWx1ZSAmJiAhdGhpcy5vcHRpb25zLm1pbmkgKSB7XG5cdFx0XHR0aGlzLmhhbmRsZS5odG1sKCBuZXdWYWx1ZSApO1xuXHRcdH1cblx0fSxcblxuXHRfc2hvd1BvcHVwOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5wb3B1cEVuYWJsZWQgJiYgIXRoaXMuX3BvcHVwVmlzaWJsZSApIHtcblx0XHRcdHRoaXMuaGFuZGxlLmh0bWwoIFwiXCIgKTtcblx0XHRcdHRoaXMuX3BvcHVwLnNob3coKTtcblx0XHRcdHRoaXMuX3Bvc2l0aW9uUG9wdXAoKTtcblx0XHRcdHRoaXMuX3BvcHVwVmlzaWJsZSA9IHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdF9oaWRlUG9wdXA6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKCBvLnBvcHVwRW5hYmxlZCAmJiB0aGlzLl9wb3B1cFZpc2libGUgKSB7XG5cdFx0XHRpZiAoIG8uc2hvd1ZhbHVlICYmICFvLm1pbmkgKSB7XG5cdFx0XHRcdHRoaXMuaGFuZGxlLmh0bWwoIHRoaXMuX3ZhbHVlKCkgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3BvcHVwLmhpZGUoKTtcblx0XHRcdHRoaXMuX3BvcHVwVmlzaWJsZSA9IGZhbHNlO1xuXHRcdH1cblx0fVxufSk7XG5cbn0pKCBqUXVlcnkgKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQud2lkZ2V0KCBcIm1vYmlsZS5mbGlwc3dpdGNoXCIsICQuZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0b25UZXh0OiBcIk9uXCIsXG5cdFx0b2ZmVGV4dDogXCJPZmZcIixcblx0XHR0aGVtZTogbnVsbCxcblx0XHRlbmhhbmNlZDogZmFsc2UsXG5cdFx0d3JhcHBlckNsYXNzOiBudWxsLFxuXHRcdGNvcm5lcnM6IHRydWUsXG5cdFx0bWluaTogZmFsc2Vcblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXRoaXMub3B0aW9ucy5lbmhhbmNlZCApIHtcblx0XHRcdFx0dGhpcy5fZW5oYW5jZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JC5leHRlbmQoIHRoaXMsIHtcblx0XHRcdFx0XHRmbGlwc3dpdGNoOiB0aGlzLmVsZW1lbnQucGFyZW50KCksXG5cdFx0XHRcdFx0b246IHRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1mbGlwc3dpdGNoLW9uXCIgKS5lcSggMCApLFxuXHRcdFx0XHRcdG9mZjogdGhpcy5lbGVtZW50LmZpbmQoIFwiLnVpLWZsaXBzd2l0Y2gtb2ZmXCIgKS5lcSgwKSxcblx0XHRcdFx0XHR0eXBlOiB0aGlzLmVsZW1lbnQuZ2V0KCAwICkudGFnTmFtZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5faGFuZGxlRm9ybVJlc2V0KCk7XG5cblx0XHRcdC8vIFRyYW5zZmVyIHRhYmluZGV4IHRvIFwib25cIiBlbGVtZW50IGFuZCBtYWtlIGlucHV0IHVuZm9jdXNhYmxlXG5cdFx0XHR0aGlzLl9vcmlnaW5hbFRhYkluZGV4ID0gdGhpcy5lbGVtZW50LmF0dHIoIFwidGFiaW5kZXhcIiApO1xuXHRcdFx0aWYgKCB0aGlzLl9vcmlnaW5hbFRhYkluZGV4ICE9IG51bGwgKSB7XG5cdFx0XHRcdHRoaXMub24uYXR0ciggXCJ0YWJpbmRleFwiLCB0aGlzLl9vcmlnaW5hbFRhYkluZGV4ICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVsZW1lbnQuYXR0ciggXCJ0YWJpbmRleFwiLCBcIi0xXCIgKTtcblx0XHRcdHRoaXMuX29uKHtcblx0XHRcdFx0XCJmb2N1c1wiIDogXCJfaGFuZGxlSW5wdXRGb2N1c1wiXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKCB0aGlzLmVsZW1lbnQuaXMoIFwiOmRpc2FibGVkXCIgKSApIHtcblx0XHRcdFx0dGhpcy5fc2V0T3B0aW9ucyh7XG5cdFx0XHRcdFx0XCJkaXNhYmxlZFwiOiB0cnVlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9vbiggdGhpcy5mbGlwc3dpdGNoLCB7XG5cdFx0XHRcdFwiY2xpY2tcIjogXCJfdG9nZ2xlXCIsXG5cdFx0XHRcdFwic3dpcGVsZWZ0XCI6IFwiX2xlZnRcIixcblx0XHRcdFx0XCJzd2lwZXJpZ2h0XCI6IFwiX3JpZ2h0XCJcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLl9vbiggdGhpcy5vbiwge1xuXHRcdFx0XHRcImtleWRvd25cIjogXCJfa2V5ZG93blwiXG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fb24oIHtcblx0XHRcdFx0XCJjaGFuZ2VcIjogXCJyZWZyZXNoXCJcblx0XHRcdH0pO1xuXHR9LFxuXG5cdF9oYW5kbGVJbnB1dEZvY3VzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLm9uLmZvY3VzKCk7XG5cdH0sXG5cblx0d2lkZ2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5mbGlwc3dpdGNoO1xuXHR9LFxuXG5cdF9sZWZ0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmZsaXBzd2l0Y2gucmVtb3ZlQ2xhc3MoIFwidWktZmxpcHN3aXRjaC1hY3RpdmVcIiApO1xuXHRcdGlmICggdGhpcy50eXBlID09PSBcIlNFTEVDVFwiICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LmdldCggMCApLnNlbGVjdGVkSW5kZXggPSAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQucHJvcCggXCJjaGVja2VkXCIsIGZhbHNlICk7XG5cdFx0fVxuXHRcdHRoaXMuZWxlbWVudC50cmlnZ2VyKCBcImNoYW5nZVwiICk7XG5cdH0sXG5cblx0X3JpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmZsaXBzd2l0Y2guYWRkQ2xhc3MoIFwidWktZmxpcHN3aXRjaC1hY3RpdmVcIiApO1xuXHRcdGlmICggdGhpcy50eXBlID09PSBcIlNFTEVDVFwiICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LmdldCggMCApLnNlbGVjdGVkSW5kZXggPSAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQucHJvcCggXCJjaGVja2VkXCIsIHRydWUgKTtcblx0XHR9XG5cdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIFwiY2hhbmdlXCIgKTtcblx0fSxcblxuXHRfZW5oYW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZsaXBzd2l0Y2ggPSAkKCBcIjxkaXY+XCIgKSxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0dGhlbWUgPSBvcHRpb25zLnRoZW1lID8gb3B0aW9ucy50aGVtZSA6IFwiaW5oZXJpdFwiLFxuXG5cdFx0XHQvLyBUaGUgXCJvblwiIGJ1dHRvbiBpcyBhbiBhbmNob3Igc28gaXQncyBmb2N1c2FibGVcblx0XHRcdG9uID0gJCggXCI8YT48L2E+XCIsIHtcblx0XHRcdFx0XCJocmVmXCI6IFwiI1wiXG5cdFx0XHR9KSxcblx0XHRcdG9mZiA9ICQoIFwiPHNwYW4+PC9zcGFuPlwiICksXG5cdFx0XHR0eXBlID0gZWxlbWVudC5nZXQoIDAgKS50YWdOYW1lLFxuXHRcdFx0b25UZXh0ID0gKCB0eXBlID09PSBcIklOUFVUXCIgKSA/XG5cdFx0XHRcdG9wdGlvbnMub25UZXh0IDogZWxlbWVudC5maW5kKCBcIm9wdGlvblwiICkuZXEoIDEgKS50ZXh0KCksXG5cdFx0XHRvZmZUZXh0ID0gKCB0eXBlID09PSBcIklOUFVUXCIgKSA/XG5cdFx0XHRcdG9wdGlvbnMub2ZmVGV4dCA6IGVsZW1lbnQuZmluZCggXCJvcHRpb25cIiApLmVxKCAwICkudGV4dCgpO1xuXG5cdFx0XHRvblxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktZmxpcHN3aXRjaC1vbiB1aS1idG4gdWktc2hhZG93IHVpLWJ0bi1pbmhlcml0XCIgKVxuXHRcdFx0XHQudGV4dCggb25UZXh0ICk7XG5cdFx0XHRvZmZcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWZsaXBzd2l0Y2gtb2ZmXCIgKVxuXHRcdFx0XHQudGV4dCggb2ZmVGV4dCApO1xuXG5cdFx0XHRmbGlwc3dpdGNoXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1mbGlwc3dpdGNoIHVpLXNoYWRvdy1pbnNldCBcIiArXG5cdFx0XHRcdFx0XCJ1aS1iYXItXCIgKyB0aGVtZSArIFwiIFwiICtcblx0XHRcdFx0XHQoIG9wdGlvbnMud3JhcHBlckNsYXNzID8gb3B0aW9ucy53cmFwcGVyQ2xhc3MgOiBcIlwiICkgKyBcIiBcIiArXG5cdFx0XHRcdFx0KCAoIGVsZW1lbnQuaXMoIFwiOmNoZWNrZWRcIiApIHx8XG5cdFx0XHRcdFx0XHRlbGVtZW50XG5cdFx0XHRcdFx0XHRcdC5maW5kKCBcIm9wdGlvblwiIClcblx0XHRcdFx0XHRcdFx0LmVxKCAxIClcblx0XHRcdFx0XHRcdFx0LmlzKCBcIjpzZWxlY3RlZFwiICkgKSA/IFwidWktZmxpcHN3aXRjaC1hY3RpdmVcIiA6IFwiXCIgKSArXG5cdFx0XHRcdFx0KCBlbGVtZW50LmlzKFwiOmRpc2FibGVkXCIpID8gXCIgdWktc3RhdGUtZGlzYWJsZWRcIjogXCJcIikgK1xuXHRcdFx0XHRcdCggb3B0aW9ucy5jb3JuZXJzID8gXCIgdWktY29ybmVyLWFsbFwiOiBcIlwiICkgK1xuXHRcdFx0XHRcdCggb3B0aW9ucy5taW5pID8gXCIgdWktbWluaVwiOiBcIlwiICkgKVxuXHRcdFx0XHQuYXBwZW5kKCBvbiwgb2ZmICk7XG5cblx0XHRcdGVsZW1lbnRcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWZsaXBzd2l0Y2gtaW5wdXRcIiApXG5cdFx0XHRcdC5hZnRlciggZmxpcHN3aXRjaCApXG5cdFx0XHRcdC5hcHBlbmRUbyggZmxpcHN3aXRjaCApO1xuXG5cdFx0JC5leHRlbmQoIHRoaXMsIHtcblx0XHRcdGZsaXBzd2l0Y2g6IGZsaXBzd2l0Y2gsXG5cdFx0XHRvbjogb24sXG5cdFx0XHRvZmY6IG9mZixcblx0XHRcdHR5cGU6IHR5cGVcblx0XHR9KTtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVmcmVzaCgpO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkaXJlY3Rpb24sXG5cdFx0XHRleGlzdGluZ0RpcmVjdGlvbiA9IHRoaXMuZmxpcHN3aXRjaC5oYXNDbGFzcyggXCJ1aS1mbGlwc3dpdGNoLWFjdGl2ZVwiICkgPyBcIl9yaWdodFwiIDogXCJfbGVmdFwiO1xuXG5cdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiU0VMRUNUXCIgKSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAoIHRoaXMuZWxlbWVudC5nZXQoIDAgKS5zZWxlY3RlZEluZGV4ID4gMCApID8gXCJfcmlnaHRcIjogXCJfbGVmdFwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXJlY3Rpb24gPSB0aGlzLmVsZW1lbnQucHJvcCggXCJjaGVja2VkXCIgKSA/IFwiX3JpZ2h0XCI6IFwiX2xlZnRcIjtcblx0XHR9XG5cblx0XHRpZiAoIGRpcmVjdGlvbiAhPT0gZXhpc3RpbmdEaXJlY3Rpb24gKSB7XG5cdFx0XHR0aGlzWyBkaXJlY3Rpb24gXSgpO1xuXHRcdH1cblx0fSxcblxuXHRfdG9nZ2xlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5mbGlwc3dpdGNoLmhhc0NsYXNzKCBcInVpLWZsaXBzd2l0Y2gtYWN0aXZlXCIgKSA/IFwiX2xlZnRcIiA6IFwiX3JpZ2h0XCI7XG5cblx0XHR0aGlzWyBkaXJlY3Rpb24gXSgpO1xuXHR9LFxuXG5cdF9rZXlkb3duOiBmdW5jdGlvbiggZSApIHtcblx0XHRpZiAoIGUud2hpY2ggPT09ICQubW9iaWxlLmtleUNvZGUuTEVGVCApIHtcblx0XHRcdHRoaXMuX2xlZnQoKTtcblx0XHR9IGVsc2UgaWYgKCBlLndoaWNoID09PSAkLm1vYmlsZS5rZXlDb2RlLlJJR0hUICkge1xuXHRcdFx0dGhpcy5fcmlnaHQoKTtcblx0XHR9IGVsc2UgaWYgKCBlLndoaWNoID09PSAkLm1vYmlsZS5rZXlDb2RlLlNQQUNFICkge1xuXHRcdFx0dGhpcy5fdG9nZ2xlKCk7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRpZiAoIG9wdGlvbnMudGhlbWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhciBjdXJyZW50VGhlbWUgPSBvcHRpb25zLnRoZW1lID8gb3B0aW9ucy50aGVtZSA6IFwiaW5oZXJpdFwiLFxuXHRcdFx0XHRuZXdUaGVtZSA9IG9wdGlvbnMudGhlbWUgPyBvcHRpb25zLnRoZW1lIDogXCJpbmhlcml0XCI7XG5cblx0XHRcdHRoaXMud2lkZ2V0KClcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWJhci1cIiArIGN1cnJlbnRUaGVtZSApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1iYXItXCIgKyBuZXdUaGVtZSApO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMub25UZXh0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLm9uLnRleHQoIG9wdGlvbnMub25UZXh0ICk7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5vZmZUZXh0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLm9mZi50ZXh0KCBvcHRpb25zLm9mZlRleHQgKTtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmRpc2FibGVkICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLndpZGdldCgpLnRvZ2dsZUNsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIsIG9wdGlvbnMuZGlzYWJsZWQgKTtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLm1pbmkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMud2lkZ2V0KCkudG9nZ2xlQ2xhc3MoIFwidWktbWluaVwiLCBvcHRpb25zLm1pbmkgKTtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmNvcm5lcnMgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMud2lkZ2V0KCkudG9nZ2xlQ2xhc3MoIFwidWktY29ybmVyLWFsbFwiLCBvcHRpb25zLmNvcm5lcnMgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdXBlciggb3B0aW9ucyApO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5lbmhhbmNlZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLl9vcmlnaW5hbFRhYkluZGV4ICE9IG51bGwgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYXR0ciggXCJ0YWJpbmRleFwiLCB0aGlzLl9vcmlnaW5hbFRhYkluZGV4ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyKCBcInRhYmluZGV4XCIgKTtcblx0XHR9XG5cdFx0dGhpcy5vbi5yZW1vdmUoKTtcblx0XHR0aGlzLm9mZi5yZW1vdmUoKTtcblx0XHR0aGlzLmVsZW1lbnQudW53cmFwKCk7XG5cdFx0dGhpcy5mbGlwc3dpdGNoLnJlbW92ZSgpO1xuXHRcdHRoaXMucmVtb3ZlQ2xhc3MoIFwidWktZmxpcHN3aXRjaC1pbnB1dFwiICk7XG5cdH1cblxufSwgJC5tb2JpbGUuYmVoYXZpb3JzLmZvcm1SZXNldCApICk7XG5cbn0pKCBqUXVlcnkgKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cdCQud2lkZ2V0KCBcIm1vYmlsZS5yYW5nZXNsaWRlclwiLCAkLmV4dGVuZCgge1xuXG5cdFx0b3B0aW9uczoge1xuXHRcdFx0dGhlbWU6IG51bGwsXG5cdFx0XHR0cmFja1RoZW1lOiBudWxsLFxuXHRcdFx0Y29ybmVyczogdHJ1ZSxcblx0XHRcdG1pbmk6IGZhbHNlLFxuXHRcdFx0aGlnaGxpZ2h0OiB0cnVlXG5cdFx0fSxcblxuXHRcdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyICRlbCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdGVsQ2xhc3MgPSB0aGlzLm9wdGlvbnMubWluaSA/IFwidWktcmFuZ2VzbGlkZXIgdWktbWluaVwiIDogXCJ1aS1yYW5nZXNsaWRlclwiLFxuXHRcdFx0X2lucHV0Rmlyc3QgPSAkZWwuZmluZCggXCJpbnB1dFwiICkuZmlyc3QoKSxcblx0XHRcdF9pbnB1dExhc3QgPSAkZWwuZmluZCggXCJpbnB1dFwiICkubGFzdCgpLFxuXHRcdFx0X2xhYmVsID0gJGVsLmZpbmQoIFwibGFiZWxcIiApLmZpcnN0KCksXG5cdFx0XHRfc2xpZGVyV2lkZ2V0Rmlyc3QgPSAkLmRhdGEoIF9pbnB1dEZpcnN0LmdldCggMCApLCBcIm1vYmlsZS1zbGlkZXJcIiApIHx8XG5cdFx0XHRcdCQuZGF0YSggX2lucHV0Rmlyc3Quc2xpZGVyKCkuZ2V0KCAwICksIFwibW9iaWxlLXNsaWRlclwiICksXG5cdFx0XHRfc2xpZGVyV2lkZ2V0TGFzdCA9ICQuZGF0YSggX2lucHV0TGFzdC5nZXQoMCksIFwibW9iaWxlLXNsaWRlclwiICkgfHxcblx0XHRcdFx0JC5kYXRhKCBfaW5wdXRMYXN0LnNsaWRlcigpLmdldCggMCApLCBcIm1vYmlsZS1zbGlkZXJcIiApLFxuXHRcdFx0X3NsaWRlckZpcnN0ID0gX3NsaWRlcldpZGdldEZpcnN0LnNsaWRlcixcblx0XHRcdF9zbGlkZXJMYXN0ID0gX3NsaWRlcldpZGdldExhc3Quc2xpZGVyLFxuXHRcdFx0Zmlyc3RIYW5kbGUgPSBfc2xpZGVyV2lkZ2V0Rmlyc3QuaGFuZGxlLFxuXHRcdFx0X3NsaWRlcnMgPSAkKCBcIjxkaXYgY2xhc3M9J3VpLXJhbmdlc2xpZGVyLXNsaWRlcnMnIC8+XCIgKS5hcHBlbmRUbyggJGVsICk7XG5cblx0XHRcdF9pbnB1dEZpcnN0LmFkZENsYXNzKCBcInVpLXJhbmdlc2xpZGVyLWZpcnN0XCIgKTtcblx0XHRcdF9pbnB1dExhc3QuYWRkQ2xhc3MoIFwidWktcmFuZ2VzbGlkZXItbGFzdFwiICk7XG5cdFx0XHQkZWwuYWRkQ2xhc3MoIGVsQ2xhc3MgKTtcblxuXHRcdFx0X3NsaWRlckZpcnN0LmFwcGVuZFRvKCBfc2xpZGVycyApO1xuXHRcdFx0X3NsaWRlckxhc3QuYXBwZW5kVG8oIF9zbGlkZXJzICk7XG5cdFx0XHRfbGFiZWwuaW5zZXJ0QmVmb3JlKCAkZWwgKTtcblx0XHRcdGZpcnN0SGFuZGxlLnByZXBlbmRUbyggX3NsaWRlckxhc3QgKTtcblxuXHRcdFx0JC5leHRlbmQoIHRoaXMsIHtcblx0XHRcdFx0X2lucHV0Rmlyc3Q6IF9pbnB1dEZpcnN0LFxuXHRcdFx0XHRfaW5wdXRMYXN0OiBfaW5wdXRMYXN0LFxuXHRcdFx0XHRfc2xpZGVyRmlyc3Q6IF9zbGlkZXJGaXJzdCxcblx0XHRcdFx0X3NsaWRlckxhc3Q6IF9zbGlkZXJMYXN0LFxuXHRcdFx0XHRfbGFiZWw6IF9sYWJlbCxcblx0XHRcdFx0X3RhcmdldFZhbDogbnVsbCxcblx0XHRcdFx0X3NsaWRlclRhcmdldDogZmFsc2UsXG5cdFx0XHRcdF9zbGlkZXJzOiBfc2xpZGVycyxcblx0XHRcdFx0X3Byb3h5OiBmYWxzZVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMucmVmcmVzaCgpO1xuXHRcdFx0dGhpcy5fb24oIHRoaXMuZWxlbWVudC5maW5kKCBcImlucHV0LnVpLXNsaWRlci1pbnB1dFwiICksIHtcblx0XHRcdFx0XCJzbGlkZWJlZm9yZXN0YXJ0XCI6IFwiX3NsaWRlYmVmb3Jlc3RhcnRcIixcblx0XHRcdFx0XCJzbGlkZXN0b3BcIjogXCJfc2xpZGVzdG9wXCIsXG5cdFx0XHRcdFwic2xpZGVkcmFnXCI6IFwiX3NsaWRlZHJhZ1wiLFxuXHRcdFx0XHRcInNsaWRlYmVmb3JlY2hhbmdlXCI6IFwiX2NoYW5nZVwiLFxuXHRcdFx0XHRcImJsdXJcIjogXCJfY2hhbmdlXCIsXG5cdFx0XHRcdFwia2V5dXBcIjogXCJfY2hhbmdlXCJcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5fb24oe1xuXHRcdFx0XHRcIm1vdXNlZG93blwiOlwiX2NoYW5nZVwiXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuX29uKCB0aGlzLmVsZW1lbnQuY2xvc2VzdCggXCJmb3JtXCIgKSwge1xuXHRcdFx0XHRcInJlc2V0XCI6XCJfaGFuZGxlUmVzZXRcIlxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLl9vbiggZmlyc3RIYW5kbGUsIHtcblx0XHRcdFx0XCJ2bW91c2Vkb3duXCI6IFwiX2RyYWdGaXJzdEhhbmRsZVwiXG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdF9oYW5kbGVSZXNldDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHQvL3dlIG11c3Qgd2FpdCBmb3IgdGhlIHN0YWNrIHRvIHVud2luZCBiZWZvcmUgdXBkYXRlaW5nIG90aGVyIHdpc2Ugc2xpZGVycyB3aWxsIG5vdCBoYXZlIHVwZGF0ZWQgeWV0XG5cdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5fdXBkYXRlSGlnaGxpZ2h0KCk7XG5cdFx0XHR9LDApO1xuXHRcdH0sXG5cblx0XHRfZHJhZ0ZpcnN0SGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHQvL2lmIHRoZSBmaXJzdCBoYW5kbGUgaXMgZHJhZ2dlZCBzZW5kIHRoZSBldmVudCB0byB0aGUgZmlyc3Qgc2xpZGVyXG5cdFx0XHQkLmRhdGEoIHRoaXMuX2lucHV0Rmlyc3QuZ2V0KDApLCBcIm1vYmlsZS1zbGlkZXJcIiApLmRyYWdnaW5nID0gdHJ1ZTtcblx0XHRcdCQuZGF0YSggdGhpcy5faW5wdXRGaXJzdC5nZXQoMCksIFwibW9iaWxlLXNsaWRlclwiICkucmVmcmVzaCggZXZlbnQgKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0X3NsaWRlZHJhZzogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIGZpcnN0ID0gJCggZXZlbnQudGFyZ2V0ICkuaXMoIHRoaXMuX2lucHV0Rmlyc3QgKSxcblx0XHRcdFx0b3RoZXJTbGlkZXIgPSAoIGZpcnN0ICkgPyB0aGlzLl9pbnB1dExhc3QgOiB0aGlzLl9pbnB1dEZpcnN0O1xuXG5cdFx0XHR0aGlzLl9zbGlkZXJUYXJnZXQgPSBmYWxzZTtcblx0XHRcdC8vaWYgdGhlIGRyYWcgd2FzIGluaXRpYXRlZCBvbiBhbiBleHRyZW1lIGFuZCB0aGUgb3RoZXIgaGFuZGxlIGlzIGZvY3VzZWQgc2VuZCB0aGUgZXZlbnRzIHRvXG5cdFx0XHQvL3RoZSBjbG9zZXN0IGhhbmRsZVxuXHRcdFx0aWYgKCAoIHRoaXMuX3Byb3h5ID09PSBcImZpcnN0XCIgJiYgZmlyc3QgKSB8fCAoIHRoaXMuX3Byb3h5ID09PSBcImxhc3RcIiAmJiAhZmlyc3QgKSApIHtcblx0XHRcdFx0JC5kYXRhKCBvdGhlclNsaWRlci5nZXQoMCksIFwibW9iaWxlLXNsaWRlclwiICkuZHJhZ2dpbmcgPSB0cnVlO1xuXHRcdFx0XHQkLmRhdGEoIG90aGVyU2xpZGVyLmdldCgwKSwgXCJtb2JpbGUtc2xpZGVyXCIgKS5yZWZyZXNoKCBldmVudCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9zbGlkZXN0b3A6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBmaXJzdCA9ICQoIGV2ZW50LnRhcmdldCApLmlzKCB0aGlzLl9pbnB1dEZpcnN0ICk7XG5cblx0XHRcdHRoaXMuX3Byb3h5ID0gZmFsc2U7XG5cdFx0XHQvL3RoaXMgc3RvcHMgZHJhZ2dpbmcgb2YgdGhlIGhhbmRsZSBhbmQgYnJpbmdzIHRoZSBhY3RpdmUgdHJhY2sgdG8gdGhlIGZyb250XG5cdFx0XHQvL3RoaXMgbWFrZXMgY2xpY2tzIG9uIHRoZSB0cmFjayBnbyB0aGUgdGhlIGxhc3QgaGFuZGxlIHVzZWRcblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCBcImlucHV0XCIgKS50cmlnZ2VyKCBcInZtb3VzZXVwXCIgKTtcblx0XHRcdHRoaXMuX3NsaWRlckZpcnN0LmNzcyggXCJ6LWluZGV4XCIsIGZpcnN0ID8gMSA6IFwiXCIgKTtcblx0XHR9LFxuXG5cdFx0X3NsaWRlYmVmb3Jlc3RhcnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHRoaXMuX3NsaWRlclRhcmdldCA9IGZhbHNlO1xuXHRcdFx0Ly9pZiB0aGUgdHJhY2sgaXMgdGhlIHRhcmdldCByZW1lbWJlciB0aGlzIGFuZCB0aGUgb3JpZ2luYWwgdmFsdWVcblx0XHRcdGlmICggJCggZXZlbnQub3JpZ2luYWxFdmVudC50YXJnZXQgKS5oYXNDbGFzcyggXCJ1aS1zbGlkZXItdHJhY2tcIiApICkge1xuXHRcdFx0XHR0aGlzLl9zbGlkZXJUYXJnZXQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl90YXJnZXRWYWwgPSAkKCBldmVudC50YXJnZXQgKS52YWwoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3NldE9wdGlvbnM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0aWYgKCBvcHRpb25zLnRoZW1lICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMuX3NldFRoZW1lKCBvcHRpb25zLnRoZW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggb3B0aW9ucy50cmFja1RoZW1lICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMuX3NldFRyYWNrVGhlbWUoIG9wdGlvbnMudHJhY2tUaGVtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9wdGlvbnMubWluaSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLl9zZXRNaW5pKCBvcHRpb25zLm1pbmkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvcHRpb25zLmhpZ2hsaWdodCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLl9zZXRIaWdobGlnaHQoIG9wdGlvbnMuaGlnaGxpZ2h0ICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zdXBlciggb3B0aW9ucyApO1xuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0fSxcblxuXHRcdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyICRlbCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdFx0byA9IHRoaXMub3B0aW9ucztcblxuXHRcdFx0aWYgKCB0aGlzLl9pbnB1dEZpcnN0LmlzKCBcIjpkaXNhYmxlZFwiICkgfHwgdGhpcy5faW5wdXRMYXN0LmlzKCBcIjpkaXNhYmxlZFwiICkgKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdCRlbC5maW5kKCBcImlucHV0XCIgKS5zbGlkZXIoe1xuXHRcdFx0XHR0aGVtZTogby50aGVtZSxcblx0XHRcdFx0dHJhY2tUaGVtZTogby50cmFja1RoZW1lLFxuXHRcdFx0XHRkaXNhYmxlZDogby5kaXNhYmxlZCxcblx0XHRcdFx0Y29ybmVyczogby5jb3JuZXJzLFxuXHRcdFx0XHRtaW5pOiBvLm1pbmksXG5cdFx0XHRcdGhpZ2hsaWdodDogby5oaWdobGlnaHRcblx0XHRcdH0pLnNsaWRlciggXCJyZWZyZXNoXCIgKTtcblx0XHRcdHRoaXMuX3VwZGF0ZUhpZ2hsaWdodCgpO1xuXHRcdH0sXG5cblx0XHRfY2hhbmdlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRpZiAoIGV2ZW50LnR5cGUgPT09IFwia2V5dXBcIiApIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlSGlnaGxpZ2h0KCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRtaW4gPSBwYXJzZUZsb2F0KCB0aGlzLl9pbnB1dEZpcnN0LnZhbCgpLCAxMCApLFxuXHRcdFx0XHRtYXggPSBwYXJzZUZsb2F0KCB0aGlzLl9pbnB1dExhc3QudmFsKCksIDEwICksXG5cdFx0XHRcdGZpcnN0ID0gJCggZXZlbnQudGFyZ2V0ICkuaGFzQ2xhc3MoIFwidWktcmFuZ2VzbGlkZXItZmlyc3RcIiApLFxuXHRcdFx0XHR0aGlzU2xpZGVyID0gZmlyc3QgPyB0aGlzLl9pbnB1dEZpcnN0IDogdGhpcy5faW5wdXRMYXN0LFxuXHRcdFx0XHRvdGhlclNsaWRlciA9IGZpcnN0ID8gdGhpcy5faW5wdXRMYXN0IDogdGhpcy5faW5wdXRGaXJzdDtcblxuXHRcdFx0aWYgKCAoIHRoaXMuX2lucHV0Rmlyc3QudmFsKCkgPiB0aGlzLl9pbnB1dExhc3QudmFsKCkgJiYgZXZlbnQudHlwZSA9PT0gXCJtb3VzZWRvd25cIiAmJiAhJChldmVudC50YXJnZXQpLmhhc0NsYXNzKFwidWktc2xpZGVyLWhhbmRsZVwiKSkgKSB7XG5cdFx0XHRcdHRoaXNTbGlkZXIuYmx1cigpO1xuXHRcdFx0fSBlbHNlIGlmICggZXZlbnQudHlwZSA9PT0gXCJtb3VzZWRvd25cIiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBtaW4gPiBtYXggJiYgIXRoaXMuX3NsaWRlclRhcmdldCApIHtcblx0XHRcdFx0Ly90aGlzIHByZXZlbnRzIG1pbiBmcm9tIGJlaW5nIGdyZWF0ZXIgdGhlbiBtYXhcblx0XHRcdFx0dGhpc1NsaWRlci52YWwoIGZpcnN0ID8gbWF4OiBtaW4gKS5zbGlkZXIoIFwicmVmcmVzaFwiICk7XG5cdFx0XHRcdHRoaXMuX3RyaWdnZXIoIFwibm9ybWFsaXplXCIgKTtcblx0XHRcdH0gZWxzZSBpZiAoIG1pbiA+IG1heCApIHtcblx0XHRcdFx0Ly90aGlzIG1ha2VzIGl0IHNvIGNsaWNrcyBvbiB0aGUgdGFyZ2V0IG9uIGVpdGhlciBleHRyZW1lIGdvIHRvIHRoZSBjbG9zZXN0IGhhbmRsZVxuXHRcdFx0XHR0aGlzU2xpZGVyLnZhbCggdGhpcy5fdGFyZ2V0VmFsICkuc2xpZGVyKCBcInJlZnJlc2hcIiApO1xuXG5cdFx0XHRcdC8vWW91IG11c3Qgd2FpdCBmb3IgdGhlIHN0YWNrIHRvIHVud2luZCBzbyBmaXJzdCBzbGlkZXIgaXMgdXBkYXRlZCBiZWZvcmUgdXBkYXRpbmcgc2Vjb25kXG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdG90aGVyU2xpZGVyLnZhbCggZmlyc3QgPyBtaW46IG1heCApLnNsaWRlciggXCJyZWZyZXNoXCIgKTtcblx0XHRcdFx0XHQkLmRhdGEoIG90aGVyU2xpZGVyLmdldCgwKSwgXCJtb2JpbGUtc2xpZGVyXCIgKS5oYW5kbGUuZm9jdXMoKTtcblx0XHRcdFx0XHRzZWxmLl9zbGlkZXJGaXJzdC5jc3MoIFwiei1pbmRleFwiLCBmaXJzdCA/IFwiXCIgOiAxICk7XG5cdFx0XHRcdFx0c2VsZi5fdHJpZ2dlciggXCJub3JtYWxpemVcIiApO1xuXHRcdFx0XHR9LCAwICk7XG5cdFx0XHRcdHRoaXMuX3Byb3h5ID0gKCBmaXJzdCApID8gXCJmaXJzdFwiIDogXCJsYXN0XCI7XG5cdFx0XHR9XG5cdFx0XHQvL2ZpeGVzIGlzc3VlIHdoZXJlIHdoZW4gYm90aCBfc2xpZGVycyBhcmUgYXQgbWluIHRoZXkgY2Fubm90IGJlIGFkanVzdGVkXG5cdFx0XHRpZiAoIG1pbiA9PT0gbWF4ICkge1xuXHRcdFx0XHQkLmRhdGEoIHRoaXNTbGlkZXIuZ2V0KDApLCBcIm1vYmlsZS1zbGlkZXJcIiApLmhhbmRsZS5jc3MoIFwiei1pbmRleFwiLCAxICk7XG5cdFx0XHRcdCQuZGF0YSggb3RoZXJTbGlkZXIuZ2V0KDApLCBcIm1vYmlsZS1zbGlkZXJcIiApLmhhbmRsZS5jc3MoIFwiei1pbmRleFwiLCAwICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkLmRhdGEoIG90aGVyU2xpZGVyLmdldCgwKSwgXCJtb2JpbGUtc2xpZGVyXCIgKS5oYW5kbGUuY3NzKCBcInotaW5kZXhcIiwgXCJcIiApO1xuXHRcdFx0XHQkLmRhdGEoIHRoaXNTbGlkZXIuZ2V0KDApLCBcIm1vYmlsZS1zbGlkZXJcIiApLmhhbmRsZS5jc3MoIFwiei1pbmRleFwiLCBcIlwiICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUhpZ2hsaWdodCgpO1xuXG5cdFx0XHRpZiAoIG1pbiA+PSBtYXggKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3VwZGF0ZUhpZ2hsaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWluID0gcGFyc2VJbnQoICQuZGF0YSggdGhpcy5faW5wdXRGaXJzdC5nZXQoMCksIFwibW9iaWxlLXNsaWRlclwiICkuaGFuZGxlLmdldCgwKS5zdHlsZS5sZWZ0LCAxMCApLFxuXHRcdFx0XHRtYXggPSBwYXJzZUludCggJC5kYXRhKCB0aGlzLl9pbnB1dExhc3QuZ2V0KDApLCBcIm1vYmlsZS1zbGlkZXJcIiApLmhhbmRsZS5nZXQoMCkuc3R5bGUubGVmdCwgMTAgKSxcblx0XHRcdFx0d2lkdGggPSAobWF4IC0gbWluKTtcblxuXHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoIFwiLnVpLXNsaWRlci1iZ1wiICkuY3NzKHtcblx0XHRcdFx0XCJtYXJnaW4tbGVmdFwiOiBtaW4gKyBcIiVcIixcblx0XHRcdFx0XCJ3aWR0aFwiOiB3aWR0aCArIFwiJVwiXG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0X3NldFRoZW1lOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR0aGlzLl9pbnB1dEZpcnN0LnNsaWRlciggXCJvcHRpb25cIiwgXCJ0aGVtZVwiLCB2YWx1ZSApO1xuXHRcdFx0dGhpcy5faW5wdXRMYXN0LnNsaWRlciggXCJvcHRpb25cIiwgXCJ0aGVtZVwiLCB2YWx1ZSApO1xuXHRcdH0sXG5cblx0XHRfc2V0VHJhY2tUaGVtZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dGhpcy5faW5wdXRGaXJzdC5zbGlkZXIoIFwib3B0aW9uXCIsIFwidHJhY2tUaGVtZVwiLCB2YWx1ZSApO1xuXHRcdFx0dGhpcy5faW5wdXRMYXN0LnNsaWRlciggXCJvcHRpb25cIiwgXCJ0cmFja1RoZW1lXCIsIHZhbHVlICk7XG5cdFx0fSxcblxuXHRcdF9zZXRNaW5pOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR0aGlzLl9pbnB1dEZpcnN0LnNsaWRlciggXCJvcHRpb25cIiwgXCJtaW5pXCIsIHZhbHVlICk7XG5cdFx0XHR0aGlzLl9pbnB1dExhc3Quc2xpZGVyKCBcIm9wdGlvblwiLCBcIm1pbmlcIiwgdmFsdWUgKTtcblx0XHRcdHRoaXMuZWxlbWVudC50b2dnbGVDbGFzcyggXCJ1aS1taW5pXCIsICEhdmFsdWUgKTtcblx0XHR9LFxuXG5cdFx0X3NldEhpZ2hsaWdodDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dGhpcy5faW5wdXRGaXJzdC5zbGlkZXIoIFwib3B0aW9uXCIsIFwiaGlnaGxpZ2h0XCIsIHZhbHVlICk7XG5cdFx0XHR0aGlzLl9pbnB1dExhc3Quc2xpZGVyKCBcIm9wdGlvblwiLCBcImhpZ2hsaWdodFwiLCB2YWx1ZSApO1xuXHRcdH0sXG5cblx0XHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9sYWJlbC5wcmVwZW5kVG8oIHRoaXMuZWxlbWVudCApO1xuXHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCBcInVpLXJhbmdlc2xpZGVyIHVpLW1pbmlcIiApO1xuXHRcdFx0dGhpcy5faW5wdXRGaXJzdC5hZnRlciggdGhpcy5fc2xpZGVyRmlyc3QgKTtcblx0XHRcdHRoaXMuX2lucHV0TGFzdC5hZnRlciggdGhpcy5fc2xpZGVyTGFzdCApO1xuXHRcdFx0dGhpcy5fc2xpZGVycy5yZW1vdmUoKTtcblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCBcImlucHV0XCIgKS5yZW1vdmVDbGFzcyggXCJ1aS1yYW5nZXNsaWRlci1maXJzdCB1aS1yYW5nZXNsaWRlci1sYXN0XCIgKS5zbGlkZXIoIFwiZGVzdHJveVwiICk7XG5cdFx0fVxuXG5cdH0sICQubW9iaWxlLmJlaGF2aW9ycy5mb3JtUmVzZXQgKSApO1xuXG59KSggalF1ZXJ5ICk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG5cdCQud2lkZ2V0KCBcIm1vYmlsZS50ZXh0aW5wdXRcIiwgJC5tb2JpbGUudGV4dGlucHV0LCB7XG5cdFx0b3B0aW9uczoge1xuXHRcdFx0Y2xlYXJCdG46IGZhbHNlLFxuXHRcdFx0Y2xlYXJCdG5UZXh0OiBcIkNsZWFyIHRleHRcIlxuXHRcdH0sXG5cblx0XHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cblx0XHRcdGlmICggISF0aGlzLm9wdGlvbnMuY2xlYXJCdG4gfHwgdGhpcy5pc1NlYXJjaCApIHtcblx0XHRcdFx0dGhpcy5fYWRkQ2xlYXJCdG4oKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y2xlYXJCdXR0b246IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRyZXR1cm4gJCggXCI8YSBocmVmPScjJyBjbGFzcz0ndWktaW5wdXQtY2xlYXIgdWktYnRuIHVpLWljb24tZGVsZXRlIHVpLWJ0bi1pY29uLW5vdGV4dCB1aS1jb3JuZXItYWxsXCIgK1xuICAgIFwiJyB0aXRsZT0nXCIgKyB0aGlzLm9wdGlvbnMuY2xlYXJCdG5UZXh0ICsgXCInPlwiICsgdGhpcy5vcHRpb25zLmNsZWFyQnRuVGV4dCArIFwiPC9hPlwiICk7XG5cblx0XHR9LFxuXG5cdFx0X2NsZWFyQnRuQ2xpY2s6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHRoaXMuZWxlbWVudC52YWwoIFwiXCIgKVxuXHRcdFx0XHRcdC5mb2N1cygpXG5cdFx0XHRcdFx0LnRyaWdnZXIoIFwiY2hhbmdlXCIgKTtcblxuXHRcdFx0dGhpcy5fY2xlYXJCdG4uYWRkQ2xhc3MoIFwidWktaW5wdXQtY2xlYXItaGlkZGVuXCIgKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fSxcblxuXHRcdF9hZGRDbGVhckJ0bjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdGlmICggIXRoaXMub3B0aW9ucy5lbmhhbmNlZCApIHtcblx0XHRcdFx0dGhpcy5fZW5oYW5jZUNsZWFyKCk7XG5cdFx0XHR9XG5cblx0XHRcdCQuZXh0ZW5kKCB0aGlzLCB7XG5cdFx0XHRcdF9jbGVhckJ0bjogdGhpcy53aWRnZXQoKS5maW5kKFwiYS51aS1pbnB1dC1jbGVhclwiKVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX2JpbmRDbGVhckV2ZW50cygpO1xuXG5cdFx0XHR0aGlzLl90b2dnbGVDbGVhcigpO1xuXG5cdFx0fSxcblxuXHRcdF9lbmhhbmNlQ2xlYXI6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHR0aGlzLmNsZWFyQnV0dG9uKCkuYXBwZW5kVG8oIHRoaXMud2lkZ2V0KCkgKTtcblx0XHRcdHRoaXMud2lkZ2V0KCkuYWRkQ2xhc3MoIFwidWktaW5wdXQtaGFzLWNsZWFyXCIgKTtcblxuXHRcdH0sXG5cblx0XHRfYmluZENsZWFyRXZlbnRzOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0dGhpcy5fb24oIHRoaXMuX2NsZWFyQnRuLCB7XG5cdFx0XHRcdFwiY2xpY2tcIjogXCJfY2xlYXJCdG5DbGlja1wiXG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fb24oe1xuXHRcdFx0XHRcImtleXVwXCI6IFwiX3RvZ2dsZUNsZWFyXCIsXG5cdFx0XHRcdFwiY2hhbmdlXCI6IFwiX3RvZ2dsZUNsZWFyXCIsXG5cdFx0XHRcdFwiaW5wdXRcIjogXCJfdG9nZ2xlQ2xlYXJcIixcblx0XHRcdFx0XCJmb2N1c1wiOiBcIl90b2dnbGVDbGVhclwiLFxuXHRcdFx0XHRcImJsdXJcIjogXCJfdG9nZ2xlQ2xlYXJcIixcblx0XHRcdFx0XCJjdXRcIjogXCJfdG9nZ2xlQ2xlYXJcIixcblx0XHRcdFx0XCJwYXN0ZVwiOiBcIl90b2dnbGVDbGVhclwiXG5cblx0XHRcdH0pO1xuXG5cdFx0fSxcblxuXHRcdF91bmJpbmRDbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9vZmYoIHRoaXMuX2NsZWFyQnRuLCBcImNsaWNrXCIpO1xuXHRcdFx0dGhpcy5fb2ZmKCB0aGlzLmVsZW1lbnQsIFwia2V5dXAgY2hhbmdlIGlucHV0IGZvY3VzIGJsdXIgY3V0IHBhc3RlXCIgKTtcblx0XHR9LFxuXG5cdFx0X3NldE9wdGlvbnM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5fc3VwZXIoIG9wdGlvbnMgKTtcblxuXHRcdFx0aWYgKCBvcHRpb25zLmNsZWFyQnRuICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0IXRoaXMuZWxlbWVudC5pcyggXCJ0ZXh0YXJlYSwgOmpxbURhdGEodHlwZT0ncmFuZ2UnKVwiICkgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5jbGVhckJ0biApIHtcblx0XHRcdFx0XHR0aGlzLl9hZGRDbGVhckJ0bigpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2Rlc3Ryb3lDbGVhcigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggb3B0aW9ucy5jbGVhckJ0blRleHQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9jbGVhckJ0biAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLl9jbGVhckJ0bi50ZXh0KCBvcHRpb25zLmNsZWFyQnRuVGV4dCApXG5cdFx0XHRcdFx0LmF0dHIoXCJ0aXRsZVwiLCBvcHRpb25zLmNsZWFyQnRuVGV4dCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF90b2dnbGVDbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9kZWxheSggXCJfdG9nZ2xlQ2xlYXJDbGFzc1wiLCAwICk7XG5cdFx0fSxcblxuXHRcdF90b2dnbGVDbGVhckNsYXNzOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX2NsZWFyQnRuLnRvZ2dsZUNsYXNzKCBcInVpLWlucHV0LWNsZWFyLWhpZGRlblwiLCAhdGhpcy5lbGVtZW50LnZhbCgpICk7XG5cdFx0fSxcblxuXHRcdF9kZXN0cm95Q2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy53aWRnZXQoKS5yZW1vdmVDbGFzcyggXCJ1aS1pbnB1dC1oYXMtY2xlYXJcIiApO1xuXHRcdFx0dGhpcy5fdW5iaW5kQ2xlYXIoKTtcblx0XHRcdHRoaXMuX2NsZWFyQnRuLnJlbW92ZSgpO1xuXHRcdH0sXG5cblx0XHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdFx0dGhpcy5fZGVzdHJveUNsZWFyKCk7XG5cdFx0fVxuXG5cdH0pO1xuXG59KSggalF1ZXJ5ICk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG5cdCQud2lkZ2V0KCBcIm1vYmlsZS50ZXh0aW5wdXRcIiwgJC5tb2JpbGUudGV4dGlucHV0LCB7XG5cdFx0b3B0aW9uczoge1xuXHRcdFx0YXV0b2dyb3c6dHJ1ZSxcblx0XHRcdGtleXVwVGltZW91dEJ1ZmZlcjogMTAwXG5cdFx0fSxcblxuXHRcdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuYXV0b2dyb3cgJiYgdGhpcy5pc1RleHRhcmVhICkge1xuXHRcdFx0XHR0aGlzLl9hdXRvZ3JvdygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfYXV0b2dyb3c6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKCBcInVpLXRleHRpbnB1dC1hdXRvZ3Jvd1wiICk7XG5cblx0XHRcdHRoaXMuX29uKHtcblx0XHRcdFx0XCJrZXl1cFwiOiBcIl90aW1lb3V0XCIsXG5cdFx0XHRcdFwiY2hhbmdlXCI6IFwiX3RpbWVvdXRcIixcblx0XHRcdFx0XCJpbnB1dFwiOiBcIl90aW1lb3V0XCIsXG5cdFx0XHRcdFwicGFzdGVcIjogXCJfdGltZW91dFwiXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXR0YWNoIHRvIHRoZSB2YXJpb3VzIHlvdS1oYXZlLWJlY29tZS12aXNpYmxlIG5vdGlmaWNhdGlvbnMgdGhhdCB0aGVcblx0XHRcdC8vIHZhcmlvdXMgZnJhbWV3b3JrIGVsZW1lbnRzIGVtaXQuXG5cdFx0XHQvLyBUT0RPOiBSZW1vdmUgYWxsIGJ1dCB0aGUgdXBkYXRlbGF5b3V0IGhhbmRsZXIgb25jZSAjNjQyNiBpcyBmaXhlZC5cblx0XHRcdHRoaXMuX29uKCB0cnVlLCB0aGlzLmRvY3VtZW50LCB7XG5cblx0XHRcdFx0Ly8gVE9ETzogTW92ZSB0byBub24tZGVwcmVjYXRlZCBldmVudFxuXHRcdFx0XHRcInBhZ2VzaG93XCI6IFwiX2hhbmRsZVNob3dcIixcblx0XHRcdFx0XCJwb3B1cGJlZm9yZXBvc2l0aW9uXCI6IFwiX2hhbmRsZVNob3dcIixcblx0XHRcdFx0XCJ1cGRhdGVsYXlvdXRcIjogXCJfaGFuZGxlU2hvd1wiLFxuXHRcdFx0XHRcInBhbmVsb3BlblwiOiBcIl9oYW5kbGVTaG93XCJcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvLyBTeW5jaHJvbm91c2x5IGZpeCB0aGUgd2lkZ2V0IGhlaWdodCBpZiB0aGlzIHdpZGdldCdzIHBhcmVudHMgYXJlIHN1Y2hcblx0XHQvLyB0aGF0IHRoZXkgc2hvdy9oaWRlIGNvbnRlbnQgYXQgcnVudGltZS4gV2Ugc3RpbGwgbmVlZCB0byBjaGVjayB3aGV0aGVyXG5cdFx0Ly8gdGhlIHdpZGdldCBpcyBhY3R1YWxseSB2aXNpYmxlIGluIGNhc2UgaXQgaXMgY29udGFpbmVkIGluc2lkZSBtdWx0aXBsZVxuXHRcdC8vIHN1Y2ggY29udGFpbmVycy4gRm9yIGV4YW1wbGU6IHBhbmVsIGNvbnRhaW5zIGNvbGxhcHNpYmxlIGNvbnRhaW5zXG5cdFx0Ly8gYXV0b2dyb3cgdGV4dGlucHV0LiBUaGUgcGFuZWwgbWF5IGVtaXQgXCJwYW5lbG9wZW5cIiBpbmRpY2F0aW5nIHRoYXQgaXRzXG5cdFx0Ly8gY29udGVudCBoYXMgYmVjb21lIHZpc2libGUsIGJ1dCB0aGUgY29sbGFwc2libGUgaXMgc3RpbGwgY29sbGFwc2VkLCBzb1xuXHRcdC8vIHRoZSBhdXRvZ3JvdyB0ZXh0YXJlYSBpcyBzdGlsbCBub3QgdmlzaWJsZS5cblx0XHRfaGFuZGxlU2hvdzogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0aWYgKCAkLmNvbnRhaW5zKCBldmVudC50YXJnZXQsIHRoaXMuZWxlbWVudFsgMCBdICkgJiZcblx0XHRcdFx0dGhpcy5lbGVtZW50LmlzKCBcIjp2aXNpYmxlXCIgKSApIHtcblxuXHRcdFx0XHRpZiAoIGV2ZW50LnR5cGUgIT09IFwicG9wdXBiZWZvcmVwb3NpdGlvblwiICkge1xuXHRcdFx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBcInVpLXRleHRpbnB1dC1hdXRvZ3Jvdy1yZXNpemVcIiApXG5cdFx0XHRcdFx0XHQuYW5pbWF0aW9uQ29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdCQucHJveHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyggXCJ1aS10ZXh0aW5wdXQtYXV0b2dyb3ctcmVzaXplXCIgKTtcblx0XHRcdFx0XHRcdFx0fSwgdGhpcyApLFxuXHRcdFx0XHRcdFx0XCJ0cmFuc2l0aW9uXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl90aW1lb3V0KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF91bmJpbmRBdXRvZ3JvdzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoIFwidWktdGV4dGlucHV0LWF1dG9ncm93XCIgKTtcblx0XHRcdHRoaXMuX29mZiggdGhpcy5lbGVtZW50LCBcImtleXVwIGNoYW5nZSBpbnB1dCBwYXN0ZVwiICk7XG5cdFx0XHR0aGlzLl9vZmYoIHRoaXMuZG9jdW1lbnQsXG5cdFx0XHRcdFwicGFnZXNob3cgcG9wdXBiZWZvcmVwb3NpdGlvbiB1cGRhdGVsYXlvdXQgcGFuZWxvcGVuXCIgKTtcblx0XHR9LFxuXG5cdFx0a2V5dXBUaW1lb3V0OiBudWxsLFxuXG5cdFx0X3ByZXBhcmVIZWlnaHRVcGRhdGU6IGZ1bmN0aW9uKCBkZWxheSApIHtcblx0XHRcdGlmICggdGhpcy5rZXl1cFRpbWVvdXQgKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5rZXl1cFRpbWVvdXQgKTtcblx0XHRcdH1cblx0XHRcdGlmICggZGVsYXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlSGVpZ2h0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmtleXVwVGltZW91dCA9IHRoaXMuX2RlbGF5KCBcIl91cGRhdGVIZWlnaHRcIiwgZGVsYXkgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3RpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fcHJlcGFyZUhlaWdodFVwZGF0ZSggdGhpcy5vcHRpb25zLmtleXVwVGltZW91dEJ1ZmZlciApO1xuXHRcdH0sXG5cblx0XHRfdXBkYXRlSGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwYWRkaW5nVG9wLCBwYWRkaW5nQm90dG9tLCBwYWRkaW5nSGVpZ2h0LCBzY3JvbGxIZWlnaHQsIGNsaWVudEhlaWdodCxcblx0XHRcdFx0Ym9yZGVyVG9wLCBib3JkZXJCb3R0b20sIGJvcmRlckhlaWdodCwgaGVpZ2h0LFxuXHRcdFx0XHRzY3JvbGxUb3AgPSB0aGlzLndpbmRvdy5zY3JvbGxUb3AoKTtcblx0XHRcdHRoaXMua2V5dXBUaW1lb3V0ID0gMDtcblxuXHRcdFx0Ly8gSUU4IHRleHRhcmVhcyBoYXZlIHRoZSBvbnBhZ2UgcHJvcGVydHkgLSBvdGhlcnMgZG8gbm90XG5cdFx0XHRpZiAoICEoIFwib25wYWdlXCIgaW4gdGhpcy5lbGVtZW50WyAwIF0gKSApIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LmNzcyh7XG5cdFx0XHRcdFx0XCJoZWlnaHRcIjogMCxcblx0XHRcdFx0XHRcIm1pbi1oZWlnaHRcIjogMCxcblx0XHRcdFx0XHRcIm1heC1oZWlnaHRcIjogMFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0c2Nyb2xsSGVpZ2h0ID0gdGhpcy5lbGVtZW50WyAwIF0uc2Nyb2xsSGVpZ2h0O1xuXHRcdFx0Y2xpZW50SGVpZ2h0ID0gdGhpcy5lbGVtZW50WyAwIF0uY2xpZW50SGVpZ2h0O1xuXHRcdFx0Ym9yZGVyVG9wID0gcGFyc2VGbG9hdCggdGhpcy5lbGVtZW50LmNzcyggXCJib3JkZXItdG9wLXdpZHRoXCIgKSApO1xuXHRcdFx0Ym9yZGVyQm90dG9tID0gcGFyc2VGbG9hdCggdGhpcy5lbGVtZW50LmNzcyggXCJib3JkZXItYm90dG9tLXdpZHRoXCIgKSApO1xuXHRcdFx0Ym9yZGVySGVpZ2h0ID0gYm9yZGVyVG9wICsgYm9yZGVyQm90dG9tO1xuXHRcdFx0aGVpZ2h0ID0gc2Nyb2xsSGVpZ2h0ICsgYm9yZGVySGVpZ2h0ICsgMTU7XG5cblx0XHRcdC8vIElzc3VlIDYxNzk6IFBhZGRpbmcgaXMgbm90IGluY2x1ZGVkIGluIHNjcm9sbEhlaWdodCBhbmRcblx0XHRcdC8vIGNsaWVudEhlaWdodCBieSBGaXJlZm94IGlmIG5vIHNjcm9sbGJhciBpcyB2aXNpYmxlLiBCZWNhdXNlXG5cdFx0XHQvLyB0ZXh0YXJlYXMgdXNlIHRoZSBib3JkZXItYm94IGJveC1zaXppbmcgbW9kZWwsIHBhZGRpbmcgc2hvdWxkIGJlXG5cdFx0XHQvLyBpbmNsdWRlZCBpbiB0aGUgbmV3IChhc3NpZ25lZCkgaGVpZ2h0LiBCZWNhdXNlIHRoZSBoZWlnaHQgaXMgc2V0XG5cdFx0XHQvLyB0byAwLCBjbGllbnRIZWlnaHQgPT0gMCBpbiBGaXJlZm94LiBUaGVyZWZvcmUsIHdlIGNhbiB1c2UgdGhpcyB0b1xuXHRcdFx0Ly8gY2hlY2sgaWYgcGFkZGluZyBtdXN0IGJlIGFkZGVkLlxuXHRcdFx0aWYgKCBjbGllbnRIZWlnaHQgPT09IDAgKSB7XG5cdFx0XHRcdHBhZGRpbmdUb3AgPSBwYXJzZUZsb2F0KCB0aGlzLmVsZW1lbnQuY3NzKCBcInBhZGRpbmctdG9wXCIgKSApO1xuXHRcdFx0XHRwYWRkaW5nQm90dG9tID0gcGFyc2VGbG9hdCggdGhpcy5lbGVtZW50LmNzcyggXCJwYWRkaW5nLWJvdHRvbVwiICkgKTtcblx0XHRcdFx0cGFkZGluZ0hlaWdodCA9IHBhZGRpbmdUb3AgKyBwYWRkaW5nQm90dG9tO1xuXG5cdFx0XHRcdGhlaWdodCArPSBwYWRkaW5nSGVpZ2h0O1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmVsZW1lbnQuY3NzKHtcblx0XHRcdFx0XCJoZWlnaHRcIjogaGVpZ2h0LFxuXHRcdFx0XHRcIm1pbi1oZWlnaHRcIjogXCJcIixcblx0XHRcdFx0XCJtYXgtaGVpZ2h0XCI6IFwiXCJcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLndpbmRvdy5zY3JvbGxUb3AoIHNjcm9sbFRvcCApO1xuXHRcdH0sXG5cblx0XHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmF1dG9ncm93ICYmIHRoaXMuaXNUZXh0YXJlYSApIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlSGVpZ2h0KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdFx0dGhpcy5fc3VwZXIoIG9wdGlvbnMgKTtcblxuXHRcdFx0aWYgKCBvcHRpb25zLmF1dG9ncm93ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pc1RleHRhcmVhICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuYXV0b2dyb3cgKSB7XG5cdFx0XHRcdFx0dGhpcy5fYXV0b2dyb3coKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl91bmJpbmRBdXRvZ3JvdygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0pO1xufSkoIGpRdWVyeSApO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoIFwibW9iaWxlLnNlbGVjdG1lbnVcIiwgJC5leHRlbmQoIHtcblx0aW5pdFNlbGVjdG9yOiBcInNlbGVjdDpub3QoIDpqcW1EYXRhKHJvbGU9J3NsaWRlcicpKTpub3QoIDpqcW1EYXRhKHJvbGU9J2ZsaXBzd2l0Y2gnKSApXCIsXG5cblx0b3B0aW9uczoge1xuXHRcdHRoZW1lOiBudWxsLFxuXHRcdGljb246IFwiY2FyYXQtZFwiLFxuXHRcdGljb25wb3M6IFwicmlnaHRcIixcblx0XHRpbmxpbmU6IGZhbHNlLFxuXHRcdGNvcm5lcnM6IHRydWUsXG5cdFx0c2hhZG93OiB0cnVlLFxuXHRcdGljb25zaGFkb3c6IGZhbHNlLCAvKiBUT0RPOiBEZXByZWNhdGVkIGluIDEuNCwgcmVtb3ZlIGluIDEuNS4gKi9cblx0XHRvdmVybGF5VGhlbWU6IG51bGwsXG5cdFx0ZGl2aWRlclRoZW1lOiBudWxsLFxuXHRcdGhpZGVQbGFjZWhvbGRlck1lbnVJdGVtczogdHJ1ZSxcblx0XHRjbG9zZVRleHQ6IFwiQ2xvc2VcIixcblx0XHRuYXRpdmVNZW51OiB0cnVlLFxuXHRcdC8vIFRoaXMgb3B0aW9uIGRlZmF1bHRzIHRvIHRydWUgb24gaU9TIGRldmljZXMuXG5cdFx0cHJldmVudEZvY3VzWm9vbTogL2lQaG9uZXxpUGFkfGlQb2QvLnRlc3QoIG5hdmlnYXRvci5wbGF0Zm9ybSApICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZiggXCJBcHBsZVdlYktpdFwiICkgPiAtMSxcblx0XHRtaW5pOiBmYWxzZVxuXHR9LFxuXG5cdF9idXR0b246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAkKCBcIjxkaXYvPlwiICk7XG5cdH0sXG5cblx0X3NldERpc2FibGVkOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dGhpcy5lbGVtZW50LmF0dHIoIFwiZGlzYWJsZWRcIiwgdmFsdWUgKTtcblx0XHR0aGlzLmJ1dHRvbi5hdHRyKCBcImFyaWEtZGlzYWJsZWRcIiwgdmFsdWUgKTtcblx0XHRyZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCBcImRpc2FibGVkXCIsIHZhbHVlICk7XG5cdH0sXG5cblx0X2ZvY3VzQnV0dG9uIDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRzZWxmLmJ1dHRvbi5mb2N1cygpO1xuXHRcdH0sIDQwKTtcblx0fSxcblxuXHRfc2VsZWN0T3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2VsZWN0LmZpbmQoIFwib3B0aW9uXCIgKTtcblx0fSxcblxuXHQvLyBzZXR1cCBpdGVtcyB0aGF0IGFyZSBnZW5lcmFsbHkgbmVjZXNzYXJ5IGZvciBzZWxlY3QgbWVudSBleHRlbnNpb25cblx0X3ByZUV4dGVuc2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlubGluZSA9IHRoaXMub3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5lbGVtZW50LmpxbURhdGEoIFwiaW5saW5lXCIgKSxcblx0XHRcdG1pbmkgPSB0aGlzLm9wdGlvbnMubWluaSB8fCB0aGlzLmVsZW1lbnQuanFtRGF0YSggXCJtaW5pXCIgKSxcblx0XHRcdGNsYXNzZXMgPSBcIlwiO1xuXHRcdC8vIFRPRE86IFBvc3QgMS4xLS1vbmNlIHdlIGhhdmUgdGltZSB0byB0ZXN0IHRob3JvdWdobHktLWFueSBjbGFzc2VzIG1hbnVhbGx5IGFwcGxpZWQgdG8gdGhlIG9yaWdpbmFsIGVsZW1lbnQgc2hvdWxkIGJlIGNhcnJpZWQgb3ZlciB0byB0aGUgZW5oYW5jZWQgZWxlbWVudCwgd2l0aCBhbiBgLWVuaGFuY2VkYCBzdWZmaXguIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS1tb2JpbGUvaXNzdWVzLzM1Nzdcblx0XHQvKiBpZiAoICRlbFswXS5jbGFzc05hbWUubGVuZ3RoICkge1xuXHRcdFx0Y2xhc3NlcyA9ICRlbFswXS5jbGFzc05hbWU7XG5cdFx0fSAqL1xuXHRcdGlmICggISF+dGhpcy5lbGVtZW50WzBdLmNsYXNzTmFtZS5pbmRleE9mKCBcInVpLWJ0bi1sZWZ0XCIgKSApIHtcblx0XHRcdGNsYXNzZXMgPSBcIiB1aS1idG4tbGVmdFwiO1xuXHRcdH1cblxuXHRcdGlmICggICEhfnRoaXMuZWxlbWVudFswXS5jbGFzc05hbWUuaW5kZXhPZiggXCJ1aS1idG4tcmlnaHRcIiApICkge1xuXHRcdFx0Y2xhc3NlcyA9IFwiIHVpLWJ0bi1yaWdodFwiO1xuXHRcdH1cblxuXHRcdGlmICggaW5saW5lICkge1xuXHRcdFx0Y2xhc3NlcyArPSBcIiB1aS1idG4taW5saW5lXCI7XG5cdFx0fVxuXHRcdGlmICggbWluaSApIHtcblx0XHRcdGNsYXNzZXMgKz0gXCIgdWktbWluaVwiO1xuXHRcdH1cblxuXHRcdHRoaXMuc2VsZWN0ID0gdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCBcInVpLWJ0bi1sZWZ0IHVpLWJ0bi1yaWdodFwiICkud3JhcCggXCI8ZGl2IGNsYXNzPSd1aS1zZWxlY3RcIiArIGNsYXNzZXMgKyBcIic+XCIgKTtcblx0XHR0aGlzLnNlbGVjdElkICA9IHRoaXMuc2VsZWN0LmF0dHIoIFwiaWRcIiApIHx8ICggXCJzZWxlY3QtXCIgKyB0aGlzLnV1aWQgKTtcblx0XHR0aGlzLmJ1dHRvbklkID0gdGhpcy5zZWxlY3RJZCArIFwiLWJ1dHRvblwiO1xuXHRcdHRoaXMubGFiZWwgPSAkKCBcImxhYmVsW2Zvcj0nXCIrIHRoaXMuc2VsZWN0SWQgK1wiJ11cIiApO1xuXHRcdHRoaXMuaXNNdWx0aXBsZSA9IHRoaXMuc2VsZWN0WyAwIF0ubXVsdGlwbGU7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB3cmFwcGVyID0gdGhpcy5lbGVtZW50LnBhcmVudHMoIFwiLnVpLXNlbGVjdFwiICk7XG5cdFx0aWYgKCB3cmFwcGVyLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRpZiAoIHdyYXBwZXIuaXMoIFwiLnVpLWJ0bi1sZWZ0LCAudWktYnRuLXJpZ2h0XCIgKSApIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKCB3cmFwcGVyLmhhc0NsYXNzKCBcInVpLWJ0bi1sZWZ0XCIgKSA/IFwidWktYnRuLWxlZnRcIiA6IFwidWktYnRuLXJpZ2h0XCIgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZWxlbWVudC5pbnNlcnRBZnRlciggd3JhcHBlciApO1xuXHRcdFx0d3JhcHBlci5yZW1vdmUoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcHJlRXh0ZW5zaW9uKCk7XG5cblx0XHR0aGlzLmJ1dHRvbiA9IHRoaXMuX2J1dHRvbigpO1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXG5cdFx0XHRpY29ucG9zID0gb3B0aW9ucy5pY29uID8gKCBvcHRpb25zLmljb25wb3MgfHwgdGhpcy5zZWxlY3QuanFtRGF0YSggXCJpY29ucG9zXCIgKSApIDogZmFsc2UsXG5cblx0XHRcdGJ1dHRvbiA9IHRoaXMuYnV0dG9uXG5cdFx0XHRcdC5pbnNlcnRCZWZvcmUoIHRoaXMuc2VsZWN0IClcblx0XHRcdFx0LmF0dHIoIFwiaWRcIiwgdGhpcy5idXR0b25JZCApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1idG5cIiArXG5cdFx0XHRcdFx0KCBvcHRpb25zLmljb24gPyAoIFwiIHVpLWljb24tXCIgKyBvcHRpb25zLmljb24gKyBcIiB1aS1idG4taWNvbi1cIiArIGljb25wb3MgK1xuXHRcdFx0XHRcdCggb3B0aW9ucy5pY29uc2hhZG93ID8gXCIgdWktc2hhZG93LWljb25cIiA6IFwiXCIgKSApIDpcdFwiXCIgKSArIC8qIFRPRE86IFJlbW92ZSBpbiAxLjUuICovXG5cdFx0XHRcdFx0KCBvcHRpb25zLnRoZW1lID8gXCIgdWktYnRuLVwiICsgb3B0aW9ucy50aGVtZSA6IFwiXCIgKSArXG5cdFx0XHRcdFx0KCBvcHRpb25zLmNvcm5lcnMgPyBcIiB1aS1jb3JuZXItYWxsXCIgOiBcIlwiICkgK1xuXHRcdFx0XHRcdCggb3B0aW9ucy5zaGFkb3cgPyBcIiB1aS1zaGFkb3dcIiA6IFwiXCIgKSApO1xuXG5cdFx0dGhpcy5zZXRCdXR0b25UZXh0KCk7XG5cblx0XHQvLyBPcGVyYSBkb2VzIG5vdCBwcm9wZXJseSBzdXBwb3J0IG9wYWNpdHkgb24gc2VsZWN0IGVsZW1lbnRzXG5cdFx0Ly8gSW4gTWluaSwgaXQgaGlkZXMgdGhlIGVsZW1lbnQsIGJ1dCBub3QgaXRzIHRleHRcblx0XHQvLyBPbiB0aGUgZGVza3RvcCxpdCBzZWVtcyB0byBkbyB0aGUgb3Bwb3NpdGVcblx0XHQvLyBmb3IgdGhlc2UgcmVhc29ucywgdXNpbmcgdGhlIG5hdGl2ZU1lbnUgb3B0aW9uIHJlc3VsdHMgaW4gYSBmdWxsIG5hdGl2ZSBzZWxlY3QgaW4gT3BlcmFcblx0XHRpZiAoIG9wdGlvbnMubmF0aXZlTWVudSAmJiB3aW5kb3cub3BlcmEgJiYgd2luZG93Lm9wZXJhLnZlcnNpb24gKSB7XG5cdFx0XHRidXR0b24uYWRkQ2xhc3MoIFwidWktc2VsZWN0LW5hdGl2ZW9ubHlcIiApO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBjb3VudGVyIGZvciBtdWx0aSBzZWxlY3RzXG5cdFx0aWYgKCB0aGlzLmlzTXVsdGlwbGUgKSB7XG5cdFx0XHR0aGlzLmJ1dHRvbkNvdW50ID0gJCggXCI8c3Bhbj5cIiApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1saS1jb3VudCB1aS1ib2R5LWluaGVyaXRcIiApXG5cdFx0XHRcdC5oaWRlKClcblx0XHRcdFx0LmFwcGVuZFRvKCBidXR0b24uYWRkQ2xhc3MoIFwidWktbGktaGFzLWNvdW50XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIERpc2FibGUgaWYgc3BlY2lmaWVkXG5cdFx0aWYgKCBvcHRpb25zLmRpc2FibGVkIHx8IHRoaXMuZWxlbWVudC5hdHRyKCBcImRpc2FibGVkXCIgKSkge1xuXHRcdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0fVxuXG5cdFx0Ly8gRXZlbnRzIG9uIG5hdGl2ZSBzZWxlY3Rcblx0XHR0aGlzLnNlbGVjdC5jaGFuZ2UoZnVuY3Rpb24oKSB7XG5cdFx0XHRzZWxmLnJlZnJlc2goKTtcblxuXHRcdFx0aWYgKCAhIW9wdGlvbnMubmF0aXZlTWVudSApIHtcblx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9oYW5kbGVGb3JtUmVzZXQoKTtcblxuXHRcdHRoaXMuX29uKCB0aGlzLmJ1dHRvbiwge1xuXHRcdFx0a2V5ZG93bjogXCJfaGFuZGxlS2V5ZG93blwiXG5cdFx0fSk7XG5cblx0XHR0aGlzLmJ1aWxkKCk7XG5cdH0sXG5cblx0YnVpbGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdHRoaXMuc2VsZWN0XG5cdFx0XHQuYXBwZW5kVG8oIHNlbGYuYnV0dG9uIClcblx0XHRcdC5iaW5kKCBcInZtb3VzZWRvd25cIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIEFkZCBhY3RpdmUgY2xhc3MgdG8gYnV0dG9uXG5cdFx0XHRcdHNlbGYuYnV0dG9uLmFkZENsYXNzKCAkLm1vYmlsZS5hY3RpdmVCdG5DbGFzcyApO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCBcImZvY3VzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmJ1dHRvbi5hZGRDbGFzcyggJC5tb2JpbGUuZm9jdXNDbGFzcyApO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCBcImJsdXJcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuYnV0dG9uLnJlbW92ZUNsYXNzKCAkLm1vYmlsZS5mb2N1c0NsYXNzICk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoIFwiZm9jdXMgdm1vdXNlb3ZlclwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5idXR0b24udHJpZ2dlciggXCJ2bW91c2VvdmVyXCIgKTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCggXCJ2bW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBSZW1vdmUgYWN0aXZlIGNsYXNzIG9uIHNjcm9sbC90b3VjaG1vdmVcblx0XHRcdFx0c2VsZi5idXR0b24ucmVtb3ZlQ2xhc3MoICQubW9iaWxlLmFjdGl2ZUJ0bkNsYXNzICk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoIFwiY2hhbmdlIGJsdXIgdm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmJ1dHRvbi50cmlnZ2VyKCBcInZtb3VzZW91dFwiIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoICQubW9iaWxlLmFjdGl2ZUJ0bkNsYXNzICk7XG5cdFx0XHR9KTtcblxuXHRcdC8vIEluIG1hbnkgc2l0dWF0aW9ucywgaU9TIHdpbGwgem9vbSBpbnRvIHRoZSBzZWxlY3QgdXBvbiB0YXAsIHRoaXMgcHJldmVudHMgdGhhdCBmcm9tIGhhcHBlbmluZ1xuXHRcdHNlbGYuYnV0dG9uLmJpbmQoIFwidm1vdXNlZG93blwiLCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc2VsZi5vcHRpb25zLnByZXZlbnRGb2N1c1pvb20gKSB7XG5cdFx0XHRcdFx0JC5tb2JpbGUuem9vbS5kaXNhYmxlKCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0c2VsZi5sYWJlbC5iaW5kKCBcImNsaWNrIGZvY3VzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzZWxmLm9wdGlvbnMucHJldmVudEZvY3VzWm9vbSApIHtcblx0XHRcdFx0XHQkLm1vYmlsZS56b29tLmRpc2FibGUoIHRydWUgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRzZWxmLnNlbGVjdC5iaW5kKCBcImZvY3VzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzZWxmLm9wdGlvbnMucHJldmVudEZvY3VzWm9vbSApIHtcblx0XHRcdFx0XHQkLm1vYmlsZS56b29tLmRpc2FibGUoIHRydWUgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRzZWxmLmJ1dHRvbi5iaW5kKCBcIm1vdXNldXBcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHNlbGYub3B0aW9ucy5wcmV2ZW50Rm9jdXNab29tICkge1xuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCQubW9iaWxlLnpvb20uZW5hYmxlKCB0cnVlICk7XG5cdFx0XHRcdH0sIDAgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRzZWxmLnNlbGVjdC5iaW5kKCBcImJsdXJcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHNlbGYub3B0aW9ucy5wcmV2ZW50Rm9jdXNab29tICkge1xuXHRcdFx0XHQkLm1vYmlsZS56b29tLmVuYWJsZSggdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0sXG5cblx0c2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RPcHRpb25zKCkuZmlsdGVyKCBcIjpzZWxlY3RlZFwiICk7XG5cdH0sXG5cblx0c2VsZWN0ZWRJbmRpY2VzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRyZXR1cm4gdGhpcy5zZWxlY3RlZCgpLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBzZWxmLl9zZWxlY3RPcHRpb25zKCkuaW5kZXgoIHRoaXMgKTtcblx0XHR9KS5nZXQoKTtcblx0fSxcblxuXHRzZXRCdXR0b25UZXh0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRzZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWQoKSxcblx0XHRcdHRleHQgPSB0aGlzLnBsYWNlaG9sZGVyLFxuXHRcdFx0c3BhbiA9ICQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic3BhblwiICkgKTtcblxuXHRcdHRoaXMuYnV0dG9uLmNoaWxkcmVuKCBcInNwYW5cIiApLm5vdCggXCIudWktbGktY291bnRcIiApLnJlbW92ZSgpLmVuZCgpLmVuZCgpLnByZXBlbmQoIChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc2VsZWN0ZWQubGVuZ3RoICkge1xuXHRcdFx0XHR0ZXh0ID0gc2VsZWN0ZWQubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiAkKCB0aGlzICkudGV4dCgpO1xuXHRcdFx0XHR9KS5nZXQoKS5qb2luKCBcIiwgXCIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRleHQgPSBzZWxmLnBsYWNlaG9sZGVyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRleHQgKSB7XG5cdFx0XHRcdHNwYW4udGV4dCggdGV4dCApO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIGNvbnRlbnRzIHRvICZuYnNwOyB3aGljaCB3ZSB3cml0ZSBhcyAmIzE2MDsgdG8gYmUgWEhUTUwgY29tcGxpYW50IC0gc2VlIGdoLTY2OTlcblx0XHRcdFx0c3Bhbi5odG1sKCBcIiYjMTYwO1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRPRE8gcG9zc2libHkgYWdncmVnYXRlIG11bHRpcGxlIHNlbGVjdCBvcHRpb24gY2xhc3Nlc1xuXHRcdFx0cmV0dXJuIHNwYW5cblx0XHRcdFx0LmFkZENsYXNzKCBzZWxmLnNlbGVjdC5hdHRyKCBcImNsYXNzXCIgKSApXG5cdFx0XHRcdC5hZGRDbGFzcyggc2VsZWN0ZWQuYXR0ciggXCJjbGFzc1wiICkgKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktc2NyZWVuLWhpZGRlblwiICk7XG5cdFx0fSkoKSk7XG5cdH0sXG5cblx0c2V0QnV0dG9uQ291bnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWQoKTtcblxuXHRcdC8vIG11bHRpcGxlIGNvdW50IGluc2lkZSBidXR0b25cblx0XHRpZiAoIHRoaXMuaXNNdWx0aXBsZSApIHtcblx0XHRcdHRoaXMuYnV0dG9uQ291bnRbIHNlbGVjdGVkLmxlbmd0aCA+IDEgPyBcInNob3dcIiA6IFwiaGlkZVwiIF0oKS50ZXh0KCBzZWxlY3RlZC5sZW5ndGggKTtcblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZUtleWRvd246IGZ1bmN0aW9uKCAvKiBldmVudCAqLyApIHtcblx0XHR0aGlzLl9kZWxheSggXCJfcmVmcmVzaEJ1dHRvblwiICk7XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlZnJlc2goKTtcblx0fSxcblxuXHRfcmVmcmVzaEJ1dHRvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zZXRCdXR0b25UZXh0KCk7XG5cdFx0dGhpcy5zZXRCdXR0b25Db3VudCgpO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3JlZnJlc2hCdXR0b24oKTtcblx0fSxcblxuXHQvLyBvcGVuIGFuZCBjbG9zZSBwcmVzZXJ2ZWQgaW4gbmF0aXZlIHNlbGVjdHNcblx0Ly8gdG8gc2ltcGxpZnkgdXNlcnMgY29kZSB3aGVuIGxvb3Bpbmcgb3ZlciBzZWxlY3RzXG5cdG9wZW46ICQubm9vcCxcblx0Y2xvc2U6ICQubm9vcCxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zZXREaXNhYmxlZCggdHJ1ZSApO1xuXHRcdHRoaXMuYnV0dG9uLmFkZENsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIgKTtcblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NldERpc2FibGVkKCBmYWxzZSApO1xuXHRcdHRoaXMuYnV0dG9uLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIgKTtcblx0fVxufSwgJC5tb2JpbGUuYmVoYXZpb3JzLmZvcm1SZXNldCApICk7XG5cbn0pKCBqUXVlcnkgKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQubW9iaWxlLmxpbmtzID0gZnVuY3Rpb24oIHRhcmdldCApIHtcblxuXHQvL2xpbmtzIHdpdGhpbiBjb250ZW50IGFyZWFzLCB0ZXN0cyBpbmNsdWRlZCB3aXRoIHBhZ2Vcblx0JCggdGFyZ2V0IClcblx0XHQuZmluZCggXCJhXCIgKVxuXHRcdC5qcW1FbmhhbmNlYWJsZSgpXG5cdFx0LmZpbHRlciggXCI6anFtRGF0YShyZWw9J3BvcHVwJylbaHJlZl1baHJlZiE9JyddXCIgKVxuXHRcdC5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdC8vIEFjY2Vzc2liaWxpdHkgaW5mbyBmb3IgcG9wdXBzXG5cdFx0XHR2YXIgZWxlbWVudCA9IHRoaXMsXG5cdFx0XHRcdGlkcmVmID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoIFwiaHJlZlwiICkuc3Vic3RyaW5nKCAxICk7XG5cblx0XHRcdGlmICggaWRyZWYgKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCBcImFyaWEtaGFzcG9wdXBcIiwgdHJ1ZSApO1xuXHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSggXCJhcmlhLW93bnNcIiwgaWRyZWYgKTtcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoIFwiYXJpYS1leHBhbmRlZFwiLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdH0pXG5cdFx0LmVuZCgpXG5cdFx0Lm5vdCggXCIudWktYnRuLCA6anFtRGF0YShyb2xlPSdub25lJyksIDpqcW1EYXRhKHJvbGU9J25vanMnKVwiIClcblx0XHQuYWRkQ2xhc3MoIFwidWktbGlua1wiICk7XG5cbn07XG5cbn0pKCBqUXVlcnkgKTtcblxuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuZnVuY3Rpb24gZml0U2VnbWVudEluc2lkZVNlZ21lbnQoIHdpbmRvd1NpemUsIHNlZ21lbnRTaXplLCBvZmZzZXQsIGRlc2lyZWQgKSB7XG5cdHZhciByZXR1cm5WYWx1ZSA9IGRlc2lyZWQ7XG5cblx0aWYgKCB3aW5kb3dTaXplIDwgc2VnbWVudFNpemUgKSB7XG5cdFx0Ly8gQ2VudGVyIHNlZ21lbnQgaWYgaXQncyBiaWdnZXIgdGhhbiB0aGUgd2luZG93XG5cdFx0cmV0dXJuVmFsdWUgPSBvZmZzZXQgKyAoIHdpbmRvd1NpemUgLSBzZWdtZW50U2l6ZSApIC8gMjtcblx0fSBlbHNlIHtcblx0XHQvLyBPdGhlcndpc2UgY2VudGVyIGl0IGF0IHRoZSBkZXNpcmVkIGNvb3JkaW5hdGUgd2hpbGUga2VlcGluZyBpdCBjb21wbGV0ZWx5IGluc2lkZSB0aGUgd2luZG93XG5cdFx0cmV0dXJuVmFsdWUgPSBNYXRoLm1pbiggTWF0aC5tYXgoIG9mZnNldCwgZGVzaXJlZCAtIHNlZ21lbnRTaXplIC8gMiApLCBvZmZzZXQgKyB3aW5kb3dTaXplIC0gc2VnbWVudFNpemUgKTtcblx0fVxuXG5cdHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93Q29vcmRpbmF0ZXMoIHRoZVdpbmRvdyApIHtcblx0cmV0dXJuIHtcblx0XHR4OiB0aGVXaW5kb3cuc2Nyb2xsTGVmdCgpLFxuXHRcdHk6IHRoZVdpbmRvdy5zY3JvbGxUb3AoKSxcblx0XHRjeDogKCB0aGVXaW5kb3dbIDAgXS5pbm5lcldpZHRoIHx8IHRoZVdpbmRvdy53aWR0aCgpICksXG5cdFx0Y3k6ICggdGhlV2luZG93WyAwIF0uaW5uZXJIZWlnaHQgfHwgdGhlV2luZG93LmhlaWdodCgpIClcblx0fTtcbn1cblxuJC53aWRnZXQoIFwibW9iaWxlLnBvcHVwXCIsIHtcblx0b3B0aW9uczoge1xuXHRcdHdyYXBwZXJDbGFzczogbnVsbCxcblx0XHR0aGVtZTogbnVsbCxcblx0XHRvdmVybGF5VGhlbWU6IG51bGwsXG5cdFx0c2hhZG93OiB0cnVlLFxuXHRcdGNvcm5lcnM6IHRydWUsXG5cdFx0dHJhbnNpdGlvbjogXCJub25lXCIsXG5cdFx0cG9zaXRpb25UbzogXCJvcmlnaW5cIixcblx0XHR0b2xlcmFuY2U6IG51bGwsXG5cdFx0Y2xvc2VMaW5rU2VsZWN0b3I6IFwiYTpqcW1EYXRhKHJlbD0nYmFjaycpXCIsXG5cdFx0Y2xvc2VMaW5rRXZlbnRzOiBcImNsaWNrLnBvcHVwXCIsXG5cdFx0bmF2aWdhdGVFdmVudHM6IFwibmF2aWdhdGUucG9wdXBcIixcblx0XHRjbG9zZUV2ZW50czogXCJuYXZpZ2F0ZS5wb3B1cCBwYWdlYmVmb3JlY2hhbmdlLnBvcHVwXCIsXG5cdFx0ZGlzbWlzc2libGU6IHRydWUsXG5cdFx0ZW5oYW5jZWQ6IGZhbHNlLFxuXG5cdFx0Ly8gTk9URSBXaW5kb3dzIFBob25lIDcgaGFzIGEgc2Nyb2xsIHBvc2l0aW9uIGNhY2hpbmcgaXNzdWUgdGhhdFxuXHRcdC8vICAgICAgcmVxdWlyZXMgdXMgdG8gZGlzYWJsZSBwb3B1cCBoaXN0b3J5IG1hbmFnZW1lbnQgYnkgZGVmYXVsdFxuXHRcdC8vICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktbW9iaWxlL2lzc3Vlcy80Nzg0XG5cdFx0Ly9cblx0XHQvLyBOT1RFIHRoaXMgb3B0aW9uIGlzIG1vZGlmaWVkIGluIF9jcmVhdGUhXG5cdFx0aGlzdG9yeTogISQubW9iaWxlLmJyb3dzZXIub2xkSUVcblx0fSxcblxuXHQvLyBXaGVuIHRoZSB1c2VyIGRlcHJlc3NlcyB0aGUgbW91c2UvZmluZ2VyIG9uIGFuIGVsZW1lbnQgaW5zaWRlIHRoZSBwb3B1cCB3aGlsZSB0aGUgcG9wdXAgaXNcblx0Ly8gb3Blbiwgd2UgaWdub3JlIHJlc2l6ZSBldmVudHMgZm9yIGEgc2hvcnQgd2hpbGUuIFRoaXMgcHJldmVudHMgIzY5NjEuXG5cdF9oYW5kbGVEb2N1bWVudFZtb3VzZWRvd246IGZ1bmN0aW9uKCB0aGVFdmVudCApIHtcblx0XHRpZiAoIHRoaXMuX2lzT3BlbiAmJiAkLmNvbnRhaW5zKCB0aGlzLl91aS5jb250YWluZXJbIDAgXSwgdGhlRXZlbnQudGFyZ2V0ICkgKSB7XG5cdFx0XHR0aGlzLl9pZ25vcmVSZXNpemVFdmVudHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoZUVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG5cdFx0XHRteUlkID0gdGhlRWxlbWVudC5hdHRyKCBcImlkXCIgKSxcblx0XHRcdGN1cnJlbnRPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0Ly8gV2UgbmVlZCB0byBhZGp1c3QgdGhlIGhpc3Rvcnkgb3B0aW9uIHRvIGJlIGZhbHNlIGlmIHRoZXJlJ3Mgbm8gQUpBWCBuYXYuXG5cdFx0Ly8gV2UgY2FuJ3QgZG8gaXQgaW4gdGhlIG9wdGlvbiBkZWNsYXJhdGlvbnMgYmVjYXVzZSB0aG9zZSBhcmUgcnVuIGJlZm9yZVxuXHRcdC8vIGl0IGlzIGRldGVybWluZWQgd2hldGhlciB0aGVyZSBzaGFsbCBiZSBBSkFYIG5hdi5cblx0XHRjdXJyZW50T3B0aW9ucy5oaXN0b3J5ID0gY3VycmVudE9wdGlvbnMuaGlzdG9yeSAmJiAkLm1vYmlsZS5hamF4RW5hYmxlZCAmJiAkLm1vYmlsZS5oYXNoTGlzdGVuaW5nRW5hYmxlZDtcblxuXHRcdHRoaXMuX29uKCB0aGlzLmRvY3VtZW50LCB7XG5cdFx0XHRcInZtb3VzZWRvd25cIjogXCJfaGFuZGxlRG9jdW1lbnRWbW91c2Vkb3duXCJcblx0XHR9KTtcblxuXHRcdC8vIERlZmluZSBpbnN0YW5jZSB2YXJpYWJsZXNcblx0XHQkLmV4dGVuZCggdGhpcywge1xuXHRcdFx0X3Njcm9sbFRvcDogMCxcblx0XHRcdF9wYWdlOiB0aGVFbGVtZW50LmNsb3Nlc3QoIFwiLnVpLXBhZ2VcIiApLFxuXHRcdFx0X3VpOiBudWxsLFxuXHRcdFx0X2ZhbGxiYWNrVHJhbnNpdGlvbjogXCJcIixcblx0XHRcdF9jdXJyZW50VHJhbnNpdGlvbjogZmFsc2UsXG5cdFx0XHRfcHJlcmVxdWlzaXRlczogbnVsbCxcblx0XHRcdF9pc09wZW46IGZhbHNlLFxuXHRcdFx0X3RvbGVyYW5jZTogbnVsbCxcblx0XHRcdF9yZXNpemVEYXRhOiBudWxsLFxuXHRcdFx0X2lnbm9yZVJlc2l6ZVRvOiAwLFxuXHRcdFx0X29yaWVudGF0aW9uY2hhbmdlSW5Qcm9ncmVzczogZmFsc2Vcblx0XHR9KTtcblxuXHRcdGlmICggdGhpcy5fcGFnZS5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHR0aGlzLl9wYWdlID0gJCggXCJib2R5XCIgKTtcblx0XHR9XG5cblx0XHRpZiAoIGN1cnJlbnRPcHRpb25zLmVuaGFuY2VkICkge1xuXHRcdFx0dGhpcy5fdWkgPSB7XG5cdFx0XHRcdGNvbnRhaW5lcjogdGhlRWxlbWVudC5wYXJlbnQoKSxcblx0XHRcdFx0c2NyZWVuOiB0aGVFbGVtZW50LnBhcmVudCgpLnByZXYoKSxcblx0XHRcdFx0cGxhY2Vob2xkZXI6ICQoIHRoaXMuZG9jdW1lbnRbIDAgXS5nZXRFbGVtZW50QnlJZCggbXlJZCArIFwiLXBsYWNlaG9sZGVyXCIgKSApXG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl91aSA9IHRoaXMuX2VuaGFuY2UoIHRoZUVsZW1lbnQsIG15SWQgKTtcblx0XHRcdHRoaXMuX2FwcGx5VHJhbnNpdGlvbiggY3VycmVudE9wdGlvbnMudHJhbnNpdGlvbiApO1xuXHRcdH1cblx0XHR0aGlzXG5cdFx0XHQuX3NldFRvbGVyYW5jZSggY3VycmVudE9wdGlvbnMudG9sZXJhbmNlIClcblx0XHRcdC5fdWkuZm9jdXNFbGVtZW50ID0gdGhpcy5fdWkuY29udGFpbmVyO1xuXG5cdFx0Ly8gRXZlbnQgaGFuZGxlcnNcblx0XHR0aGlzLl9vbiggdGhpcy5fdWkuc2NyZWVuLCB7IFwidmNsaWNrXCI6IFwiX2VhdEV2ZW50QW5kQ2xvc2VcIiB9ICk7XG5cdFx0dGhpcy5fb24oIHRoaXMud2luZG93LCB7XG5cdFx0XHRvcmllbnRhdGlvbmNoYW5nZTogJC5wcm94eSggdGhpcywgXCJfaGFuZGxlV2luZG93T3JpZW50YXRpb25jaGFuZ2VcIiApLFxuXHRcdFx0cmVzaXplOiAkLnByb3h5KCB0aGlzLCBcIl9oYW5kbGVXaW5kb3dSZXNpemVcIiApLFxuXHRcdFx0a2V5dXA6ICQucHJveHkoIHRoaXMsIFwiX2hhbmRsZVdpbmRvd0tleVVwXCIgKVxuXHRcdH0pO1xuXHRcdHRoaXMuX29uKCB0aGlzLmRvY3VtZW50LCB7IFwiZm9jdXNpblwiOiBcIl9oYW5kbGVEb2N1bWVudEZvY3VzSW5cIiB9ICk7XG5cdH0sXG5cblx0X2VuaGFuY2U6IGZ1bmN0aW9uKCB0aGVFbGVtZW50LCBteUlkICkge1xuXHRcdHZhciBjdXJyZW50T3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdHdyYXBwZXJDbGFzcyA9IGN1cnJlbnRPcHRpb25zLndyYXBwZXJDbGFzcyxcblx0XHRcdHVpID0ge1xuXHRcdFx0XHRzY3JlZW46ICQoIFwiPGRpdiBjbGFzcz0ndWktc2NyZWVuLWhpZGRlbiB1aS1wb3B1cC1zY3JlZW4gXCIgK1xuXHRcdFx0XHR0aGlzLl90aGVtZUNsYXNzRnJvbU9wdGlvbiggXCJ1aS1vdmVybGF5LVwiLCBjdXJyZW50T3B0aW9ucy5vdmVybGF5VGhlbWUgKSArIFwiJz48L2Rpdj5cIiApLFxuXHRcdFx0XHRwbGFjZWhvbGRlcjogJCggXCI8ZGl2IHN0eWxlPSdkaXNwbGF5OiBub25lOyc+PCEtLSBwbGFjZWhvbGRlciAtLT48L2Rpdj5cIiApLFxuXHRcdFx0XHRjb250YWluZXI6ICQoIFwiPGRpdiBjbGFzcz0ndWktcG9wdXAtY29udGFpbmVyIHVpLXBvcHVwLWhpZGRlbiB1aS1wb3B1cC10cnVuY2F0ZVwiICtcblx0XHRcdFx0XHQoIHdyYXBwZXJDbGFzcyA/ICggXCIgXCIgKyB3cmFwcGVyQ2xhc3MgKSA6IFwiXCIgKSArIFwiJz48L2Rpdj5cIiApXG5cdFx0XHR9LFxuXHRcdFx0ZnJhZ21lbnQgPSB0aGlzLmRvY3VtZW50WyAwIF0uY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIHVpLnNjcmVlblsgMCBdICk7XG5cdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIHVpLmNvbnRhaW5lclsgMCBdICk7XG5cblx0XHRpZiAoIG15SWQgKSB7XG5cdFx0XHR1aS5zY3JlZW4uYXR0ciggXCJpZFwiLCBteUlkICsgXCItc2NyZWVuXCIgKTtcblx0XHRcdHVpLmNvbnRhaW5lci5hdHRyKCBcImlkXCIsIG15SWQgKyBcIi1wb3B1cFwiICk7XG5cdFx0XHR1aS5wbGFjZWhvbGRlclxuXHRcdFx0XHQuYXR0ciggXCJpZFwiLCBteUlkICsgXCItcGxhY2Vob2xkZXJcIiApXG5cdFx0XHRcdC5odG1sKCBcIjwhLS0gcGxhY2Vob2xkZXIgZm9yIFwiICsgbXlJZCArIFwiIC0tPlwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIHByb3RvXG5cdFx0dGhpcy5fcGFnZVsgMCBdLmFwcGVuZENoaWxkKCBmcmFnbWVudCApO1xuXHRcdC8vIExlYXZlIGEgcGxhY2Vob2xkZXIgd2hlcmUgdGhlIGVsZW1lbnQgdXNlZCB0byBiZVxuXHRcdHVpLnBsYWNlaG9sZGVyLmluc2VydEFmdGVyKCB0aGVFbGVtZW50ICk7XG5cdFx0dGhlRWxlbWVudFxuXHRcdFx0LmRldGFjaCgpXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktcG9wdXAgXCIgK1xuXHRcdFx0XHR0aGlzLl90aGVtZUNsYXNzRnJvbU9wdGlvbiggXCJ1aS1ib2R5LVwiLCBjdXJyZW50T3B0aW9ucy50aGVtZSApICsgXCIgXCIgK1xuXHRcdFx0XHQoIGN1cnJlbnRPcHRpb25zLnNoYWRvdyA/IFwidWktb3ZlcmxheS1zaGFkb3cgXCIgOiBcIlwiICkgK1xuXHRcdFx0XHQoIGN1cnJlbnRPcHRpb25zLmNvcm5lcnMgPyBcInVpLWNvcm5lci1hbGwgXCIgOiBcIlwiICkgKVxuXHRcdFx0LmFwcGVuZFRvKCB1aS5jb250YWluZXIgKTtcblxuXHRcdHJldHVybiB1aTtcblx0fSxcblxuXHRfZWF0RXZlbnRBbmRDbG9zZTogZnVuY3Rpb24oIHRoZUV2ZW50ICkge1xuXHRcdHRoZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0dGhlRXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGlzbWlzc2libGUgKSB7XG5cdFx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvLyBNYWtlIHN1cmUgdGhlIHNjcmVlbiBjb3ZlcnMgdGhlIGVudGlyZSBkb2N1bWVudCAtIENTUyBpcyBzb21ldGltZXMgbm90XG5cdC8vIGVub3VnaCB0byBhY2NvbXBsaXNoIHRoaXMuXG5cdF9yZXNpemVTY3JlZW46IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzY3JlZW4gPSB0aGlzLl91aS5zY3JlZW4sXG5cdFx0XHRwb3B1cEhlaWdodCA9IHRoaXMuX3VpLmNvbnRhaW5lci5vdXRlckhlaWdodCggdHJ1ZSApLFxuXHRcdFx0c2NyZWVuSGVpZ2h0ID0gc2NyZWVuLnJlbW92ZUF0dHIoIFwic3R5bGVcIiApLmhlaWdodCgpLFxuXG5cdFx0XHQvLyBTdWJ0cmFjdGluZyAxIGhlcmUgaXMgbmVjZXNzYXJ5IGZvciBhbiBvYnNjdXJlIEFuZHJkb2lkIDQuMCBidWcgd2hlcmVcblx0XHRcdC8vIHRoZSBicm93c2VyIGhhbmdzIGlmIHRoZSBzY3JlZW4gY292ZXJzIHRoZSBlbnRpcmUgZG9jdW1lbnQgOi9cblx0XHRcdGRvY3VtZW50SGVpZ2h0ID0gdGhpcy5kb2N1bWVudC5oZWlnaHQoKSAtIDE7XG5cblx0XHRpZiAoIHNjcmVlbkhlaWdodCA8IGRvY3VtZW50SGVpZ2h0ICkge1xuXHRcdFx0c2NyZWVuLmhlaWdodCggZG9jdW1lbnRIZWlnaHQgKTtcblx0XHR9IGVsc2UgaWYgKCBwb3B1cEhlaWdodCA+IHNjcmVlbkhlaWdodCApIHtcblx0XHRcdHNjcmVlbi5oZWlnaHQoIHBvcHVwSGVpZ2h0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVXaW5kb3dLZXlVcDogZnVuY3Rpb24oIHRoZUV2ZW50ICkge1xuXHRcdGlmICggdGhpcy5faXNPcGVuICYmIHRoZUV2ZW50LmtleUNvZGUgPT09ICQubW9iaWxlLmtleUNvZGUuRVNDQVBFICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2VhdEV2ZW50QW5kQ2xvc2UoIHRoZUV2ZW50ICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9leHBlY3RSZXNpemVFdmVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHdpbmRvd0Nvb3JkaW5hdGVzID0gZ2V0V2luZG93Q29vcmRpbmF0ZXMoIHRoaXMud2luZG93ICk7XG5cblx0XHRpZiAoIHRoaXMuX3Jlc2l6ZURhdGEgKSB7XG5cdFx0XHRpZiAoIHdpbmRvd0Nvb3JkaW5hdGVzLnggPT09IHRoaXMuX3Jlc2l6ZURhdGEud2luZG93Q29vcmRpbmF0ZXMueCAmJlxuXHRcdFx0XHR3aW5kb3dDb29yZGluYXRlcy55ID09PSB0aGlzLl9yZXNpemVEYXRhLndpbmRvd0Nvb3JkaW5hdGVzLnkgJiZcblx0XHRcdFx0d2luZG93Q29vcmRpbmF0ZXMuY3ggPT09IHRoaXMuX3Jlc2l6ZURhdGEud2luZG93Q29vcmRpbmF0ZXMuY3ggJiZcblx0XHRcdFx0d2luZG93Q29vcmRpbmF0ZXMuY3kgPT09IHRoaXMuX3Jlc2l6ZURhdGEud2luZG93Q29vcmRpbmF0ZXMuY3kgKSB7XG5cdFx0XHRcdC8vIHRpbWVvdXQgbm90IHJlZnJlc2hlZFxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBjbGVhciBleGlzdGluZyB0aW1lb3V0IC0gaXQgd2lsbCBiZSByZWZyZXNoZWQgYmVsb3dcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLl9yZXNpemVEYXRhLnRpbWVvdXRJZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3Jlc2l6ZURhdGEgPSB7XG5cdFx0XHR0aW1lb3V0SWQ6IHRoaXMuX2RlbGF5KCBcIl9yZXNpemVUaW1lb3V0XCIsIDIwMCApLFxuXHRcdFx0d2luZG93Q29vcmRpbmF0ZXM6IHdpbmRvd0Nvb3JkaW5hdGVzXG5cdFx0fTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9yZXNpemVUaW1lb3V0OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMuX2lzT3BlbiApIHtcblx0XHRcdGlmICggIXRoaXMuX2V4cGVjdFJlc2l6ZUV2ZW50KCkgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5fdWkuY29udGFpbmVyLmhhc0NsYXNzKCBcInVpLXBvcHVwLWhpZGRlblwiICkgKSB7XG5cdFx0XHRcdFx0Ly8gZWZmZWN0aXZlbHkgcmFwaWQtb3BlbiB0aGUgcG9wdXAgd2hpbGUgbGVhdmluZyB0aGUgc2NyZWVuIGludGFjdFxuXHRcdFx0XHRcdHRoaXMuX3VpLmNvbnRhaW5lci5yZW1vdmVDbGFzcyggXCJ1aS1wb3B1cC1oaWRkZW4gdWktcG9wdXAtdHJ1bmNhdGVcIiApO1xuXHRcdFx0XHRcdHRoaXMucmVwb3NpdGlvbiggeyBwb3NpdGlvblRvOiBcIndpbmRvd1wiIH0gKTtcblx0XHRcdFx0XHR0aGlzLl9pZ25vcmVSZXNpemVFdmVudHMoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX3Jlc2l6ZVNjcmVlbigpO1xuXHRcdFx0XHR0aGlzLl9yZXNpemVEYXRhID0gbnVsbDtcblx0XHRcdFx0dGhpcy5fb3JpZW50YXRpb25jaGFuZ2VJblByb2dyZXNzID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3Jlc2l6ZURhdGEgPSBudWxsO1xuXHRcdFx0dGhpcy5fb3JpZW50YXRpb25jaGFuZ2VJblByb2dyZXNzID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdF9zdG9wSWdub3JpbmdSZXNpemVFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2lnbm9yZVJlc2l6ZVRvID0gMDtcblx0fSxcblxuXHRfaWdub3JlUmVzaXplRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMuX2lnbm9yZVJlc2l6ZVRvICkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLl9pZ25vcmVSZXNpemVUbyApO1xuXHRcdH1cblx0XHR0aGlzLl9pZ25vcmVSZXNpemVUbyA9IHRoaXMuX2RlbGF5KCBcIl9zdG9wSWdub3JpbmdSZXNpemVFdmVudHNcIiwgMTAwMCApO1xuXHR9LFxuXG5cdF9oYW5kbGVXaW5kb3dSZXNpemU6IGZ1bmN0aW9uKC8qIHRoZUV2ZW50ICovKSB7XG5cdFx0aWYgKCB0aGlzLl9pc09wZW4gJiYgdGhpcy5faWdub3JlUmVzaXplVG8gPT09IDAgKSB7XG5cdFx0XHRpZiAoICggdGhpcy5fZXhwZWN0UmVzaXplRXZlbnQoKSB8fCB0aGlzLl9vcmllbnRhdGlvbmNoYW5nZUluUHJvZ3Jlc3MgKSAmJlxuXHRcdFx0XHQhdGhpcy5fdWkuY29udGFpbmVyLmhhc0NsYXNzKCBcInVpLXBvcHVwLWhpZGRlblwiICkgKSB7XG5cdFx0XHRcdC8vIGVmZmVjdGl2ZWx5IHJhcGlkLWNsb3NlIHRoZSBwb3B1cCB3aGlsZSBsZWF2aW5nIHRoZSBzY3JlZW4gaW50YWN0XG5cdFx0XHRcdHRoaXMuX3VpLmNvbnRhaW5lclxuXHRcdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1wb3B1cC1oaWRkZW4gdWktcG9wdXAtdHJ1bmNhdGVcIiApXG5cdFx0XHRcdFx0LnJlbW92ZUF0dHIoIFwic3R5bGVcIiApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlV2luZG93T3JpZW50YXRpb25jaGFuZ2U6IGZ1bmN0aW9uKC8qIHRoZUV2ZW50ICovKSB7XG5cdFx0aWYgKCAhdGhpcy5fb3JpZW50YXRpb25jaGFuZ2VJblByb2dyZXNzICYmIHRoaXMuX2lzT3BlbiAmJiB0aGlzLl9pZ25vcmVSZXNpemVUbyA9PT0gMCApIHtcblx0XHRcdHRoaXMuX2V4cGVjdFJlc2l6ZUV2ZW50KCk7XG5cdFx0XHR0aGlzLl9vcmllbnRhdGlvbmNoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHQvLyBXaGVuIHRoZSBwb3B1cCBpcyBvcGVuLCBhdHRlbXB0aW5nIHRvIGZvY3VzIG9uIGFuIGVsZW1lbnQgdGhhdCBpcyBub3QgYVxuXHQvLyBjaGlsZCBvZiB0aGUgcG9wdXAgd2lsbCByZWRpcmVjdCBmb2N1cyB0byB0aGUgcG9wdXBcblx0X2hhbmRsZURvY3VtZW50Rm9jdXNJbjogZnVuY3Rpb24oIHRoZUV2ZW50ICkge1xuXHRcdHZhciB0YXJnZXQsXG5cdFx0XHR0YXJnZXRFbGVtZW50ID0gdGhlRXZlbnQudGFyZ2V0LFxuXHRcdFx0dWkgPSB0aGlzLl91aTtcblxuXHRcdGlmICggIXRoaXMuX2lzT3BlbiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRhcmdldEVsZW1lbnQgIT09IHVpLmNvbnRhaW5lclsgMCBdICkge1xuXHRcdFx0dGFyZ2V0ID0gJCggdGFyZ2V0RWxlbWVudCApO1xuXHRcdFx0aWYgKCAwID09PSB0YXJnZXQucGFyZW50cygpLmZpbHRlciggdWkuY29udGFpbmVyWyAwIF0gKS5sZW5ndGggKSB7XG5cdFx0XHRcdCQoIHRoaXMuZG9jdW1lbnRbIDAgXS5hY3RpdmVFbGVtZW50ICkub25lKCBcImZvY3VzXCIsIGZ1bmN0aW9uKC8qIHRoZUV2ZW50ICovKSB7XG5cdFx0XHRcdFx0dGFyZ2V0LmJsdXIoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHVpLmZvY3VzRWxlbWVudC5mb2N1cygpO1xuXHRcdFx0XHR0aGVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR0aGVFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggdWkuZm9jdXNFbGVtZW50WyAwIF0gPT09IHVpLmNvbnRhaW5lclsgMCBdICkge1xuXHRcdFx0XHR1aS5mb2N1c0VsZW1lbnQgPSB0YXJnZXQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5faWdub3JlUmVzaXplRXZlbnRzKCk7XG5cdH0sXG5cblx0X3RoZW1lQ2xhc3NGcm9tT3B0aW9uOiBmdW5jdGlvbiggcHJlZml4LCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gKCB2YWx1ZSA/ICggdmFsdWUgPT09IFwibm9uZVwiID8gXCJcIiA6ICggcHJlZml4ICsgdmFsdWUgKSApIDogKCBwcmVmaXggKyBcImluaGVyaXRcIiApICk7XG5cdH0sXG5cblx0X2FwcGx5VHJhbnNpdGlvbjogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHR0aGlzLl91aS5jb250YWluZXIucmVtb3ZlQ2xhc3MoIHRoaXMuX2ZhbGxiYWNrVHJhbnNpdGlvbiApO1xuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHRoaXMuX2ZhbGxiYWNrVHJhbnNpdGlvbiA9ICQubW9iaWxlLl9tYXliZURlZ3JhZGVUcmFuc2l0aW9uKCB2YWx1ZSApO1xuXHRcdFx0XHRpZiAoIHRoaXMuX2ZhbGxiYWNrVHJhbnNpdGlvbiA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdFx0dGhpcy5fZmFsbGJhY2tUcmFuc2l0aW9uID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl91aS5jb250YWluZXIuYWRkQ2xhc3MoIHRoaXMuX2ZhbGxiYWNrVHJhbnNpdGlvbiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggbmV3T3B0aW9ucyApIHtcblx0XHR2YXIgY3VycmVudE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHR0aGVFbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0c2NyZWVuID0gdGhpcy5fdWkuc2NyZWVuO1xuXG5cdFx0aWYgKCBuZXdPcHRpb25zLndyYXBwZXJDbGFzcyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5fdWkuY29udGFpbmVyXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggY3VycmVudE9wdGlvbnMud3JhcHBlckNsYXNzIClcblx0XHRcdFx0LmFkZENsYXNzKCBuZXdPcHRpb25zLndyYXBwZXJDbGFzcyApO1xuXHRcdH1cblxuXHRcdGlmICggbmV3T3B0aW9ucy50aGVtZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhlRWxlbWVudFxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIHRoaXMuX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKCBcInVpLWJvZHktXCIsIGN1cnJlbnRPcHRpb25zLnRoZW1lICkgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIHRoaXMuX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKCBcInVpLWJvZHktXCIsIG5ld09wdGlvbnMudGhlbWUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbmV3T3B0aW9ucy5vdmVybGF5VGhlbWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHNjcmVlblxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIHRoaXMuX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKCBcInVpLW92ZXJsYXktXCIsIGN1cnJlbnRPcHRpb25zLm92ZXJsYXlUaGVtZSApIClcblx0XHRcdFx0LmFkZENsYXNzKCB0aGlzLl90aGVtZUNsYXNzRnJvbU9wdGlvbiggXCJ1aS1vdmVybGF5LVwiLCBuZXdPcHRpb25zLm92ZXJsYXlUaGVtZSApICk7XG5cblx0XHRcdGlmICggdGhpcy5faXNPcGVuICkge1xuXHRcdFx0XHRzY3JlZW4uYWRkQ2xhc3MoIFwiaW5cIiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggbmV3T3B0aW9ucy5zaGFkb3cgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoZUVsZW1lbnQudG9nZ2xlQ2xhc3MoIFwidWktb3ZlcmxheS1zaGFkb3dcIiwgbmV3T3B0aW9ucy5zaGFkb3cgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5ld09wdGlvbnMuY29ybmVycyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhlRWxlbWVudC50b2dnbGVDbGFzcyggXCJ1aS1jb3JuZXItYWxsXCIsIG5ld09wdGlvbnMuY29ybmVycyApO1xuXHRcdH1cblxuXHRcdGlmICggbmV3T3B0aW9ucy50cmFuc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoICF0aGlzLl9jdXJyZW50VHJhbnNpdGlvbiApIHtcblx0XHRcdFx0dGhpcy5fYXBwbHlUcmFuc2l0aW9uKCBuZXdPcHRpb25zLnRyYW5zaXRpb24gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIG5ld09wdGlvbnMudG9sZXJhbmNlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLl9zZXRUb2xlcmFuY2UoIG5ld09wdGlvbnMudG9sZXJhbmNlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBuZXdPcHRpb25zLmRpc2FibGVkICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIG5ld09wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fc3VwZXIoIG5ld09wdGlvbnMgKTtcblx0fSxcblxuXHRfc2V0VG9sZXJhbmNlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIHRvbCA9IHsgdDogMzAsIHI6IDE1LCBiOiAzMCwgbDogMTUgfSxcblx0XHRcdGFyO1xuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0YXIgPSBTdHJpbmcoIHZhbHVlICkuc3BsaXQoIFwiLFwiICk7XG5cblx0XHRcdCQuZWFjaCggYXIsIGZ1bmN0aW9uKCBpZHgsIHZhbCApIHsgYXJbIGlkeCBdID0gcGFyc2VJbnQoIHZhbCwgMTAgKTsgfSApO1xuXG5cdFx0XHRzd2l0Y2goIGFyLmxlbmd0aCApIHtcblx0XHRcdFx0Ly8gQWxsIHZhbHVlcyBhcmUgdG8gYmUgdGhlIHNhbWVcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdGlmICggIWlzTmFOKCBhclsgMCBdICkgKSB7XG5cdFx0XHRcdFx0XHR0b2wudCA9IHRvbC5yID0gdG9sLmIgPSB0b2wubCA9IGFyWyAwIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdC8vIFRoZSBmaXJzdCB2YWx1ZSBkZW5vdGVzIHRvcC9ib3R0b20gdG9sZXJhbmNlLCBhbmQgdGhlIHNlY29uZCB2YWx1ZSBkZW5vdGVzIGxlZnQvcmlnaHQgdG9sZXJhbmNlXG5cdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRpZiAoICFpc05hTiggYXJbIDAgXSApICkge1xuXHRcdFx0XHRcdFx0dG9sLnQgPSB0b2wuYiA9IGFyWyAwIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIWlzTmFOKCBhclsgMSBdICkgKSB7XG5cdFx0XHRcdFx0XHR0b2wubCA9IHRvbC5yID0gYXJbIDEgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Ly8gVGhlIGFycmF5IGNvbnRhaW5zIHZhbHVlcyBpbiB0aGUgb3JkZXIgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XG5cdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHRpZiAoICFpc05hTiggYXJbIDAgXSApICkge1xuXHRcdFx0XHRcdFx0dG9sLnQgPSBhclsgMCBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICFpc05hTiggYXJbIDEgXSApICkge1xuXHRcdFx0XHRcdFx0dG9sLnIgPSBhclsgMSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICFpc05hTiggYXJbIDIgXSApICkge1xuXHRcdFx0XHRcdFx0dG9sLmIgPSBhclsgMiBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICFpc05hTiggYXJbIDMgXSApICkge1xuXHRcdFx0XHRcdFx0dG9sLmwgPSBhclsgMyBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3RvbGVyYW5jZSA9IHRvbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfY2xhbXBQb3B1cFdpZHRoOiBmdW5jdGlvbiggaW5mb09ubHkgKSB7XG5cdFx0dmFyIG1lbnVTaXplLFxuXHRcdFx0d2luZG93Q29vcmRpbmF0ZXMgPSBnZXRXaW5kb3dDb29yZGluYXRlcyggdGhpcy53aW5kb3cgKSxcblx0XHRcdC8vIHJlY3RhbmdsZSB3aXRoaW4gd2hpY2ggdGhlIHBvcHVwIG11c3QgZml0XG5cdFx0XHRyZWN0YW5nbGUgPSB7XG5cdFx0XHRcdHg6IHRoaXMuX3RvbGVyYW5jZS5sLFxuXHRcdFx0XHR5OiB3aW5kb3dDb29yZGluYXRlcy55ICsgdGhpcy5fdG9sZXJhbmNlLnQsXG5cdFx0XHRcdGN4OiB3aW5kb3dDb29yZGluYXRlcy5jeCAtIHRoaXMuX3RvbGVyYW5jZS5sIC0gdGhpcy5fdG9sZXJhbmNlLnIsXG5cdFx0XHRcdGN5OiB3aW5kb3dDb29yZGluYXRlcy5jeSAtIHRoaXMuX3RvbGVyYW5jZS50IC0gdGhpcy5fdG9sZXJhbmNlLmJcblx0XHRcdH07XG5cblx0XHRpZiAoICFpbmZvT25seSApIHtcblx0XHRcdC8vIENsYW1wIHRoZSB3aWR0aCBvZiB0aGUgbWVudSBiZWZvcmUgZ3JhYmJpbmcgaXRzIHNpemVcblx0XHRcdHRoaXMuX3VpLmNvbnRhaW5lci5jc3MoIFwibWF4LXdpZHRoXCIsIHJlY3RhbmdsZS5jeCApO1xuXHRcdH1cblxuXHRcdG1lbnVTaXplID0ge1xuXHRcdFx0Y3g6IHRoaXMuX3VpLmNvbnRhaW5lci5vdXRlcldpZHRoKCB0cnVlICksXG5cdFx0XHRjeTogdGhpcy5fdWkuY29udGFpbmVyLm91dGVySGVpZ2h0KCB0cnVlIClcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHsgcmM6IHJlY3RhbmdsZSwgbWVudVNpemU6IG1lbnVTaXplIH07XG5cdH0sXG5cblx0X2NhbGN1bGF0ZUZpbmFsTG9jYXRpb246IGZ1bmN0aW9uKCBkZXNpcmVkLCBjbGFtcEluZm8gKSB7XG5cdFx0dmFyIHJldHVyblZhbHVlLFxuXHRcdFx0cmVjdGFuZ2xlID0gY2xhbXBJbmZvLnJjLFxuXHRcdFx0bWVudVNpemUgPSBjbGFtcEluZm8ubWVudVNpemU7XG5cblx0XHQvLyBDZW50ZXIgdGhlIG1lbnUgb3ZlciB0aGUgZGVzaXJlZCBjb29yZGluYXRlcywgd2hpbGUgbm90IGdvaW5nIG91dHNpZGVcblx0XHQvLyB0aGUgd2luZG93IHRvbGVyYW5jZXMuIFRoaXMgd2lsbCBjZW50ZXIgd3J0LiB0aGUgd2luZG93IGlmIHRoZSBwb3B1cCBpc1xuXHRcdC8vIHRvbyBsYXJnZS5cblx0XHRyZXR1cm5WYWx1ZSA9IHtcblx0XHRcdGxlZnQ6IGZpdFNlZ21lbnRJbnNpZGVTZWdtZW50KCByZWN0YW5nbGUuY3gsIG1lbnVTaXplLmN4LCByZWN0YW5nbGUueCwgZGVzaXJlZC54ICksXG5cdFx0XHR0b3A6IGZpdFNlZ21lbnRJbnNpZGVTZWdtZW50KCByZWN0YW5nbGUuY3ksIG1lbnVTaXplLmN5LCByZWN0YW5nbGUueSwgZGVzaXJlZC55IClcblx0XHR9O1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoZSB0b3Agb2YgdGhlIG1lbnUgaXMgdmlzaWJsZVxuXHRcdHJldHVyblZhbHVlLnRvcCA9IE1hdGgubWF4KCAwLCByZXR1cm5WYWx1ZS50b3AgKTtcblxuXHRcdC8vIElmIHRoZSBoZWlnaHQgb2YgdGhlIG1lbnUgaXMgc21hbGxlciB0aGFuIHRoZSBoZWlnaHQgb2YgdGhlIGRvY3VtZW50XG5cdFx0Ly8gYWxpZ24gdGhlIGJvdHRvbSB3aXRoIHRoZSBib3R0b20gb2YgdGhlIGRvY3VtZW50XG5cblx0XHRyZXR1cm5WYWx1ZS50b3AgLT0gTWF0aC5taW4oIHJldHVyblZhbHVlLnRvcCxcblx0XHRcdE1hdGgubWF4KCAwLCByZXR1cm5WYWx1ZS50b3AgKyBtZW51U2l6ZS5jeSAtIHRoaXMuZG9jdW1lbnQuaGVpZ2h0KCkgKSApO1xuXG5cdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHR9LFxuXG5cdC8vIFRyeSBhbmQgY2VudGVyIHRoZSBvdmVybGF5IG92ZXIgdGhlIGdpdmVuIGNvb3JkaW5hdGVzXG5cdF9wbGFjZW1lbnRDb29yZHM6IGZ1bmN0aW9uKCBkZXNpcmVkICkge1xuXHRcdHJldHVybiB0aGlzLl9jYWxjdWxhdGVGaW5hbExvY2F0aW9uKCBkZXNpcmVkLCB0aGlzLl9jbGFtcFBvcHVwV2lkdGgoKSApO1xuXHR9LFxuXG5cdF9jcmVhdGVQcmVyZXF1aXNpdGVzOiBmdW5jdGlvbiggc2NyZWVuUHJlcmVxdWlzaXRlLCBjb250YWluZXJQcmVyZXF1aXNpdGUsIHdoZW5Eb25lICkge1xuXHRcdHZhciBwcmVyZXF1aXNpdGVzLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHQvLyBJdCBpcyBpbXBvcnRhbnQgdG8gbWFpbnRhaW4gYm90aCB0aGUgbG9jYWwgdmFyaWFibGUgcHJlcmVxdWlzaXRlcyBhbmRcblx0XHQvLyBzZWxmLl9wcmVyZXF1aXNpdGVzLiBUaGUgbG9jYWwgdmFyaWFibGUgcmVtYWlucyBpbiB0aGUgY2xvc3VyZSBvZiB0aGVcblx0XHQvLyBmdW5jdGlvbnMgd2hpY2ggY2FsbCB0aGUgY2FsbGJhY2tzIHBhc3NlZCBpbi4gVGhlIGNvbXBhcmlzb24gYmV0d2VlbiB0aGVcblx0XHQvLyBsb2NhbCB2YXJpYWJsZSBhbmQgc2VsZi5fcHJlcmVxdWlzaXRlcyBpcyBuZWNlc3NhcnksIGJlY2F1c2Ugb25jZSBhXG5cdFx0Ly8gZnVuY3Rpb24gaGFzIGJlZW4gcGFzc2VkIHRvIC5hbmltYXRpb25Db21wbGV0ZSgpIGl0IHdpbGwgYmUgY2FsbGVkIG5leHRcblx0XHQvLyB0aW1lIGFuIGFuaW1hdGlvbiBjb21wbGV0ZXMsIGV2ZW4gaWYgdGhhdCdzIG5vdCB0aGUgYW5pbWF0aW9uIHdob3NlIGVuZFxuXHRcdC8vIHRoZSBmdW5jdGlvbiB3YXMgc3VwcG9zZWQgdG8gY2F0Y2ggKGZvciBleGFtcGxlLCBpZiBhbiBhYm9ydCBoYXBwZW5zXG5cdFx0Ly8gZHVyaW5nIHRoZSBvcGVuaW5nIGFuaW1hdGlvbiwgdGhlIC5hbmltYXRpb25Db21wbGV0ZSBoYW5kbGVyIGlzIG5vdFxuXHRcdC8vIGNhbGxlZCBmb3IgdGhhdCBhbmltYXRpb24gYW55bW9yZSwgYnV0IHRoZSBoYW5kbGVyIHJlbWFpbnMgYXR0YWNoZWQsIHNvXG5cdFx0Ly8gaXQgaXMgY2FsbGVkIHRoZSBuZXh0IHRpbWUgdGhlIHBvcHVwIGlzIG9wZW5lZCAtIG1ha2luZyBpdCBzdGFsZS5cblx0XHQvLyBDb21wYXJpbmcgdGhlIGxvY2FsIHZhcmlhYmxlIHByZXJlcXVpc2l0ZXMgdG8gdGhlIHdpZGdldC1sZXZlbCB2YXJpYWJsZVxuXHRcdC8vIHNlbGYuX3ByZXJlcXVpc2l0ZXMgZW5zdXJlcyB0aGF0IGNhbGxiYWNrcyB0cmlnZ2VyZWQgYnkgYSBzdGFsZVxuXHRcdC8vIC5hbmltYXRpb25Db21wbGV0ZSB3aWxsIGJlIGlnbm9yZWQuXG5cblx0XHRwcmVyZXF1aXNpdGVzID0ge1xuXHRcdFx0c2NyZWVuOiAkLkRlZmVycmVkKCksXG5cdFx0XHRjb250YWluZXI6ICQuRGVmZXJyZWQoKVxuXHRcdH07XG5cblx0XHRwcmVyZXF1aXNpdGVzLnNjcmVlbi50aGVuKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggcHJlcmVxdWlzaXRlcyA9PT0gc2VsZi5fcHJlcmVxdWlzaXRlcyApIHtcblx0XHRcdFx0c2NyZWVuUHJlcmVxdWlzaXRlKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRwcmVyZXF1aXNpdGVzLmNvbnRhaW5lci50aGVuKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggcHJlcmVxdWlzaXRlcyA9PT0gc2VsZi5fcHJlcmVxdWlzaXRlcyApIHtcblx0XHRcdFx0Y29udGFpbmVyUHJlcmVxdWlzaXRlKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQkLndoZW4oIHByZXJlcXVpc2l0ZXMuc2NyZWVuLCBwcmVyZXF1aXNpdGVzLmNvbnRhaW5lciApLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBwcmVyZXF1aXNpdGVzID09PSBzZWxmLl9wcmVyZXF1aXNpdGVzICkge1xuXHRcdFx0XHRzZWxmLl9wcmVyZXF1aXNpdGVzID0gbnVsbDtcblx0XHRcdFx0d2hlbkRvbmUoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHNlbGYuX3ByZXJlcXVpc2l0ZXMgPSBwcmVyZXF1aXNpdGVzO1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiggYXJncyApIHtcblx0XHQvLyBOT1RFIGJlZm9yZSByZW1vdmluZyB0aGUgZGVmYXVsdCBhbmltYXRpb24gb2YgdGhlIHNjcmVlblxuXHRcdC8vICAgICAgdGhpcyBoYWQgYW4gYW5pbWF0ZSBjYWxsYmFjayB0aGF0IHdvdWxkIHJlc29sdmUgdGhlIGRlZmVycmVkXG5cdFx0Ly8gICAgICBub3cgdGhlIGRlZmVycmVkIGlzIHJlc29sdmVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gVE9ETyByZW1vdmUgdGhlIGRlcGVuZGVuY3kgb24gdGhlIHNjcmVlbiBkZWZlcnJlZFxuXHRcdHRoaXMuX3VpLnNjcmVlblxuXHRcdFx0LnJlbW92ZUNsYXNzKCBhcmdzLmNsYXNzVG9SZW1vdmUgKVxuXHRcdFx0LmFkZENsYXNzKCBhcmdzLnNjcmVlbkNsYXNzVG9BZGQgKTtcblxuXHRcdGFyZ3MucHJlcmVxdWlzaXRlcy5zY3JlZW4ucmVzb2x2ZSgpO1xuXG5cdFx0aWYgKCBhcmdzLnRyYW5zaXRpb24gJiYgYXJncy50cmFuc2l0aW9uICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggYXJncy5hcHBseVRyYW5zaXRpb24gKSB7XG5cdFx0XHRcdHRoaXMuX2FwcGx5VHJhbnNpdGlvbiggYXJncy50cmFuc2l0aW9uICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuX2ZhbGxiYWNrVHJhbnNpdGlvbiApIHtcblx0XHRcdFx0dGhpcy5fdWkuY29udGFpbmVyXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBhcmdzLmNvbnRhaW5lckNsYXNzVG9BZGQgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggYXJncy5jbGFzc1RvUmVtb3ZlIClcblx0XHRcdFx0XHQuYW5pbWF0aW9uQ29tcGxldGUoICQucHJveHkoIGFyZ3MucHJlcmVxdWlzaXRlcy5jb250YWluZXIsIFwicmVzb2x2ZVwiICkgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl91aS5jb250YWluZXIucmVtb3ZlQ2xhc3MoIGFyZ3MuY2xhc3NUb1JlbW92ZSApO1xuXHRcdGFyZ3MucHJlcmVxdWlzaXRlcy5jb250YWluZXIucmVzb2x2ZSgpO1xuXHR9LFxuXG5cdC8vIFRoZSBkZXNpcmVkIGNvb3JkaW5hdGVzIHBhc3NlZCBpbiB3aWxsIGJlIHJldHVybmVkIHVudG91Y2hlZCBpZiBubyByZWZlcmVuY2UgZWxlbWVudCBjYW4gYmUgaWRlbnRpZmllZCB2aWFcblx0Ly8gZGVzaXJlZFBvc2l0aW9uLnBvc2l0aW9uVG8uIE5ldmVydGhlbGVzcywgdGhpcyBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgaXRzIHJldHVybiB2YWx1ZSBhbHdheXMgY29udGFpbnMgdmFsaWRcblx0Ly8geCBhbmQgeSBjb29yZGluYXRlcyBieSBzcGVjaWZ5aW5nIHRoZSBjZW50ZXIgbWlkZGxlIG9mIHRoZSB3aW5kb3cgaWYgdGhlIGNvb3JkaW5hdGVzIGFyZSBhYnNlbnQuXG5cdC8vIG9wdGlvbnM6IHsgeDogY29vcmRpbmF0ZSwgeTogY29vcmRpbmF0ZSwgcG9zaXRpb25Ubzogc3RyaW5nOiBcIm9yaWdpblwiLCBcIndpbmRvd1wiLCBvciBqUXVlcnkgc2VsZWN0b3Jcblx0X2Rlc2lyZWRDb29yZHM6IGZ1bmN0aW9uKCBvcGVuT3B0aW9ucyApIHtcblx0XHR2YXIgb2Zmc2V0LFxuXHRcdFx0ZHN0ID0gbnVsbCxcblx0XHRcdHdpbmRvd0Nvb3JkaW5hdGVzID0gZ2V0V2luZG93Q29vcmRpbmF0ZXMoIHRoaXMud2luZG93ICksXG5cdFx0XHR4ID0gb3Blbk9wdGlvbnMueCxcblx0XHRcdHkgPSBvcGVuT3B0aW9ucy55LFxuXHRcdFx0cFRvID0gb3Blbk9wdGlvbnMucG9zaXRpb25UbztcblxuXHRcdC8vIEVzdGFibGlzaCB3aGljaCBlbGVtZW50IHdpbGwgc2VydmUgYXMgdGhlIHJlZmVyZW5jZVxuXHRcdGlmICggcFRvICYmIHBUbyAhPT0gXCJvcmlnaW5cIiApIHtcblx0XHRcdGlmICggcFRvID09PSBcIndpbmRvd1wiICkge1xuXHRcdFx0XHR4ID0gd2luZG93Q29vcmRpbmF0ZXMuY3ggLyAyICsgd2luZG93Q29vcmRpbmF0ZXMueDtcblx0XHRcdFx0eSA9IHdpbmRvd0Nvb3JkaW5hdGVzLmN5IC8gMiArIHdpbmRvd0Nvb3JkaW5hdGVzLnk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGRzdCA9ICQoIHBUbyApO1xuXHRcdFx0XHR9IGNhdGNoKCBlcnIgKSB7XG5cdFx0XHRcdFx0ZHN0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGRzdCApIHtcblx0XHRcdFx0XHRkc3QuZmlsdGVyKCBcIjp2aXNpYmxlXCIgKTtcblx0XHRcdFx0XHRpZiAoIGRzdC5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRkc3QgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIGFuIGVsZW1lbnQgd2FzIGZvdW5kLCBjZW50ZXIgb3ZlciBpdFxuXHRcdGlmICggZHN0ICkge1xuXHRcdFx0b2Zmc2V0ID0gZHN0Lm9mZnNldCgpO1xuXHRcdFx0eCA9IG9mZnNldC5sZWZ0ICsgZHN0Lm91dGVyV2lkdGgoKSAvIDI7XG5cdFx0XHR5ID0gb2Zmc2V0LnRvcCArIGRzdC5vdXRlckhlaWdodCgpIC8gMjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgeCBhbmQgeSBhcmUgdmFsaWQgbnVtYmVycyAtIGNlbnRlciBvdmVyIHRoZSB3aW5kb3dcblx0XHRpZiAoICQudHlwZSggeCApICE9PSBcIm51bWJlclwiIHx8IGlzTmFOKCB4ICkgKSB7XG5cdFx0XHR4ID0gd2luZG93Q29vcmRpbmF0ZXMuY3ggLyAyICsgd2luZG93Q29vcmRpbmF0ZXMueDtcblx0XHR9XG5cdFx0aWYgKCAkLnR5cGUoIHkgKSAhPT0gXCJudW1iZXJcIiB8fCBpc05hTiggeSApICkge1xuXHRcdFx0eSA9IHdpbmRvd0Nvb3JkaW5hdGVzLmN5IC8gMiArIHdpbmRvd0Nvb3JkaW5hdGVzLnk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgeDogeCwgeTogeSB9O1xuXHR9LFxuXG5cdF9yZXBvc2l0aW9uOiBmdW5jdGlvbiggb3Blbk9wdGlvbnMgKSB7XG5cdFx0Ly8gV2Ugb25seSBjYXJlIGFib3V0IHBvc2l0aW9uLXJlbGF0ZWQgcGFyYW1ldGVycyBmb3IgcmVwb3NpdGlvbmluZ1xuXHRcdG9wZW5PcHRpb25zID0ge1xuXHRcdFx0eDogb3Blbk9wdGlvbnMueCxcblx0XHRcdHk6IG9wZW5PcHRpb25zLnksXG5cdFx0XHRwb3NpdGlvblRvOiBvcGVuT3B0aW9ucy5wb3NpdGlvblRvXG5cdFx0fTtcblx0XHR0aGlzLl90cmlnZ2VyKCBcImJlZm9yZXBvc2l0aW9uXCIsIHVuZGVmaW5lZCwgb3Blbk9wdGlvbnMgKTtcblx0XHR0aGlzLl91aS5jb250YWluZXIub2Zmc2V0KCB0aGlzLl9wbGFjZW1lbnRDb29yZHMoIHRoaXMuX2Rlc2lyZWRDb29yZHMoIG9wZW5PcHRpb25zICkgKSApO1xuXHR9LFxuXG5cdHJlcG9zaXRpb246IGZ1bmN0aW9uKCBvcGVuT3B0aW9ucyApIHtcblx0XHRpZiAoIHRoaXMuX2lzT3BlbiApIHtcblx0XHRcdHRoaXMuX3JlcG9zaXRpb24oIG9wZW5PcHRpb25zICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vcGVuUHJlcmVxdWlzaXRlc0NvbXBsZXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWQgPSB0aGlzLmVsZW1lbnQuYXR0ciggXCJpZFwiICk7XG5cblx0XHR0aGlzLl91aS5jb250YWluZXIuYWRkQ2xhc3MoIFwidWktcG9wdXAtYWN0aXZlXCIgKTtcblx0XHR0aGlzLl9pc09wZW4gPSB0cnVlO1xuXHRcdHRoaXMuX3Jlc2l6ZVNjcmVlbigpO1xuXHRcdHRoaXMuX3VpLmNvbnRhaW5lci5hdHRyKCBcInRhYmluZGV4XCIsIFwiMFwiICkuZm9jdXMoKTtcblx0XHR0aGlzLl9pZ25vcmVSZXNpemVFdmVudHMoKTtcblx0XHRpZiAoIGlkICkge1xuXHRcdFx0dGhpcy5kb2N1bWVudC5maW5kKCBcIlthcmlhLWhhc3BvcHVwPSd0cnVlJ11bYXJpYS1vd25zPSdcIiArICBpZCArIFwiJ11cIiApLmF0dHIoIFwiYXJpYS1leHBhbmRlZFwiLCB0cnVlICk7XG5cdFx0fVxuXHRcdHRoaXMuX3RyaWdnZXIoIFwiYWZ0ZXJvcGVuXCIgKTtcblx0fSxcblxuXHRfb3BlbjogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIG9wZW5PcHRpb25zID0gJC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMgKSxcblx0XHRcdC8vIFRPRE8gbW92ZSBibGFja2xpc3QgdG8gcHJpdmF0ZSBtZXRob2Rcblx0XHRcdGFuZHJvaWRCbGFja2xpc3QgPSAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuXHRcdFx0XHRcdC8vIFJlbmRlcmluZyBlbmdpbmUgaXMgV2Via2l0LCBhbmQgY2FwdHVyZSBtYWpvciB2ZXJzaW9uXG5cdFx0XHRcdFx0d2ttYXRjaCA9IHVhLm1hdGNoKCAvQXBwbGVXZWJLaXRcXC8oWzAtOVxcLl0rKS8gKSxcblx0XHRcdFx0XHR3a3ZlcnNpb24gPSAhIXdrbWF0Y2ggJiYgd2ttYXRjaFsgMSBdLFxuXHRcdFx0XHRcdGFuZHJvaWRtYXRjaCA9IHVhLm1hdGNoKCAvQW5kcm9pZCAoXFxkKyg/OlxcLlxcZCspKS8gKSxcblx0XHRcdFx0XHRhbmR2ZXJzaW9uID0gISFhbmRyb2lkbWF0Y2ggJiYgYW5kcm9pZG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0Y2hyb21lbWF0Y2ggPSB1YS5pbmRleE9mKCBcIkNocm9tZVwiICkgPiAtMTtcblxuXHRcdFx0XHQvLyBQbGF0Zm9ybSBpcyBBbmRyb2lkLCBXZWJLaXQgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gNTM0LjEzICggQW5kcm9pZCAzLjIuMSApIGFuZCBub3QgQ2hyb21lLlxuXHRcdFx0XHRpZiAoIGFuZHJvaWRtYXRjaCAhPT0gbnVsbCAmJiBhbmR2ZXJzaW9uID09PSBcIjQuMFwiICYmIHdrdmVyc2lvbiAmJiB3a3ZlcnNpb24gPiA1MzQuMTMgJiYgIWNocm9tZW1hdGNoICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0oKSk7XG5cblx0XHQvLyBDb3VudCBkb3duIHRvIHRyaWdnZXJpbmcgXCJwb3B1cGFmdGVyb3BlblwiIC0gd2UgaGF2ZSB0d28gcHJlcmVxdWlzaXRlczpcblx0XHQvLyAxLiBUaGUgcG9wdXAgd2luZG93IGFuaW1hdGlvbiBjb21wbGV0ZXMgKGNvbnRhaW5lcigpKVxuXHRcdC8vIDIuIFRoZSBzY3JlZW4gb3BhY2l0eSBhbmltYXRpb24gY29tcGxldGVzIChzY3JlZW4oKSlcblx0XHR0aGlzLl9jcmVhdGVQcmVyZXF1aXNpdGVzKFxuXHRcdFx0JC5ub29wLFxuXHRcdFx0JC5ub29wLFxuXHRcdFx0JC5wcm94eSggdGhpcywgXCJfb3BlblByZXJlcXVpc2l0ZXNDb21wbGV0ZVwiICkgKTtcblxuXHRcdHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uID0gb3Blbk9wdGlvbnMudHJhbnNpdGlvbjtcblx0XHR0aGlzLl9hcHBseVRyYW5zaXRpb24oIG9wZW5PcHRpb25zLnRyYW5zaXRpb24gKTtcblxuXHRcdHRoaXMuX3VpLnNjcmVlbi5yZW1vdmVDbGFzcyggXCJ1aS1zY3JlZW4taGlkZGVuXCIgKTtcblx0XHR0aGlzLl91aS5jb250YWluZXIucmVtb3ZlQ2xhc3MoIFwidWktcG9wdXAtdHJ1bmNhdGVcIiApO1xuXG5cdFx0Ly8gR2l2ZSBhcHBsaWNhdGlvbnMgYSBjaGFuY2UgdG8gbW9kaWZ5IHRoZSBjb250ZW50cyBvZiB0aGUgY29udGFpbmVyIGJlZm9yZSBpdCBhcHBlYXJzXG5cdFx0dGhpcy5fcmVwb3NpdGlvbiggb3Blbk9wdGlvbnMgKTtcblxuXHRcdHRoaXMuX3VpLmNvbnRhaW5lci5yZW1vdmVDbGFzcyggXCJ1aS1wb3B1cC1oaWRkZW5cIiApO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMub3ZlcmxheVRoZW1lICYmIGFuZHJvaWRCbGFja2xpc3QgKSB7XG5cdFx0XHQvKiBUT0RPOiBUaGUgbmF0aXZlIGJyb3dzZXIgb24gQW5kcm9pZCA0LjAuWCAoXCJJY2UgQ3JlYW0gU2FuZHdpY2hcIikgc3VmZmVycyBmcm9tIGFuIGlzc3VlIHdoZXJlIHRoZSBwb3B1cCBvdmVybGF5IGFwcGVhcnMgdG8gYmUgei1pbmRleGVkIGFib3ZlIHRoZSBwb3B1cCBpdHNlbGYgd2hlbiBjZXJ0YWluIG90aGVyIHN0eWxlcyBleGlzdCBvbiB0aGUgc2FtZSBwYWdlIC0tIG5hbWVseSwgYW55IGVsZW1lbnQgc2V0IHRvIGBwb3NpdGlvbjogZml4ZWRgIGFuZCBjZXJ0YWluIHR5cGVzIG9mIGlucHV0LiBUaGVzZSBpc3N1ZXMgYXJlIHJlbWluaXNjZW50IG9mIHByZXZpb3VzbHkgdW5jb3ZlcmVkIGJ1Z3MgaW4gb2xkZXIgdmVyc2lvbnMgb2YgQW5kcm9pZCdzIG5hdGl2ZSBicm93c2VyOiBodHRwczovL2dpdGh1Yi5jb20vc2NvdHRqZWhsL0RldmljZS1CdWdzL2lzc3Vlcy8zXG5cdFx0XHRUaGlzIGZpeCBjbG9zZXMgdGhlIGZvbGxvd2luZyBidWdzICggSSB1c2UgXCJjbG9zZXNcIiB3aXRoIHJlbHVjdGFuY2UsIGFuZCBzdHJlc3MgdGhhdCB0aGlzIGlzc3VlIHNob3VsZCBiZSByZXZpc2l0ZWQgYXMgc29vbiBhcyBwb3NzaWJsZSApOlxuXHRcdFx0aHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktbW9iaWxlL2lzc3Vlcy80ODE2XG5cdFx0XHRodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS1tb2JpbGUvaXNzdWVzLzQ4NDRcblx0XHRcdGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5LW1vYmlsZS9pc3N1ZXMvNDg3NFxuXHRcdFx0Ki9cblxuXHRcdFx0Ly8gVE9ETyBzb3J0IG91dCB3aHkgdGhpcy5fcGFnZSBpc24ndCB3b3JraW5nXG5cdFx0XHR0aGlzLmVsZW1lbnQuY2xvc2VzdCggXCIudWktcGFnZVwiICkuYWRkQ2xhc3MoIFwidWktcG9wdXAtb3BlblwiICk7XG5cdFx0fVxuXHRcdHRoaXMuX2FuaW1hdGUoe1xuXHRcdFx0YWRkaXRpb25hbENvbmRpdGlvbjogdHJ1ZSxcblx0XHRcdHRyYW5zaXRpb246IG9wZW5PcHRpb25zLnRyYW5zaXRpb24sXG5cdFx0XHRjbGFzc1RvUmVtb3ZlOiBcIlwiLFxuXHRcdFx0c2NyZWVuQ2xhc3NUb0FkZDogXCJpblwiLFxuXHRcdFx0Y29udGFpbmVyQ2xhc3NUb0FkZDogXCJpblwiLFxuXHRcdFx0YXBwbHlUcmFuc2l0aW9uOiBmYWxzZSxcblx0XHRcdHByZXJlcXVpc2l0ZXM6IHRoaXMuX3ByZXJlcXVpc2l0ZXNcblx0XHR9KTtcblx0fSxcblxuXHRfY2xvc2VQcmVyZXF1aXNpdGVTY3JlZW46IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3VpLnNjcmVlblxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcIm91dFwiIClcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1zY3JlZW4taGlkZGVuXCIgKTtcblx0fSxcblxuXHRfY2xvc2VQcmVyZXF1aXNpdGVDb250YWluZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3VpLmNvbnRhaW5lclxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInJldmVyc2Ugb3V0XCIgKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLXBvcHVwLWhpZGRlbiB1aS1wb3B1cC10cnVuY2F0ZVwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcInN0eWxlXCIgKTtcblx0fSxcblxuXHRfY2xvc2VQcmVyZXF1aXNpdGVzRG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX3VpLmNvbnRhaW5lcixcblx0XHRcdGlkID0gdGhpcy5lbGVtZW50LmF0dHIoIFwiaWRcIiApO1xuXG5cdFx0Y29udGFpbmVyLnJlbW92ZUF0dHIoIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0Ly8gcmVtb3ZlIHRoZSBnbG9iYWwgbXV0ZXggZm9yIHBvcHVwc1xuXHRcdCQubW9iaWxlLnBvcHVwLmFjdGl2ZSA9IHVuZGVmaW5lZDtcblxuXHRcdC8vIEJsdXIgZWxlbWVudHMgaW5zaWRlIHRoZSBjb250YWluZXIsIGluY2x1ZGluZyB0aGUgY29udGFpbmVyXG5cdFx0JCggXCI6Zm9jdXNcIiwgY29udGFpbmVyWyAwIF0gKS5hZGQoIGNvbnRhaW5lclsgMCBdICkuYmx1cigpO1xuXG5cdFx0aWYgKCBpZCApIHtcblx0XHRcdHRoaXMuZG9jdW1lbnQuZmluZCggXCJbYXJpYS1oYXNwb3B1cD0ndHJ1ZSddW2FyaWEtb3ducz0nXCIgKyAgaWQgKyBcIiddXCIgKS5hdHRyKCBcImFyaWEtZXhwYW5kZWRcIiwgZmFsc2UgKTtcblx0XHR9XG5cblx0XHQvLyBhbGVydCB1c2VycyB0aGF0IHRoZSBwb3B1cCBpcyBjbG9zZWRcblx0XHR0aGlzLl90cmlnZ2VyKCBcImFmdGVyY2xvc2VcIiApO1xuXHR9LFxuXG5cdF9jbG9zZTogZnVuY3Rpb24oIGltbWVkaWF0ZSApIHtcblx0XHR0aGlzLl91aS5jb250YWluZXIucmVtb3ZlQ2xhc3MoIFwidWktcG9wdXAtYWN0aXZlXCIgKTtcblx0XHR0aGlzLl9wYWdlLnJlbW92ZUNsYXNzKCBcInVpLXBvcHVwLW9wZW5cIiApO1xuXG5cdFx0dGhpcy5faXNPcGVuID0gZmFsc2U7XG5cblx0XHQvLyBDb3VudCBkb3duIHRvIHRyaWdnZXJpbmcgXCJwb3B1cGFmdGVyY2xvc2VcIiAtIHdlIGhhdmUgdHdvIHByZXJlcXVpc2l0ZXM6XG5cdFx0Ly8gMS4gVGhlIHBvcHVwIHdpbmRvdyByZXZlcnNlIGFuaW1hdGlvbiBjb21wbGV0ZXMgKGNvbnRhaW5lcigpKVxuXHRcdC8vIDIuIFRoZSBzY3JlZW4gb3BhY2l0eSBhbmltYXRpb24gY29tcGxldGVzIChzY3JlZW4oKSlcblx0XHR0aGlzLl9jcmVhdGVQcmVyZXF1aXNpdGVzKFxuXHRcdFx0JC5wcm94eSggdGhpcywgXCJfY2xvc2VQcmVyZXF1aXNpdGVTY3JlZW5cIiApLFxuXHRcdFx0JC5wcm94eSggdGhpcywgXCJfY2xvc2VQcmVyZXF1aXNpdGVDb250YWluZXJcIiApLFxuXHRcdFx0JC5wcm94eSggdGhpcywgXCJfY2xvc2VQcmVyZXF1aXNpdGVzRG9uZVwiICkgKTtcblxuXHRcdHRoaXMuX2FuaW1hdGUoIHtcblx0XHRcdGFkZGl0aW9uYWxDb25kaXRpb246IHRoaXMuX3VpLnNjcmVlbi5oYXNDbGFzcyggXCJpblwiICksXG5cdFx0XHR0cmFuc2l0aW9uOiAoIGltbWVkaWF0ZSA/IFwibm9uZVwiIDogKCB0aGlzLl9jdXJyZW50VHJhbnNpdGlvbiApICksXG5cdFx0XHRjbGFzc1RvUmVtb3ZlOiBcImluXCIsXG5cdFx0XHRzY3JlZW5DbGFzc1RvQWRkOiBcIm91dFwiLFxuXHRcdFx0Y29udGFpbmVyQ2xhc3NUb0FkZDogXCJyZXZlcnNlIG91dFwiLFxuXHRcdFx0YXBwbHlUcmFuc2l0aW9uOiB0cnVlLFxuXHRcdFx0cHJlcmVxdWlzaXRlczogdGhpcy5fcHJlcmVxdWlzaXRlc1xuXHRcdH0pO1xuXHR9LFxuXG5cdF91bmVuaGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmVuaGFuY2VkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFB1dCB0aGUgZWxlbWVudCBiYWNrIHRvIHdoZXJlIHRoZSBwbGFjZWhvbGRlciB3YXMgYW5kIHJlbW92ZSB0aGUgXCJ1aS1wb3B1cFwiIGNsYXNzXG5cdFx0dGhpcy5fc2V0T3B0aW9ucyggeyB0aGVtZTogJC5tb2JpbGUucG9wdXAucHJvdG90eXBlLm9wdGlvbnMudGhlbWUgfSApO1xuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0Ly8gQ2Fubm90IGRpcmVjdGx5IGluc2VydEFmdGVyKCkgLSB3ZSBuZWVkIHRvIGRldGFjaCgpIGZpcnN0LCBiZWNhdXNlXG5cdFx0XHQvLyBpbnNlcnRBZnRlcigpIHdpbGwgZG8gbm90aGluZyBpZiB0aGUgcGF5bG9hZCBkaXYgd2FzIG5vdCBhdHRhY2hlZFxuXHRcdFx0Ly8gdG8gdGhlIERPTSBhdCB0aGUgdGltZSB0aGUgd2lkZ2V0IHdhcyBjcmVhdGVkLCBhbmQgc28gdGhlIHBheWxvYWRcblx0XHRcdC8vIHdpbGwgcmVtYWluIGluc2lkZSB0aGUgY29udGFpbmVyIGV2ZW4gYWZ0ZXIgd2UgY2FsbCBpbnNlcnRBZnRlcigpLlxuXHRcdFx0Ly8gSWYgdGhhdCBoYXBwZW5zIGFuZCB3ZSByZW1vdmUgdGhlIGNvbnRhaW5lciBhIGZldyBsaW5lcyBiZWxvdywgd2Vcblx0XHRcdC8vIHdpbGwgY2F1c2UgYW4gaW5maW5pdGUgcmVjdXJzaW9uIC0gIzUyNDRcblx0XHRcdC5kZXRhY2goKVxuXHRcdFx0Lmluc2VydEFmdGVyKCB0aGlzLl91aS5wbGFjZWhvbGRlciApXG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktcG9wdXAgdWktb3ZlcmxheS1zaGFkb3cgdWktY29ybmVyLWFsbCB1aS1ib2R5LWluaGVyaXRcIiApO1xuXHRcdHRoaXMuX3VpLnNjcmVlbi5yZW1vdmUoKTtcblx0XHR0aGlzLl91aS5jb250YWluZXIucmVtb3ZlKCk7XG5cdFx0dGhpcy5fdWkucGxhY2Vob2xkZXIucmVtb3ZlKCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggJC5tb2JpbGUucG9wdXAuYWN0aXZlID09PSB0aGlzICkge1xuXHRcdFx0dGhpcy5lbGVtZW50Lm9uZSggXCJwb3B1cGFmdGVyY2xvc2VcIiwgJC5wcm94eSggdGhpcywgXCJfdW5lbmhhbmNlXCIgKSApO1xuXHRcdFx0dGhpcy5jbG9zZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl91bmVuaGFuY2UoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfY2xvc2VQb3B1cDogZnVuY3Rpb24oIHRoZUV2ZW50LCBkYXRhICkge1xuXHRcdHZhciBwYXJzZWREc3QsIHRvVXJsLFxuXHRcdFx0Y3VycmVudE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRpbW1lZGlhdGUgPSBmYWxzZTtcblxuXHRcdGlmICggKCB0aGVFdmVudCAmJiB0aGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHx8ICQubW9iaWxlLnBvcHVwLmFjdGl2ZSAhPT0gdGhpcyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyByZXN0b3JlIGxvY2F0aW9uIG9uIHNjcmVlblxuXHRcdHdpbmRvdy5zY3JvbGxUbyggMCwgdGhpcy5fc2Nyb2xsVG9wICk7XG5cblx0XHRpZiAoIHRoZUV2ZW50ICYmIHRoZUV2ZW50LnR5cGUgPT09IFwicGFnZWJlZm9yZWNoYW5nZVwiICYmIGRhdGEgKSB7XG5cdFx0XHQvLyBEZXRlcm1pbmUgd2hldGhlciB3ZSBuZWVkIHRvIHJhcGlkLWNsb3NlIHRoZSBwb3B1cCwgb3Igd2hldGhlciB3ZSBjYW5cblx0XHRcdC8vIHRha2UgdGhlIHRpbWUgdG8gcnVuIHRoZSBjbG9zaW5nIHRyYW5zaXRpb25cblx0XHRcdGlmICggdHlwZW9mIGRhdGEudG9QYWdlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRwYXJzZWREc3QgPSBkYXRhLnRvUGFnZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhcnNlZERzdCA9IGRhdGEudG9QYWdlLmpxbURhdGEoIFwidXJsXCIgKTtcblx0XHRcdH1cblx0XHRcdHBhcnNlZERzdCA9ICQubW9iaWxlLnBhdGgucGFyc2VVcmwoIHBhcnNlZERzdCApO1xuXHRcdFx0dG9VcmwgPSBwYXJzZWREc3QucGF0aG5hbWUgKyBwYXJzZWREc3Quc2VhcmNoICsgcGFyc2VkRHN0Lmhhc2g7XG5cblx0XHRcdGlmICggdGhpcy5fbXlVcmwgIT09ICQubW9iaWxlLnBhdGgubWFrZVVybEFic29sdXRlKCB0b1VybCApICkge1xuXHRcdFx0XHQvLyBHb2luZyB0byBhIGRpZmZlcmVudCBwYWdlIC0gY2xvc2UgaW1tZWRpYXRlbHlcblx0XHRcdFx0aW1tZWRpYXRlID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcmVtb3ZlIG5hdiBiaW5kaW5nc1xuXHRcdHRoaXMud2luZG93Lm9mZiggY3VycmVudE9wdGlvbnMuY2xvc2VFdmVudHMgKTtcblx0XHQvLyB1bmJpbmQgY2xpY2sgaGFuZGxlcnMgYWRkZWQgd2hlbiBoaXN0b3J5IGlzIGRpc2FibGVkXG5cdFx0dGhpcy5lbGVtZW50LnVuZGVsZWdhdGUoIGN1cnJlbnRPcHRpb25zLmNsb3NlTGlua1NlbGVjdG9yLCBjdXJyZW50T3B0aW9ucy5jbG9zZUxpbmtFdmVudHMgKTtcblxuXHRcdHRoaXMuX2Nsb3NlKCBpbW1lZGlhdGUgKTtcblx0fSxcblxuXHQvLyBhbnkgbmF2aWdhdGlvbiBldmVudCBhZnRlciBhIHBvcHVwIGlzIG9wZW5lZCBzaG91bGQgY2xvc2UgdGhlIHBvcHVwXG5cdC8vIE5PVEUgdGhlIHBhZ2ViZWZvcmVjaGFuZ2UgaXMgYm91bmQgdG8gY2F0Y2ggbmF2aWdhdGlvbiBldmVudHMgdGhhdCBkb24ndFxuXHQvLyAgICAgIGFsdGVyIHRoZSB1cmwgKGVnLCBkaWFsb2dzIGZyb20gcG9wdXBzKVxuXHRfYmluZENvbnRhaW5lckNsb3NlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLndpbmRvd1xuXHRcdFx0Lm9uKCB0aGlzLm9wdGlvbnMuY2xvc2VFdmVudHMsICQucHJveHkoIHRoaXMsIFwiX2Nsb3NlUG9wdXBcIiApICk7XG5cdH0sXG5cblx0d2lkZ2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdWkuY29udGFpbmVyO1xuXHR9LFxuXG5cdC8vIFRPRE8gbm8gY2xlYXIgZGVsaW5pYXRpb24gb2Ygd2hhdCBzaG91bGQgYmUgaGVyZSBhbmRcblx0Ly8gd2hhdCBzaG91bGQgYmUgaW4gX29wZW4uIFNlZW1zIHRvIGJlIFwidmlzdWFsXCIgdnMgXCJoaXN0b3J5XCIgZm9yIG5vd1xuXHRvcGVuOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIgdXJsLCBoYXNoa2V5LCBhY3RpdmVQYWdlLCBjdXJyZW50SXNEaWFsb2csIGhhc0hhc2gsIHVybEhpc3RvcnksXG5cdFx0XHRzZWxmID0gdGhpcyxcblx0XHRcdGN1cnJlbnRPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0Ly8gbWFrZSBzdXJlIG9wZW4gaXMgaWRlbXBvdGVudFxuXHRcdGlmICggJC5tb2JpbGUucG9wdXAuYWN0aXZlIHx8IGN1cnJlbnRPcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gc2V0IHRoZSBnbG9iYWwgcG9wdXAgbXV0ZXhcblx0XHQkLm1vYmlsZS5wb3B1cC5hY3RpdmUgPSB0aGlzO1xuXHRcdHRoaXMuX3Njcm9sbFRvcCA9IHRoaXMud2luZG93LnNjcm9sbFRvcCgpO1xuXG5cdFx0Ly8gaWYgaGlzdG9yeSBhbHRlcmF0aW9uIGlzIGRpc2FibGVkIGNsb3NlIG9uIG5hdmlnYXRlIGV2ZW50c1xuXHRcdC8vIGFuZCBsZWF2ZSB0aGUgdXJsIGFzIGlzXG5cdFx0aWYgKCAhKCBjdXJyZW50T3B0aW9ucy5oaXN0b3J5ICkgKSB7XG5cdFx0XHRzZWxmLl9vcGVuKCBvcHRpb25zICk7XG5cdFx0XHRzZWxmLl9iaW5kQ29udGFpbmVyQ2xvc2UoKTtcblxuXHRcdFx0Ly8gV2hlbiBoaXN0b3kgaXMgZGlzYWJsZWQgd2UgaGF2ZSB0byBncmFiIHRoZSBkYXRhLXJlbFxuXHRcdFx0Ly8gYmFjayBsaW5rIGNsaWNrcyBzbyB3ZSBjYW4gY2xvc2UgdGhlIHBvcHVwIGluc3RlYWQgb2Zcblx0XHRcdC8vIHJlbHlpbmcgb24gaGlzdG9yeSB0byBkbyBpdCBmb3IgdXNcblx0XHRcdHNlbGYuZWxlbWVudFxuXHRcdFx0XHQuZGVsZWdhdGUoIGN1cnJlbnRPcHRpb25zLmNsb3NlTGlua1NlbGVjdG9yLCBjdXJyZW50T3B0aW9ucy5jbG9zZUxpbmtFdmVudHMsIGZ1bmN0aW9uKCB0aGVFdmVudCApIHtcblx0XHRcdFx0XHRzZWxmLmNsb3NlKCk7XG5cdFx0XHRcdFx0dGhlRXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIGNhY2hlIHNvbWUgdmFsdWVzIGZvciBtaW4vcmVhZGFiaWxpdHlcblx0XHR1cmxIaXN0b3J5ID0gJC5tb2JpbGUubmF2aWdhdGUuaGlzdG9yeTtcblx0XHRoYXNoa2V5ID0gJC5tb2JpbGUuZGlhbG9nSGFzaEtleTtcblx0XHRhY3RpdmVQYWdlID0gJC5tb2JpbGUuYWN0aXZlUGFnZTtcblx0XHRjdXJyZW50SXNEaWFsb2cgPSAoIGFjdGl2ZVBhZ2UgPyBhY3RpdmVQYWdlLmhhc0NsYXNzKCBcInVpLWRpYWxvZ1wiICkgOiBmYWxzZSApO1xuXHRcdHRoaXMuX215VXJsID0gdXJsID0gdXJsSGlzdG9yeS5nZXRBY3RpdmUoKS51cmw7XG5cdFx0aGFzSGFzaCA9ICggdXJsLmluZGV4T2YoIGhhc2hrZXkgKSA+IC0xICkgJiYgIWN1cnJlbnRJc0RpYWxvZyAmJiAoIHVybEhpc3RvcnkuYWN0aXZlSW5kZXggPiAwICk7XG5cblx0XHRpZiAoIGhhc0hhc2ggKSB7XG5cdFx0XHRzZWxmLl9vcGVuKCBvcHRpb25zICk7XG5cdFx0XHRzZWxmLl9iaW5kQ29udGFpbmVyQ2xvc2UoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIGlmIHRoZSBjdXJyZW50IHVybCBoYXMgbm8gZGlhbG9nIGhhc2gga2V5IHByb2NlZWQgYXMgbm9ybWFsXG5cdFx0Ly8gb3RoZXJ3aXNlLCBpZiB0aGUgcGFnZSBpcyBhIGRpYWxvZyBzaW1wbHkgdGFjayBvbiB0aGUgaGFzaCBrZXlcblx0XHRpZiAoIHVybC5pbmRleE9mKCBoYXNoa2V5ICkgPT09IC0xICYmICFjdXJyZW50SXNEaWFsb2cgKSB7XG5cdFx0XHR1cmwgPSB1cmwgKyAodXJsLmluZGV4T2YoIFwiI1wiICkgPiAtMSA/IGhhc2hrZXkgOiBcIiNcIiArIGhhc2hrZXkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR1cmwgPSAkLm1vYmlsZS5wYXRoLnBhcnNlTG9jYXRpb24oKS5oYXNoICsgaGFzaGtleTtcblx0XHR9XG5cblx0XHQvLyBUYWNrIG9uIGFuIGV4dHJhIGhhc2hrZXkgaWYgdGhpcyBpcyB0aGUgZmlyc3QgcGFnZSBhbmQgd2UndmUganVzdCByZWNvbnN0cnVjdGVkIHRoZSBpbml0aWFsIGhhc2hcblx0XHRpZiAoIHVybEhpc3RvcnkuYWN0aXZlSW5kZXggPT09IDAgJiYgdXJsID09PSB1cmxIaXN0b3J5LmluaXRpYWxEc3QgKSB7XG5cdFx0XHR1cmwgKz0gaGFzaGtleTtcblx0XHR9XG5cblx0XHQvLyBzd2FsbG93IHRoZSB0aGUgaW5pdGlhbCBuYXZpZ2F0aW9uIGV2ZW50LCBhbmQgYmluZCBmb3IgdGhlIG5leHRcblx0XHR0aGlzLndpbmRvdy5vbmUoIFwiYmVmb3JlbmF2aWdhdGVcIiwgZnVuY3Rpb24oIHRoZUV2ZW50ICkge1xuXHRcdFx0dGhlRXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHNlbGYuX29wZW4oIG9wdGlvbnMgKTtcblx0XHRcdHNlbGYuX2JpbmRDb250YWluZXJDbG9zZSgpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy51cmxBbHRlcmVkID0gdHJ1ZTtcblx0XHQkLm1vYmlsZS5uYXZpZ2F0ZSggdXJsLCB7IHJvbGU6IFwiZGlhbG9nXCIgfSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIG1ha2Ugc3VyZSBjbG9zZSBpcyBpZGVtcG90ZW50XG5cdFx0aWYgKCAkLm1vYmlsZS5wb3B1cC5hY3RpdmUgIT09IHRoaXMgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0aGlzLl9zY3JvbGxUb3AgPSB0aGlzLndpbmRvdy5zY3JvbGxUb3AoKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmhpc3RvcnkgJiYgdGhpcy51cmxBbHRlcmVkICkge1xuXHRcdFx0JC5tb2JpbGUuYmFjaygpO1xuXHRcdFx0dGhpcy51cmxBbHRlcmVkID0gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHNpbXVsYXRlIHRoZSBuYXYgYmluZGluZ3MgaGF2aW5nIGZpcmVkXG5cdFx0XHR0aGlzLl9jbG9zZVBvcHVwKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG4vLyBUT0RPIHRoaXMgY2FuIGJlIG1vdmVkIGluc2lkZSB0aGUgd2lkZ2V0XG4kLm1vYmlsZS5wb3B1cC5oYW5kbGVMaW5rID0gZnVuY3Rpb24oICRsaW5rICkge1xuXHR2YXIgb2Zmc2V0LFxuXHRcdHBhdGggPSAkLm1vYmlsZS5wYXRoLFxuXG5cdFx0Ly8gTk9URSBtYWtlIHN1cmUgdG8gZ2V0IG9ubHkgdGhlIGhhc2ggZnJvbSB0aGUgaHJlZiBiZWNhdXNlIGllNyAod3A3KVxuXHRcdC8vICAgICAgcmV0dXJucyB0aGUgYWJzb2x1dGUgaHJlZiBpbiB0aGlzIGNhc2UgcnVpbmluZyB0aGUgZWxlbWVudCBzZWxlY3Rpb25cblx0XHRwb3B1cCA9ICQoIHBhdGguaGFzaFRvU2VsZWN0b3IoIHBhdGgucGFyc2VVcmwoICRsaW5rLmF0dHIoIFwiaHJlZlwiICkgKS5oYXNoICkgKS5maXJzdCgpO1xuXG5cdGlmICggcG9wdXAubGVuZ3RoID4gMCAmJiBwb3B1cC5kYXRhKCBcIm1vYmlsZS1wb3B1cFwiICkgKSB7XG5cdFx0b2Zmc2V0ID0gJGxpbmsub2Zmc2V0KCk7XG5cdFx0cG9wdXAucG9wdXAoIFwib3BlblwiLCB7XG5cdFx0XHR4OiBvZmZzZXQubGVmdCArICRsaW5rLm91dGVyV2lkdGgoKSAvIDIsXG5cdFx0XHR5OiBvZmZzZXQudG9wICsgJGxpbmsub3V0ZXJIZWlnaHQoKSAvIDIsXG5cdFx0XHR0cmFuc2l0aW9uOiAkbGluay5qcW1EYXRhKCBcInRyYW5zaXRpb25cIiApLFxuXHRcdFx0cG9zaXRpb25UbzogJGxpbmsuanFtRGF0YSggXCJwb3NpdGlvbi10b1wiIClcblx0XHR9KTtcblx0fVxuXG5cdC8vcmVtb3ZlIGFmdGVyIGRlbGF5XG5cdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdCRsaW5rLnJlbW92ZUNsYXNzKCAkLm1vYmlsZS5hY3RpdmVCdG5DbGFzcyApO1xuXHR9LCAzMDAgKTtcbn07XG5cbi8vIFRPRE8gbW92ZSBpbnNpZGUgX2NyZWF0ZVxuJC5tb2JpbGUuZG9jdW1lbnQub24oIFwicGFnZWJlZm9yZWNoYW5nZVwiLCBmdW5jdGlvbiggdGhlRXZlbnQsIGRhdGEgKSB7XG5cdGlmICggZGF0YS5vcHRpb25zLnJvbGUgPT09IFwicG9wdXBcIiApIHtcblx0XHQkLm1vYmlsZS5wb3B1cC5oYW5kbGVMaW5rKCBkYXRhLm9wdGlvbnMubGluayApO1xuXHRcdHRoZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH1cbn0pO1xuXG59KSggalF1ZXJ5ICk7XG5cbi8qXG4qIGN1c3RvbSBcInNlbGVjdG1lbnVcIiBwbHVnaW5cbiovXG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgdW5mb2N1c2FibGVJdGVtU2VsZWN0b3IgPSBcIi51aS1kaXNhYmxlZCwudWktc3RhdGUtZGlzYWJsZWQsLnVpLWxpLWRpdmlkZXIsLnVpLXNjcmVlbi1oaWRkZW4sOmpxbURhdGEocm9sZT0ncGxhY2Vob2xkZXInKVwiLFxuXHRnb1RvQWRqYWNlbnRJdGVtID0gZnVuY3Rpb24oIGl0ZW0sIHRhcmdldCwgZGlyZWN0aW9uICkge1xuXHRcdHZhciBhZGphY2VudCA9IGl0ZW1bIGRpcmVjdGlvbiArIFwiQWxsXCIgXSgpXG5cdFx0XHQubm90KCB1bmZvY3VzYWJsZUl0ZW1TZWxlY3RvciApXG5cdFx0XHQuZmlyc3QoKTtcblxuXHRcdC8vIGlmIHRoZXJlJ3MgYSBwcmV2aW91cyBvcHRpb24sIGZvY3VzIGl0XG5cdFx0aWYgKCBhZGphY2VudC5sZW5ndGggKSB7XG5cdFx0XHR0YXJnZXRcblx0XHRcdFx0LmJsdXIoKVxuXHRcdFx0XHQuYXR0ciggXCJ0YWJpbmRleFwiLCBcIi0xXCIgKTtcblxuXHRcdFx0YWRqYWNlbnQuZmluZCggXCJhXCIgKS5maXJzdCgpLmZvY3VzKCk7XG5cdFx0fVxuXHR9O1xuXG4kLndpZGdldCggXCJtb2JpbGUuc2VsZWN0bWVudVwiLCAkLm1vYmlsZS5zZWxlY3RtZW51LCB7XG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0Ly8gQ3VzdG9tIHNlbGVjdHMgY2Fubm90IGV4aXN0IGluc2lkZSBwb3B1cHMsIHNvIHJldmVydCB0aGUgXCJuYXRpdmVNZW51XCJcblx0XHQvLyBvcHRpb24gdG8gdHJ1ZSBpZiBhIHBhcmVudCBpcyBhIHBvcHVwXG5cdFx0by5uYXRpdmVNZW51ID0gby5uYXRpdmVNZW51IHx8ICggdGhpcy5lbGVtZW50LnBhcmVudHMoIFwiOmpxbURhdGEocm9sZT0ncG9wdXAnKSw6bW9iaWxlLXBvcHVwXCIgKS5sZW5ndGggPiAwICk7XG5cblx0XHRyZXR1cm4gdGhpcy5fc3VwZXIoKTtcblx0fSxcblxuXHRfaGFuZGxlU2VsZWN0Rm9jdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudC5ibHVyKCk7XG5cdFx0dGhpcy5idXR0b24uZm9jdXMoKTtcblx0fSxcblxuXHRfaGFuZGxlS2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHRoaXMuX3N1cGVyKCBldmVudCApO1xuXHRcdHRoaXMuX2hhbmRsZUJ1dHRvblZjbGlja0tleWRvd24oIGV2ZW50ICk7XG5cdH0sXG5cblx0X2hhbmRsZUJ1dHRvblZjbGlja0tleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCB8fCB0aGlzLmlzT3BlbiB8fCB0aGlzLm9wdGlvbnMubmF0aXZlTWVudSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoZXZlbnQudHlwZSA9PT0gXCJ2Y2xpY2tcIiB8fFxuXHRcdFx0XHRldmVudC5rZXlDb2RlICYmIChldmVudC5rZXlDb2RlID09PSAkLm1vYmlsZS5rZXlDb2RlLkVOVEVSIHx8IGV2ZW50LmtleUNvZGUgPT09ICQubW9iaWxlLmtleUNvZGUuU1BBQ0UpKSB7XG5cblx0XHRcdHRoaXMuX2RlY2lkZUZvcm1hdCgpO1xuXHRcdFx0aWYgKCB0aGlzLm1lbnVUeXBlID09PSBcIm92ZXJsYXlcIiApIHtcblx0XHRcdFx0dGhpcy5idXR0b24uYXR0ciggXCJocmVmXCIsIFwiI1wiICsgdGhpcy5wb3B1cElkICkuYXR0ciggXCJkYXRhLVwiICsgKCAkLm1vYmlsZS5ucyB8fCBcIlwiICkgKyBcInJlbFwiLCBcInBvcHVwXCIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYnV0dG9uLmF0dHIoIFwiaHJlZlwiLCBcIiNcIiArIHRoaXMuZGlhbG9nSWQgKS5hdHRyKCBcImRhdGEtXCIgKyAoICQubW9iaWxlLm5zIHx8IFwiXCIgKSArIFwicmVsXCIsIFwiZGlhbG9nXCIgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaXNPcGVuID0gdHJ1ZTtcblx0XHRcdC8vIERvIG5vdCBwcmV2ZW50IGRlZmF1bHQsIHNvIHRoZSBuYXZpZ2F0aW9uIG1heSBoYXZlIGEgY2hhbmNlIHRvIGFjdHVhbGx5IG9wZW4gdGhlIGNob3NlbiBmb3JtYXRcblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZUxpc3RGb2N1czogZnVuY3Rpb24oIGUgKSB7XG5cdFx0dmFyIHBhcmFtcyA9ICggZS50eXBlID09PSBcImZvY3VzaW5cIiApID9cblx0XHRcdHsgdGFiaW5kZXg6IFwiMFwiLCBldmVudDogXCJ2bW91c2VvdmVyXCIgfTpcblx0XHRcdHsgdGFiaW5kZXg6IFwiLTFcIiwgZXZlbnQ6IFwidm1vdXNlb3V0XCIgfTtcblxuXHRcdCQoIGUudGFyZ2V0IClcblx0XHRcdC5hdHRyKCBcInRhYmluZGV4XCIsIHBhcmFtcy50YWJpbmRleCApXG5cdFx0XHQudHJpZ2dlciggcGFyYW1zLmV2ZW50ICk7XG5cdH0sXG5cblx0X2hhbmRsZUxpc3RLZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHRhcmdldCA9ICQoIGV2ZW50LnRhcmdldCApLFxuXHRcdFx0bGkgPSB0YXJnZXQuY2xvc2VzdCggXCJsaVwiICk7XG5cblx0XHQvLyBzd2l0Y2ggbG9naWMgYmFzZWQgb24gd2hpY2gga2V5IHdhcyBwcmVzc2VkXG5cdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcblx0XHRcdC8vIHVwIG9yIGxlZnQgYXJyb3cga2V5c1xuXHRcdGNhc2UgMzg6XG5cdFx0XHRnb1RvQWRqYWNlbnRJdGVtKCBsaSwgdGFyZ2V0LCBcInByZXZcIiApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0Ly8gZG93biBvciByaWdodCBhcnJvdyBrZXlzXG5cdFx0Y2FzZSA0MDpcblx0XHRcdGdvVG9BZGphY2VudEl0ZW0oIGxpLCB0YXJnZXQsIFwibmV4dFwiICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHQvLyBJZiBlbnRlciBvciBzcGFjZSBpcyBwcmVzc2VkLCB0cmlnZ2VyIGNsaWNrXG5cdFx0Y2FzZSAxMzpcblx0XHRjYXNlIDMyOlxuXHRcdFx0dGFyZ2V0LnRyaWdnZXIoIFwiY2xpY2tcIiApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlTWVudVBhZ2VIaWRlOiBmdW5jdGlvbigpIHtcblxuXHRcdC8vIEFmdGVyIHRoZSBkaWFsb2cncyBkb25lLCB3ZSBtYXkgd2FudCB0byB0cmlnZ2VyIGNoYW5nZSBpZiB0aGUgdmFsdWUgaGFzIGFjdHVhbGx5IGNoYW5nZWRcblx0XHR0aGlzLl9kZWxheWVkVHJpZ2dlcigpO1xuXG5cdFx0Ly8gVE9ETyBjZW50cmFsaXplIHBhZ2UgcmVtb3ZhbCBiaW5kaW5nIC8gaGFuZGxpbmcgaW4gdGhlIHBhZ2UgcGx1Z2luLlxuXHRcdC8vIFN1Z2dlc3Rpb24gZnJvbSBAamJsYXMgdG8gZG8gcmVmY291bnRpbmdcblx0XHQvL1xuXHRcdC8vIFRPRE8gZXh0cmVtZWx5IGNvbmZ1c2luZyBkZXBlbmRlbmN5IG9uIHRoZSBvcGVuIG1ldGhvZCB3aGVyZSB0aGUgcGFnZWhpZGUucmVtb3ZlXG5cdFx0Ly8gYmluZGluZ3MgYXJlIHN0cmlwcGVkIHRvIHByZXZlbnQgdGhlIHBhcmVudCBwYWdlIGZyb20gZGlzYXBwZWFyaW5nLiBUaGUgd2F5XG5cdFx0Ly8gd2UncmUga2VlcGluZyBwYWdlcyBpbiB0aGUgRE9NIHJpZ2h0IG5vdyBzdWNrc1xuXHRcdC8vXG5cdFx0Ly8gcmViaW5kIHRoZSBwYWdlIHJlbW92ZSB0aGF0IHdhcyB1bmJvdW5kIGluIHRoZSBvcGVuIGZ1bmN0aW9uXG5cdFx0Ly8gdG8gYWxsb3cgZm9yIHRoZSBwYXJlbnQgcGFnZSByZW1vdmFsIGZyb20gYWN0aW9ucyBvdGhlciB0aGFuIHRoZSB1c2Vcblx0XHQvLyBvZiBhIGRpYWxvZyBzaXplZCBjdXN0b20gc2VsZWN0XG5cdFx0Ly9cblx0XHQvLyBkb2luZyB0aGlzIGhlcmUgcHJvdmlkZXMgZm9yIHRoZSBiYWNrIGJ1dHRvbiBvbiB0aGUgY3VzdG9tIHNlbGVjdCBkaWFsb2dcblx0XHR0aGlzLnRoaXNQYWdlLnBhZ2UoIFwiYmluZFJlbW92ZVwiICk7XG5cdH0sXG5cblx0X2hhbmRsZUhlYWRlckNsb3NlQ2xpY2s6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggdGhpcy5tZW51VHlwZSA9PT0gXCJvdmVybGF5XCIgKSB7XG5cdFx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVMaXN0SXRlbUNsaWNrOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGxpc3RJdGVtID0gJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggXCJsaVwiICksXG5cblx0XHRcdC8vIEluZGV4IG9mIG9wdGlvbiB0YWcgdG8gYmUgc2VsZWN0ZWRcblx0XHRcdG9sZEluZGV4ID0gdGhpcy5zZWxlY3RbIDAgXS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0bmV3SW5kZXggPSAkLm1vYmlsZS5nZXRBdHRyaWJ1dGUoIGxpc3RJdGVtLCBcIm9wdGlvbi1pbmRleFwiICksXG5cdFx0XHRvcHRpb24gPSB0aGlzLl9zZWxlY3RPcHRpb25zKCkuZXEoIG5ld0luZGV4IClbIDAgXTtcblxuXHRcdC8vIFRvZ2dsZSBzZWxlY3RlZCBzdGF0dXMgb24gdGhlIHRhZyBmb3IgbXVsdGkgc2VsZWN0c1xuXHRcdG9wdGlvbi5zZWxlY3RlZCA9IHRoaXMuaXNNdWx0aXBsZSA/ICFvcHRpb24uc2VsZWN0ZWQgOiB0cnVlO1xuXG5cdFx0Ly8gVG9nZ2xlIGNoZWNrYm94IGNsYXNzIGZvciBtdWx0aXBsZSBzZWxlY3RzXG5cdFx0aWYgKCB0aGlzLmlzTXVsdGlwbGUgKSB7XG5cdFx0XHRsaXN0SXRlbS5maW5kKCBcImFcIiApXG5cdFx0XHRcdC50b2dnbGVDbGFzcyggXCJ1aS1jaGVja2JveC1vblwiLCBvcHRpb24uc2VsZWN0ZWQgKVxuXHRcdFx0XHQudG9nZ2xlQ2xhc3MoIFwidWktY2hlY2tib3gtb2ZmXCIsICFvcHRpb24uc2VsZWN0ZWQgKTtcblx0XHR9XG5cblx0XHQvLyBJZiBpdCdzIG5vdCBhIG11bHRpcGxlIHNlbGVjdCwgdHJpZ2dlciBjaGFuZ2UgYWZ0ZXIgaXQgaGFzIGZpbmlzaGVkIGNsb3Npbmdcblx0XHRpZiAoICF0aGlzLmlzTXVsdGlwbGUgJiYgb2xkSW5kZXggIT09IG5ld0luZGV4ICkge1xuXHRcdFx0dGhpcy5fdHJpZ2dlckNoYW5nZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gVHJpZ2dlciBjaGFuZ2UgaWYgaXQncyBhIG11bHRpcGxlIHNlbGVjdFxuXHRcdC8vIEhpZGUgY3VzdG9tIHNlbGVjdCBmb3Igc2luZ2xlIHNlbGVjdHMgb25seSAtIG90aGVyd2lzZSBmb2N1cyBjbGlja2VkIGl0ZW1cblx0XHQvLyBXZSBuZWVkIHRvIGdyYWIgdGhlIGNsaWNrZWQgaXRlbSB0aGUgaGFyZCB3YXksIGJlY2F1c2UgdGhlIGxpc3QgbWF5IGhhdmUgYmVlbiByZWJ1aWx0XG5cdFx0aWYgKCB0aGlzLmlzTXVsdGlwbGUgKSB7XG5cdFx0XHR0aGlzLnNlbGVjdC50cmlnZ2VyKCBcImNoYW5nZVwiICk7XG5cdFx0XHR0aGlzLmxpc3QuZmluZCggXCJsaTpub3QoLnVpLWxpLWRpdmlkZXIpXCIgKS5lcSggbmV3SW5kZXggKVxuXHRcdFx0XHQuZmluZCggXCJhXCIgKS5maXJzdCgpLmZvY3VzKCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5jbG9zZSgpO1xuXHRcdH1cblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH0sXG5cblx0YnVpbGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxlY3RJZCwgcG9wdXBJZCwgZGlhbG9nSWQsIGxhYmVsLCB0aGlzUGFnZSwgaXNNdWx0aXBsZSwgbWVudUlkLFxuXHRcdFx0dGhlbWVBdHRyLCBvdmVybGF5VGhlbWUsIG92ZXJsYXlUaGVtZUF0dHIsIGRpdmlkZXJUaGVtZUF0dHIsXG5cdFx0XHRtZW51UGFnZSwgbGlzdGJveCwgbGlzdCwgaGVhZGVyLCBoZWFkZXJUaXRsZSwgbWVudVBhZ2VDb250ZW50LFxuXHRcdFx0bWVudVBhZ2VDbG9zZSwgaGVhZGVyQ2xvc2UsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKCBvLm5hdGl2ZU1lbnUgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3VwZXIoKTtcblx0XHR9XG5cblx0XHRzZWxlY3RJZCA9IHRoaXMuc2VsZWN0SWQ7XG5cdFx0cG9wdXBJZCA9IHNlbGVjdElkICsgXCItbGlzdGJveFwiO1xuXHRcdGRpYWxvZ0lkID0gc2VsZWN0SWQgKyBcIi1kaWFsb2dcIjtcblx0XHRsYWJlbCA9IHRoaXMubGFiZWw7XG5cdFx0dGhpc1BhZ2UgPSB0aGlzLmVsZW1lbnQuY2xvc2VzdCggXCIudWktcGFnZVwiICk7XG5cdFx0aXNNdWx0aXBsZSA9IHRoaXMuZWxlbWVudFsgMCBdLm11bHRpcGxlO1xuXHRcdG1lbnVJZCA9IHNlbGVjdElkICsgXCItbWVudVwiO1xuXHRcdHRoZW1lQXR0ciA9IG8udGhlbWUgPyAoIFwiIGRhdGEtXCIgKyAkLm1vYmlsZS5ucyArIFwidGhlbWU9J1wiICsgby50aGVtZSArIFwiJ1wiICkgOiBcIlwiO1xuXHRcdG92ZXJsYXlUaGVtZSA9IG8ub3ZlcmxheVRoZW1lIHx8IG8udGhlbWUgfHwgbnVsbDtcblx0XHRvdmVybGF5VGhlbWVBdHRyID0gb3ZlcmxheVRoZW1lID8gKCBcIiBkYXRhLVwiICsgJC5tb2JpbGUubnMgK1xuXHRcdFx0XCJvdmVybGF5LXRoZW1lPSdcIiArIG92ZXJsYXlUaGVtZSArIFwiJ1wiICkgOiBcIlwiO1xuXHRcdGRpdmlkZXJUaGVtZUF0dHIgPSAoIG8uZGl2aWRlclRoZW1lICYmIGlzTXVsdGlwbGUgKSA/ICggXCIgZGF0YS1cIiArICQubW9iaWxlLm5zICsgXCJkaXZpZGVyLXRoZW1lPSdcIiArIG8uZGl2aWRlclRoZW1lICsgXCInXCIgKSA6IFwiXCI7XG5cdFx0bWVudVBhZ2UgPSAkKCBcIjxkaXYgZGF0YS1cIiArICQubW9iaWxlLm5zICsgXCJyb2xlPSdkaWFsb2cnIGNsYXNzPSd1aS1zZWxlY3RtZW51JyBpZD0nXCIgKyBkaWFsb2dJZCArIFwiJ1wiICsgdGhlbWVBdHRyICsgb3ZlcmxheVRoZW1lQXR0ciArIFwiPlwiICtcblx0XHRcdFwiPGRpdiBkYXRhLVwiICsgJC5tb2JpbGUubnMgKyBcInJvbGU9J2hlYWRlcic+XCIgK1xuXHRcdFx0XCI8ZGl2IGNsYXNzPSd1aS10aXRsZSc+PC9kaXY+XCIrXG5cdFx0XHRcIjwvZGl2PlwiK1xuXHRcdFx0XCI8ZGl2IGRhdGEtXCIgKyAkLm1vYmlsZS5ucyArIFwicm9sZT0nY29udGVudCc+PC9kaXY+XCIrXG5cdFx0XHRcIjwvZGl2PlwiICk7XG5cdFx0bGlzdGJveCA9ICQoIFwiPGRpdlwiICsgdGhlbWVBdHRyICsgb3ZlcmxheVRoZW1lQXR0ciArIFwiIGlkPSdcIiArIHBvcHVwSWQgK1xuXHRcdFx0XHRcIicgY2xhc3M9J3VpLXNlbGVjdG1lbnUnPjwvZGl2PlwiIClcblx0XHRcdC5pbnNlcnRBZnRlciggdGhpcy5zZWxlY3QgKVxuXHRcdFx0LnBvcHVwKCk7XG5cdFx0bGlzdCA9ICQoIFwiPHVsIGNsYXNzPSd1aS1zZWxlY3RtZW51LWxpc3QnIGlkPSdcIiArIG1lbnVJZCArIFwiJyByb2xlPSdsaXN0Ym94JyBhcmlhLWxhYmVsbGVkYnk9J1wiICsgdGhpcy5idXR0b25JZCArIFwiJ1wiICsgdGhlbWVBdHRyICsgZGl2aWRlclRoZW1lQXR0ciArIFwiPjwvdWw+XCIgKS5hcHBlbmRUbyggbGlzdGJveCApO1xuXHRcdGhlYWRlciA9ICQoIFwiPGRpdiBjbGFzcz0ndWktaGVhZGVyIHVpLWJhci1cIiArICggby50aGVtZSA/IG8udGhlbWUgOiBcImluaGVyaXRcIiApICsgXCInPjwvZGl2PlwiICkucHJlcGVuZFRvKCBsaXN0Ym94ICk7XG5cdFx0aGVhZGVyVGl0bGUgPSAkKCBcIjxoMSBjbGFzcz0ndWktdGl0bGUnPjwvaDE+XCIgKS5hcHBlbmRUbyggaGVhZGVyICk7XG5cblx0XHRpZiAoIHRoaXMuaXNNdWx0aXBsZSApIHtcblx0XHRcdGhlYWRlckNsb3NlID0gJCggXCI8YT5cIiwge1xuXHRcdFx0XHRcInJvbGVcIjogXCJidXR0b25cIixcblx0XHRcdFx0XCJ0ZXh0XCI6IG8uY2xvc2VUZXh0LFxuXHRcdFx0XHRcImhyZWZcIjogXCIjXCIsXG5cdFx0XHRcdFwiY2xhc3NcIjogXCJ1aS1idG4gdWktY29ybmVyLWFsbCB1aS1idG4tbGVmdCB1aS1idG4taWNvbi1ub3RleHQgdWktaWNvbi1kZWxldGVcIlxuXHRcdFx0fSkuYXBwZW5kVG8oIGhlYWRlciApO1xuXHRcdH1cblxuXHRcdCQuZXh0ZW5kKCB0aGlzLCB7XG5cdFx0XHRzZWxlY3RJZDogc2VsZWN0SWQsXG5cdFx0XHRtZW51SWQ6IG1lbnVJZCxcblx0XHRcdHBvcHVwSWQ6IHBvcHVwSWQsXG5cdFx0XHRkaWFsb2dJZDogZGlhbG9nSWQsXG5cdFx0XHR0aGlzUGFnZTogdGhpc1BhZ2UsXG5cdFx0XHRtZW51UGFnZTogbWVudVBhZ2UsXG5cdFx0XHRsYWJlbDogbGFiZWwsXG5cdFx0XHRpc011bHRpcGxlOiBpc011bHRpcGxlLFxuXHRcdFx0dGhlbWU6IG8udGhlbWUsXG5cdFx0XHRsaXN0Ym94OiBsaXN0Ym94LFxuXHRcdFx0bGlzdDogbGlzdCxcblx0XHRcdGhlYWRlcjogaGVhZGVyLFxuXHRcdFx0aGVhZGVyVGl0bGU6IGhlYWRlclRpdGxlLFxuXHRcdFx0aGVhZGVyQ2xvc2U6IGhlYWRlckNsb3NlLFxuXHRcdFx0bWVudVBhZ2VDb250ZW50OiBtZW51UGFnZUNvbnRlbnQsXG5cdFx0XHRtZW51UGFnZUNsb3NlOiBtZW51UGFnZUNsb3NlLFxuXHRcdFx0cGxhY2Vob2xkZXI6IFwiXCJcblx0XHR9KTtcblxuXHRcdC8vIENyZWF0ZSBsaXN0IGZyb20gc2VsZWN0LCB1cGRhdGUgc3RhdGVcblx0XHR0aGlzLnJlZnJlc2goKTtcblxuXHRcdGlmICggdGhpcy5fb3JpZ1RhYkluZGV4ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBNYXAgdW5kZWZpbmVkIHRvIGZhbHNlLCBiZWNhdXNlIHRoaXMuX29yaWdUYWJJbmRleCA9PT0gdW5kZWZpbmVkXG5cdFx0XHQvLyBpbmRpY2F0ZXMgdGhhdCB3ZSBoYXZlIG5vdCB5ZXQgY2hlY2tlZCB3aGV0aGVyIHRoZSBzZWxlY3QgaGFzXG5cdFx0XHQvLyBvcmlnaW5hbGx5IGhhZCBhIHRhYmluZGV4IGF0dHJpYnV0ZSwgd2hlcmVhcyBmYWxzZSBpbmRpY2F0ZXMgdGhhdFxuXHRcdFx0Ly8gd2UgaGF2ZSBjaGVja2VkIHRoZSBzZWxlY3QgZm9yIHN1Y2ggYW4gYXR0cmlidXRlLCBhbmQgaGF2ZSBmb3VuZFxuXHRcdFx0Ly8gbm9uZSBwcmVzZW50LlxuXHRcdFx0dGhpcy5fb3JpZ1RhYkluZGV4ID0gKCB0aGlzLnNlbGVjdFsgMCBdLmdldEF0dHJpYnV0ZSggXCJ0YWJpbmRleFwiICkgPT09IG51bGwgKSA/IGZhbHNlIDogdGhpcy5zZWxlY3QuYXR0ciggXCJ0YWJpbmRleFwiICk7XG5cdFx0fVxuXHRcdHRoaXMuc2VsZWN0LmF0dHIoIFwidGFiaW5kZXhcIiwgXCItMVwiICk7XG5cdFx0dGhpcy5fb24oIHRoaXMuc2VsZWN0LCB7IGZvY3VzIDogXCJfaGFuZGxlU2VsZWN0Rm9jdXNcIiB9ICk7XG5cblx0XHQvLyBCdXR0b24gZXZlbnRzXG5cdFx0dGhpcy5fb24oIHRoaXMuYnV0dG9uLCB7XG5cdFx0XHR2Y2xpY2s6IFwiX2hhbmRsZUJ1dHRvblZjbGlja0tleWRvd25cIlxuXHRcdH0pO1xuXG5cdFx0Ly8gRXZlbnRzIGZvciBsaXN0IGl0ZW1zXG5cdFx0dGhpcy5saXN0LmF0dHIoIFwicm9sZVwiLCBcImxpc3Rib3hcIiApO1xuXHRcdHRoaXMuX29uKCB0aGlzLmxpc3QsIHtcblx0XHRcdFwiZm9jdXNpblwiOiBcIl9oYW5kbGVMaXN0Rm9jdXNcIixcblx0XHRcdFwiZm9jdXNvdXRcIjogXCJfaGFuZGxlTGlzdEZvY3VzXCIsXG5cdFx0XHRcImtleWRvd25cIjogXCJfaGFuZGxlTGlzdEtleWRvd25cIixcblx0XHRcdFwiY2xpY2sgbGk6bm90KC51aS1kaXNhYmxlZCwudWktc3RhdGUtZGlzYWJsZWQsLnVpLWxpLWRpdmlkZXIpXCI6IFwiX2hhbmRsZUxpc3RJdGVtQ2xpY2tcIlxuXHRcdH0pO1xuXG5cdFx0Ly8gYnV0dG9uIHJlZm9jdXMgZW5zdXJlcyBwcm9wZXIgaGVpZ2h0IGNhbGN1bGF0aW9uXG5cdFx0Ly8gYnkgcmVtb3ZpbmcgdGhlIGlubGluZSBzdHlsZSBhbmQgZW5zdXJpbmcgcGFnZSBpbmNsdXNpb25cblx0XHR0aGlzLl9vbiggdGhpcy5tZW51UGFnZSwgeyBwYWdlaGlkZTogXCJfaGFuZGxlTWVudVBhZ2VIaWRlXCIgfSApO1xuXG5cdFx0Ly8gRXZlbnRzIG9uIHRoZSBwb3B1cFxuXHRcdHRoaXMuX29uKCB0aGlzLmxpc3Rib3gsIHsgcG9wdXBhZnRlcmNsb3NlOiBcIl9wb3B1cENsb3NlZFwiIH0gKTtcblxuXHRcdC8vIENsb3NlIGJ1dHRvbiBvbiBzbWFsbCBvdmVybGF5c1xuXHRcdGlmICggdGhpcy5pc011bHRpcGxlICkge1xuXHRcdFx0dGhpcy5fb24oIHRoaXMuaGVhZGVyQ2xvc2UsIHsgY2xpY2s6IFwiX2hhbmRsZUhlYWRlckNsb3NlQ2xpY2tcIiB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3BvcHVwQ2xvc2VkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0dGhpcy5fZGVsYXllZFRyaWdnZXIoKTtcblx0fSxcblxuXHRfZGVsYXllZFRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggdGhpcy5fdHJpZ2dlckNoYW5nZSApIHtcblx0XHRcdHRoaXMuZWxlbWVudC50cmlnZ2VyKCBcImNoYW5nZVwiICk7XG5cdFx0fVxuXHRcdHRoaXMuX3RyaWdnZXJDaGFuZ2UgPSBmYWxzZTtcblx0fSxcblxuXHRfaXNSZWJ1aWxkUmVxdWlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsaXN0ID0gdGhpcy5saXN0LmZpbmQoIFwibGlcIiApLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMuX3NlbGVjdE9wdGlvbnMoKS5ub3QoIFwiLnVpLXNjcmVlbi1oaWRkZW5cIiApO1xuXG5cdFx0Ly8gVE9ETyBleGNlZWRpbmdseSBuYWl2ZSBtZXRob2QgdG8gZGV0ZXJtaW5lIGRpZmZlcmVuY2Vcblx0XHQvLyBpZ25vcmVzIHZhbHVlIGNoYW5nZXMgZXRjIGluIGZhdm9yIG9mIGEgZm9yY2VkUmVidWlsZFxuXHRcdC8vIGZyb20gdGhlIHVzZXIgaW4gdGhlIHJlZnJlc2ggbWV0aG9kXG5cdFx0cmV0dXJuIG9wdGlvbnMudGV4dCgpICE9PSBsaXN0LnRleHQoKTtcblx0fSxcblxuXHRzZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdE9wdGlvbnMoKS5maWx0ZXIoIFwiOnNlbGVjdGVkOm5vdCggOmpxbURhdGEocGxhY2Vob2xkZXI9J3RydWUnKSApXCIgKTtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbiggZm9yY2UgKSB7XG5cdFx0dmFyIHNlbGYsIGluZGljZXM7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5uYXRpdmVNZW51ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3N1cGVyKCBmb3JjZSApO1xuXHRcdH1cblxuXHRcdHNlbGYgPSB0aGlzO1xuXHRcdGlmICggZm9yY2UgfHwgdGhpcy5faXNSZWJ1aWxkUmVxdWlyZWQoKSApIHtcblx0XHRcdHNlbGYuX2J1aWxkTGlzdCgpO1xuXHRcdH1cblxuXHRcdGluZGljZXMgPSB0aGlzLnNlbGVjdGVkSW5kaWNlcygpO1xuXG5cdFx0c2VsZi5zZXRCdXR0b25UZXh0KCk7XG5cdFx0c2VsZi5zZXRCdXR0b25Db3VudCgpO1xuXG5cdFx0c2VsZi5saXN0LmZpbmQoIFwibGk6bm90KC51aS1saS1kaXZpZGVyKVwiIClcblx0XHRcdC5maW5kKCBcImFcIiApLnJlbW92ZUNsYXNzKCAkLm1vYmlsZS5hY3RpdmVCdG5DbGFzcyApLmVuZCgpXG5cdFx0XHQuYXR0ciggXCJhcmlhLXNlbGVjdGVkXCIsIGZhbHNlIClcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXG5cdFx0XHRcdGlmICggJC5pbkFycmF5KCBpLCBpbmRpY2VzICkgPiAtMSApIHtcblx0XHRcdFx0XHR2YXIgaXRlbSA9ICQoIHRoaXMgKTtcblxuXHRcdFx0XHRcdC8vIEFyaWEgc2VsZWN0ZWQgYXR0clxuXHRcdFx0XHRcdGl0ZW0uYXR0ciggXCJhcmlhLXNlbGVjdGVkXCIsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIE11bHRpcGxlIHNlbGVjdHM6IGFkZCB0aGUgXCJvblwiIGNoZWNrYm94IHN0YXRlIHRvIHRoZSBpY29uXG5cdFx0XHRcdFx0aWYgKCBzZWxmLmlzTXVsdGlwbGUgKSB7XG5cdFx0XHRcdFx0XHRpdGVtLmZpbmQoIFwiYVwiICkucmVtb3ZlQ2xhc3MoIFwidWktY2hlY2tib3gtb2ZmXCIgKS5hZGRDbGFzcyggXCJ1aS1jaGVja2JveC1vblwiICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICggaXRlbS5oYXNDbGFzcyggXCJ1aS1zY3JlZW4taGlkZGVuXCIgKSApIHtcblx0XHRcdFx0XHRcdFx0aXRlbS5uZXh0KCkuZmluZCggXCJhXCIgKS5hZGRDbGFzcyggJC5tb2JpbGUuYWN0aXZlQnRuQ2xhc3MgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGl0ZW0uZmluZCggXCJhXCIgKS5hZGRDbGFzcyggJC5tb2JpbGUuYWN0aXZlQnRuQ2xhc3MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9LFxuXG5cdGNsb3NlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCB8fCAhdGhpcy5pc09wZW4gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCBzZWxmLm1lbnVUeXBlID09PSBcInBhZ2VcIiApIHtcblx0XHRcdHNlbGYubWVudVBhZ2UuZGlhbG9nKCBcImNsb3NlXCIgKTtcblx0XHRcdHNlbGYubGlzdC5hcHBlbmRUbyggc2VsZi5saXN0Ym94ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlbGYubGlzdGJveC5wb3B1cCggXCJjbG9zZVwiICk7XG5cdFx0fVxuXG5cdFx0c2VsZi5fZm9jdXNCdXR0b24oKTtcblx0XHQvLyBhbGxvdyB0aGUgZGlhbG9nIHRvIGJlIGNsb3NlZCBhZ2FpblxuXHRcdHNlbGYuaXNPcGVuID0gZmFsc2U7XG5cdH0sXG5cblx0b3BlbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5idXR0b24uY2xpY2soKTtcblx0fSxcblxuXHRfZm9jdXNNZW51SXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGVjdG9yID0gdGhpcy5saXN0LmZpbmQoIFwiYS5cIiArICQubW9iaWxlLmFjdGl2ZUJ0bkNsYXNzICk7XG5cdFx0aWYgKCBzZWxlY3Rvci5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHRoaXMubGlzdC5maW5kKCBcImxpOm5vdChcIiArIHVuZm9jdXNhYmxlSXRlbVNlbGVjdG9yICsgXCIpIGEudWktYnRuXCIgKTtcblx0XHR9XG5cdFx0c2VsZWN0b3IuZmlyc3QoKS5mb2N1cygpO1xuXHR9LFxuXG5cdF9kZWNpZGVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdCR3aW5kb3cgPSB0aGlzLndpbmRvdyxcblx0XHRcdHNlbGZMaXN0UGFyZW50ID0gc2VsZi5saXN0LnBhcmVudCgpLFxuXHRcdFx0bWVudUhlaWdodCA9IHNlbGZMaXN0UGFyZW50Lm91dGVySGVpZ2h0KCksXG5cdFx0XHRzY3JvbGxUb3AgPSAkd2luZG93LnNjcm9sbFRvcCgpLFxuXHRcdFx0YnRuT2Zmc2V0ID0gc2VsZi5idXR0b24ub2Zmc2V0KCkudG9wLFxuXHRcdFx0c2NyZWVuSGVpZ2h0ID0gJHdpbmRvdy5oZWlnaHQoKTtcblxuXHRcdGlmICggbWVudUhlaWdodCA+IHNjcmVlbkhlaWdodCAtIDgwIHx8ICEkLnN1cHBvcnQuc2Nyb2xsVG9wICkge1xuXG5cdFx0XHRzZWxmLm1lbnVQYWdlLmFwcGVuZFRvKCAkLm1vYmlsZS5wYWdlQ29udGFpbmVyICkucGFnZSgpO1xuXHRcdFx0c2VsZi5tZW51UGFnZUNvbnRlbnQgPSBzZWxmLm1lbnVQYWdlLmZpbmQoIFwiLnVpLWNvbnRlbnRcIiApO1xuXHRcdFx0c2VsZi5tZW51UGFnZUNsb3NlID0gc2VsZi5tZW51UGFnZS5maW5kKCBcIi51aS1oZWFkZXIgYVwiICk7XG5cblx0XHRcdC8vIHByZXZlbnQgdGhlIHBhcmVudCBwYWdlIGZyb20gYmVpbmcgcmVtb3ZlZCBmcm9tIHRoZSBET00sXG5cdFx0XHQvLyBvdGhlcndpc2UgdGhlIHJlc3VsdHMgb2Ygc2VsZWN0aW5nIGEgbGlzdCBpdGVtIGluIHRoZSBkaWFsb2dcblx0XHRcdC8vIGZhbGwgaW50byBhIGJsYWNrIGhvbGVcblx0XHRcdHNlbGYudGhpc1BhZ2UudW5iaW5kKCBcInBhZ2VoaWRlLnJlbW92ZVwiICk7XG5cblx0XHRcdC8vZm9yIFdlYk9TL09wZXJhIE1pbmkgKHNldCBsYXN0c2Nyb2xsIHVzaW5nIGJ1dHRvbiBvZmZzZXQpXG5cdFx0XHRpZiAoIHNjcm9sbFRvcCA9PT0gMCAmJiBidG5PZmZzZXQgPiBzY3JlZW5IZWlnaHQgKSB7XG5cdFx0XHRcdHNlbGYudGhpc1BhZ2Uub25lKCBcInBhZ2VoaWRlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCQoIHRoaXMgKS5qcW1EYXRhKCBcImxhc3RTY3JvbGxcIiwgYnRuT2Zmc2V0ICk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxmLm1lbnVQYWdlLm9uZSgge1xuXHRcdFx0XHRwYWdlc2hvdzogJC5wcm94eSggdGhpcywgXCJfZm9jdXNNZW51SXRlbVwiICksXG5cdFx0XHRcdHBhZ2VoaWRlOiAkLnByb3h5KCB0aGlzLCBcImNsb3NlXCIgKVxuXHRcdFx0fSk7XG5cblx0XHRcdHNlbGYubWVudVR5cGUgPSBcInBhZ2VcIjtcblx0XHRcdHNlbGYubWVudVBhZ2VDb250ZW50LmFwcGVuZCggc2VsZi5saXN0ICk7XG5cdFx0XHRzZWxmLm1lbnVQYWdlXG5cdFx0XHRcdC5maW5kKCBcImRpdiAudWktdGl0bGVcIiApXG5cdFx0XHRcdFx0LnRleHQoIHNlbGYubGFiZWwuZ2V0RW5jb2RlZFRleHQoKSB8fCBzZWxmLnBsYWNlaG9sZGVyICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlbGYubWVudVR5cGUgPSBcIm92ZXJsYXlcIjtcblxuXHRcdFx0c2VsZi5saXN0Ym94Lm9uZSggeyBwb3B1cGFmdGVyb3BlbjogJC5wcm94eSggdGhpcywgXCJfZm9jdXNNZW51SXRlbVwiICkgfSApO1xuXHRcdH1cblx0fSxcblxuXHRfYnVpbGRMaXN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0cGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyLFxuXHRcdFx0bmVlZFBsYWNlaG9sZGVyID0gdHJ1ZSxcblx0XHRcdGRhdGFJY29uID0gXCJmYWxzZVwiLFxuXHRcdFx0JG9wdGlvbnMsIG51bU9wdGlvbnMsIHNlbGVjdCxcblx0XHRcdGRhdGFQcmVmaXggPSBcImRhdGEtXCIgKyAkLm1vYmlsZS5ucyxcblx0XHRcdGRhdGFJbmRleEF0dHIgPSBkYXRhUHJlZml4ICsgXCJvcHRpb24taW5kZXhcIixcblx0XHRcdGRhdGFJY29uQXR0ciA9IGRhdGFQcmVmaXggKyBcImljb25cIixcblx0XHRcdGRhdGFSb2xlQXR0ciA9IGRhdGFQcmVmaXggKyBcInJvbGVcIixcblx0XHRcdGRhdGFQbGFjZWhvbGRlckF0dHIgPSBkYXRhUHJlZml4ICsgXCJwbGFjZWhvbGRlclwiLFxuXHRcdFx0ZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0XHRpc1BsYWNlaG9sZGVySXRlbSA9IGZhbHNlLFxuXHRcdFx0b3B0R3JvdXAsXG5cdFx0XHRpLFxuXHRcdFx0b3B0aW9uLCAkb3B0aW9uLCBwYXJlbnQsIHRleHQsIGFuY2hvciwgY2xhc3Nlcyxcblx0XHRcdG9wdExhYmVsLCBkaXZpZGVyLCBpdGVtO1xuXG5cdFx0c2VsZi5saXN0LmVtcHR5KCkuZmlsdGVyKCBcIi51aS1saXN0dmlld1wiICkubGlzdHZpZXcoIFwiZGVzdHJveVwiICk7XG5cdFx0JG9wdGlvbnMgPSB0aGlzLl9zZWxlY3RPcHRpb25zKCk7XG5cdFx0bnVtT3B0aW9ucyA9ICRvcHRpb25zLmxlbmd0aDtcblx0XHRzZWxlY3QgPSB0aGlzLnNlbGVjdFsgMCBdO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBudW1PcHRpb25zO2krKywgaXNQbGFjZWhvbGRlckl0ZW0gPSBmYWxzZSkge1xuXHRcdFx0b3B0aW9uID0gJG9wdGlvbnNbaV07XG5cdFx0XHQkb3B0aW9uID0gJCggb3B0aW9uICk7XG5cblx0XHRcdC8vIERvIG5vdCBjcmVhdGUgb3B0aW9ucyBiYXNlZCBvbiB1aS1zY3JlZW4taGlkZGVuIHNlbGVjdCBvcHRpb25zXG5cdFx0XHRpZiAoICRvcHRpb24uaGFzQ2xhc3MoIFwidWktc2NyZWVuLWhpZGRlblwiICkgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRwYXJlbnQgPSBvcHRpb24ucGFyZW50Tm9kZTtcblx0XHRcdHRleHQgPSAkb3B0aW9uLmdldEVuY29kZWRUZXh0KCk7XG5cdFx0XHRhbmNob3IgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0XHRcdGNsYXNzZXMgPSBbXTtcblxuXHRcdFx0YW5jaG9yLnNldEF0dHJpYnV0ZSggXCJocmVmXCIsIFwiI1wiICk7XG5cdFx0XHRhbmNob3IuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCB0ZXh0ICkgKTtcblxuXHRcdFx0Ly8gQXJlIHdlIGluc2lkZSBhbiBvcHRncm91cD9cblx0XHRcdGlmICggcGFyZW50ICE9PSBzZWxlY3QgJiYgcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwib3B0Z3JvdXBcIiApIHtcblx0XHRcdFx0b3B0TGFiZWwgPSBwYXJlbnQuZ2V0QXR0cmlidXRlKCBcImxhYmVsXCIgKTtcblx0XHRcdFx0aWYgKCBvcHRMYWJlbCAhPT0gb3B0R3JvdXAgKSB7XG5cdFx0XHRcdFx0ZGl2aWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwibGlcIiApO1xuXHRcdFx0XHRcdGRpdmlkZXIuc2V0QXR0cmlidXRlKCBkYXRhUm9sZUF0dHIsIFwibGlzdC1kaXZpZGVyXCIgKTtcblx0XHRcdFx0XHRkaXZpZGVyLnNldEF0dHJpYnV0ZSggXCJyb2xlXCIsIFwib3B0aW9uXCIgKTtcblx0XHRcdFx0XHRkaXZpZGVyLnNldEF0dHJpYnV0ZSggXCJ0YWJpbmRleFwiLCBcIi0xXCIgKTtcblx0XHRcdFx0XHRkaXZpZGVyLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggb3B0TGFiZWwgKSApO1xuXHRcdFx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKCBkaXZpZGVyICk7XG5cdFx0XHRcdFx0b3B0R3JvdXAgPSBvcHRMYWJlbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5lZWRQbGFjZWhvbGRlciAmJiAoICFvcHRpb24uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSB8fCB0ZXh0Lmxlbmd0aCA9PT0gMCB8fCAkb3B0aW9uLmpxbURhdGEoIFwicGxhY2Vob2xkZXJcIiApICkgKSB7XG5cdFx0XHRcdG5lZWRQbGFjZWhvbGRlciA9IGZhbHNlO1xuXHRcdFx0XHRpc1BsYWNlaG9sZGVySXRlbSA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBpZGVudGlmaWVkIGEgcGxhY2Vob2xkZXIsIHJlY29yZCB0aGUgZmFjdCB0aGF0IGl0IHdhc1xuXHRcdFx0XHQvLyB1cyB3aG8gaGF2ZSBhZGRlZCB0aGUgcGxhY2Vob2xkZXIgdG8gdGhlIG9wdGlvbiBhbmQgbWFyayBpdFxuXHRcdFx0XHQvLyByZXRyb2FjdGl2ZWx5IGluIHRoZSBzZWxlY3QgYXMgd2VsbFxuXHRcdFx0XHRpZiAoIG51bGwgPT09IG9wdGlvbi5nZXRBdHRyaWJ1dGUoIGRhdGFQbGFjZWhvbGRlckF0dHIgKSApIHtcblx0XHRcdFx0XHR0aGlzLl9yZW1vdmVQbGFjZWhvbGRlckF0dHIgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9wdGlvbi5zZXRBdHRyaWJ1dGUoIGRhdGFQbGFjZWhvbGRlckF0dHIsIHRydWUgKTtcblx0XHRcdFx0aWYgKCBvLmhpZGVQbGFjZWhvbGRlck1lbnVJdGVtcyApIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goIFwidWktc2NyZWVuLWhpZGRlblwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBwbGFjZWhvbGRlciAhPT0gdGV4dCApIHtcblx0XHRcdFx0XHRwbGFjZWhvbGRlciA9IHNlbGYucGxhY2Vob2xkZXIgPSB0ZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImxpXCIgKTtcblx0XHRcdGlmICggb3B0aW9uLmRpc2FibGVkICkge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goIFwidWktc3RhdGUtZGlzYWJsZWRcIiApO1xuXHRcdFx0XHRpdGVtLnNldEF0dHJpYnV0ZSggXCJhcmlhLWRpc2FibGVkXCIsIHRydWUgKTtcblx0XHRcdH1cblx0XHRcdGl0ZW0uc2V0QXR0cmlidXRlKCBkYXRhSW5kZXhBdHRyLCBpICk7XG5cdFx0XHRpdGVtLnNldEF0dHJpYnV0ZSggZGF0YUljb25BdHRyLCBkYXRhSWNvbiApO1xuXHRcdFx0aWYgKCBpc1BsYWNlaG9sZGVySXRlbSApIHtcblx0XHRcdFx0aXRlbS5zZXRBdHRyaWJ1dGUoIGRhdGFQbGFjZWhvbGRlckF0dHIsIHRydWUgKTtcblx0XHRcdH1cblx0XHRcdGl0ZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCBcIiBcIiApO1xuXHRcdFx0aXRlbS5zZXRBdHRyaWJ1dGUoIFwicm9sZVwiLCBcIm9wdGlvblwiICk7XG5cdFx0XHRhbmNob3Iuc2V0QXR0cmlidXRlKCBcInRhYmluZGV4XCIsIFwiLTFcIiApO1xuXHRcdFx0aWYgKCB0aGlzLmlzTXVsdGlwbGUgKSB7XG5cdFx0XHRcdCQoIGFuY2hvciApLmFkZENsYXNzKCBcInVpLWJ0biB1aS1jaGVja2JveC1vZmYgdWktYnRuLWljb24tcmlnaHRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHRpdGVtLmFwcGVuZENoaWxkKCBhbmNob3IgKTtcblx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKCBpdGVtICk7XG5cdFx0fVxuXG5cdFx0c2VsZi5saXN0WzBdLmFwcGVuZENoaWxkKCBmcmFnbWVudCApO1xuXG5cdFx0Ly8gSGlkZSBoZWFkZXIgaWYgaXQncyBub3QgYSBtdWx0aXNlbGVjdCBhbmQgdGhlcmUncyBubyBwbGFjZWhvbGRlclxuXHRcdGlmICggIXRoaXMuaXNNdWx0aXBsZSAmJiAhcGxhY2Vob2xkZXIubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5oZWFkZXIuYWRkQ2xhc3MoIFwidWktc2NyZWVuLWhpZGRlblwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuaGVhZGVyVGl0bGUudGV4dCggdGhpcy5wbGFjZWhvbGRlciApO1xuXHRcdH1cblxuXHRcdC8vIE5vdyBwb3B1bGF0ZWQsIGNyZWF0ZSBsaXN0dmlld1xuXHRcdHNlbGYubGlzdC5saXN0dmlldygpO1xuXHR9LFxuXG5cdF9idXR0b246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubmF0aXZlTWVudSA/XG5cdFx0XHR0aGlzLl9zdXBlcigpIDpcblx0XHRcdCQoIFwiPGE+XCIsIHtcblx0XHRcdFx0XCJocmVmXCI6IFwiI1wiLFxuXHRcdFx0XHRcInJvbGVcIjogXCJidXR0b25cIixcblx0XHRcdFx0Ly8gVE9ETyB2YWx1ZSBpcyB1bmRlZmluZWQgYXQgY3JlYXRpb25cblx0XHRcdFx0XCJpZFwiOiB0aGlzLmJ1dHRvbklkLFxuXHRcdFx0XHRcImFyaWEtaGFzcG9wdXBcIjogXCJ0cnVlXCIsXG5cblx0XHRcdFx0Ly8gVE9ETyB2YWx1ZSBpcyB1bmRlZmluZWQgYXQgY3JlYXRpb25cblx0XHRcdFx0XCJhcmlhLW93bnNcIjogdGhpcy5tZW51SWRcblx0XHRcdH0pO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5uYXRpdmVNZW51ICkge1xuXHRcdFx0dGhpcy5jbG9zZSgpO1xuXG5cdFx0XHQvLyBSZXN0b3JlIHRoZSB0YWJpbmRleCBhdHRyaWJ1dGUgdG8gaXRzIG9yaWdpbmFsIHZhbHVlXG5cdFx0XHRpZiAoIHRoaXMuX29yaWdUYWJJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuX29yaWdUYWJJbmRleCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3QuYXR0ciggXCJ0YWJpbmRleFwiLCB0aGlzLl9vcmlnVGFiSW5kZXggKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdC5yZW1vdmVBdHRyKCBcInRhYmluZGV4XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZSBpZiB3ZSB3ZXJlIHRoZSBvbmVzIHRvIGFkZCBpdFxuXHRcdFx0aWYgKCB0aGlzLl9yZW1vdmVQbGFjZWhvbGRlckF0dHIgKSB7XG5cdFx0XHRcdHRoaXMuX3NlbGVjdE9wdGlvbnMoKS5yZW1vdmVBdHRyKCBcImRhdGEtXCIgKyAkLm1vYmlsZS5ucyArIFwicGxhY2Vob2xkZXJcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgdGhlIHBvcHVwXG5cdFx0XHR0aGlzLmxpc3Rib3gucmVtb3ZlKCk7XG5cblx0XHRcdC8vIFJlbW92ZSB0aGUgZGlhbG9nXG5cdFx0XHR0aGlzLm1lbnVQYWdlLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdC8vIENoYWluIHVwXG5cdFx0dGhpcy5fc3VwZXIoKTtcblx0fVxufSk7XG5cbn0pKCBqUXVlcnkgKTtcblxuXG4vLyBidXR0b25NYXJrdXAgaXMgZGVwcmVjYXRlZCBhcyBvZiAxLjQuMCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIDEuNS4wLlxuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuLy8gR2VuZXJhbCBwb2xpY3k6IERvIG5vdCBhY2Nlc3MgZGF0YS0qIGF0dHJpYnV0ZXMgZXhjZXB0IGR1cmluZyBlbmhhbmNlbWVudC5cbi8vIEluIGFsbCBvdGhlciBjYXNlcyB3ZSBkZXRlcm1pbmUgdGhlIHN0YXRlIG9mIHRoZSBidXR0b24gZXhjbHVzaXZlbHkgZnJvbSBpdHNcbi8vIGNsYXNzTmFtZS4gVGhhdCdzIHdoeSBvcHRpb25zVG9DbGFzc2VzIGV4cGVjdHMgYSBmdWxsIGNvbXBsZW1lbnQgb2Ygb3B0aW9ucyxcbi8vIGFuZCB0aGUgalF1ZXJ5IHBsdWdpbiBjb21wbGV0ZXMgdGhlIHNldCBvZiBvcHRpb25zIGZyb20gdGhlIGRlZmF1bHQgdmFsdWVzLlxuXG4vLyBNYXAgY2xhc3NlcyB0byBidXR0b25NYXJrdXAgYm9vbGVhbiBvcHRpb25zIC0gdXNlZCBpbiBjbGFzc05hbWVUb09wdGlvbnMoKVxudmFyIHJldmVyc2VCb29sT3B0aW9uTWFwID0ge1xuXHRcdFwidWktc2hhZG93XCIgOiBcInNoYWRvd1wiLFxuXHRcdFwidWktY29ybmVyLWFsbFwiIDogXCJjb3JuZXJzXCIsXG5cdFx0XCJ1aS1idG4taW5saW5lXCIgOiBcImlubGluZVwiLFxuXHRcdFwidWktc2hhZG93LWljb25cIiA6IFwiaWNvbnNoYWRvd1wiLCAvKiBUT0RPOiBSZW1vdmUgaW4gMS41ICovXG5cdFx0XCJ1aS1taW5pXCIgOiBcIm1pbmlcIlxuXHR9LFxuXHRnZXRBdHRyRml4ZWQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmV0ID0gJC5tb2JpbGUuZ2V0QXR0cmlidXRlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdHJldHVybiAoIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0ICk7XG5cdH0sXG5cdGNhcGl0YWxMZXR0ZXJzUkUgPSAvW0EtWl0vZztcblxuLy8gb3B0aW9uc1RvQ2xhc3Nlczpcbi8vIEBvcHRpb25zOiBBIGNvbXBsZXRlIHNldCBvZiBvcHRpb25zIHRvIGNvbnZlcnQgdG8gY2xhc3MgbmFtZXMuXG4vLyBAZXhpc3RpbmdDbGFzc2VzOiBleHRyYSBjbGFzc2VzIHRvIGFkZCB0byB0aGUgcmVzdWx0XG4vL1xuLy8gQ29udmVydHMgQG9wdGlvbnMgdG8gYnV0dG9uTWFya3VwIGNsYXNzZXMgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhbiBhcnJheVxuLy8gdGhhdCBjYW4gYmUgY29udmVydGVkIHRvIGFuIGVsZW1lbnQncyBjbGFzc05hbWUgd2l0aCAuam9pbiggXCIgXCIgKS4gQWxsXG4vLyBwb3NzaWJsZSBvcHRpb25zIG11c3QgYmUgc2V0IGluc2lkZSBAb3B0aW9ucy4gVXNlICQuZm4uYnV0dG9uTWFya3VwLmRlZmF1bHRzXG4vLyB0byBnZXQgYSBjb21wbGV0ZSBzZXQgYW5kIHVzZSAkLmV4dGVuZCB0byBvdmVycmlkZSB5b3VyIGNob2ljZSBvZiBvcHRpb25zXG4vLyBmcm9tIHRoYXQgc2V0LlxuZnVuY3Rpb24gb3B0aW9uc1RvQ2xhc3Nlcyggb3B0aW9ucywgZXhpc3RpbmdDbGFzc2VzICkge1xuXHR2YXIgY2xhc3NlcyA9IGV4aXN0aW5nQ2xhc3NlcyA/IGV4aXN0aW5nQ2xhc3NlcyA6IFtdO1xuXG5cdC8vIEFkZCBjbGFzc2VzIHRvIHRoZSBhcnJheSAtIGZpcnN0IHVpLWJ0blxuXHRjbGFzc2VzLnB1c2goIFwidWktYnRuXCIgKTtcblxuXHQvLyBJZiB0aGVyZSBpcyBhIHRoZW1lXG5cdGlmICggb3B0aW9ucy50aGVtZSApIHtcblx0XHRjbGFzc2VzLnB1c2goIFwidWktYnRuLVwiICsgb3B0aW9ucy50aGVtZSApO1xuXHR9XG5cblx0Ly8gSWYgdGhlcmUncyBhbiBpY29uLCBhZGQgdGhlIGljb24tcmVsYXRlZCBjbGFzc2VzXG5cdGlmICggb3B0aW9ucy5pY29uICkge1xuXHRcdGNsYXNzZXMgPSBjbGFzc2VzLmNvbmNhdChbXG5cdFx0XHRcInVpLWljb24tXCIgKyBvcHRpb25zLmljb24sXG5cdFx0XHRcInVpLWJ0bi1pY29uLVwiICsgb3B0aW9ucy5pY29ucG9zXG5cdFx0XSk7XG5cdFx0aWYgKCBvcHRpb25zLmljb25zaGFkb3cgKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goIFwidWktc2hhZG93LWljb25cIiApOyAvKiBUT0RPOiBSZW1vdmUgaW4gMS41ICovXG5cdFx0fVxuXHR9XG5cblx0Ly8gQWRkIHRoZSBhcHByb3ByaWF0ZSBjbGFzcyBmb3IgZWFjaCBib29sZWFuIG9wdGlvblxuXHRpZiAoIG9wdGlvbnMuaW5saW5lICkge1xuXHRcdGNsYXNzZXMucHVzaCggXCJ1aS1idG4taW5saW5lXCIgKTtcblx0fVxuXHRpZiAoIG9wdGlvbnMuc2hhZG93ICkge1xuXHRcdGNsYXNzZXMucHVzaCggXCJ1aS1zaGFkb3dcIiApO1xuXHR9XG5cdGlmICggb3B0aW9ucy5jb3JuZXJzICkge1xuXHRcdGNsYXNzZXMucHVzaCggXCJ1aS1jb3JuZXItYWxsXCIgKTtcblx0fVxuXHRpZiAoIG9wdGlvbnMubWluaSApIHtcblx0XHRjbGFzc2VzLnB1c2goIFwidWktbWluaVwiICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSBzdHJpbmcgZnJvbSB0aGUgYXJyYXkgYW5kIHJldHVybiBpdFxuXHRyZXR1cm4gY2xhc3Nlcztcbn1cblxuLy8gY2xhc3NOYW1lVG9PcHRpb25zOlxuLy8gQGNsYXNzZXM6IEEgc3RyaW5nIGNvbnRhaW5pbmcgYSAuY2xhc3NOYW1lLXN0eWxlIHNwYWNlLXNlcGFyYXRlZCBjbGFzcyBsaXN0XG4vL1xuLy8gTG9vcHMgb3ZlciBAY2xhc3NlcyBhbmQgY2FsY3VsYXRlcyBhbiBvcHRpb25zIG9iamVjdCBiYXNlZCBvbiB0aGVcbi8vIGJ1dHRvbk1hcmt1cC1yZWxhdGVkIGNsYXNzZXMgaXQgZmluZHMuIEl0IHJlY29yZHMgdW5yZWNvZ25pemVkIGNsYXNzZXMgaW4gYW5cbi8vIGFycmF5LlxuLy9cbi8vIFJldHVybnM6IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgaXRlbXM6XG4vL1xuLy8gXCJvcHRpb25zXCI6IGJ1dHRvbk1hcmt1cCBvcHRpb25zIGZvdW5kIHRvIGJlIHByZXNlbnQgYmVjYXVzZSBvZiB0aGVcbi8vIHByZXNlbmNlL2Fic2VuY2Ugb2YgY29ycmVzcG9uZGluZyBjbGFzc2VzXG4vL1xuLy8gXCJ1bmtub3duQ2xhc3Nlc1wiOiBhIHN0cmluZyBjb250YWluaW5nIGFsbCB0aGUgbm9uLWJ1dHRvbk1hcmt1cC1yZWxhdGVkXG4vLyBjbGFzc2VzIGZvdW5kIGluIEBjbGFzc2VzXG4vL1xuLy8gXCJhbHJlYWR5RW5oYW5jZWRcIjogQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgdWktYnRuIGNsYXNzIHdhcyBhbW9uZ1xuLy8gdGhvc2UgZm91bmQgdG8gYmUgcHJlc2VudFxuZnVuY3Rpb24gY2xhc3NOYW1lVG9PcHRpb25zKCBjbGFzc2VzICkge1xuXHR2YXIgaWR4LCBtYXAsIHVua25vd25DbGFzcyxcblx0XHRhbHJlYWR5RW5oYW5jZWQgPSBmYWxzZSxcblx0XHRub0ljb24gPSB0cnVlLFxuXHRcdG8gPSB7XG5cdFx0XHRpY29uOiBcIlwiLFxuXHRcdFx0aW5saW5lOiBmYWxzZSxcblx0XHRcdHNoYWRvdzogZmFsc2UsXG5cdFx0XHRjb3JuZXJzOiBmYWxzZSxcblx0XHRcdGljb25zaGFkb3c6IGZhbHNlLFxuXHRcdFx0bWluaTogZmFsc2Vcblx0XHR9LFxuXHRcdHVua25vd25DbGFzc2VzID0gW107XG5cblx0Y2xhc3NlcyA9IGNsYXNzZXMuc3BsaXQoIFwiIFwiICk7XG5cblx0Ly8gTG9vcCBvdmVyIHRoZSBjbGFzc2VzXG5cdGZvciAoIGlkeCA9IDAgOyBpZHggPCBjbGFzc2VzLmxlbmd0aCA7IGlkeCsrICkge1xuXG5cdFx0Ly8gQXNzdW1lIGl0J3MgYW4gdW5yZWNvZ25pemVkIGNsYXNzXG5cdFx0dW5rbm93bkNsYXNzID0gdHJ1ZTtcblxuXHRcdC8vIFJlY29nbml6ZSBib29sZWFuIG9wdGlvbnMgZnJvbSB0aGUgcHJlc2VuY2Ugb2YgY2xhc3Nlc1xuXHRcdG1hcCA9IHJldmVyc2VCb29sT3B0aW9uTWFwWyBjbGFzc2VzWyBpZHggXSBdO1xuXHRcdGlmICggbWFwICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR1bmtub3duQ2xhc3MgPSBmYWxzZTtcblx0XHRcdG9bIG1hcCBdID0gdHJ1ZTtcblxuXHRcdC8vIFJlY29nbml6ZSB0aGUgcHJlc2VuY2Ugb2YgYW4gaWNvbiBhbmQgZXN0YWJsaXNoIHRoZSBpY29uIHBvc2l0aW9uXG5cdFx0fSBlbHNlIGlmICggY2xhc3Nlc1sgaWR4IF0uaW5kZXhPZiggXCJ1aS1idG4taWNvbi1cIiApID09PSAwICkge1xuXHRcdFx0dW5rbm93bkNsYXNzID0gZmFsc2U7XG5cdFx0XHRub0ljb24gPSBmYWxzZTtcblx0XHRcdG8uaWNvbnBvcyA9IGNsYXNzZXNbIGlkeCBdLnN1YnN0cmluZyggMTIgKTtcblxuXHRcdC8vIEVzdGFibGlzaCB3aGljaCBpY29uIGlzIHByZXNlbnRcblx0XHR9IGVsc2UgaWYgKCBjbGFzc2VzWyBpZHggXS5pbmRleE9mKCBcInVpLWljb24tXCIgKSA9PT0gMCApIHtcblx0XHRcdHVua25vd25DbGFzcyA9IGZhbHNlO1xuXHRcdFx0by5pY29uID0gY2xhc3Nlc1sgaWR4IF0uc3Vic3RyaW5nKCA4ICk7XG5cblx0XHQvLyBFc3RhYmxpc2ggdGhlIHRoZW1lIC0gdGhpcyByZWNvZ25pemVzIG9uZS1sZXR0ZXIgdGhlbWUgc3dhdGNoIG5hbWVzXG5cdFx0fSBlbHNlIGlmICggY2xhc3Nlc1sgaWR4IF0uaW5kZXhPZiggXCJ1aS1idG4tXCIgKSA9PT0gMCAmJiBjbGFzc2VzWyBpZHggXS5sZW5ndGggPT09IDggKSB7XG5cdFx0XHR1bmtub3duQ2xhc3MgPSBmYWxzZTtcblx0XHRcdG8udGhlbWUgPSBjbGFzc2VzWyBpZHggXS5zdWJzdHJpbmcoIDcgKTtcblxuXHRcdC8vIFJlY29nbml6ZSB0aGF0IHRoaXMgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIGJ1dHRvbk1hcmt1cC1lbmhhbmNlZFxuXHRcdH0gZWxzZSBpZiAoIGNsYXNzZXNbIGlkeCBdID09PSBcInVpLWJ0blwiICkge1xuXHRcdFx0dW5rbm93bkNsYXNzID0gZmFsc2U7XG5cdFx0XHRhbHJlYWR5RW5oYW5jZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoaXMgY2xhc3MgaGFzIG5vdCBiZWVuIHJlY29nbml6ZWQsIGFkZCBpdCB0byB0aGUgbGlzdFxuXHRcdGlmICggdW5rbm93bkNsYXNzICkge1xuXHRcdFx0dW5rbm93bkNsYXNzZXMucHVzaCggY2xhc3Nlc1sgaWR4IF0gKTtcblx0XHR9XG5cdH1cblxuXHQvLyBJZiBhIFwidWktYnRuLWljb24tKlwiIGljb24gcG9zaXRpb24gY2xhc3MgaXMgYWJzZW50IHRoZXJlIGNhbm5vdCBiZSBhbiBpY29uXG5cdGlmICggbm9JY29uICkge1xuXHRcdG8uaWNvbiA9IFwiXCI7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdG9wdGlvbnM6IG8sXG5cdFx0dW5rbm93bkNsYXNzZXM6IHVua25vd25DbGFzc2VzLFxuXHRcdGFscmVhZHlFbmhhbmNlZDogYWxyZWFkeUVuaGFuY2VkXG5cdH07XG59XG5cbmZ1bmN0aW9uIGNhbWVsQ2FzZTJIeXBoZW5hdGVkKCBjICkge1xuXHRyZXR1cm4gXCItXCIgKyBjLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8vICQuZm4uYnV0dG9uTWFya3VwOlxuLy8gRE9NOiBnZXRzL3NldHMgLmNsYXNzTmFtZVxuLy9cbi8vIEBvcHRpb25zOiBvcHRpb25zIHRvIGFwcGx5IHRvIHRoZSBlbGVtZW50cyBpbiB0aGUgalF1ZXJ5IG9iamVjdFxuLy8gQG92ZXJ3cml0ZUNsYXNzZXM6IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGhvbm91ciBleGlzdGluZyBjbGFzc2VzXG4vL1xuLy8gQ2FsY3VsYXRlcyB0aGUgY2xhc3NlcyB0byBhcHBseSB0byB0aGUgZWxlbWVudHMgaW4gdGhlIGpRdWVyeSBvYmplY3QgYmFzZWQgb25cbi8vIHRoZSBvcHRpb25zIHBhc3NlZCBpbi4gSWYgQG92ZXJ3cml0ZUNsYXNzZXMgaXMgdHJ1ZSwgaXQgc2V0cyB0aGUgY2xhc3NOYW1lXG4vLyBwcm9wZXJ0eSBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIGpRdWVyeSBvYmplY3QgdG8gdGhlIGJ1dHRvbk1hcmt1cCBjbGFzc2VzXG4vLyBpdCBjYWxjdWxhdGVzIGJhc2VkIG9uIHRoZSBvcHRpb25zIHBhc3NlZCBpbi5cbi8vXG4vLyBJZiB5b3Ugd2lzaCB0byBwcmVzZXJ2ZSBhbnkgY2xhc3NlcyB0aGF0IGFyZSBhbHJlYWR5IHByZXNlbnQgb24gdGhlIGVsZW1lbnRzXG4vLyBpbnNpZGUgdGhlIGpRdWVyeSBvYmplY3QsIGluY2x1ZGluZyBidXR0b25NYXJrdXAtcmVsYXRlZCBjbGFzc2VzIHRoYXQgd2VyZVxuLy8gYWRkZWQgYnkgYSBwcmV2aW91cyBjYWxsIHRvICQuZm4uYnV0dG9uTWFya3VwKCkgb3IgZHVyaW5nIHBhZ2UgZW5oYW5jZW1lbnRcbi8vIHRoZW4geW91IHNob3VsZCBvbWl0IEBvdmVyd3JpdGVDbGFzc2VzIG9yIHNldCBpdCB0byBmYWxzZS5cbiQuZm4uYnV0dG9uTWFya3VwID0gZnVuY3Rpb24oIG9wdGlvbnMsIG92ZXJ3cml0ZUNsYXNzZXMgKSB7XG5cdHZhciBpZHgsIGRhdGEsIGVsLCByZXRyaWV2ZWRPcHRpb25zLCBvcHRpb25LZXksXG5cdFx0ZGVmYXVsdHMgPSAkLmZuLmJ1dHRvbk1hcmt1cC5kZWZhdWx0cztcblxuXHRmb3IgKCBpZHggPSAwIDsgaWR4IDwgdGhpcy5sZW5ndGggOyBpZHgrKyApIHtcblx0XHRlbCA9IHRoaXNbIGlkeCBdO1xuXHRcdGRhdGEgPSBvdmVyd3JpdGVDbGFzc2VzID9cblxuXHRcdFx0Ly8gQXNzdW1lIHRoaXMgZWxlbWVudCBpcyBub3QgZW5oYW5jZWQgYW5kIGlnbm9yZSBpdHMgY2xhc3Nlc1xuXHRcdFx0eyBhbHJlYWR5RW5oYW5jZWQ6IGZhbHNlLCB1bmtub3duQ2xhc3NlczogW10gfSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBhbmFseXplIGV4aXN0aW5nIGNsYXNzZXMgdG8gZXN0YWJsaXNoIGV4aXN0aW5nIG9wdGlvbnMgYW5kXG5cdFx0XHQvLyBjbGFzc2VzXG5cdFx0XHRjbGFzc05hbWVUb09wdGlvbnMoIGVsLmNsYXNzTmFtZSApO1xuXG5cdFx0cmV0cmlldmVkT3B0aW9ucyA9ICQuZXh0ZW5kKCB7fSxcblxuXHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgYWxyZWFkeSBoYXMgdGhlIGNsYXNzIHVpLWJ0biwgdGhlbiB3ZSBhc3N1bWUgdGhhdFxuXHRcdFx0Ly8gaXQgaGFzIHBhc3NlZCB0aHJvdWdoIGJ1dHRvbk1hcmt1cCBiZWZvcmUgLSBvdGhlcndpc2UsIHRoZSBvcHRpb25zXG5cdFx0XHQvLyByZXR1cm5lZCBieSBjbGFzc05hbWVUb09wdGlvbnMgZG8gbm90IGNvcnJlY3RseSByZWZsZWN0IHRoZSBzdGF0ZSBvZlxuXHRcdFx0Ly8gdGhlIGVsZW1lbnRcblx0XHRcdCggZGF0YS5hbHJlYWR5RW5oYW5jZWQgPyBkYXRhLm9wdGlvbnMgOiB7fSApLFxuXG5cdFx0XHQvLyBGaW5hbGx5LCBhcHBseSB0aGUgb3B0aW9ucyBwYXNzZWQgaW5cblx0XHRcdG9wdGlvbnMgKTtcblxuXHRcdC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwgb24gdGhpcyBlbGVtZW50LCByZXRyaWV2ZSByZW1haW5pbmcgb3B0aW9uc1xuXHRcdC8vIGZyb20gdGhlIGRhdGEtYXR0cmlidXRlc1xuXHRcdGlmICggIWRhdGEuYWxyZWFkeUVuaGFuY2VkICkge1xuXHRcdFx0Zm9yICggb3B0aW9uS2V5IGluIGRlZmF1bHRzICkge1xuXHRcdFx0XHRpZiAoIHJldHJpZXZlZE9wdGlvbnNbIG9wdGlvbktleSBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0cmlldmVkT3B0aW9uc1sgb3B0aW9uS2V5IF0gPSBnZXRBdHRyRml4ZWQoIGVsLFxuXHRcdFx0XHRcdFx0b3B0aW9uS2V5LnJlcGxhY2UoIGNhcGl0YWxMZXR0ZXJzUkUsIGNhbWVsQ2FzZTJIeXBoZW5hdGVkIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZWwuY2xhc3NOYW1lID0gb3B0aW9uc1RvQ2xhc3NlcyhcblxuXHRcdFx0Ly8gTWVyZ2UgYWxsIHRoZSBvcHRpb25zIGFuZCBhcHBseSB0aGVtIGFzIGNsYXNzZXNcblx0XHRcdCQuZXh0ZW5kKCB7fSxcblxuXHRcdFx0XHQvLyBUaGUgZGVmYXVsdHMgZm9ybSB0aGUgYmFzaXNcblx0XHRcdFx0ZGVmYXVsdHMsXG5cblx0XHRcdFx0Ly8gQWRkIHRoZSBjb21wdXRlZCBvcHRpb25zXG5cdFx0XHRcdHJldHJpZXZlZE9wdGlvbnNcblx0XHRcdCksXG5cblx0XHRcdC8vIC4uLiBhbmQgcmUtYXBwbHkgYW55IHVucmVjb2duaXplZCBjbGFzc2VzIHRoYXQgd2VyZSBmb3VuZFxuXHRcdFx0ZGF0YS51bmtub3duQ2xhc3NlcyApLmpvaW4oIFwiIFwiICk7XG5cdFx0aWYgKCBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiYnV0dG9uXCIgKSB7XG5cdFx0XHRlbC5zZXRBdHRyaWJ1dGUoIFwicm9sZVwiLCBcImJ1dHRvblwiICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vLyBidXR0b25NYXJrdXAgZGVmYXVsdHMuIFRoaXMgbXVzdCBiZSBhIGNvbXBsZXRlIHNldCwgaS5lLiwgYSB2YWx1ZSBtdXN0IGJlXG4vLyBnaXZlbiBoZXJlIGZvciBhbGwgcmVjb2duaXplZCBvcHRpb25zXG4kLmZuLmJ1dHRvbk1hcmt1cC5kZWZhdWx0cyA9IHtcblx0aWNvbjogXCJcIixcblx0aWNvbnBvczogXCJsZWZ0XCIsXG5cdHRoZW1lOiBudWxsLFxuXHRpbmxpbmU6IGZhbHNlLFxuXHRzaGFkb3c6IHRydWUsXG5cdGNvcm5lcnM6IHRydWUsXG5cdGljb25zaGFkb3c6IGZhbHNlLCAvKiBUT0RPOiBSZW1vdmUgaW4gMS41LiBPcHRpb24gZGVwcmVjYXRlZCBpbiAxLjQuICovXG5cdG1pbmk6IGZhbHNlXG59O1xuXG4kLmV4dGVuZCggJC5mbi5idXR0b25NYXJrdXAsIHtcblx0aW5pdFNlbGVjdG9yOiBcImE6anFtRGF0YShyb2xlPSdidXR0b24nKSwgLnVpLWJhciA+IGEsIC51aS1iYXIgPiA6anFtRGF0YShyb2xlPSdjb250cm9sZ3JvdXAnKSA+IGEsIGJ1dHRvblwiXG59KTtcblxufSkoIGpRdWVyeSApO1xuXG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLndpZGdldCggXCJtb2JpbGUuY29udHJvbGdyb3VwXCIsICQuZXh0ZW5kKCB7XG5cdG9wdGlvbnM6IHtcblx0XHRlbmhhbmNlZDogZmFsc2UsXG5cdFx0dGhlbWU6IG51bGwsXG5cdFx0c2hhZG93OiBmYWxzZSxcblx0XHRjb3JuZXJzOiB0cnVlLFxuXHRcdGV4Y2x1ZGVJbnZpc2libGU6IHRydWUsXG5cdFx0dHlwZTogXCJ2ZXJ0aWNhbFwiLFxuXHRcdG1pbmk6IGZhbHNlXG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzLmVsZW1lbnQsXG5cdFx0XHRvcHRzID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0Ly8gUnVuIGJ1dHRvbm1hcmt1cFxuXHRcdGlmICggJC5mbi5idXR0b25NYXJrdXAgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCggJC5mbi5idXR0b25NYXJrdXAuaW5pdFNlbGVjdG9yICkuYnV0dG9uTWFya3VwKCk7XG5cdFx0fVxuXHRcdC8vIEVuaGFuY2UgY2hpbGQgd2lkZ2V0c1xuXHRcdCQuZWFjaCggdGhpcy5fY2hpbGRXaWRnZXRzLCAkLnByb3h5KCBmdW5jdGlvbiggbnVtYmVyLCB3aWRnZXROYW1lICkge1xuXHRcdFx0aWYgKCAkLm1vYmlsZVsgd2lkZ2V0TmFtZSBdICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZCggJC5tb2JpbGVbIHdpZGdldE5hbWUgXS5pbml0U2VsZWN0b3IgKS5ub3QoICQubW9iaWxlLnBhZ2UucHJvdG90eXBlLmtlZXBOYXRpdmVTZWxlY3RvcigpIClbIHdpZGdldE5hbWUgXSgpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMgKSk7XG5cblx0XHQkLmV4dGVuZCggdGhpcywge1xuXHRcdFx0X3VpOiBudWxsLFxuXHRcdFx0X2luaXRpYWxSZWZyZXNoOiB0cnVlXG5cdFx0fSk7XG5cblx0XHRpZiAoIG9wdHMuZW5oYW5jZWQgKSB7XG5cdFx0XHR0aGlzLl91aSA9IHtcblx0XHRcdFx0Z3JvdXBMZWdlbmQ6IGVsZW0uY2hpbGRyZW4oIFwiLnVpLWNvbnRyb2xncm91cC1sYWJlbFwiICkuY2hpbGRyZW4oKSxcblx0XHRcdFx0Y2hpbGRXcmFwcGVyOiBlbGVtLmNoaWxkcmVuKCBcIi51aS1jb250cm9sZ3JvdXAtY29udHJvbHNcIiApXG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl91aSA9IHRoaXMuX2VuaGFuY2UoKTtcblx0XHR9XG5cblx0fSxcblxuXHRfY2hpbGRXaWRnZXRzOiBbIFwiY2hlY2tib3hyYWRpb1wiLCBcInNlbGVjdG1lbnVcIiwgXCJidXR0b25cIiBdLFxuXG5cdF90aGVtZUNsYXNzRnJvbU9wdGlvbjogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiAoIHZhbHVlID8gKCB2YWx1ZSA9PT0gXCJub25lXCIgPyBcIlwiIDogXCJ1aS1ncm91cC10aGVtZS1cIiArIHZhbHVlICkgOiBcIlwiICk7XG5cdH0sXG5cblx0X2VuaGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0b3B0cyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdHVpID0ge1xuXHRcdFx0XHRncm91cExlZ2VuZDogZWxlbS5jaGlsZHJlbiggXCJsZWdlbmRcIiApLFxuXHRcdFx0XHRjaGlsZFdyYXBwZXI6IGVsZW1cblx0XHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktY29udHJvbGdyb3VwIFwiICtcblx0XHRcdFx0XHRcdFwidWktY29udHJvbGdyb3VwLVwiICtcblx0XHRcdFx0XHRcdFx0KCBvcHRzLnR5cGUgPT09IFwiaG9yaXpvbnRhbFwiID8gXCJob3Jpem9udGFsXCIgOiBcInZlcnRpY2FsXCIgKSArIFwiIFwiICtcblx0XHRcdFx0XHRcdHRoaXMuX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKCBvcHRzLnRoZW1lICkgKyBcIiBcIiArXG5cdFx0XHRcdFx0XHQoIG9wdHMuY29ybmVycyA/IFwidWktY29ybmVyLWFsbCBcIiA6IFwiXCIgKSArXG5cdFx0XHRcdFx0XHQoIG9wdHMubWluaSA/IFwidWktbWluaSBcIiA6IFwiXCIgKSApXG5cdFx0XHRcdFx0LndyYXBJbm5lciggXCI8ZGl2IFwiICtcblx0XHRcdFx0XHRcdFwiY2xhc3M9J3VpLWNvbnRyb2xncm91cC1jb250cm9scyBcIiArXG5cdFx0XHRcdFx0XHRcdCggb3B0cy5zaGFkb3cgPT09IHRydWUgPyBcInVpLXNoYWRvd1wiIDogXCJcIiApICsgXCInPjwvZGl2PlwiIClcblx0XHRcdFx0XHQuY2hpbGRyZW4oKVxuXHRcdFx0fTtcblxuXHRcdGlmICggdWkuZ3JvdXBMZWdlbmQubGVuZ3RoID4gMCApIHtcblx0XHRcdCQoIFwiPGRpdiByb2xlPSdoZWFkaW5nJyBjbGFzcz0ndWktY29udHJvbGdyb3VwLWxhYmVsJz48L2Rpdj5cIiApXG5cdFx0XHRcdC5hcHBlbmQoIHVpLmdyb3VwTGVnZW5kIClcblx0XHRcdFx0LnByZXBlbmRUbyggZWxlbSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB1aTtcblx0fSxcblxuXHRfaW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZWZyZXNoKCk7XG5cdH0sXG5cblx0X3NldE9wdGlvbnM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBjYWxsUmVmcmVzaCwgcmV0dXJuVmFsdWUsXG5cdFx0XHRlbGVtID0gdGhpcy5lbGVtZW50O1xuXG5cdFx0Ly8gTXVzdCBoYXZlIG9uZSBvZiBob3Jpem9udGFsIG9yIHZlcnRpY2FsXG5cdFx0aWYgKCBvcHRpb25zLnR5cGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGVsZW1cblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWNvbnRyb2xncm91cC1ob3Jpem9udGFsIHVpLWNvbnRyb2xncm91cC12ZXJ0aWNhbFwiIClcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWNvbnRyb2xncm91cC1cIiArICggb3B0aW9ucy50eXBlID09PSBcImhvcml6b250YWxcIiA/IFwiaG9yaXpvbnRhbFwiIDogXCJ2ZXJ0aWNhbFwiICkgKTtcblx0XHRcdGNhbGxSZWZyZXNoID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudGhlbWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGVsZW1cblx0XHRcdFx0LnJlbW92ZUNsYXNzKCB0aGlzLl90aGVtZUNsYXNzRnJvbU9wdGlvbiggdGhpcy5vcHRpb25zLnRoZW1lICkgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIHRoaXMuX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKCBvcHRpb25zLnRoZW1lICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMuY29ybmVycyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0ZWxlbS50b2dnbGVDbGFzcyggXCJ1aS1jb3JuZXItYWxsXCIsIG9wdGlvbnMuY29ybmVycyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy5taW5pICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRlbGVtLnRvZ2dsZUNsYXNzKCBcInVpLW1pbmlcIiwgb3B0aW9ucy5taW5pICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnNoYWRvdyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5fdWkuY2hpbGRXcmFwcGVyLnRvZ2dsZUNsYXNzKCBcInVpLXNoYWRvd1wiLCBvcHRpb25zLnNoYWRvdyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy5leGNsdWRlSW52aXNpYmxlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuZXhjbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuZXhjbHVkZUludmlzaWJsZTtcblx0XHRcdGNhbGxSZWZyZXNoID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm5WYWx1ZSA9IHRoaXMuX3N1cGVyKCBvcHRpb25zICk7XG5cblx0XHRpZiAoIGNhbGxSZWZyZXNoICkge1xuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHR9LFxuXG5cdGNvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3VpLmNoaWxkV3JhcHBlcjtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgJGVsID0gdGhpcy5jb250YWluZXIoKSxcblx0XHRcdGVscyA9ICRlbC5maW5kKCBcIi51aS1idG5cIiApLm5vdCggXCIudWktc2xpZGVyLWhhbmRsZVwiICksXG5cdFx0XHRjcmVhdGUgPSB0aGlzLl9pbml0aWFsUmVmcmVzaDtcblx0XHRpZiAoICQubW9iaWxlLmNoZWNrYm94cmFkaW8gKSB7XG5cdFx0XHQkZWwuZmluZCggXCI6bW9iaWxlLWNoZWNrYm94cmFkaW9cIiApLmNoZWNrYm94cmFkaW8oIFwicmVmcmVzaFwiICk7XG5cdFx0fVxuXHRcdHRoaXMuX2FkZEZpcnN0TGFzdENsYXNzZXMoIGVscyxcblx0XHRcdHRoaXMub3B0aW9ucy5leGNsdWRlSW52aXNpYmxlID8gdGhpcy5fZ2V0VmlzaWJsZXMoIGVscywgY3JlYXRlICkgOiBlbHMsXG5cdFx0XHRjcmVhdGUgKTtcblx0XHR0aGlzLl9pbml0aWFsUmVmcmVzaCA9IGZhbHNlO1xuXHR9LFxuXG5cdC8vIENhdmVhdDogSWYgdGhlIGxlZ2VuZCBpcyBub3QgdGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBjb250cm9sZ3JvdXAgYXQgZW5oYW5jZVxuXHQvLyB0aW1lLCBpdCB3aWxsIGJlIGFmdGVyIF9kZXN0cm95KCkuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdWksIGJ1dHRvbnMsXG5cdFx0XHRvcHRzID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKCBvcHRzLmVuaGFuY2VkICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dWkgPSB0aGlzLl91aTtcblx0XHRidXR0b25zID0gdGhpcy5lbGVtZW50XG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktY29udHJvbGdyb3VwIFwiICtcblx0XHRcdFx0XCJ1aS1jb250cm9sZ3JvdXAtaG9yaXpvbnRhbCB1aS1jb250cm9sZ3JvdXAtdmVydGljYWwgdWktY29ybmVyLWFsbCB1aS1taW5pIFwiICtcblx0XHRcdFx0dGhpcy5fdGhlbWVDbGFzc0Zyb21PcHRpb24oIG9wdHMudGhlbWUgKSApXG5cdFx0XHQuZmluZCggXCIudWktYnRuXCIgKVxuXHRcdFx0Lm5vdCggXCIudWktc2xpZGVyLWhhbmRsZVwiICk7XG5cblx0XHR0aGlzLl9yZW1vdmVGaXJzdExhc3RDbGFzc2VzKCBidXR0b25zICk7XG5cblx0XHR1aS5ncm91cExlZ2VuZC51bndyYXAoKTtcblx0XHR1aS5jaGlsZFdyYXBwZXIuY2hpbGRyZW4oKS51bndyYXAoKTtcblx0fVxufSwgJC5tb2JpbGUuYmVoYXZpb3JzLmFkZEZpcnN0TGFzdENsYXNzZXMgKSApO1xuXG59KShqUXVlcnkpO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuXHQkLndpZGdldCggXCJtb2JpbGUudG9vbGJhclwiLCB7XG5cdFx0aW5pdFNlbGVjdG9yOiBcIjpqcW1EYXRhKHJvbGU9J2Zvb3RlcicpLCA6anFtRGF0YShyb2xlPSdoZWFkZXInKVwiLFxuXG5cdFx0b3B0aW9uczoge1xuXHRcdFx0dGhlbWU6IG51bGwsXG5cdFx0XHRhZGRCYWNrQnRuOiBmYWxzZSxcblx0XHRcdGJhY2tCdG5UaGVtZTogbnVsbCxcblx0XHRcdGJhY2tCdG5UZXh0OiBcIkJhY2tcIlxuXHRcdH0sXG5cblx0XHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBsZWZ0YnRuLCByaWdodGJ0bixcblx0XHRcdFx0cm9sZSA9ICB0aGlzLmVsZW1lbnQuaXMoIFwiOmpxbURhdGEocm9sZT0naGVhZGVyJylcIiApID8gXCJoZWFkZXJcIiA6IFwiZm9vdGVyXCIsXG5cdFx0XHRcdHBhZ2UgPSB0aGlzLmVsZW1lbnQuY2xvc2VzdCggXCIudWktcGFnZVwiICk7XG5cdFx0XHRpZiAoIHBhZ2UubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHRwYWdlID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX29uKCB0aGlzLmRvY3VtZW50LCB7XG5cdFx0XHRcdFx0XCJwYWdlc2hvd1wiOiBcInJlZnJlc2hcIlxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdCQuZXh0ZW5kKCB0aGlzLCB7XG5cdFx0XHRcdHJvbGU6IHJvbGUsXG5cdFx0XHRcdHBhZ2U6IHBhZ2UsXG5cdFx0XHRcdGxlZnRidG46IGxlZnRidG4sXG5cdFx0XHRcdHJpZ2h0YnRuOiByaWdodGJ0blxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYXR0ciggXCJyb2xlXCIsIHJvbGUgPT09IFwiaGVhZGVyXCIgPyBcImJhbm5lclwiIDogXCJjb250ZW50aW5mb1wiICkuYWRkQ2xhc3MoIFwidWktXCIgKyByb2xlICk7XG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHRcdHRoaXMuX3NldE9wdGlvbnMoIHRoaXMub3B0aW9ucyApO1xuXHRcdH0sXG5cdFx0X3NldE9wdGlvbnM6IGZ1bmN0aW9uKCBvICkge1xuXHRcdFx0aWYgKCBvLmFkZEJhY2tCdG4gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlQmFja0J1dHRvbigpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvLmJhY2tCdG5UaGVtZSAhPSBudWxsICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0XHQuZmluZCggXCIudWktdG9vbGJhci1iYWNrLWJ0blwiIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktYnRuIHVpLWJ0bi1cIiArIG8uYmFja0J0blRoZW1lICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG8uYmFja0J0blRleHQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoIFwiLnVpLXRvb2xiYXItYmFjay1idG4gLnVpLWJ0bi10ZXh0XCIgKS50ZXh0KCBvLmJhY2tCdG5UZXh0ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG8udGhlbWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dmFyIGN1cnJlbnRUaGVtZSA9IHRoaXMub3B0aW9ucy50aGVtZSA/IHRoaXMub3B0aW9ucy50aGVtZSA6IFwiaW5oZXJpdFwiLFxuXHRcdFx0XHRcdG5ld1RoZW1lID0gby50aGVtZSA/IG8udGhlbWUgOiBcImluaGVyaXRcIjtcblxuXHRcdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoIFwidWktYmFyLVwiICsgY3VycmVudFRoZW1lICkuYWRkQ2xhc3MoIFwidWktYmFyLVwiICsgbmV3VGhlbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc3VwZXIoIG8gKTtcblx0XHR9LFxuXHRcdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCB0aGlzLnJvbGUgPT09IFwiaGVhZGVyXCIgKSB7XG5cdFx0XHRcdHRoaXMuX2FkZEhlYWRlckJ1dHRvbkNsYXNzZXMoKTtcblx0XHRcdH1cblx0XHRcdGlmICggIXRoaXMucGFnZSApIHtcblx0XHRcdFx0dGhpcy5fc2V0UmVsYXRpdmUoKTtcblx0XHRcdFx0aWYgKCB0aGlzLnJvbGUgPT09IFwiZm9vdGVyXCIgKSB7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50LmFwcGVuZFRvKCBcImJvZHlcIiApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnJvbGUgPT09IFwiaGVhZGVyXCIgKSB7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlQmFja0J1dHRvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9hZGRIZWFkaW5nQ2xhc3NlcygpO1xuXHRcdFx0dGhpcy5fYnRuTWFya3VwKCk7XG5cdFx0fSxcblxuXHRcdC8vd2Ugb25seSB3YW50IHRoaXMgdG8gcnVuIG9uIG5vbiBmaXhlZCB0b29sYmFycyBzbyBtYWtlIGl0IGVhc3kgdG8gb3ZlcnJpZGVcblx0XHRfc2V0UmVsYXRpdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0JCggXCJbZGF0YS1cIisgJC5tb2JpbGUubnMgKyBcInJvbGU9J3BhZ2UnXVwiICkuY3NzKHsgXCJwb3NpdGlvblwiOiBcInJlbGF0aXZlXCIgfSk7XG5cdFx0fSxcblxuXHRcdC8vIERlcHJlY2F0ZWQgaW4gMS40LiBBcyBmcm9tIDEuNSBidXR0b24gY2xhc3NlcyBoYXZlIHRvIGJlIHByZXNlbnQgaW4gdGhlIG1hcmt1cC5cblx0XHRfYnRuTWFya3VwOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHQuY2hpbGRyZW4oIFwiYVwiIClcblx0XHRcdFx0LmZpbHRlciggXCI6bm90KFtkYXRhLVwiICsgJC5tb2JpbGUubnMgKyBcInJvbGU9J25vbmUnXSlcIiApXG5cdFx0XHRcdC5hdHRyKCBcImRhdGEtXCIgKyAkLm1vYmlsZS5ucyArIFwicm9sZVwiLCBcImJ1dHRvblwiICk7XG5cdFx0XHR0aGlzLmVsZW1lbnQudHJpZ2dlciggXCJjcmVhdGVcIiApO1xuXHRcdH0sXG5cdFx0Ly8gRGVwcmVjYXRlZCBpbiAxLjQuIEFzIGZyb20gMS41IHVpLWJ0bi1sZWZ0L3JpZ2h0IGNsYXNzZXMgaGF2ZSB0byBiZSBwcmVzZW50IGluIHRoZSBtYXJrdXAuXG5cdFx0X2FkZEhlYWRlckJ1dHRvbkNsYXNzZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhlYWRlckFuY2hvcnMgPSB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oIFwiYSwgYnV0dG9uXCIgKTtcblxuXHRcdFx0Ly8gRG8gbm90IG1pc3Rha2UgYSBiYWNrIGJ1dHRvbiBmb3IgYSBsZWZ0IHRvb2xiYXIgYnV0dG9uXG5cdFx0XHR0aGlzLmxlZnRidG4gPSBoZWFkZXJBbmNob3JzLmhhc0NsYXNzKCBcInVpLWJ0bi1sZWZ0XCIgKSAmJlxuXHRcdFx0XHQhaGVhZGVyQW5jaG9ycy5oYXNDbGFzcyggXCJ1aS10b29sYmFyLWJhY2stYnRuXCIgKTtcblxuXHRcdFx0dGhpcy5yaWdodGJ0biA9IGhlYWRlckFuY2hvcnMuaGFzQ2xhc3MoIFwidWktYnRuLXJpZ2h0XCIgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCByaWdodCBidXR0b25zIGFuZCBiYWNrIGJ1dHRvbnNcblx0XHRcdHRoaXMubGVmdGJ0biA9IHRoaXMubGVmdGJ0biB8fFxuXHRcdFx0XHRoZWFkZXJBbmNob3JzLmVxKCAwIClcblx0XHRcdFx0XHQubm90KCBcIi51aS1idG4tcmlnaHQsLnVpLXRvb2xiYXItYmFjay1idG5cIiApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWJ0bi1sZWZ0XCIgKVxuXHRcdFx0XHRcdC5sZW5ndGg7XG5cblx0XHRcdHRoaXMucmlnaHRidG4gPSB0aGlzLnJpZ2h0YnRuIHx8IGhlYWRlckFuY2hvcnMuZXEoIDEgKS5hZGRDbGFzcyggXCJ1aS1idG4tcmlnaHRcIiApLmxlbmd0aDtcblx0XHR9LFxuXHRcdF91cGRhdGVCYWNrQnV0dG9uOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBiYWNrQnV0dG9uLFxuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHR0aGVtZSA9IG9wdGlvbnMuYmFja0J0blRoZW1lIHx8IG9wdGlvbnMudGhlbWU7XG5cblx0XHRcdC8vIFJldHJpZXZlIHRoZSBiYWNrIGJ1dHRvbiBvciBjcmVhdGUgYSBuZXcsIGVtcHR5IG9uZVxuXHRcdFx0YmFja0J1dHRvbiA9IHRoaXMuX2JhY2tCdXR0b24gPSAoIHRoaXMuX2JhY2tCdXR0b24gfHwge30gKTtcblxuXHRcdFx0Ly8gV2UgYWRkIGEgYmFjayBidXR0b24gb25seSBpZiB0aGUgb3B0aW9uIHRvIGRvIHNvIGlzIG9uXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5hZGRCYWNrQnRuICYmXG5cblx0XHRcdFx0XHQvLyBUaGlzIG11c3QgYWxzbyBiZSBhIGhlYWRlciB0b29sYmFyXG5cdFx0XHRcdFx0dGhpcy5yb2xlID09PSBcImhlYWRlclwiICYmXG5cblx0XHRcdFx0XHQvLyBUaGVyZSBtdXN0IGJlIG11bHRpcGxlIHBhZ2VzIGluIHRoZSBET01cblx0XHRcdFx0XHQkKCBcIi51aS1wYWdlXCIgKS5sZW5ndGggPiAxICYmXG5cdFx0XHRcdFx0KCB0aGlzLnBhZ2UgP1xuXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgdG9vbGJhciBpcyBpbnRlcm5hbCB0aGUgcGFnZSdzIFVSTCBtdXN0IGRpZmZlciBmcm9tIHRoZSBoYXNoXG5cdFx0XHRcdFx0XHQoIHRoaXMucGFnZVsgMCBdLmdldEF0dHJpYnV0ZSggXCJkYXRhLVwiICsgJC5tb2JpbGUubnMgKyBcInVybFwiICkgIT09XG5cdFx0XHRcdFx0XHRcdCQubW9iaWxlLnBhdGguc3RyaXBIYXNoKCBsb2NhdGlvbi5oYXNoICkgKSA6XG5cblx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaWYgdGhlIHRvb2xiYXIgaXMgZXh0ZXJuYWwgdGhlcmUgbXVzdCBiZSBhdCBsZWFzdCBvbmVcblx0XHRcdFx0XHRcdC8vIGhpc3RvcnkgaXRlbSB0byB3aGljaCBvbmUgY2FuIGdvIGJhY2tcblx0XHRcdFx0XHRcdCggJC5tb2JpbGUubmF2aWdhdGUgJiYgJC5tb2JpbGUubmF2aWdhdGUuaGlzdG9yeSAmJlxuXHRcdFx0XHRcdFx0XHQkLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5LmFjdGl2ZUluZGV4ID4gMCApICkgJiZcblxuXHRcdFx0XHRcdC8vIFRoZSB0b29sYmFyIGRvZXMgbm90IGhhdmUgYSBsZWZ0IGJ1dHRvblxuXHRcdFx0XHRcdCF0aGlzLmxlZnRidG4gKSB7XG5cblx0XHRcdFx0Ly8gU2tpcCBiYWNrIGJ1dHRvbiBjcmVhdGlvbiBpZiBvbmUgaXMgYWxyZWFkeSBwcmVzZW50XG5cdFx0XHRcdGlmICggIWJhY2tCdXR0b24uYXR0YWNoZWQgKSB7XG5cdFx0XHRcdFx0YmFja0J1dHRvbi5lbGVtZW50ID0gKCBiYWNrQnV0dG9uLmVsZW1lbnQgfHxcblx0XHRcdFx0XHRcdCQoIFwiPGEgcm9sZT0nYnV0dG9uJyBocmVmPSdqYXZhc2NyaXB0OnZvaWQoMCk7JyBcIiArXG5cdFx0XHRcdFx0XHRcdFwiY2xhc3M9J3VpLWJ0biB1aS1jb3JuZXItYWxsIHVpLXNoYWRvdyB1aS1idG4tbGVmdCBcIiArXG5cdFx0XHRcdFx0XHRcdFx0KCB0aGVtZSA/IFwidWktYnRuLVwiICsgdGhlbWUgKyBcIiBcIiA6IFwiXCIgKSArXG5cdFx0XHRcdFx0XHRcdFx0XCJ1aS10b29sYmFyLWJhY2stYnRuIHVpLWljb24tY2FyYXQtbCB1aS1idG4taWNvbi1sZWZ0JyBcIiArXG5cdFx0XHRcdFx0XHRcdFwiZGF0YS1cIiArICQubW9iaWxlLm5zICsgXCJyZWw9J2JhY2snPlwiICsgb3B0aW9ucy5iYWNrQnRuVGV4dCArXG5cdFx0XHRcdFx0XHRcdFwiPC9hPlwiICkgKVxuXHRcdFx0XHRcdFx0XHQucHJlcGVuZFRvKCB0aGlzLmVsZW1lbnQgKTtcblx0XHRcdFx0XHRiYWNrQnV0dG9uLmF0dGFjaGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB3ZSBhcmUgbm90IGFkZGluZyBhIGJhY2sgYnV0dG9uLCB0aGVuIHJlbW92ZSB0aGUgb25lIHByZXNlbnQsIGlmIGFueVxuXHRcdFx0fSBlbHNlIGlmICggYmFja0J1dHRvbi5lbGVtZW50ICkge1xuXHRcdFx0XHRiYWNrQnV0dG9uLmVsZW1lbnQuZGV0YWNoKCk7XG5cdFx0XHRcdGJhY2tCdXR0b24uYXR0YWNoZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdF9hZGRIZWFkaW5nQ2xhc3NlczogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuY2hpbGRyZW4oIFwiaDEsIGgyLCBoMywgaDQsIGg1LCBoNlwiIClcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLXRpdGxlXCIgKVxuXHRcdFx0XHQvLyBSZWdhcmRsZXNzIG9mIGggZWxlbWVudCBudW1iZXIgaW4gc3JjLCBpdCBiZWNvbWVzIGgxIGZvciB0aGUgZW5oYW5jZWQgcGFnZVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XCJyb2xlXCI6IFwiaGVhZGluZ1wiLFxuXHRcdFx0XHRcdFwiYXJpYS1sZXZlbFwiOiBcIjFcIlxuXHRcdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xuXG59KSggalF1ZXJ5ICk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG5cdCQud2lkZ2V0KCBcIm1vYmlsZS50b29sYmFyXCIsICQubW9iaWxlLnRvb2xiYXIsIHtcblx0XHRvcHRpb25zOiB7XG5cdFx0XHRwb3NpdGlvbjpudWxsLFxuXHRcdFx0dmlzaWJsZU9uUGFnZVNob3c6IHRydWUsXG5cdFx0XHRkaXNhYmxlUGFnZVpvb206IHRydWUsXG5cdFx0XHR0cmFuc2l0aW9uOiBcInNsaWRlXCIsIC8vY2FuIGJlIG5vbmUsIGZhZGUsIHNsaWRlIChzbGlkZSBtYXBzIHRvIHNsaWRldXAgb3Igc2xpZGVkb3duKVxuXHRcdFx0ZnVsbHNjcmVlbjogZmFsc2UsXG5cdFx0XHR0YXBUb2dnbGU6IHRydWUsXG5cdFx0XHR0YXBUb2dnbGVCbGFja2xpc3Q6IFwiYSwgYnV0dG9uLCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgLnVpLWhlYWRlci1maXhlZCwgLnVpLWZvb3Rlci1maXhlZCwgLnVpLWZsaXBzd2l0Y2gsIC51aS1wb3B1cCwgLnVpLXBhbmVsLCAudWktcGFuZWwtZGlzbWlzcy1vcGVuXCIsXG5cdFx0XHRoaWRlRHVyaW5nRm9jdXM6IFwiaW5wdXQsIHRleHRhcmVhLCBzZWxlY3RcIixcblx0XHRcdHVwZGF0ZVBhZ2VQYWRkaW5nOiB0cnVlLFxuXHRcdFx0dHJhY2tQZXJzaXN0ZW50VG9vbGJhcnM6IHRydWUsXG5cblx0XHRcdC8vIEJyb3dzZXIgZGV0ZWN0aW9uISBXZWVlZSwgaGVyZSB3ZSBnby4uLlxuXHRcdFx0Ly8gVW5mb3J0dW5hdGVseSwgcG9zaXRpb246Zml4ZWQgaXMgY29zdGx5LCBub3QgdG8gbWVudGlvbiBwcm9iYWJseSBpbXBvc3NpYmxlLCB0byBmZWF0dXJlLWRldGVjdCBhY2N1cmF0ZWx5LlxuXHRcdFx0Ly8gU29tZSB0ZXN0cyBleGlzdCwgYnV0IHRoZXkgY3VycmVudGx5IHJldHVybiBmYWxzZSByZXN1bHRzIGluIGNyaXRpY2FsIGRldmljZXMgYW5kIGJyb3dzZXJzLCB3aGljaCBjb3VsZCBsZWFkIHRvIGEgYnJva2VuIGV4cGVyaWVuY2UuXG5cdFx0XHQvLyBUZXN0aW5nIGZpeGVkIHBvc2l0aW9uaW5nIGlzIGFsc28gcHJldHR5IG9idHJ1c2l2ZSB0byBwYWdlIGxvYWQsIHJlcXVpcmluZyBpbmplY3RlZCBlbGVtZW50cyBhbmQgc2Nyb2xsaW5nIHRoZSB3aW5kb3dcblx0XHRcdC8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gc2VydmVzIHRvIHJ1bGUgb3V0IHNvbWUgcG9wdWxhciBicm93c2VycyB3aXRoIGtub3duIGZpeGVkLXBvc2l0aW9uaW5nIGlzc3Vlc1xuXHRcdFx0Ly8gVGhpcyBpcyBhIHBsdWdpbiBvcHRpb24gbGlrZSBhbnkgb3RoZXIsIHNvIGZlZWwgZnJlZSB0byBpbXByb3ZlIG9yIG92ZXJ3cml0ZSBpdFxuXHRcdFx0c3VwcG9ydEJsYWNrbGlzdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhJC5zdXBwb3J0LmZpeGVkUG9zaXRpb247XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSBcImZpeGVkXCIgJiYgIXRoaXMub3B0aW9ucy5zdXBwb3J0QmxhY2tsaXN0KCkgKSB7XG5cdFx0XHRcdHRoaXMuX21ha2VGaXhlZCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfbWFrZUZpeGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyggXCJ1aS1cIisgdGhpcy5yb2xlICtcIi1maXhlZFwiICk7XG5cdFx0XHR0aGlzLnVwZGF0ZVBhZ2VQYWRkaW5nKCk7XG5cdFx0XHR0aGlzLl9hZGRUcmFuc2l0aW9uQ2xhc3MoKTtcblx0XHRcdHRoaXMuX2JpbmRQYWdlRXZlbnRzKCk7XG5cdFx0XHR0aGlzLl9iaW5kVG9nZ2xlSGFuZGxlcnMoKTtcblx0XHR9LFxuXG5cdFx0X3NldE9wdGlvbnM6IGZ1bmN0aW9uKCBvICkge1xuXHRcdFx0aWYgKCBvLnBvc2l0aW9uID09PSBcImZpeGVkXCIgJiYgdGhpcy5vcHRpb25zLnBvc2l0aW9uICE9PSBcImZpeGVkXCIgKSB7XG5cdFx0XHRcdHRoaXMuX21ha2VGaXhlZCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09IFwiZml4ZWRcIiAmJiAhdGhpcy5vcHRpb25zLnN1cHBvcnRCbGFja2xpc3QoKSApIHtcblx0XHRcdFx0dmFyICRwYWdlID0gKCAhIXRoaXMucGFnZSApPyB0aGlzLnBhZ2U6ICggJChcIi51aS1wYWdlLWFjdGl2ZVwiKS5sZW5ndGggPiAwICk/ICQoXCIudWktcGFnZS1hY3RpdmVcIik6ICQoXCIudWktcGFnZVwiKS5lcSgwKTtcblxuXHRcdFx0XHRpZiAoIG8uZnVsbHNjcmVlbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0aWYgKCBvLmZ1bGxzY3JlZW4gKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoIFwidWktXCIrIHRoaXMucm9sZSArXCItZnVsbHNjcmVlblwiICk7XG5cdFx0XHRcdFx0XHQkcGFnZS5hZGRDbGFzcyggXCJ1aS1wYWdlLVwiICsgdGhpcy5yb2xlICsgXCItZnVsbHNjcmVlblwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIElmIG5vdCBmdWxsc2NyZWVuLCBhZGQgY2xhc3MgdG8gcGFnZSB0byBzZXQgdG9wIG9yIGJvdHRvbSBwYWRkaW5nXG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoIFwidWktXCIrIHRoaXMucm9sZSArXCItZnVsbHNjcmVlblwiICk7XG5cdFx0XHRcdFx0XHQkcGFnZS5yZW1vdmVDbGFzcyggXCJ1aS1wYWdlLVwiICsgdGhpcy5yb2xlICsgXCItZnVsbHNjcmVlblwiICkuYWRkQ2xhc3MoIFwidWktcGFnZS1cIiArIHRoaXMucm9sZSsgXCItZml4ZWRcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc3VwZXIobyk7XG5cdFx0fSxcblxuXHRcdF9hZGRUcmFuc2l0aW9uQ2xhc3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRjbGFzcyA9IHRoaXMub3B0aW9ucy50cmFuc2l0aW9uO1xuXG5cdFx0XHRpZiAoIHRjbGFzcyAmJiB0Y2xhc3MgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHQvLyB1c2UgYXBwcm9wcmlhdGUgc2xpZGUgZm9yIGhlYWRlciBvciBmb290ZXJcblx0XHRcdFx0aWYgKCB0Y2xhc3MgPT09IFwic2xpZGVcIiApIHtcblx0XHRcdFx0XHR0Y2xhc3MgPSB0aGlzLmVsZW1lbnQuaGFzQ2xhc3MoIFwidWktaGVhZGVyXCIgKSA/IFwic2xpZGVkb3duXCIgOiBcInNsaWRldXBcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyggdGNsYXNzICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9iaW5kUGFnZUV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcGFnZSA9ICggISF0aGlzLnBhZ2UgKT8gdGhpcy5lbGVtZW50LmNsb3Nlc3QoIFwiLnVpLXBhZ2VcIiApOiB0aGlzLmRvY3VtZW50O1xuXHRcdFx0Ly9wYWdlIGV2ZW50IGJpbmRpbmdzXG5cdFx0XHQvLyBGaXhlZCB0b29sYmFycyByZXF1aXJlIHBhZ2Ugem9vbSB0byBiZSBkaXNhYmxlZCwgb3RoZXJ3aXNlIHVzYWJpbGl0eSBpc3N1ZXMgY3JvcCB1cFxuXHRcdFx0Ly8gVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gZGlzYWJsZSB6b29tIHdoaWxlIGEgZml4ZWQtcG9zaXRpb25lZCB0b29sYmFyIHBhZ2UgaXMgdmlzaWJsZVxuXHRcdFx0dGhpcy5fb24oIHBhZ2UgLCB7XG5cdFx0XHRcdFwicGFnZWJlZm9yZXNob3dcIjogXCJfaGFuZGxlUGFnZUJlZm9yZVNob3dcIixcblx0XHRcdFx0XCJ3ZWJraXRBbmltYXRpb25TdGFydFwiOlwiX2hhbmRsZUFuaW1hdGlvblN0YXJ0XCIsXG5cdFx0XHRcdFwiYW5pbWF0aW9uc3RhcnRcIjpcIl9oYW5kbGVBbmltYXRpb25TdGFydFwiLFxuXHRcdFx0XHRcInVwZGF0ZWxheW91dFwiOiBcIl9oYW5kbGVBbmltYXRpb25TdGFydFwiLFxuXHRcdFx0XHRcInBhZ2VzaG93XCI6IFwiX2hhbmRsZVBhZ2VTaG93XCIsXG5cdFx0XHRcdFwicGFnZWJlZm9yZWhpZGVcIjogXCJfaGFuZGxlUGFnZUJlZm9yZUhpZGVcIlxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdF9oYW5kbGVQYWdlQmVmb3JlU2hvdzogZnVuY3Rpb24oICkge1xuXHRcdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnM7XG5cdFx0XHRpZiAoIG8uZGlzYWJsZVBhZ2Vab29tICkge1xuXHRcdFx0XHQkLm1vYmlsZS56b29tLmRpc2FibGUoIHRydWUgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIW8udmlzaWJsZU9uUGFnZVNob3cgKSB7XG5cdFx0XHRcdHRoaXMuaGlkZSggdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfaGFuZGxlQW5pbWF0aW9uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMudXBkYXRlUGFnZVBhZGRpbmcgKSB7XG5cdFx0XHRcdHRoaXMudXBkYXRlUGFnZVBhZGRpbmcoICggISF0aGlzLnBhZ2UgKT8gdGhpcy5wYWdlOiBcIi51aS1wYWdlLWFjdGl2ZVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9oYW5kbGVQYWdlU2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZVBhZ2VQYWRkaW5nKCAoICEhdGhpcy5wYWdlICk/IHRoaXMucGFnZTogXCIudWktcGFnZS1hY3RpdmVcIiApO1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMudXBkYXRlUGFnZVBhZGRpbmcgKSB7XG5cdFx0XHRcdHRoaXMuX29uKCB0aGlzLndpbmRvdywgeyBcInRocm90dGxlZHJlc2l6ZVwiOiBcInVwZGF0ZVBhZ2VQYWRkaW5nXCIgfSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfaGFuZGxlUGFnZUJlZm9yZUhpZGU6IGZ1bmN0aW9uKCBlLCB1aSApIHtcblx0XHRcdHZhciBvID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHR0aGlzRm9vdGVyLCB0aGlzSGVhZGVyLCBuZXh0Rm9vdGVyLCBuZXh0SGVhZGVyO1xuXG5cdFx0XHRpZiAoIG8uZGlzYWJsZVBhZ2Vab29tICkge1xuXHRcdFx0XHQkLm1vYmlsZS56b29tLmVuYWJsZSggdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvLnVwZGF0ZVBhZ2VQYWRkaW5nICkge1xuXHRcdFx0XHR0aGlzLl9vZmYoIHRoaXMud2luZG93LCBcInRocm90dGxlZHJlc2l6ZVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggby50cmFja1BlcnNpc3RlbnRUb29sYmFycyApIHtcblx0XHRcdFx0dGhpc0Zvb3RlciA9ICQoIFwiLnVpLWZvb3Rlci1maXhlZDpqcW1EYXRhKGlkKVwiLCB0aGlzLnBhZ2UgKTtcblx0XHRcdFx0dGhpc0hlYWRlciA9ICQoIFwiLnVpLWhlYWRlci1maXhlZDpqcW1EYXRhKGlkKVwiLCB0aGlzLnBhZ2UgKTtcblx0XHRcdFx0bmV4dEZvb3RlciA9IHRoaXNGb290ZXIubGVuZ3RoICYmIHVpLm5leHRQYWdlICYmICQoIFwiLnVpLWZvb3Rlci1maXhlZDpqcW1EYXRhKGlkPSdcIiArIHRoaXNGb290ZXIuanFtRGF0YSggXCJpZFwiICkgKyBcIicpXCIsIHVpLm5leHRQYWdlICkgfHwgJCgpO1xuXHRcdFx0XHRuZXh0SGVhZGVyID0gdGhpc0hlYWRlci5sZW5ndGggJiYgdWkubmV4dFBhZ2UgJiYgJCggXCIudWktaGVhZGVyLWZpeGVkOmpxbURhdGEoaWQ9J1wiICsgdGhpc0hlYWRlci5qcW1EYXRhKCBcImlkXCIgKSArIFwiJylcIiwgdWkubmV4dFBhZ2UgKSB8fCAkKCk7XG5cblx0XHRcdFx0aWYgKCBuZXh0Rm9vdGVyLmxlbmd0aCB8fCBuZXh0SGVhZGVyLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdG5leHRGb290ZXIuYWRkKCBuZXh0SGVhZGVyICkuYXBwZW5kVG8oICQubW9iaWxlLnBhZ2VDb250YWluZXIgKTtcblxuXHRcdFx0XHRcdHVpLm5leHRQYWdlLm9uZSggXCJwYWdlc2hvd1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdG5leHRIZWFkZXIucHJlcGVuZFRvKCB0aGlzICk7XG5cdFx0XHRcdFx0XHRuZXh0Rm9vdGVyLmFwcGVuZFRvKCB0aGlzICk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3Zpc2libGU6IHRydWUsXG5cblx0XHQvLyBUaGlzIHdpbGwgc2V0IHRoZSBjb250ZW50IGVsZW1lbnQncyB0b3Agb3IgYm90dG9tIHBhZGRpbmcgZXF1YWwgdG8gdGhlIHRvb2xiYXIncyBoZWlnaHRcblx0XHR1cGRhdGVQYWdlUGFkZGluZzogZnVuY3Rpb24oIHRiUGFnZSApIHtcblx0XHRcdHZhciAkZWwgPSB0aGlzLmVsZW1lbnQsXG5cdFx0XHRcdGhlYWRlciA9ICggdGhpcy5yb2xlID09PVwiaGVhZGVyXCIgKSxcblx0XHRcdFx0cG9zID0gcGFyc2VGbG9hdCggJGVsLmNzcyggaGVhZGVyID8gXCJ0b3BcIiA6IFwiYm90dG9tXCIgKSApO1xuXG5cdFx0XHQvLyBUaGlzIGJlaGF2aW9yIG9ubHkgYXBwbGllcyB0byBcImZpeGVkXCIsIG5vdCBcImZ1bGxzY3JlZW5cIlxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuZnVsbHNjcmVlbiApIHsgcmV0dXJuOyB9XG5cdFx0XHQvLyB0YlBhZ2UgYXJndW1lbnQgY2FuIGJlIGEgUGFnZSBvYmplY3Qgb3IgYW4gZXZlbnQsIGlmIGNvbWluZyBmcm9tIHRocm90dGxlZCByZXNpemUuXG5cdFx0XHR0YlBhZ2UgPSAoIHRiUGFnZSAmJiB0YlBhZ2UudHlwZSA9PT0gdW5kZWZpbmVkICYmIHRiUGFnZSApIHx8IHRoaXMucGFnZSB8fCAkZWwuY2xvc2VzdCggXCIudWktcGFnZVwiICk7XG5cdFx0XHR0YlBhZ2UgPSAoICEhdGhpcy5wYWdlICk/IHRoaXMucGFnZTogXCIudWktcGFnZS1hY3RpdmVcIjtcblx0XHRcdCQoIHRiUGFnZSApLmNzcyggXCJwYWRkaW5nLVwiICsgKCBoZWFkZXIgPyBcInRvcFwiIDogXCJib3R0b21cIiApLCAkZWwub3V0ZXJIZWlnaHQoKSArIHBvcyApO1xuXHRcdH0sXG5cblx0XHRfdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24oIG5vdHJhbnNpdGlvbiApIHtcblx0XHRcdHZhciAkd2luID0gdGhpcy53aW5kb3csXG5cdFx0XHRcdCRlbCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdFx0c2Nyb2xsID0gJHdpbi5zY3JvbGxUb3AoKSxcblx0XHRcdFx0ZWxIZWlnaHQgPSAkZWwuaGVpZ2h0KCksXG5cdFx0XHRcdHBIZWlnaHQgPSAoICEhdGhpcy5wYWdlICk/ICRlbC5jbG9zZXN0KCBcIi51aS1wYWdlXCIgKS5oZWlnaHQoKTokKFwiLnVpLXBhZ2UtYWN0aXZlXCIpLmhlaWdodCgpLFxuXHRcdFx0XHR2aWV3cG9ydEhlaWdodCA9ICQubW9iaWxlLmdldFNjcmVlbkhlaWdodCgpO1xuXG5cdFx0XHRyZXR1cm4gIW5vdHJhbnNpdGlvbiAmJlxuXHRcdFx0XHQoIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uICYmIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uICE9PSBcIm5vbmVcIiAmJlxuXHRcdFx0XHQoXG5cdFx0XHRcdFx0KCB0aGlzLnJvbGUgPT09IFwiaGVhZGVyXCIgJiYgIXRoaXMub3B0aW9ucy5mdWxsc2NyZWVuICYmIHNjcm9sbCA+IGVsSGVpZ2h0ICkgfHxcblx0XHRcdFx0XHQoIHRoaXMucm9sZSA9PT0gXCJmb290ZXJcIiAmJiAhdGhpcy5vcHRpb25zLmZ1bGxzY3JlZW4gJiYgc2Nyb2xsICsgdmlld3BvcnRIZWlnaHQgPCBwSGVpZ2h0IC0gZWxIZWlnaHQgKVxuXHRcdFx0XHQpIHx8IHRoaXMub3B0aW9ucy5mdWxsc2NyZWVuXG5cdFx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdHNob3c6IGZ1bmN0aW9uKCBub3RyYW5zaXRpb24gKSB7XG5cdFx0XHR2YXIgaGlkZUNsYXNzID0gXCJ1aS1maXhlZC1oaWRkZW5cIixcblx0XHRcdFx0JGVsID0gdGhpcy5lbGVtZW50O1xuXG5cdFx0XHRpZiAoIHRoaXMuX3VzZVRyYW5zaXRpb24oIG5vdHJhbnNpdGlvbiApICkge1xuXHRcdFx0XHQkZWxcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwib3V0IFwiICsgaGlkZUNsYXNzIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIFwiaW5cIiApXG5cdFx0XHRcdFx0LmFuaW1hdGlvbkNvbXBsZXRlKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdCRlbC5yZW1vdmVDbGFzcyggXCJpblwiICk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0JGVsLnJlbW92ZUNsYXNzKCBoaWRlQ2xhc3MgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuXHRcdH0sXG5cblx0XHRoaWRlOiBmdW5jdGlvbiggbm90cmFuc2l0aW9uICkge1xuXHRcdFx0dmFyIGhpZGVDbGFzcyA9IFwidWktZml4ZWQtaGlkZGVuXCIsXG5cdFx0XHRcdCRlbCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdFx0Ly8gaWYgaXQncyBhIHNsaWRlIHRyYW5zaXRpb24sIG91ciBuZXcgdHJhbnNpdGlvbnMgbmVlZCB0aGUgcmV2ZXJzZSBjbGFzcyBhcyB3ZWxsIHRvIHNsaWRlIG91dHdhcmRcblx0XHRcdFx0b3V0Y2xhc3MgPSBcIm91dFwiICsgKCB0aGlzLm9wdGlvbnMudHJhbnNpdGlvbiA9PT0gXCJzbGlkZVwiID8gXCIgcmV2ZXJzZVwiIDogXCJcIiApO1xuXG5cdFx0XHRpZiAoIHRoaXMuX3VzZVRyYW5zaXRpb24oIG5vdHJhbnNpdGlvbiApICkge1xuXHRcdFx0XHQkZWxcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIG91dGNsYXNzIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwiaW5cIiApXG5cdFx0XHRcdFx0LmFuaW1hdGlvbkNvbXBsZXRlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0JGVsLmFkZENsYXNzKCBoaWRlQ2xhc3MgKS5yZW1vdmVDbGFzcyggb3V0Y2xhc3MgKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQkZWwuYWRkQ2xhc3MoIGhpZGVDbGFzcyApLnJlbW92ZUNsYXNzKCBvdXRjbGFzcyApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuXHRcdH0sXG5cblx0XHR0b2dnbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpc1sgdGhpcy5fdmlzaWJsZSA/IFwiaGlkZVwiIDogXCJzaG93XCIgXSgpO1xuXHRcdH0sXG5cblx0XHRfYmluZFRvZ2dsZUhhbmRsZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdFx0byA9IHNlbGYub3B0aW9ucyxcblx0XHRcdFx0ZGVsYXlTaG93LCBkZWxheUhpZGUsXG5cdFx0XHRcdGlzVmlzaWJsZSA9IHRydWUsXG5cdFx0XHRcdHBhZ2UgPSAoICEhdGhpcy5wYWdlICk/IHRoaXMucGFnZTogJChcIi51aS1wYWdlXCIpO1xuXG5cdFx0XHQvLyB0YXAgdG9nZ2xlXG5cdFx0XHRwYWdlXG5cdFx0XHRcdC5iaW5kKCBcInZjbGlja1wiLCBmdW5jdGlvbiggZSApIHtcblx0XHRcdFx0XHRpZiAoIG8udGFwVG9nZ2xlICYmICEkKCBlLnRhcmdldCApLmNsb3Nlc3QoIG8udGFwVG9nZ2xlQmxhY2tsaXN0ICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0c2VsZi50b2dnbGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5iaW5kKCBcImZvY3VzaW4gZm9jdXNvdXRcIiwgZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRcdFx0Ly90aGlzIGhpZGVzIHRoZSB0b29sYmFycyBvbiBhIGtleWJvYXJkIHBvcCB0byBnaXZlIG1vcmUgc2NyZWVuIHJvb20gYW5kIHByZXZlbnQgaW9zIGJ1ZyB3aGljaFxuXHRcdFx0XHRcdC8vcG9zaXRpb25zIGZpeGVkIHRvb2xiYXJzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlbiBvbiBwb3AgaWYgdGhlIGlucHV0IGlzIG5lYXIgdGhlIHRvcCBvclxuXHRcdFx0XHRcdC8vYm90dG9tIG9mIHRoZSBzY3JlZW4gYWRkcmVzc2VzIGlzc3VlcyAjNDQxMCBGb290ZXIgbmF2YmFyIG1vdmVzIHVwIHdoZW4gY2xpY2tpbmcgb24gYSB0ZXh0Ym94IGluIGFuIEFuZHJvaWQgZW52aXJvbm1lbnRcblx0XHRcdFx0XHQvL2FuZCBpc3N1ZSAjNDExMyBIZWFkZXIgYW5kIGZvb3RlciBjaGFuZ2UgdGhlaXIgcG9zaXRpb24gYWZ0ZXIga2V5Ym9hcmQgcG9wdXAgLSBpT1Ncblx0XHRcdFx0XHQvL2FuZCBpc3N1ZSAjNDQxMCBGb290ZXIgbmF2YmFyIG1vdmVzIHVwIHdoZW4gY2xpY2tpbmcgb24gYSB0ZXh0Ym94IGluIGFuIEFuZHJvaWQgZW52aXJvbm1lbnRcblx0XHRcdFx0XHRpZiAoIHNjcmVlbi53aWR0aCA8IDEwMjUgJiYgJCggZS50YXJnZXQgKS5pcyggby5oaWRlRHVyaW5nRm9jdXMgKSAmJiAhJCggZS50YXJnZXQgKS5jbG9zZXN0KCBcIi51aS1oZWFkZXItZml4ZWQsIC51aS1mb290ZXItZml4ZWRcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdC8vRml4IGZvciBpc3N1ZSAjNDcyNCBNb3ZpbmcgdGhyb3VnaCBmb3JtIGluIE1vYmlsZSBTYWZhcmkgd2l0aCBcIk5leHRcIiBhbmQgXCJQcmV2aW91c1wiIHN5c3RlbVxuXHRcdFx0XHRcdFx0Ly9jb250cm9scyBjYXVzZXMgZml4ZWQgcG9zaXRpb24sIHRhcC10b2dnbGUgZmFsc2UgSGVhZGVyIHRvIHJldmVhbCBpdHNlbGZcblx0XHRcdFx0XHRcdC8vIGlzVmlzaWJsZSBpbnN0ZWFkIG9mIHNlbGYuX3Zpc2libGUgYmVjYXVzZSB0aGUgZm9jdXNpbiBhbmQgZm9jdXNvdXQgZXZlbnRzIGZpcmUgdHdpY2UgYXQgdGhlIHNhbWUgdGltZVxuXHRcdFx0XHRcdFx0Ly8gQWxzbyB1c2UgYSBkZWxheSBmb3IgaGlkaW5nIHRoZSB0b29sYmFycyBiZWNhdXNlIG9uIEFuZHJvaWQgbmF0aXZlIGJyb3dzZXIgZm9jdXNpbiBpcyBkaXJlY2x0eSBmb2xsb3dlZFxuXHRcdFx0XHRcdFx0Ly8gYnkgYSBmb2N1c291dCB3aGVuIGEgbmF0aXZlIHNlbGVjdHMgb3BlbnMgYW5kIHRoZSBvdGhlciB3YXkgYXJvdW5kIHdoZW4gaXQgY2xvc2VzLlxuXHRcdFx0XHRcdFx0aWYgKCBlLnR5cGUgPT09IFwiZm9jdXNvdXRcIiAmJiAhaXNWaXNpYmxlICkge1xuXHRcdFx0XHRcdFx0XHRpc1Zpc2libGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHQvL3dhaXQgZm9yIHRoZSBzdGFjayB0byB1bndpbmQgYW5kIHNlZSBpZiB3ZSBoYXZlIGp1bXBlZCB0byBhbm90aGVyIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNsZWFyVGltZW91dCggZGVsYXlIaWRlICk7XG5cdFx0XHRcdFx0XHRcdGRlbGF5U2hvdyA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHNlbGYuc2hvdygpO1xuXHRcdFx0XHRcdFx0XHR9LCAwICk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBlLnR5cGUgPT09IFwiZm9jdXNpblwiICYmICEhaXNWaXNpYmxlICkge1xuXHRcdFx0XHRcdFx0XHQvL2lmIHdlIGhhdmUganVtcGVkIHRvIGFub3RoZXIgaW5wdXQgY2xlYXIgdGhlIHRpbWUgb3V0IHRvIGNhbmNlbCB0aGUgc2hvdy5cblx0XHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KCBkZWxheVNob3cgKTtcblx0XHRcdFx0XHRcdFx0aXNWaXNpYmxlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGRlbGF5SGlkZSA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHNlbGYuaGlkZSgpO1xuXHRcdFx0XHRcdFx0XHR9LCAwICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0X3NldFJlbGF0aXZlOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmKCB0aGlzLm9wdGlvbnMucG9zaXRpb24gIT09IFwiZml4ZWRcIiApe1xuXHRcdFx0XHQkKCBcIltkYXRhLVwiKyAkLm1vYmlsZS5ucyArIFwicm9sZT0ncGFnZSddXCIgKS5jc3MoeyBcInBvc2l0aW9uXCI6IFwicmVsYXRpdmVcIiB9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyICRlbCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdFx0aGVhZGVyID0gJGVsLmhhc0NsYXNzKCBcInVpLWhlYWRlclwiICk7XG5cblx0XHRcdCRlbC5jbG9zZXN0KCBcIi51aS1wYWdlXCIgKS5jc3MoIFwicGFkZGluZy1cIiArICggaGVhZGVyID8gXCJ0b3BcIiA6IFwiYm90dG9tXCIgKSwgXCJcIiApO1xuXHRcdFx0JGVsLnJlbW92ZUNsYXNzKCBcInVpLWhlYWRlci1maXhlZCB1aS1mb290ZXItZml4ZWQgdWktaGVhZGVyLWZ1bGxzY3JlZW4gdWktZm9vdGVyLWZ1bGxzY3JlZW4gaW4gb3V0IGZhZGUgc2xpZGVkb3duIHNsaWRldXAgdWktZml4ZWQtaGlkZGVuXCIgKTtcblx0XHRcdCRlbC5jbG9zZXN0KCBcIi51aS1wYWdlXCIgKS5yZW1vdmVDbGFzcyggXCJ1aS1wYWdlLWhlYWRlci1maXhlZCB1aS1wYWdlLWZvb3Rlci1maXhlZCB1aS1wYWdlLWhlYWRlci1mdWxsc2NyZWVuIHVpLXBhZ2UtZm9vdGVyLWZ1bGxzY3JlZW5cIiApO1xuXHRcdH1cblxuXHR9KTtcbn0pKCBqUXVlcnkgKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cdCQud2lkZ2V0KCBcIm1vYmlsZS50b29sYmFyXCIsICQubW9iaWxlLnRvb2xiYXIsIHtcblxuXHRcdF9tYWtlRml4ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHRcdHRoaXMuX3dvcmthcm91bmRzKCk7XG5cdFx0fSxcblxuXHRcdC8vY2hlY2sgdGhlIGJyb3dzZXIgYW5kIHZlcnNpb24gYW5kIHJ1biBuZWVkZWQgd29ya2Fyb3VuZHNcblx0XHRfd29ya2Fyb3VuZHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcblx0XHRcdHBsYXRmb3JtID0gbmF2aWdhdG9yLnBsYXRmb3JtLFxuXHRcdFx0Ly8gUmVuZGVyaW5nIGVuZ2luZSBpcyBXZWJraXQsIGFuZCBjYXB0dXJlIG1ham9yIHZlcnNpb25cblx0XHRcdHdrbWF0Y2ggPSB1YS5tYXRjaCggL0FwcGxlV2ViS2l0XFwvKFswLTldKykvICksXG5cdFx0XHR3a3ZlcnNpb24gPSAhIXdrbWF0Y2ggJiYgd2ttYXRjaFsgMSBdLFxuXHRcdFx0b3MgPSBudWxsLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cdFx0XHQvL3NldCB0aGUgb3Mgd2UgYXJlIHdvcmtpbmcgaW4gaWYgaXQgZG9zZW50IG1hdGNoIG9uZSB3aXRoIHdvcmthcm91bmRzIHJldHVyblxuXHRcdFx0aWYgKCBwbGF0Zm9ybS5pbmRleE9mKCBcImlQaG9uZVwiICkgPiAtMSB8fCBwbGF0Zm9ybS5pbmRleE9mKCBcImlQYWRcIiApID4gLTEgIHx8IHBsYXRmb3JtLmluZGV4T2YoIFwiaVBvZFwiICkgPiAtMSApIHtcblx0XHRcdFx0b3MgPSBcImlvc1wiO1xuXHRcdFx0fSBlbHNlIGlmICggdWEuaW5kZXhPZiggXCJBbmRyb2lkXCIgKSA+IC0xICkge1xuXHRcdFx0XHRvcyA9IFwiYW5kcm9pZFwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly9jaGVjayBvcyB2ZXJzaW9uIGlmIGl0IGRvc2VudCBtYXRjaCBvbmUgd2l0aCB3b3JrYXJvdW5kcyByZXR1cm5cblx0XHRcdGlmICggb3MgPT09IFwiaW9zXCIgKSB7XG5cdFx0XHRcdC8vaU9TICB3b3JrYXJvdW5kc1xuXHRcdFx0XHRzZWxmLl9iaW5kU2Nyb2xsV29ya2Fyb3VuZCgpO1xuXHRcdFx0fSBlbHNlIGlmICggb3MgPT09IFwiYW5kcm9pZFwiICYmIHdrdmVyc2lvbiAmJiB3a3ZlcnNpb24gPCA1MzQgKSB7XG5cdFx0XHRcdC8vQW5kcm9pZCAyLjMgcnVuIGFsbCBBbmRyb2lkIDIuMyB3b3JrYXJvdW5kXG5cdFx0XHRcdHNlbGYuX2JpbmRTY3JvbGxXb3JrYXJvdW5kKCk7XG5cdFx0XHRcdHNlbGYuX2JpbmRMaXN0VGh1bWJXb3JrYXJvdW5kKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vVXRpbGl0eSBjbGFzcyBmb3IgY2hlY2tpbmcgaGVhZGVyIGFuZCBmb290ZXIgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHZpZXdwb3J0XG5cdFx0X3ZpZXdwb3J0T2Zmc2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciAkZWwgPSB0aGlzLmVsZW1lbnQsXG5cdFx0XHRcdGhlYWRlciA9ICRlbC5oYXNDbGFzcyggXCJ1aS1oZWFkZXJcIiApLFxuXHRcdFx0XHRvZmZzZXQgPSBNYXRoLmFicyggJGVsLm9mZnNldCgpLnRvcCAtIHRoaXMud2luZG93LnNjcm9sbFRvcCgpICk7XG5cdFx0XHRpZiAoICFoZWFkZXIgKSB7XG5cdFx0XHRcdG9mZnNldCA9IE1hdGgucm91bmQoIG9mZnNldCAtIHRoaXMud2luZG93LmhlaWdodCgpICsgJGVsLm91dGVySGVpZ2h0KCkgKSAtIDYwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHR9LFxuXG5cdFx0Ly9iaW5kIGV2ZW50cyBmb3IgX3RyaWdnZXJSZWRyYXcoKSBmdW5jdGlvblxuXHRcdF9iaW5kU2Nyb2xsV29ya2Fyb3VuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHQvL2JpbmQgdG8gc2Nyb2xsc3RvcCBhbmQgY2hlY2sgaWYgdGhlIHRvb2xiYXJzIGFyZSBjb3JyZWN0bHkgcG9zaXRpb25lZFxuXHRcdFx0dGhpcy5fb24oIHRoaXMud2luZG93LCB7IHNjcm9sbHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdmlld3BvcnRPZmZzZXQgPSBzZWxmLl92aWV3cG9ydE9mZnNldCgpO1xuXHRcdFx0XHQvL2NoZWNrIGlmIHRoZSBoZWFkZXIgaXMgdmlzaWJsZSBhbmQgaWYgaXRzIGluIHRoZSByaWdodCBwbGFjZVxuXHRcdFx0XHRpZiAoIHZpZXdwb3J0T2Zmc2V0ID4gMiAmJiBzZWxmLl92aXNpYmxlICkge1xuXHRcdFx0XHRcdHNlbGYuX3RyaWdnZXJSZWRyYXcoKTtcblx0XHRcdFx0fVxuXHRcdFx0fX0pO1xuXHRcdH0sXG5cblx0XHQvL3RoaXMgYWRkcmVzc2VzIGlzc3VlICM0MjUwIFBlcnNpc3RlbnQgZm9vdGVyIGluc3RhYmlsaXR5IGluIHYxLjEgd2l0aCBsb25nIHNlbGVjdCBsaXN0cyBpbiBBbmRyb2lkIDIuMy4zXG5cdFx0Ly9hbmQgaXNzdWUgIzM3NDggQW5kcm9pZCAyLng6IFBhZ2UgdHJhbnNpdGlvbnMgYnJva2VuIHdoZW4gZml4ZWQgdG9vbGJhcnMgdXNlZFxuXHRcdC8vdGhlIGFic29sdXRlbHkgcG9zaXRpb25lZCB0aHVtYm5haWwgaW4gYSBsaXN0IHZpZXcgY2F1c2VzIHByb2JsZW1zIHdpdGggZml4ZWQgcG9zaXRpb24gYnV0dG9ucyBhYm92ZSBpbiBhIG5hdiBiYXJcblx0XHQvL3NldHRpbmcgdGhlIGxpJ3MgdG8gLXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApOyBzb2x2ZXMgdGhpcyBwcm9ibGVtIHRvIGF2b2lkZSBwb3RlbnRpYWwgaXNzdWVzIGluIG90aGVyXG5cdFx0Ly9wbGF0Zm9ybXMgd2Ugc2NvcGUgdGhpcyB3aXRoIHRoZSBjbGFzcyB1aS1hbmRyb2lkLTJ4LWZpeFxuXHRcdF9iaW5kTGlzdFRodW1iV29ya2Fyb3VuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuY2xvc2VzdCggXCIudWktcGFnZVwiICkuYWRkQ2xhc3MoIFwidWktYW5kcm9pZC0yeC1maXhlZFwiICk7XG5cdFx0fSxcblx0XHQvL3RoaXMgYWRkcmVzc2VzIGlzc3VlcyAjNDMzNyBGaXhlZCBoZWFkZXIgcHJvYmxlbSBhZnRlciBzY3JvbGxpbmcgY29udGVudCBvbiBpT1MgYW5kIEFuZHJvaWRcblx0XHQvL2FuZCBkZXZpY2UgYnVncyBwcm9qZWN0IGlzc3VlICMxIEZvcm0gZWxlbWVudHMgY2FuIGxvc2UgY2xpY2sgaGl0IGFyZWEgaW4gcG9zaXRpb246IGZpeGVkIGNvbnRhaW5lcnMuXG5cdFx0Ly90aGlzIGFsc28gYWRkcmVzc2VzIG5vdCBvbiBmaXhlZCB0b29sYmFycyBwYWdlIGluIGRvY3Ncblx0XHQvL2FkZGluZyAxcHggb2YgcGFkZGluZyB0byB0aGUgYm90dG9tIHRoZW4gcmVtb3ZpbmcgaXQgY2F1c2VzIGEgXCJyZWRyYXdcIlxuXHRcdC8vd2hpY2ggcG9zaXRpb25zIHRoZSB0b29sYmFycyBjb3JyZWN0bHkgKHRoZXkgd2lsbCBhbHdheXMgYmUgdmlzdWFsbHkgY29ycmVjdClcblx0XHRfdHJpZ2dlclJlZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcGFkZGluZ0JvdHRvbSA9IHBhcnNlRmxvYXQoICQoIFwiLnVpLXBhZ2UtYWN0aXZlXCIgKS5jc3MoIFwicGFkZGluZy1ib3R0b21cIiApICk7XG5cdFx0XHQvL3RyaWdnZXIgcGFnZSByZWRyYXcgdG8gZml4IGluY29ycmVjdGx5IHBvc2l0aW9uZWQgZml4ZWQgZWxlbWVudHNcblx0XHRcdCQoIFwiLnVpLXBhZ2UtYWN0aXZlXCIgKS5jc3MoIFwicGFkZGluZy1ib3R0b21cIiwgKCBwYWRkaW5nQm90dG9tICsgMSApICsgXCJweFwiICk7XG5cdFx0XHQvL2lmIHRoZSBwYWRkaW5nIGlzIHJlc2V0IHdpdGggb3V0IGEgdGltZW91dCB0aGUgcmVwb3NpdGlvbiB3aWxsIG5vdCBvY2N1cmUuXG5cdFx0XHQvL3RoaXMgaXMgaW5kZXBlbmRhbnQgb2YgSlFNIHRoZSBicm93c2VyIHNlZW1zIHRvIG5lZWQgdGhlIHRpbWUgdG8gcmVhY3QuXG5cdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggXCIudWktcGFnZS1hY3RpdmVcIiApLmNzcyggXCJwYWRkaW5nLWJvdHRvbVwiLCBwYWRkaW5nQm90dG9tICsgXCJweFwiICk7XG5cdFx0XHR9LCAwICk7XG5cdFx0fSxcblxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHRcdC8vUmVtb3ZlIHRoZSBjbGFzcyB3ZSBhZGRlZCB0byB0aGUgcGFnZSBwcmV2aW91c2x5IGluIGFuZHJvaWQgMi54XG5cdFx0XHR0aGlzLmVsZW1lbnQuY2xvc2VzdCggXCIudWktcGFnZS1hY3RpdmVcIiApLnJlbW92ZUNsYXNzKCBcInVpLWFuZHJvaWQtMngtZml4XCIgKTtcblx0XHR9XG5cdH0pO1xuXG59KSggalF1ZXJ5ICk7XG5cblxuKCBmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgaWVIYWNrID0gKCAkLm1vYmlsZS5icm93c2VyLm9sZElFICYmICQubW9iaWxlLmJyb3dzZXIub2xkSUUgPD0gOCApLFxuXHR1aVRlbXBsYXRlID0gJChcblx0XHRcIjxkaXYgY2xhc3M9J3VpLXBvcHVwLWFycm93LWd1aWRlJz48L2Rpdj5cIiArXG5cdFx0XCI8ZGl2IGNsYXNzPSd1aS1wb3B1cC1hcnJvdy1jb250YWluZXJcIiArICggaWVIYWNrID8gXCIgaWVcIiA6IFwiXCIgKSArIFwiJz5cIiArXG5cdFx0XHRcIjxkaXYgY2xhc3M9J3VpLXBvcHVwLWFycm93Jz48L2Rpdj5cIiArXG5cdFx0XCI8L2Rpdj5cIlxuXHQpO1xuXG5mdW5jdGlvbiBnZXRBcnJvdygpIHtcblx0dmFyIGNsb25lID0gdWlUZW1wbGF0ZS5jbG9uZSgpLFxuXHRcdGdkID0gY2xvbmUuZXEoIDAgKSxcblx0XHRjdCA9IGNsb25lLmVxKCAxICksXG5cdFx0YXIgPSBjdC5jaGlsZHJlbigpO1xuXG5cdHJldHVybiB7IGFyRWxzOiBjdC5hZGQoIGdkICksIGdkOiBnZCwgY3Q6IGN0LCBhcjogYXIgfTtcbn1cblxuJC53aWRnZXQoIFwibW9iaWxlLnBvcHVwXCIsICQubW9iaWxlLnBvcHVwLCB7XG5cdG9wdGlvbnM6IHtcblxuXHRcdGFycm93OiBcIlwiXG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyLFxuXHRcdFx0cmV0ID0gdGhpcy5fc3VwZXIoKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmFycm93ICkge1xuXHRcdFx0dGhpcy5fdWkuYXJyb3cgPSBhciA9IHRoaXMuX2FkZEFycm93KCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRfYWRkQXJyb3c6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGVtZSxcblx0XHRcdG9wdHMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRhciA9IGdldEFycm93KCk7XG5cblx0XHR0aGVtZSA9IHRoaXMuX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKCBcInVpLWJvZHktXCIsIG9wdHMudGhlbWUgKTtcblx0XHRhci5hci5hZGRDbGFzcyggdGhlbWUgKyAoIG9wdHMuc2hhZG93ID8gXCIgdWktb3ZlcmxheS1zaGFkb3dcIiA6IFwiXCIgKSApO1xuXHRcdGFyLmFyRWxzLmhpZGUoKS5hcHBlbmRUbyggdGhpcy5lbGVtZW50ICk7XG5cblx0XHRyZXR1cm4gYXI7XG5cdH0sXG5cblx0X3VuZW5oYW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyID0gdGhpcy5fdWkuYXJyb3c7XG5cblx0XHRpZiAoIGFyICkge1xuXHRcdFx0YXIuYXJFbHMucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3N1cGVyKCk7XG5cdH0sXG5cblx0Ly8gUHJldGVuZCB0byBzaG93IGFuIGFycm93IGRlc2NyaWJlZCBieSBAcCBhbmQgQGRpciBhbmQgY2FsY3VsYXRlIHRoZVxuXHQvLyBkaXN0YW5jZSBmcm9tIHRoZSBkZXNpcmVkIHBvaW50LiBJZiBhIGJlc3QtZGlzdGFuY2UgaXMgcGFzc2VkIGluLCByZXR1cm5cblx0Ly8gdGhlIG1pbmltdW0gb2YgdGhlIG9uZSBwYXNzZWQgaW4gYW5kIHRoZSBvbmUgY2FsY3VsYXRlZC5cblx0X3RyeUFuQXJyb3c6IGZ1bmN0aW9uKCBwLCBkaXIsIGRlc2lyZWQsIHMsIGJlc3QgKSB7XG5cdFx0dmFyIHJlc3VsdCwgciwgZGlmZiwgZGVzaXJlZEZvckFycm93ID0ge30sIHRpcCA9IHt9O1xuXG5cdFx0Ly8gSWYgdGhlIGFycm93IGhhcyBubyB3aWdnbGUgcm9vbSBhbG9uZyB0aGUgZWRnZSBvZiB0aGUgcG9wdXAsIGl0IGNhbm5vdFxuXHRcdC8vIGJlIGRpc3BsYXllZCBhbG9uZyB0aGUgcmVxdWVzdGVkIGVkZ2Ugd2l0aG91dCBpdCBzdGlja2luZyBvdXQuXG5cdFx0aWYgKCBzLmFyRnVsbFsgcC5kaW1LZXkgXSA+IHMuZ3VpZGVEaW1zWyBwLmRpbUtleSBdICkge1xuXHRcdFx0cmV0dXJuIGJlc3Q7XG5cdFx0fVxuXG5cdFx0ZGVzaXJlZEZvckFycm93WyBwLmZzdCBdID0gZGVzaXJlZFsgcC5mc3QgXSArXG5cdFx0XHQoIHMuYXJIYWxmWyBwLm9EaW1LZXkgXSArIHMubWVudUhhbGZbIHAub0RpbUtleSBdICkgKiBwLm9mZnNldEZhY3RvciAtXG5cdFx0XHRzLmNvbnRlbnRCb3hbIHAuZnN0IF0gKyAoIHMuY2xhbXBJbmZvLm1lbnVTaXplWyBwLm9EaW1LZXkgXSAtIHMuY29udGVudEJveFsgcC5vRGltS2V5IF0gKSAqIHAuYXJyb3dPZmZzZXRGYWN0b3I7XG5cdFx0ZGVzaXJlZEZvckFycm93WyBwLnNuZCBdID0gZGVzaXJlZFsgcC5zbmQgXTtcblxuXHRcdHJlc3VsdCA9IHMucmVzdWx0IHx8IHRoaXMuX2NhbGN1bGF0ZUZpbmFsTG9jYXRpb24oIGRlc2lyZWRGb3JBcnJvdywgcy5jbGFtcEluZm8gKTtcblx0XHRyID0geyB4OiByZXN1bHQubGVmdCwgeTogcmVzdWx0LnRvcCB9O1xuXG5cdFx0dGlwWyBwLmZzdCBdID0gclsgcC5mc3QgXSArIHMuY29udGVudEJveFsgcC5mc3QgXSArIHAudGlwT2Zmc2V0O1xuXHRcdHRpcFsgcC5zbmQgXSA9IE1hdGgubWF4KCByZXN1bHRbIHAucHJvcCBdICsgcy5ndWlkZU9mZnNldFsgcC5wcm9wIF0gKyBzLmFySGFsZlsgcC5kaW1LZXkgXSxcblx0XHRcdE1hdGgubWluKCByZXN1bHRbIHAucHJvcCBdICsgcy5ndWlkZU9mZnNldFsgcC5wcm9wIF0gKyBzLmd1aWRlRGltc1sgcC5kaW1LZXkgXSAtIHMuYXJIYWxmWyBwLmRpbUtleSBdLFxuXHRcdFx0XHRkZXNpcmVkWyBwLnNuZCBdICkgKTtcblxuXHRcdGRpZmYgPSBNYXRoLmFicyggZGVzaXJlZC54IC0gdGlwLnggKSArIE1hdGguYWJzKCBkZXNpcmVkLnkgLSB0aXAueSApO1xuXHRcdGlmICggIWJlc3QgfHwgZGlmZiA8IGJlc3QuZGlmZiApIHtcblx0XHRcdC8vIENvbnZlcnQgdGlwIG9mZnNldCB0byBjb29yZGluYXRlcyBpbnNpZGUgdGhlIHBvcHVwXG5cdFx0XHR0aXBbIHAuc25kIF0gLT0gcy5hckhhbGZbIHAuZGltS2V5IF0gKyByZXN1bHRbIHAucHJvcCBdICsgcy5jb250ZW50Qm94WyBwLnNuZCBdO1xuXHRcdFx0YmVzdCA9IHsgZGlyOiBkaXIsIGRpZmY6IGRpZmYsIHJlc3VsdDogcmVzdWx0LCBwb3NQcm9wOiBwLnByb3AsIHBvc1ZhbDogdGlwWyBwLnNuZCBdIH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJlc3Q7XG5cdH0sXG5cblx0X2dldFBsYWNlbWVudFN0YXRlOiBmdW5jdGlvbiggY2xhbXAgKSB7XG5cdFx0dmFyIG9mZnNldCwgZ2RPZmZzZXQsXG5cdFx0XHRhciA9IHRoaXMuX3VpLmFycm93LFxuXHRcdFx0c3RhdGUgPSB7XG5cdFx0XHRcdGNsYW1wSW5mbzogdGhpcy5fY2xhbXBQb3B1cFdpZHRoKCAhY2xhbXAgKSxcblx0XHRcdFx0YXJGdWxsOiB7IGN4OiBhci5jdC53aWR0aCgpLCBjeTogYXIuY3QuaGVpZ2h0KCkgfSxcblx0XHRcdFx0Z3VpZGVEaW1zOiB7IGN4OiBhci5nZC53aWR0aCgpLCBjeTogYXIuZ2QuaGVpZ2h0KCkgfSxcblx0XHRcdFx0Z3VpZGVPZmZzZXQ6IGFyLmdkLm9mZnNldCgpXG5cdFx0XHR9O1xuXG5cdFx0b2Zmc2V0ID0gdGhpcy5lbGVtZW50Lm9mZnNldCgpO1xuXG5cdFx0YXIuZ2QuY3NzKCB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCB9ICk7XG5cdFx0Z2RPZmZzZXQgPSBhci5nZC5vZmZzZXQoKTtcblx0XHRzdGF0ZS5jb250ZW50Qm94ID0ge1xuXHRcdFx0eDogZ2RPZmZzZXQubGVmdCAtIG9mZnNldC5sZWZ0LFxuXHRcdFx0eTogZ2RPZmZzZXQudG9wIC0gb2Zmc2V0LnRvcCxcblx0XHRcdGN4OiBhci5nZC53aWR0aCgpLFxuXHRcdFx0Y3k6IGFyLmdkLmhlaWdodCgpXG5cdFx0fTtcblx0XHRhci5nZC5yZW1vdmVBdHRyKCBcInN0eWxlXCIgKTtcblxuXHRcdC8vIFRoZSBhcnJvdyBib3ggbW92ZXMgYmV0d2VlbiBndWlkZU9mZnNldCBhbmQgZ3VpZGVPZmZzZXQgKyBndWlkZURpbXMgLSBhckZ1bGxcblx0XHRzdGF0ZS5ndWlkZU9mZnNldCA9IHsgbGVmdDogc3RhdGUuZ3VpZGVPZmZzZXQubGVmdCAtIG9mZnNldC5sZWZ0LCB0b3A6IHN0YXRlLmd1aWRlT2Zmc2V0LnRvcCAtIG9mZnNldC50b3AgfTtcblx0XHRzdGF0ZS5hckhhbGYgPSB7IGN4OiBzdGF0ZS5hckZ1bGwuY3ggLyAyLCBjeTogc3RhdGUuYXJGdWxsLmN5IC8gMiB9O1xuXHRcdHN0YXRlLm1lbnVIYWxmID0geyBjeDogc3RhdGUuY2xhbXBJbmZvLm1lbnVTaXplLmN4IC8gMiwgY3k6IHN0YXRlLmNsYW1wSW5mby5tZW51U2l6ZS5jeSAvIDIgfTtcblxuXHRcdHJldHVybiBzdGF0ZTtcblx0fSxcblxuXHRfcGxhY2VtZW50Q29vcmRzOiBmdW5jdGlvbiggZGVzaXJlZCApIHtcblx0XHR2YXIgc3RhdGUsIGJlc3QsIHBhcmFtcywgZWxPZmZzZXQsIGJnUmVmLFxuXHRcdFx0b3B0aW9uVmFsdWUgPSB0aGlzLm9wdGlvbnMuYXJyb3csXG5cdFx0XHRhciA9IHRoaXMuX3VpLmFycm93O1xuXG5cdFx0aWYgKCAhYXIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3VwZXIoIGRlc2lyZWQgKTtcblx0XHR9XG5cblx0XHRhci5hckVscy5zaG93KCk7XG5cblx0XHRiZ1JlZiA9IHt9O1xuXHRcdHN0YXRlID0gdGhpcy5fZ2V0UGxhY2VtZW50U3RhdGUoIHRydWUgKTtcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcImxcIjogeyBmc3Q6IFwieFwiLCBzbmQ6IFwieVwiLCBwcm9wOiBcInRvcFwiLCBkaW1LZXk6IFwiY3lcIiwgb0RpbUtleTogXCJjeFwiLCBvZmZzZXRGYWN0b3I6IDEsIHRpcE9mZnNldDogIC1zdGF0ZS5hckhhbGYuY3gsIGFycm93T2Zmc2V0RmFjdG9yOiAwIH0sXG5cdFx0XHRcInJcIjogeyBmc3Q6IFwieFwiLCBzbmQ6IFwieVwiLCBwcm9wOiBcInRvcFwiLCBkaW1LZXk6IFwiY3lcIiwgb0RpbUtleTogXCJjeFwiLCBvZmZzZXRGYWN0b3I6IC0xLCB0aXBPZmZzZXQ6IHN0YXRlLmFySGFsZi5jeCArIHN0YXRlLmNvbnRlbnRCb3guY3gsIGFycm93T2Zmc2V0RmFjdG9yOiAxIH0sXG5cdFx0XHRcImJcIjogeyBmc3Q6IFwieVwiLCBzbmQ6IFwieFwiLCBwcm9wOiBcImxlZnRcIiwgZGltS2V5OiBcImN4XCIsIG9EaW1LZXk6IFwiY3lcIiwgb2Zmc2V0RmFjdG9yOiAtMSwgdGlwT2Zmc2V0OiBzdGF0ZS5hckhhbGYuY3kgKyBzdGF0ZS5jb250ZW50Qm94LmN5LCBhcnJvd09mZnNldEZhY3RvcjogMSB9LFxuXHRcdFx0XCJ0XCI6IHsgZnN0OiBcInlcIiwgc25kOiBcInhcIiwgcHJvcDogXCJsZWZ0XCIsIGRpbUtleTogXCJjeFwiLCBvRGltS2V5OiBcImN5XCIsIG9mZnNldEZhY3RvcjogMSwgdGlwT2Zmc2V0OiAtc3RhdGUuYXJIYWxmLmN5LCBhcnJvd09mZnNldEZhY3RvcjogMCB9XG5cdFx0fTtcblxuXHRcdC8vIFRyeSBlYWNoIHNpZGUgc3BlY2lmaWVkIGluIHRoZSBvcHRpb25zIHRvIHNlZSBvbiB3aGljaCBvbmUgdGhlIGFycm93XG5cdFx0Ly8gc2hvdWxkIGJlIHBsYWNlZCBzdWNoIHRoYXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHRpcCBvZiB0aGUgYXJyb3cgYW5kXG5cdFx0Ly8gdGhlIGRlc2lyZWQgY29vcmRpbmF0ZXMgaXMgdGhlIHNob3J0ZXN0LlxuXHRcdCQuZWFjaCggKCBvcHRpb25WYWx1ZSA9PT0gdHJ1ZSA/IFwibCx0LHIsYlwiIDogb3B0aW9uVmFsdWUgKS5zcGxpdCggXCIsXCIgKSxcblx0XHRcdCQucHJveHkoIGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRiZXN0ID0gdGhpcy5fdHJ5QW5BcnJvdyggcGFyYW1zWyB2YWx1ZSBdLCB2YWx1ZSwgZGVzaXJlZCwgc3RhdGUsIGJlc3QgKTtcblx0XHRcdH0sIHRoaXMgKSApO1xuXG5cdFx0Ly8gQ291bGQgbm90IHBsYWNlIHRoZSBhcnJvdyBhbG9uZyBhbnkgb2YgdGhlIGVkZ2VzIC0gYmVoYXZlIGFzIGlmIHNob3dpbmdcblx0XHQvLyB0aGUgYXJyb3cgd2FzIHR1cm5lZCBvZmYuXG5cdFx0aWYgKCAhYmVzdCApIHtcblx0XHRcdGFyLmFyRWxzLmhpZGUoKTtcblx0XHRcdHJldHVybiB0aGlzLl9zdXBlciggZGVzaXJlZCApO1xuXHRcdH1cblxuXHRcdC8vIE1vdmUgdGhlIGFycm93IGludG8gcGxhY2Vcblx0XHRhci5jdFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXBvcHVwLWFycm93LWwgdWktcG9wdXAtYXJyb3ctdCB1aS1wb3B1cC1hcnJvdy1yIHVpLXBvcHVwLWFycm93LWJcIiApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktcG9wdXAtYXJyb3ctXCIgKyBiZXN0LmRpciApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJzdHlsZVwiICkuY3NzKCBiZXN0LnBvc1Byb3AsIGJlc3QucG9zVmFsIClcblx0XHRcdC5zaG93KCk7XG5cblx0XHQvLyBEbyBub3QgbW92ZS9zaXplIHRoZSBiYWNrZ3JvdW5kIGRpdiBvbiBJRSwgYmVjYXVzZSB3ZSB1c2UgdGhlIGFycm93IGRpdiBmb3IgYmFja2dyb3VuZCBhcyB3ZWxsLlxuXHRcdGlmICggIWllSGFjayApIHtcblx0XHRcdGVsT2Zmc2V0ID0gdGhpcy5lbGVtZW50Lm9mZnNldCgpO1xuXHRcdFx0YmdSZWZbIHBhcmFtc1sgYmVzdC5kaXIgXS5mc3QgXSA9IGFyLmN0Lm9mZnNldCgpO1xuXHRcdFx0YmdSZWZbIHBhcmFtc1sgYmVzdC5kaXIgXS5zbmQgXSA9IHtcblx0XHRcdFx0bGVmdDogZWxPZmZzZXQubGVmdCArIHN0YXRlLmNvbnRlbnRCb3gueCxcblx0XHRcdFx0dG9wOiBlbE9mZnNldC50b3AgKyBzdGF0ZS5jb250ZW50Qm94Lnlcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJlc3QucmVzdWx0O1xuXHR9LFxuXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0cyApIHtcblx0XHR2YXIgbmV3VGhlbWUsXG5cdFx0XHRvbGRUaGVtZSA9IHRoaXMub3B0aW9ucy50aGVtZSxcblx0XHRcdGFyID0gdGhpcy5fdWkuYXJyb3csXG5cdFx0XHRyZXQgPSB0aGlzLl9zdXBlciggb3B0cyApO1xuXG5cdFx0aWYgKCBvcHRzLmFycm93ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoICFhciAmJiBvcHRzLmFycm93ICkge1xuXHRcdFx0XHR0aGlzLl91aS5hcnJvdyA9IHRoaXMuX2FkZEFycm93KCk7XG5cblx0XHRcdFx0Ly8gSW1wb3J0YW50IHRvIHJldHVybiBoZXJlIHNvIHdlIGRvbid0IHNldCB0aGUgc2FtZSBvcHRpb25zIGFsbCBvdmVyXG5cdFx0XHRcdC8vIGFnYWluIGJlbG93LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2UgaWYgKCBhciAmJiAhb3B0cy5hcnJvdyApIHtcblx0XHRcdFx0YXIuYXJFbHMucmVtb3ZlKCk7XG5cdFx0XHRcdHRoaXMuX3VpLmFycm93ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZWFzc2lnbiB3aXRoIHBvdGVudGlhbGx5IG5ldyBhcnJvd1xuXHRcdGFyID0gdGhpcy5fdWkuYXJyb3c7XG5cblx0XHRpZiAoIGFyICkge1xuXHRcdFx0aWYgKCBvcHRzLnRoZW1lICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdG9sZFRoZW1lID0gdGhpcy5fdGhlbWVDbGFzc0Zyb21PcHRpb24oIFwidWktYm9keS1cIiwgb2xkVGhlbWUgKTtcblx0XHRcdFx0bmV3VGhlbWUgPSB0aGlzLl90aGVtZUNsYXNzRnJvbU9wdGlvbiggXCJ1aS1ib2R5LVwiLCBvcHRzLnRoZW1lICk7XG5cdFx0XHRcdGFyLmFyLnJlbW92ZUNsYXNzKCBvbGRUaGVtZSApLmFkZENsYXNzKCBuZXdUaGVtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9wdHMuc2hhZG93ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGFyLmFyLnRvZ2dsZUNsYXNzKCBcInVpLW92ZXJsYXktc2hhZG93XCIsIG9wdHMuc2hhZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyID0gdGhpcy5fdWkuYXJyb3c7XG5cblx0XHRpZiAoIGFyICkge1xuXHRcdFx0YXIuYXJFbHMucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3N1cGVyKCk7XG5cdH1cbn0pO1xuXG59KSggalF1ZXJ5ICk7XG5cblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQud2lkZ2V0KCBcIm1vYmlsZS5wYW5lbFwiLCB7XG5cdG9wdGlvbnM6IHtcblx0XHRjbGFzc2VzOiB7XG5cdFx0XHRwYW5lbDogXCJ1aS1wYW5lbFwiLFxuXHRcdFx0cGFuZWxPcGVuOiBcInVpLXBhbmVsLW9wZW5cIixcblx0XHRcdHBhbmVsQ2xvc2VkOiBcInVpLXBhbmVsLWNsb3NlZFwiLFxuXHRcdFx0cGFuZWxGaXhlZDogXCJ1aS1wYW5lbC1maXhlZFwiLFxuXHRcdFx0cGFuZWxJbm5lcjogXCJ1aS1wYW5lbC1pbm5lclwiLFxuXHRcdFx0bW9kYWw6IFwidWktcGFuZWwtZGlzbWlzc1wiLFxuXHRcdFx0bW9kYWxPcGVuOiBcInVpLXBhbmVsLWRpc21pc3Mtb3BlblwiLFxuXHRcdFx0cGFnZUNvbnRhaW5lcjogXCJ1aS1wYW5lbC1wYWdlLWNvbnRhaW5lclwiLFxuXHRcdFx0cGFnZVdyYXBwZXI6IFwidWktcGFuZWwtd3JhcHBlclwiLFxuXHRcdFx0cGFnZUZpeGVkVG9vbGJhcjogXCJ1aS1wYW5lbC1maXhlZC10b29sYmFyXCIsXG5cdFx0XHRwYWdlQ29udGVudFByZWZpeDogXCJ1aS1wYW5lbC1wYWdlLWNvbnRlbnRcIiwgLyogVXNlZCBmb3Igd3JhcHBlciBhbmQgZml4ZWQgdG9vbGJhcnMgcG9zaXRpb24sIGRpc3BsYXkgYW5kIG9wZW4gY2xhc3Nlcy4gKi9cblx0XHRcdGFuaW1hdGU6IFwidWktcGFuZWwtYW5pbWF0ZVwiXG5cdFx0fSxcblx0XHRhbmltYXRlOiB0cnVlLFxuXHRcdHRoZW1lOiBudWxsLFxuXHRcdHBvc2l0aW9uOiBcImxlZnRcIixcblx0XHRkaXNtaXNzaWJsZTogdHJ1ZSxcblx0XHRkaXNwbGF5OiBcInJldmVhbFwiLCAvL2FjY2VwdHMgcmV2ZWFsLCBwdXNoLCBvdmVybGF5XG5cdFx0c3dpcGVDbG9zZTogdHJ1ZSxcblx0XHRwb3NpdGlvbkZpeGVkOiBmYWxzZVxuXHR9LFxuXG5cdF9jbG9zZUxpbms6IG51bGwsXG5cdF9wYXJlbnRQYWdlOiBudWxsLFxuXHRfcGFnZTogbnVsbCxcblx0X21vZGFsOiBudWxsLFxuXHRfcGFuZWxJbm5lcjogbnVsbCxcblx0X3dyYXBwZXI6IG51bGwsXG5cdF9maXhlZFRvb2xiYXJzOiBudWxsLFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdHBhcmVudFBhZ2UgPSBlbC5jbG9zZXN0KCBcIi51aS1wYWdlLCA6anFtRGF0YShyb2xlPSdwYWdlJylcIiApO1xuXG5cdFx0Ly8gZXhwb3NlIHNvbWUgcHJpdmF0ZSBwcm9wcyB0byBvdGhlciBtZXRob2RzXG5cdFx0JC5leHRlbmQoIHRoaXMsIHtcblx0XHRcdF9jbG9zZUxpbms6IGVsLmZpbmQoIFwiOmpxbURhdGEocmVsPSdjbG9zZScpXCIgKSxcblx0XHRcdF9wYXJlbnRQYWdlOiAoIHBhcmVudFBhZ2UubGVuZ3RoID4gMCApID8gcGFyZW50UGFnZSA6IGZhbHNlLFxuXHRcdFx0X29wZW5lZFBhZ2U6IG51bGwsXG5cdFx0XHRfcGFnZTogdGhpcy5fZ2V0UGFnZSxcblx0XHRcdF9wYW5lbElubmVyOiB0aGlzLl9nZXRQYW5lbElubmVyKCksXG5cdFx0XHRfZml4ZWRUb29sYmFyczogdGhpcy5fZ2V0Rml4ZWRUb29sYmFyc1xuXHRcdH0pO1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmRpc3BsYXkgIT09IFwib3ZlcmxheVwiICl7XG5cdFx0XHR0aGlzLl9nZXRXcmFwcGVyKCk7XG5cdFx0fVxuXHRcdHRoaXMuX2FkZFBhbmVsQ2xhc3NlcygpO1xuXG5cdFx0Ly8gaWYgYW5pbWF0aW5nLCBhZGQgdGhlIGNsYXNzIHRvIGRvIHNvXG5cdFx0aWYgKCAkLnN1cHBvcnQuY3NzVHJhbnNmb3JtM2QgJiYgISF0aGlzLm9wdGlvbnMuYW5pbWF0ZSApIHtcblx0XHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyggdGhpcy5vcHRpb25zLmNsYXNzZXMuYW5pbWF0ZSApO1xuXHRcdH1cblxuXHRcdHRoaXMuX2JpbmRVcGRhdGVMYXlvdXQoKTtcblx0XHR0aGlzLl9iaW5kQ2xvc2VFdmVudHMoKTtcblx0XHR0aGlzLl9iaW5kTGlua0xpc3RlbmVycygpO1xuXHRcdHRoaXMuX2JpbmRQYWdlRXZlbnRzKCk7XG5cblx0XHRpZiAoICEhdGhpcy5vcHRpb25zLmRpc21pc3NpYmxlICkge1xuXHRcdFx0dGhpcy5fY3JlYXRlTW9kYWwoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9iaW5kU3dpcGVFdmVudHMoKTtcblx0fSxcblxuXHRfZ2V0UGFuZWxJbm5lcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhbmVsSW5uZXIgPSB0aGlzLmVsZW1lbnQuZmluZCggXCIuXCIgKyB0aGlzLm9wdGlvbnMuY2xhc3Nlcy5wYW5lbElubmVyICk7XG5cblx0XHRpZiAoIHBhbmVsSW5uZXIubGVuZ3RoID09PSAwICkge1xuXHRcdFx0cGFuZWxJbm5lciA9IHRoaXMuZWxlbWVudC5jaGlsZHJlbigpLndyYXBBbGwoIFwiPGRpdiBjbGFzcz0nXCIgKyB0aGlzLm9wdGlvbnMuY2xhc3Nlcy5wYW5lbElubmVyICsgXCInIC8+XCIgKS5wYXJlbnQoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGFuZWxJbm5lcjtcblx0fSxcblxuXHRfY3JlYXRlTW9kYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdHRhcmdldCA9IHNlbGYuX3BhcmVudFBhZ2UgPyBzZWxmLl9wYXJlbnRQYWdlLnBhcmVudCgpIDogc2VsZi5lbGVtZW50LnBhcmVudCgpO1xuXG5cdFx0c2VsZi5fbW9kYWwgPSAkKCBcIjxkaXYgY2xhc3M9J1wiICsgc2VsZi5vcHRpb25zLmNsYXNzZXMubW9kYWwgKyBcIic+PC9kaXY+XCIgKVxuXHRcdFx0Lm9uKCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5jbG9zZSgpO1xuXHRcdFx0fSlcblx0XHRcdC5hcHBlbmRUbyggdGFyZ2V0ICk7XG5cdH0sXG5cblx0X2dldFBhZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYWdlID0gdGhpcy5fb3BlbmVkUGFnZSB8fCB0aGlzLl9wYXJlbnRQYWdlIHx8ICQoIFwiLlwiICsgJC5tb2JpbGUuYWN0aXZlUGFnZUNsYXNzICk7XG5cblx0XHRyZXR1cm4gcGFnZTtcblx0fSxcblxuXHRfZ2V0V3JhcHBlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLl9wYWdlKCkuZmluZCggXCIuXCIgKyB0aGlzLm9wdGlvbnMuY2xhc3Nlcy5wYWdlV3JhcHBlciApO1xuXHRcdGlmICggd3JhcHBlci5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHR3cmFwcGVyID0gdGhpcy5fcGFnZSgpLmNoaWxkcmVuKCBcIi51aS1oZWFkZXI6bm90KC51aS1oZWFkZXItZml4ZWQpLCAudWktY29udGVudDpub3QoLnVpLXBvcHVwKSwgLnVpLWZvb3Rlcjpub3QoLnVpLWZvb3Rlci1maXhlZClcIiApXG5cdFx0XHRcdC53cmFwQWxsKCBcIjxkaXYgY2xhc3M9J1wiICsgdGhpcy5vcHRpb25zLmNsYXNzZXMucGFnZVdyYXBwZXIgKyBcIic+PC9kaXY+XCIgKVxuXHRcdFx0XHQucGFyZW50KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fd3JhcHBlciA9IHdyYXBwZXI7XG5cdH0sXG5cblx0X2dldEZpeGVkVG9vbGJhcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBleHRGaXhlZFRvb2xiYXJzID0gJCggXCJib2R5XCIgKS5jaGlsZHJlbiggXCIudWktaGVhZGVyLWZpeGVkLCAudWktZm9vdGVyLWZpeGVkXCIgKSxcblx0XHRcdGludEZpeGVkVG9vbGJhcnMgPSB0aGlzLl9wYWdlKCkuZmluZCggXCIudWktaGVhZGVyLWZpeGVkLCAudWktZm9vdGVyLWZpeGVkXCIgKSxcblx0XHRcdGZpeGVkVG9vbGJhcnMgPSBleHRGaXhlZFRvb2xiYXJzLmFkZCggaW50Rml4ZWRUb29sYmFycyApLmFkZENsYXNzKCB0aGlzLm9wdGlvbnMuY2xhc3Nlcy5wYWdlRml4ZWRUb29sYmFyICk7XG5cblx0XHRyZXR1cm4gZml4ZWRUb29sYmFycztcblx0fSxcblxuXHRfZ2V0UG9zRGlzcGxheUNsYXNzZXM6IGZ1bmN0aW9uKCBwcmVmaXggKSB7XG5cdFx0cmV0dXJuIHByZWZpeCArIFwiLXBvc2l0aW9uLVwiICsgdGhpcy5vcHRpb25zLnBvc2l0aW9uICsgXCIgXCIgKyBwcmVmaXggKyBcIi1kaXNwbGF5LVwiICsgdGhpcy5vcHRpb25zLmRpc3BsYXk7XG5cdH0sXG5cblx0X2dldFBhbmVsQ2xhc3NlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhbmVsQ2xhc3NlcyA9IHRoaXMub3B0aW9ucy5jbGFzc2VzLnBhbmVsICtcblx0XHRcdFwiIFwiICsgdGhpcy5fZ2V0UG9zRGlzcGxheUNsYXNzZXMoIHRoaXMub3B0aW9ucy5jbGFzc2VzLnBhbmVsICkgK1xuXHRcdFx0XCIgXCIgKyB0aGlzLm9wdGlvbnMuY2xhc3Nlcy5wYW5lbENsb3NlZCArXG5cdFx0XHRcIiBcIiArIFwidWktYm9keS1cIiArICggdGhpcy5vcHRpb25zLnRoZW1lID8gdGhpcy5vcHRpb25zLnRoZW1lIDogXCJpbmhlcml0XCIgKTtcblxuXHRcdGlmICggISF0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCApIHtcblx0XHRcdHBhbmVsQ2xhc3NlcyArPSBcIiBcIiArIHRoaXMub3B0aW9ucy5jbGFzc2VzLnBhbmVsRml4ZWQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhbmVsQ2xhc3Nlcztcblx0fSxcblxuXHRfYWRkUGFuZWxDbGFzc2VzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoIHRoaXMuX2dldFBhbmVsQ2xhc3NlcygpICk7XG5cdH0sXG5cblx0X2hhbmRsZUNsb3NlQ2xpY2s6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblx0XHRcdHRoaXMuY2xvc2UoKTtcblx0XHR9XG5cdH0sXG5cblx0X2JpbmRDbG9zZUV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fb24oIHRoaXMuX2Nsb3NlTGluaywge1xuXHRcdFx0XCJjbGlja1wiOiBcIl9oYW5kbGVDbG9zZUNsaWNrXCJcblx0XHR9KTtcblxuXHRcdHRoaXMuX29uKHtcblx0XHRcdFwiY2xpY2sgYTpqcW1EYXRhKGFqYXg9J2ZhbHNlJylcIjogXCJfaGFuZGxlQ2xvc2VDbGlja1wiXG5cdFx0fSk7XG5cdH0sXG5cblx0X3Bvc2l0aW9uUGFuZWw6IGZ1bmN0aW9uKCBzY3JvbGxUb1RvcCApIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRwYW5lbElubmVySGVpZ2h0ID0gc2VsZi5fcGFuZWxJbm5lci5vdXRlckhlaWdodCgpLFxuXHRcdFx0ZXhwYW5kID0gcGFuZWxJbm5lckhlaWdodCA+ICQubW9iaWxlLmdldFNjcmVlbkhlaWdodCgpO1xuXG5cdFx0aWYgKCBleHBhbmQgfHwgIXNlbGYub3B0aW9ucy5wb3NpdGlvbkZpeGVkICkge1xuXHRcdFx0aWYgKCBleHBhbmQgKSB7XG5cdFx0XHRcdHNlbGYuX3VuZml4UGFuZWwoKTtcblx0XHRcdFx0JC5tb2JpbGUucmVzZXRBY3RpdmVQYWdlSGVpZ2h0KCBwYW5lbElubmVySGVpZ2h0ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHNjcm9sbFRvVG9wICkge1xuXHRcdFx0XHR0aGlzLndpbmRvd1sgMCBdLnNjcm9sbFRvKCAwLCAkLm1vYmlsZS5kZWZhdWx0SG9tZVNjcm9sbCApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZWxmLl9maXhQYW5lbCgpO1xuXHRcdH1cblx0fSxcblxuXHRfYmluZEZpeExpc3RlbmVyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9vbiggJCggd2luZG93ICksIHsgXCJ0aHJvdHRsZWRyZXNpemVcIjogXCJfcG9zaXRpb25QYW5lbFwiIH0pO1xuXHR9LFxuXG5cdF91bmJpbmRGaXhMaXN0ZW5lcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fb2ZmKCAkKCB3aW5kb3cgKSwgXCJ0aHJvdHRsZWRyZXNpemVcIiApO1xuXHR9LFxuXG5cdF91bmZpeFBhbmVsOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICEhdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQgJiYgJC5zdXBwb3J0LmZpeGVkUG9zaXRpb24gKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoIHRoaXMub3B0aW9ucy5jbGFzc2VzLnBhbmVsRml4ZWQgKTtcblx0XHR9XG5cdH0sXG5cblx0X2ZpeFBhbmVsOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICEhdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQgJiYgJC5zdXBwb3J0LmZpeGVkUG9zaXRpb24gKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoIHRoaXMub3B0aW9ucy5jbGFzc2VzLnBhbmVsRml4ZWQgKTtcblx0XHR9XG5cdH0sXG5cblx0X2JpbmRVcGRhdGVMYXlvdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdHNlbGYuZWxlbWVudC5vbiggXCJ1cGRhdGVsYXlvdXRcIiwgZnVuY3Rpb24oLyogZSAqLykge1xuXHRcdFx0aWYgKCBzZWxmLl9vcGVuICkge1xuXHRcdFx0XHRzZWxmLl9wb3NpdGlvblBhbmVsKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X2JpbmRMaW5rTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9vbiggXCJib2R5XCIsIHtcblx0XHRcdFwiY2xpY2sgYVwiOiBcIl9oYW5kbGVDbGlja1wiXG5cdFx0fSk7XG5cblx0fSxcblxuXHRfaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uKCBlICkge1xuXHRcdHZhciBsaW5rLFxuXHRcdFx0cGFuZWxJZCA9IHRoaXMuZWxlbWVudC5hdHRyKCBcImlkXCIgKTtcblxuXHRcdGlmICggZS5jdXJyZW50VGFyZ2V0LmhyZWYuc3BsaXQoIFwiI1wiIClbIDEgXSA9PT0gcGFuZWxJZCAmJiBwYW5lbElkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGxpbmsgPSAkKCBlLnRhcmdldCApO1xuXHRcdFx0aWYgKCBsaW5rLmhhc0NsYXNzKCBcInVpLWJ0blwiICkgKSB7XG5cdFx0XHRcdGxpbmsuYWRkQ2xhc3MoICQubW9iaWxlLmFjdGl2ZUJ0bkNsYXNzICk7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5vbmUoIFwicGFuZWxvcGVuIHBhbmVsY2xvc2VcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0bGluay5yZW1vdmVDbGFzcyggJC5tb2JpbGUuYWN0aXZlQnRuQ2xhc3MgKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnRvZ2dsZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfYmluZFN3aXBlRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRhcmVhID0gc2VsZi5fbW9kYWwgPyBzZWxmLmVsZW1lbnQuYWRkKCBzZWxmLl9tb2RhbCApIDogc2VsZi5lbGVtZW50O1xuXG5cdFx0Ly8gb24gc3dpcGUsIGNsb3NlIHRoZSBwYW5lbFxuXHRcdGlmICggISFzZWxmLm9wdGlvbnMuc3dpcGVDbG9zZSApIHtcblx0XHRcdGlmICggc2VsZi5vcHRpb25zLnBvc2l0aW9uID09PSBcImxlZnRcIiApIHtcblx0XHRcdFx0YXJlYS5vbiggXCJzd2lwZWxlZnQucGFuZWxcIiwgZnVuY3Rpb24oLyogZSAqLykge1xuXHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhcmVhLm9uKCBcInN3aXBlcmlnaHQucGFuZWxcIiwgZnVuY3Rpb24oLyogZSAqLykge1xuXHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9iaW5kUGFnZUV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0dGhpcy5kb2N1bWVudFxuXHRcdFx0Ly8gQ2xvc2UgdGhlIHBhbmVsIGlmIGFub3RoZXIgcGFuZWwgb24gdGhlIHBhZ2Ugb3BlbnNcblx0XHRcdC5vbiggXCJwYW5lbGJlZm9yZW9wZW5cIiwgZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRcdGlmICggc2VsZi5fb3BlbiAmJiBlLnRhcmdldCAhPT0gc2VsZi5lbGVtZW50WyAwIF0gKSB7XG5cdFx0XHRcdFx0c2VsZi5jbG9zZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdFx0Ly8gT24gZXNjYXBlLCBjbG9zZT8gbWlnaHQgbmVlZCB0byBoYXZlIGEgdGFyZ2V0IGNoZWNrIHRvby4uLlxuXHRcdFx0Lm9uKCBcImtleXVwLnBhbmVsXCIsIGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0XHRpZiAoIGUua2V5Q29kZSA9PT0gMjcgJiYgc2VsZi5fb3BlbiApIHtcblx0XHRcdFx0XHRzZWxmLmNsb3NlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdGlmICggIXRoaXMuX3BhcmVudFBhZ2UgJiYgdGhpcy5vcHRpb25zLmRpc3BsYXkgIT09IFwib3ZlcmxheVwiICkge1xuXHRcdFx0dGhpcy5fb24oIHRoaXMuZG9jdW1lbnQsIHtcblx0XHRcdFx0XCJwYWdlc2hvd1wiOiBcIl9nZXRXcmFwcGVyXCJcblx0XHRcdH0pO1xuXHRcdH1cblx0XHQvLyBDbGVhbiB1cCBvcGVuIHBhbmVscyBhZnRlciBwYWdlIGhpZGVcblx0XHRpZiAoIHNlbGYuX3BhcmVudFBhZ2UgKSB7XG5cdFx0XHR0aGlzLmRvY3VtZW50Lm9uKCBcInBhZ2VoaWRlXCIsIFwiOmpxbURhdGEocm9sZT0ncGFnZScpXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHNlbGYuX29wZW4gKSB7XG5cdFx0XHRcdFx0c2VsZi5jbG9zZSggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5kb2N1bWVudC5vbiggXCJwYWdlYmVmb3JlaGlkZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBzZWxmLl9vcGVuICkge1xuXHRcdFx0XHRcdHNlbGYuY2xvc2UoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIHN0YXRlIHN0b3JhZ2Ugb2Ygb3BlbiBvciBjbG9zZWRcblx0X29wZW46IGZhbHNlLFxuXHRfcGFnZUNvbnRlbnRPcGVuQ2xhc3NlczogbnVsbCxcblx0X21vZGFsT3BlbkNsYXNzZXM6IG51bGwsXG5cblx0b3BlbjogZnVuY3Rpb24oIGltbWVkaWF0ZSApIHtcblx0XHRpZiAoICF0aGlzLl9vcGVuICkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRvID0gc2VsZi5vcHRpb25zLFxuXG5cdFx0XHRcdF9vcGVuUGFuZWwgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLl9vZmYoIHNlbGYuZG9jdW1lbnQgLCBcInBhbmVsY2xvc2VcIiApO1xuXHRcdFx0XHRcdHNlbGYuX3BhZ2UoKS5qcW1EYXRhKCBcInBhbmVsXCIsIFwib3BlblwiICk7XG5cblx0XHRcdFx0XHRpZiAoICQuc3VwcG9ydC5jc3NUcmFuc2Zvcm0zZCAmJiAhIW8uYW5pbWF0ZSAmJiBvLmRpc3BsYXkgIT09IFwib3ZlcmxheVwiICkge1xuXHRcdFx0XHRcdFx0c2VsZi5fd3JhcHBlci5hZGRDbGFzcyggby5jbGFzc2VzLmFuaW1hdGUgKTtcblx0XHRcdFx0XHRcdHNlbGYuX2ZpeGVkVG9vbGJhcnMoKS5hZGRDbGFzcyggby5jbGFzc2VzLmFuaW1hdGUgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICFpbW1lZGlhdGUgJiYgJC5zdXBwb3J0LmNzc1RyYW5zZm9ybTNkICYmICEhby5hbmltYXRlICkge1xuXHRcdFx0XHRcdFx0KCBzZWxmLl93cmFwcGVyIHx8IHNlbGYuZWxlbWVudCApXG5cdFx0XHRcdFx0XHRcdC5hbmltYXRpb25Db21wbGV0ZSggY29tcGxldGUsIFwidHJhbnNpdGlvblwiICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoIGNvbXBsZXRlLCAwICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBvLnRoZW1lICYmIG8uZGlzcGxheSAhPT0gXCJvdmVybGF5XCIgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLl9wYWdlKCkucGFyZW50KClcblx0XHRcdFx0XHRcdFx0LmFkZENsYXNzKCBvLmNsYXNzZXMucGFnZUNvbnRhaW5lciArIFwiLXRoZW1lZCBcIiArIG8uY2xhc3Nlcy5wYWdlQ29udGFpbmVyICsgXCItXCIgKyBvLnRoZW1lICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2VsZi5lbGVtZW50XG5cdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIG8uY2xhc3Nlcy5wYW5lbENsb3NlZCApXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoIG8uY2xhc3Nlcy5wYW5lbE9wZW4gKTtcblxuXHRcdFx0XHRcdHNlbGYuX3Bvc2l0aW9uUGFuZWwoIHRydWUgKTtcblxuXHRcdFx0XHRcdHNlbGYuX3BhZ2VDb250ZW50T3BlbkNsYXNzZXMgPSBzZWxmLl9nZXRQb3NEaXNwbGF5Q2xhc3Nlcyggby5jbGFzc2VzLnBhZ2VDb250ZW50UHJlZml4ICk7XG5cblx0XHRcdFx0XHRpZiAoIG8uZGlzcGxheSAhPT0gXCJvdmVybGF5XCIgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLl9wYWdlKCkucGFyZW50KCkuYWRkQ2xhc3MoIG8uY2xhc3Nlcy5wYWdlQ29udGFpbmVyICk7XG5cdFx0XHRcdFx0XHRzZWxmLl93cmFwcGVyLmFkZENsYXNzKCBzZWxmLl9wYWdlQ29udGVudE9wZW5DbGFzc2VzICk7XG5cdFx0XHRcdFx0XHRzZWxmLl9maXhlZFRvb2xiYXJzKCkuYWRkQ2xhc3MoIHNlbGYuX3BhZ2VDb250ZW50T3BlbkNsYXNzZXMgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzZWxmLl9tb2RhbE9wZW5DbGFzc2VzID0gc2VsZi5fZ2V0UG9zRGlzcGxheUNsYXNzZXMoIG8uY2xhc3Nlcy5tb2RhbCApICsgXCIgXCIgKyBvLmNsYXNzZXMubW9kYWxPcGVuO1xuXHRcdFx0XHRcdGlmICggc2VsZi5fbW9kYWwgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLl9tb2RhbFxuXHRcdFx0XHRcdFx0XHQuYWRkQ2xhc3MoIHNlbGYuX21vZGFsT3BlbkNsYXNzZXMgKVxuXHRcdFx0XHRcdFx0XHQuaGVpZ2h0KCBNYXRoLm1heCggc2VsZi5fbW9kYWwuaGVpZ2h0KCksIHNlbGYuZG9jdW1lbnQuaGVpZ2h0KCkgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0Y29tcGxldGUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdC8vIEJhaWwgaWYgdGhlIHBhbmVsIHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBvcGVuaW5nIGFuaW1hdGlvbiBoYXMgY29tcGxldGVkXG5cdFx0XHRcdFx0aWYgKCAhc2VsZi5fb3BlbiApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIG8uZGlzcGxheSAhPT0gXCJvdmVybGF5XCIgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLl93cmFwcGVyLmFkZENsYXNzKCBvLmNsYXNzZXMucGFnZUNvbnRlbnRQcmVmaXggKyBcIi1vcGVuXCIgKTtcblx0XHRcdFx0XHRcdHNlbGYuX2ZpeGVkVG9vbGJhcnMoKS5hZGRDbGFzcyggby5jbGFzc2VzLnBhZ2VDb250ZW50UHJlZml4ICsgXCItb3BlblwiICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2VsZi5fYmluZEZpeExpc3RlbmVyKCk7XG5cblx0XHRcdFx0XHRzZWxmLl90cmlnZ2VyKCBcIm9wZW5cIiApO1xuXG5cdFx0XHRcdFx0c2VsZi5fb3BlbmVkUGFnZSA9IHNlbGYuX3BhZ2UoKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0c2VsZi5fdHJpZ2dlciggXCJiZWZvcmVvcGVuXCIgKTtcblxuXHRcdFx0aWYgKCBzZWxmLl9wYWdlKCkuanFtRGF0YSggXCJwYW5lbFwiICkgPT09IFwib3BlblwiICkge1xuXHRcdFx0XHRzZWxmLl9vbiggc2VsZi5kb2N1bWVudCwge1xuXHRcdFx0XHRcdFwicGFuZWxjbG9zZVwiOiBfb3BlblBhbmVsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X29wZW5QYW5lbCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxmLl9vcGVuID0gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0Y2xvc2U6IGZ1bmN0aW9uKCBpbW1lZGlhdGUgKSB7XG5cdFx0aWYgKCB0aGlzLl9vcGVuICkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRvID0gdGhpcy5vcHRpb25zLFxuXG5cdFx0XHRcdF9jbG9zZVBhbmVsID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRzZWxmLmVsZW1lbnQucmVtb3ZlQ2xhc3MoIG8uY2xhc3Nlcy5wYW5lbE9wZW4gKTtcblxuXHRcdFx0XHRcdGlmICggby5kaXNwbGF5ICE9PSBcIm92ZXJsYXlcIiApIHtcblx0XHRcdFx0XHRcdHNlbGYuX3dyYXBwZXIucmVtb3ZlQ2xhc3MoIHNlbGYuX3BhZ2VDb250ZW50T3BlbkNsYXNzZXMgKTtcblx0XHRcdFx0XHRcdHNlbGYuX2ZpeGVkVG9vbGJhcnMoKS5yZW1vdmVDbGFzcyggc2VsZi5fcGFnZUNvbnRlbnRPcGVuQ2xhc3NlcyApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggIWltbWVkaWF0ZSAmJiAkLnN1cHBvcnQuY3NzVHJhbnNmb3JtM2QgJiYgISFvLmFuaW1hdGUgKSB7XG5cdFx0XHRcdFx0XHQoIHNlbGYuX3dyYXBwZXIgfHwgc2VsZi5lbGVtZW50IClcblx0XHRcdFx0XHRcdFx0LmFuaW1hdGlvbkNvbXBsZXRlKCBjb21wbGV0ZSwgXCJ0cmFuc2l0aW9uXCIgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2V0VGltZW91dCggY29tcGxldGUsIDAgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHNlbGYuX21vZGFsICkge1xuXHRcdFx0XHRcdFx0c2VsZi5fbW9kYWxcblx0XHRcdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBzZWxmLl9tb2RhbE9wZW5DbGFzc2VzIClcblx0XHRcdFx0XHRcdFx0LmhlaWdodCggXCJcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0Y29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIG8udGhlbWUgJiYgby5kaXNwbGF5ICE9PSBcIm92ZXJsYXlcIiApIHtcblx0XHRcdFx0XHRcdHNlbGYuX3BhZ2UoKS5wYXJlbnQoKS5yZW1vdmVDbGFzcyggby5jbGFzc2VzLnBhZ2VDb250YWluZXIgKyBcIi10aGVtZWQgXCIgKyBvLmNsYXNzZXMucGFnZUNvbnRhaW5lciArIFwiLVwiICsgby50aGVtZSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNlbGYuZWxlbWVudC5hZGRDbGFzcyggby5jbGFzc2VzLnBhbmVsQ2xvc2VkICk7XG5cblx0XHRcdFx0XHRpZiAoIG8uZGlzcGxheSAhPT0gXCJvdmVybGF5XCIgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLl9wYWdlKCkucGFyZW50KCkucmVtb3ZlQ2xhc3MoIG8uY2xhc3Nlcy5wYWdlQ29udGFpbmVyICk7XG5cdFx0XHRcdFx0XHRzZWxmLl93cmFwcGVyLnJlbW92ZUNsYXNzKCBvLmNsYXNzZXMucGFnZUNvbnRlbnRQcmVmaXggKyBcIi1vcGVuXCIgKTtcblx0XHRcdFx0XHRcdHNlbGYuX2ZpeGVkVG9vbGJhcnMoKS5yZW1vdmVDbGFzcyggby5jbGFzc2VzLnBhZ2VDb250ZW50UHJlZml4ICsgXCItb3BlblwiICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAkLnN1cHBvcnQuY3NzVHJhbnNmb3JtM2QgJiYgISFvLmFuaW1hdGUgJiYgby5kaXNwbGF5ICE9PSBcIm92ZXJsYXlcIiApIHtcblx0XHRcdFx0XHRcdHNlbGYuX3dyYXBwZXIucmVtb3ZlQ2xhc3MoIG8uY2xhc3Nlcy5hbmltYXRlICk7XG5cdFx0XHRcdFx0XHRzZWxmLl9maXhlZFRvb2xiYXJzKCkucmVtb3ZlQ2xhc3MoIG8uY2xhc3Nlcy5hbmltYXRlICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2VsZi5fZml4UGFuZWwoKTtcblx0XHRcdFx0XHRzZWxmLl91bmJpbmRGaXhMaXN0ZW5lcigpO1xuXHRcdFx0XHRcdCQubW9iaWxlLnJlc2V0QWN0aXZlUGFnZUhlaWdodCgpO1xuXG5cdFx0XHRcdFx0c2VsZi5fcGFnZSgpLmpxbVJlbW92ZURhdGEoIFwicGFuZWxcIiApO1xuXG5cdFx0XHRcdFx0c2VsZi5fdHJpZ2dlciggXCJjbG9zZVwiICk7XG5cblx0XHRcdFx0XHRzZWxmLl9vcGVuZWRQYWdlID0gbnVsbDtcblx0XHRcdFx0fTtcblxuXHRcdFx0c2VsZi5fdHJpZ2dlciggXCJiZWZvcmVjbG9zZVwiICk7XG5cblx0XHRcdF9jbG9zZVBhbmVsKCk7XG5cblx0XHRcdHNlbGYuX29wZW4gPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0dG9nZ2xlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzWyB0aGlzLl9vcGVuID8gXCJjbG9zZVwiIDogXCJvcGVuXCIgXSgpO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3RoZXJQYW5lbHMsXG5cdFx0byA9IHRoaXMub3B0aW9ucyxcblx0XHRtdWx0aXBsZVBhbmVscyA9ICggJCggXCJib2R5ID4gOm1vYmlsZS1wYW5lbFwiICkubGVuZ3RoICsgJC5tb2JpbGUuYWN0aXZlUGFnZS5maW5kKCBcIjptb2JpbGUtcGFuZWxcIiApLmxlbmd0aCApID4gMTtcblxuXHRcdGlmICggby5kaXNwbGF5ICE9PSBcIm92ZXJsYXlcIiApIHtcblxuXHRcdFx0Ly8gIHJlbW92ZSB0aGUgd3JhcHBlciBpZiBub3QgaW4gdXNlIGJ5IGFub3RoZXIgcGFuZWxcblx0XHRcdG90aGVyUGFuZWxzID0gJCggXCJib2R5ID4gOm1vYmlsZS1wYW5lbFwiICkuYWRkKCAkLm1vYmlsZS5hY3RpdmVQYWdlLmZpbmQoIFwiOm1vYmlsZS1wYW5lbFwiICkgKTtcblx0XHRcdGlmICggb3RoZXJQYW5lbHMubm90KCBcIi51aS1wYW5lbC1kaXNwbGF5LW92ZXJsYXlcIiApLm5vdCggdGhpcy5lbGVtZW50ICkubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHR0aGlzLl93cmFwcGVyLmNoaWxkcmVuKCkudW53cmFwKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5fb3BlbiApIHtcblxuXHRcdFx0XHR0aGlzLl9maXhlZFRvb2xiYXJzKCkucmVtb3ZlQ2xhc3MoIG8uY2xhc3Nlcy5wYWdlQ29udGVudFByZWZpeCArIFwiLW9wZW5cIiApO1xuXG5cdFx0XHRcdGlmICggJC5zdXBwb3J0LmNzc1RyYW5zZm9ybTNkICYmICEhby5hbmltYXRlICkge1xuXHRcdFx0XHRcdHRoaXMuX2ZpeGVkVG9vbGJhcnMoKS5yZW1vdmVDbGFzcyggby5jbGFzc2VzLmFuaW1hdGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX3BhZ2UoKS5wYXJlbnQoKS5yZW1vdmVDbGFzcyggby5jbGFzc2VzLnBhZ2VDb250YWluZXIgKTtcblxuXHRcdFx0XHRpZiAoIG8udGhlbWUgKSB7XG5cdFx0XHRcdFx0dGhpcy5fcGFnZSgpLnBhcmVudCgpLnJlbW92ZUNsYXNzKCBvLmNsYXNzZXMucGFnZUNvbnRhaW5lciArIFwiLXRoZW1lZCBcIiArIG8uY2xhc3Nlcy5wYWdlQ29udGFpbmVyICsgXCItXCIgKyBvLnRoZW1lICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtdWx0aXBsZVBhbmVscyApIHtcblxuXHRcdFx0dGhpcy5kb2N1bWVudC5vZmYoIFwicGFuZWxvcGVuIHBhbmVsY2xvc2VcIiApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9vcGVuICkge1xuXHRcdFx0dGhpcy5fcGFnZSgpLmpxbVJlbW92ZURhdGEoIFwicGFuZWxcIiApO1xuXHRcdH1cblxuXHRcdHRoaXMuX3BhbmVsSW5uZXIuY2hpbGRyZW4oKS51bndyYXAoKTtcblxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBbIHRoaXMuX2dldFBhbmVsQ2xhc3NlcygpLCBvLmNsYXNzZXMucGFuZWxPcGVuLCBvLmNsYXNzZXMuYW5pbWF0ZSBdLmpvaW4oIFwiIFwiICkgKVxuXHRcdFx0Lm9mZiggXCJzd2lwZWxlZnQucGFuZWwgc3dpcGVyaWdodC5wYW5lbFwiIClcblx0XHRcdC5vZmYoIFwicGFuZWxiZWZvcmVvcGVuXCIgKVxuXHRcdFx0Lm9mZiggXCJwYW5lbGhpZGVcIiApXG5cdFx0XHQub2ZmKCBcImtleXVwLnBhbmVsXCIgKVxuXHRcdFx0Lm9mZiggXCJ1cGRhdGVsYXlvdXRcIiApO1xuXG5cdFx0aWYgKCB0aGlzLl9tb2RhbCApIHtcblx0XHRcdHRoaXMuX21vZGFsLnJlbW92ZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbn0pKCBqUXVlcnkgKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQud2lkZ2V0KCBcIm1vYmlsZS50YWJsZVwiLCB7XG5cdG9wdGlvbnM6IHtcblx0XHRjbGFzc2VzOiB7XG5cdFx0XHR0YWJsZTogXCJ1aS10YWJsZVwiXG5cdFx0fSxcblx0XHRlbmhhbmNlZDogZmFsc2Vcblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZW5oYW5jZWQgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoIHRoaXMub3B0aW9ucy5jbGFzc2VzLnRhYmxlICk7XG5cdFx0fVxuXG5cdFx0Ly8gZXh0ZW5kIGhlcmUsIGFzc2lnbiBvbiByZWZyZXNoID4gX3NldEhlYWRlcnNcblx0XHQkLmV4dGVuZCggdGhpcywge1xuXG5cdFx0XHQvLyBFeHBvc2UgaGVhZGVycyBhbmQgYWxsSGVhZGVycyBwcm9wZXJ0aWVzIG9uIHRoZSB3aWRnZXRcblx0XHRcdC8vIGhlYWRlcnMgcmVmZXJlbmNlcyB0aGUgVEhzIHdpdGhpbiB0aGUgZmlyc3QgVFIgaW4gdGhlIHRhYmxlXG5cdFx0XHRoZWFkZXJzOiB1bmRlZmluZWQsXG5cblx0XHRcdC8vIGFsbEhlYWRlcnMgcmVmZXJlbmNlcyBoZWFkZXJzLCBwbHVzIGFsbCBUSHMgaW4gdGhlIHRoZWFkLCB3aGljaCBtYXlcblx0XHRcdC8vIGluY2x1ZGUgc2V2ZXJhbCByb3dzLCBvciBub3Rcblx0XHRcdGFsbEhlYWRlcnM6IHVuZGVmaW5lZFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fcmVmcmVzaCggdHJ1ZSApO1xuXHR9LFxuXG5cdF9zZXRIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHJzID0gdGhpcy5lbGVtZW50LmZpbmQoIFwidGhlYWQgdHJcIiApO1xuXG5cdFx0dGhpcy5oZWFkZXJzID0gdGhpcy5lbGVtZW50LmZpbmQoIFwidHI6ZXEoMClcIiApLmNoaWxkcmVuKCk7XG5cdFx0dGhpcy5hbGxIZWFkZXJzID0gdGhpcy5oZWFkZXJzLmFkZCggdHJzLmNoaWxkcmVuKCkgKTtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdH0sXG5cblx0cmVidWlsZDogJC5ub29wLFxuXG5cdF9yZWZyZXNoOiBmdW5jdGlvbiggLyogY3JlYXRlICovICkge1xuXHRcdHZhciB0YWJsZSA9IHRoaXMuZWxlbWVudCxcblx0XHRcdHRycyA9IHRhYmxlLmZpbmQoIFwidGhlYWQgdHJcIiApO1xuXG5cdFx0Ly8gdXBkYXRpbmcgaGVhZGVycyBvbiByZWZyZXNoIChmaXhlcyAjNTg4MClcblx0XHR0aGlzLl9zZXRIZWFkZXJzKCk7XG5cblx0XHQvLyBJdGVyYXRlIG92ZXIgdGhlIHRyc1xuXHRcdHRycy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjb2x1bW5Db3VudCA9IDA7XG5cblx0XHRcdC8vIEl0ZXJhdGUgb3ZlciB0aGUgY2hpbGRyZW4gb2YgdGhlIHRyXG5cdFx0XHQkKCB0aGlzICkuY2hpbGRyZW4oKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHNwYW4gPSBwYXJzZUludCggdGhpcy5nZXRBdHRyaWJ1dGUoIFwiY29sc3BhblwiICksIDEwICksXG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBcIjpudGgtY2hpbGQoXCIgKyAoIGNvbHVtbkNvdW50ICsgMSApICsgXCIpXCIsXG5cdFx0XHRcdFx0ajtcblxuXHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJkYXRhLVwiICsgJC5tb2JpbGUubnMgKyBcImNvbHN0YXJ0XCIsIGNvbHVtbkNvdW50ICsgMSApO1xuXG5cdFx0XHRcdGlmICggc3BhbiApIHtcblx0XHRcdFx0XHRmb3IoIGogPSAwOyBqIDwgc3BhbiAtIDE7IGorKyApIHtcblx0XHRcdFx0XHRcdGNvbHVtbkNvdW50Kys7XG5cdFx0XHRcdFx0XHRzZWxlY3RvciArPSBcIiwgOm50aC1jaGlsZChcIiArICggY29sdW1uQ291bnQgKyAxICkgKyBcIilcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdG9yZSBcImNlbGxzXCIgZGF0YSBvbiBoZWFkZXIgYXMgYSByZWZlcmVuY2UgdG8gYWxsIGNlbGxzIGluIHRoZVxuXHRcdFx0XHQvLyBzYW1lIGNvbHVtbiBhcyB0aGlzIFRIXG5cdFx0XHRcdCQoIHRoaXMgKS5qcW1EYXRhKCBcImNlbGxzXCIsIHRhYmxlLmZpbmQoIFwidHJcIiApLm5vdCggdHJzLmVxKCAwICkgKS5ub3QoIHRoaXMgKS5jaGlsZHJlbiggc2VsZWN0b3IgKSApO1xuXG5cdFx0XHRcdGNvbHVtbkNvdW50Kys7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxufSk7XG5cbn0pKCBqUXVlcnkgKTtcblxuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoIFwibW9iaWxlLnRhYmxlXCIsICQubW9iaWxlLnRhYmxlLCB7XG5cdG9wdGlvbnM6IHtcblx0XHRtb2RlOiBcImNvbHVtbnRvZ2dsZVwiLFxuXHRcdGNvbHVtbkJ0blRoZW1lOiBudWxsLFxuXHRcdGNvbHVtblBvcHVwVGhlbWU6IG51bGwsXG5cdFx0Y29sdW1uQnRuVGV4dDogXCJDb2x1bW5zLi4uXCIsXG5cdFx0Y2xhc3NlczogJC5leHRlbmQoICQubW9iaWxlLnRhYmxlLnByb3RvdHlwZS5vcHRpb25zLmNsYXNzZXMsIHtcblx0XHRcdHBvcHVwOiBcInVpLXRhYmxlLWNvbHVtbnRvZ2dsZS1wb3B1cFwiLFxuXHRcdFx0Y29sdW1uQnRuOiBcInVpLXRhYmxlLWNvbHVtbnRvZ2dsZS1idG5cIixcblx0XHRcdHByaW9yaXR5UHJlZml4OiBcInVpLXRhYmxlLXByaW9yaXR5LVwiLFxuXHRcdFx0Y29sdW1uVG9nZ2xlVGFibGU6IFwidWktdGFibGUtY29sdW1udG9nZ2xlXCJcblx0XHR9KVxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3N1cGVyKCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5tb2RlICE9PSBcImNvbHVtbnRvZ2dsZVwiICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdCQuZXh0ZW5kKCB0aGlzLCB7XG5cdFx0XHRfbWVudTogbnVsbFxuXHRcdH0pO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZW5oYW5jZWQgKSB7XG5cdFx0XHR0aGlzLl9tZW51ID0gJCggdGhpcy5kb2N1bWVudFsgMCBdLmdldEVsZW1lbnRCeUlkKCB0aGlzLl9pZCgpICsgXCItcG9wdXBcIiApICkuY2hpbGRyZW4oKS5maXJzdCgpO1xuXHRcdFx0dGhpcy5fYWRkVG9nZ2xlcyggdGhpcy5fbWVudSwgdHJ1ZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9tZW51ID0gdGhpcy5fZW5oYW5jZUNvbFRvZ2dsZSgpO1xuXHRcdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKCB0aGlzLm9wdGlvbnMuY2xhc3Nlcy5jb2x1bW5Ub2dnbGVUYWJsZSApO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NldHVwRXZlbnRzKCk7XG5cblx0XHR0aGlzLl9zZXRUb2dnbGVTdGF0ZSgpO1xuXHR9LFxuXG5cdF9pZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICggdGhpcy5lbGVtZW50LmF0dHIoIFwiaWRcIiApIHx8ICggdGhpcy53aWRnZXROYW1lICsgdGhpcy51dWlkICkgKTtcblx0fSxcblxuXHRfc2V0dXBFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vTk9URTogaW5wdXRzIGFyZSBib3VuZCBpbiBiaW5kVG9nZ2xlcyxcblx0XHQvLyBzbyBpdCBjYW4gYmUgY2FsbGVkIG9uIHJlZnJlc2gsIHRvb1xuXG5cdFx0Ly8gdXBkYXRlIGNvbHVtbiB0b2dnbGVzIG9uIHJlc2l6ZVxuXHRcdHRoaXMuX29uKCB0aGlzLndpbmRvdywge1xuXHRcdFx0dGhyb3R0bGVkcmVzaXplOiBcIl9zZXRUb2dnbGVTdGF0ZVwiXG5cdFx0fSk7XG5cdFx0dGhpcy5fb24oIHRoaXMuX21lbnUsIHtcblx0XHRcdFwiY2hhbmdlIGlucHV0XCI6IFwiX21lbnVJbnB1dENoYW5nZVwiXG5cdFx0fSk7XG5cdH0sXG5cblx0X2FkZFRvZ2dsZXM6IGZ1bmN0aW9uKCBtZW51LCBrZWVwICkge1xuXHRcdHZhciBpbnB1dHMsXG5cdFx0XHRjaGVja2JveEluZGV4ID0gMCxcblx0XHRcdG9wdHMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRjb250YWluZXIgPSBtZW51LmNvbnRyb2xncm91cCggXCJjb250YWluZXJcIiApO1xuXG5cdFx0Ly8gYWxsb3cgdXBkYXRlIG9mIG1lbnUgb24gcmVmcmVzaCAoZml4ZXMgIzU4ODApXG5cdFx0aWYgKCBrZWVwICkge1xuXHRcdFx0aW5wdXRzID0gbWVudS5maW5kKCBcImlucHV0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGFpbmVyLmVtcHR5KCk7XG5cdFx0fVxuXG5cdFx0Ly8gY3JlYXRlIHRoZSBoaWRlL3Nob3cgdG9nZ2xlc1xuXHRcdHRoaXMuaGVhZGVycy5ub3QoIFwidGRcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGlucHV0LCBjZWxscyxcblx0XHRcdFx0aGVhZGVyID0gJCggdGhpcyApLFxuXHRcdFx0XHRwcmlvcml0eSA9ICQubW9iaWxlLmdldEF0dHJpYnV0ZSggdGhpcywgXCJwcmlvcml0eVwiICk7XG5cblx0XHRcdGlmICggcHJpb3JpdHkgKSB7XG5cdFx0XHRcdGNlbGxzID0gaGVhZGVyLmFkZCggaGVhZGVyLmpxbURhdGEoIFwiY2VsbHNcIiApICk7XG5cdFx0XHRcdGNlbGxzLmFkZENsYXNzKCBvcHRzLmNsYXNzZXMucHJpb3JpdHlQcmVmaXggKyBwcmlvcml0eSApO1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGUgKG5ldz8pIGNoZWNrYm94IGlzIGFzc29jaWF0ZWQgd2l0aCBpdHMgaGVhZGVyIHZpYSAuanFtRGF0YSgpIGFuZFxuXHRcdFx0XHQvLyB0aGF0LCB2aWNlIHZlcnNhLCB0aGUgaGVhZGVyIGlzIGFsc28gYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGVja2JveFxuXHRcdFx0XHRpbnB1dCA9ICgga2VlcCA/IGlucHV0cy5lcSggY2hlY2tib3hJbmRleCsrICkgOlxuXHRcdFx0XHRcdCQoXCI8bGFiZWw+PGlucHV0IHR5cGU9J2NoZWNrYm94JyBjaGVja2VkIC8+XCIgK1xuXHRcdFx0XHRcdFx0KCBoZWFkZXIuY2hpbGRyZW4oIFwiYWJiclwiICkuZmlyc3QoKS5hdHRyKCBcInRpdGxlXCIgKSB8fFxuXHRcdFx0XHRcdFx0XHRoZWFkZXIudGV4dCgpICkgK1xuXHRcdFx0XHRcdFx0XCI8L2xhYmVsPlwiIClcblx0XHRcdFx0XHRcdC5hcHBlbmRUbyggY29udGFpbmVyIClcblx0XHRcdFx0XHRcdC5jaGlsZHJlbiggMCApXG5cdFx0XHRcdFx0XHQuY2hlY2tib3hyYWRpbygge1xuXHRcdFx0XHRcdFx0XHR0aGVtZTogb3B0cy5jb2x1bW5Qb3B1cFRoZW1lXG5cdFx0XHRcdFx0XHR9KSApXG5cblx0XHRcdFx0XHRcdC8vIEFzc29jaWF0ZSB0aGUgaGVhZGVyIHdpdGggdGhlIGNoZWNrYm94XG5cdFx0XHRcdFx0XHQuanFtRGF0YSggXCJoZWFkZXJcIiwgaGVhZGVyIClcblx0XHRcdFx0XHRcdC5qcW1EYXRhKCBcImNlbGxzXCIsIGNlbGxzICk7XG5cblx0XHRcdFx0Ly8gQXNzb2NpYXRlIHRoZSBjaGVja2JveCB3aXRoIHRoZSBoZWFkZXJcblx0XHRcdFx0aGVhZGVyLmpxbURhdGEoIFwiaW5wdXRcIiwgaW5wdXQgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIHNldCBiaW5kaW5ncyBoZXJlXG5cdFx0aWYgKCAha2VlcCApIHtcblx0XHRcdG1lbnUuY29udHJvbGdyb3VwKCBcInJlZnJlc2hcIiApO1xuXHRcdH1cblx0fSxcblxuXHRfbWVudUlucHV0Q2hhbmdlOiBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdHZhciBpbnB1dCA9ICQoIGV2dC50YXJnZXQgKSxcblx0XHRcdGNoZWNrZWQgPSBpbnB1dFsgMCBdLmNoZWNrZWQ7XG5cblx0XHRpbnB1dC5qcW1EYXRhKCBcImNlbGxzXCIgKVxuXHRcdFx0LnRvZ2dsZUNsYXNzKCBcInVpLXRhYmxlLWNlbGwtaGlkZGVuXCIsICFjaGVja2VkIClcblx0XHRcdC50b2dnbGVDbGFzcyggXCJ1aS10YWJsZS1jZWxsLXZpc2libGVcIiwgY2hlY2tlZCApO1xuXHR9LFxuXG5cdF91bmxvY2tDZWxsczogZnVuY3Rpb24oIGNlbGxzICkge1xuXHRcdC8vIGFsbG93IGhpZGUvc2hvdyB2aWEgQ1NTIG9ubHkgPSByZW1vdmUgYWxsIHRvZ2dsZS1sb2Nrc1xuXHRcdGNlbGxzLnJlbW92ZUNsYXNzKCBcInVpLXRhYmxlLWNlbGwtaGlkZGVuIHVpLXRhYmxlLWNlbGwtdmlzaWJsZVwiKTtcblx0fSxcblxuXHRfZW5oYW5jZUNvbFRvZ2dsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlkICwgbWVudUJ1dHRvbiwgcG9wdXAsIG1lbnUsXG5cdFx0XHR0YWJsZSA9IHRoaXMuZWxlbWVudCxcblx0XHRcdG9wdHMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRucyA9ICQubW9iaWxlLm5zLFxuXHRcdFx0ZnJhZ21lbnQgPSB0aGlzLmRvY3VtZW50WyAwIF0uY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdFx0aWQgPSB0aGlzLl9pZCgpICsgXCItcG9wdXBcIjtcblx0XHRtZW51QnV0dG9uID0gJCggXCI8YSBocmVmPScjXCIgKyBpZCArIFwiJyBcIiArXG5cdFx0XHRcImNsYXNzPSdcIiArIG9wdHMuY2xhc3Nlcy5jb2x1bW5CdG4gKyBcIiB1aS1idG4gXCIgK1xuXHRcdFx0XCJ1aS1idG4tXCIgKyAoIG9wdHMuY29sdW1uQnRuVGhlbWUgfHwgXCJhXCIgKSArXG5cdFx0XHRcIiB1aS1jb3JuZXItYWxsIHVpLXNoYWRvdyB1aS1taW5pJyBcIiArXG5cdFx0XHRcImRhdGEtXCIgKyBucyArIFwicmVsPSdwb3B1cCc+XCIgKyBvcHRzLmNvbHVtbkJ0blRleHQgKyBcIjwvYT5cIiApO1xuXHRcdHBvcHVwID0gJCggXCI8ZGl2IGNsYXNzPSdcIiArIG9wdHMuY2xhc3Nlcy5wb3B1cCArIFwiJyBpZD0nXCIgKyBpZCArIFwiJz48L2Rpdj5cIiApO1xuXHRcdG1lbnUgPSAkKCBcIjxmaWVsZHNldD48L2ZpZWxkc2V0PlwiICkuY29udHJvbGdyb3VwKCk7XG5cblx0XHQvLyBzZXQgZXh0ZW5zaW9uIGhlcmUsIHNlbmQgXCJmYWxzZVwiIHRvIHRyaWdnZXIgYnVpbGQvcmVidWlsZFxuXHRcdHRoaXMuX2FkZFRvZ2dsZXMoIG1lbnUsIGZhbHNlICk7XG5cblx0XHRtZW51LmFwcGVuZFRvKCBwb3B1cCApO1xuXG5cdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIHBvcHVwWyAwIF0gKTtcblx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZCggbWVudUJ1dHRvblsgMCBdICk7XG5cdFx0dGFibGUuYmVmb3JlKCBmcmFnbWVudCApO1xuXG5cdFx0cG9wdXAucG9wdXAoKTtcblxuXHRcdHJldHVybiBtZW51O1xuXHR9LFxuXG5cdHJlYnVpbGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3N1cGVyKCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5tb2RlID09PSBcImNvbHVtbnRvZ2dsZVwiICkge1xuXHRcdFx0Ly8gTk9URTogcmVidWlsZCBwYXNzZXMgXCJmYWxzZVwiLCB3aGlsZSByZWZyZXNoIHBhc3NlcyBcInVuZGVmaW5lZFwiXG5cdFx0XHQvLyBib3RoIHJlZnJlc2ggdGhlIHRhYmxlLCBidXQgaW5zaWRlIGFkZFRvZ2dsZXMsICFmYWxzZSB3aWxsIGJlIHRydWUsXG5cdFx0XHQvLyBzbyBhIHJlYnVpbGQgY2FsbCBjYW4gYmUgaW5kZW50aWZpZWRcblx0XHRcdHRoaXMuX3JlZnJlc2goIGZhbHNlICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZWZyZXNoOiBmdW5jdGlvbiggY3JlYXRlICkge1xuXHRcdHZhciBoZWFkZXJzLCBoaWRkZW5Db2x1bW5zLCBpbmRleDtcblxuXHRcdC8vIENhbGxpbmcgX3N1cGVyKCkgaGVyZSB1cGRhdGVzIHRoaXMuaGVhZGVyc1xuXHRcdHRoaXMuX3N1cGVyKCBjcmVhdGUgKTtcblxuXHRcdGlmICggIWNyZWF0ZSAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gXCJjb2x1bW50b2dnbGVcIiApIHtcblx0XHRcdGhlYWRlcnMgPSB0aGlzLmhlYWRlcnM7XG5cdFx0XHRoaWRkZW5Db2x1bW5zID0gW107XG5cblx0XHRcdC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gaGVhZGVyIGFzc29jaWF0ZWQgd2l0aCBlYWNoIG9sZCBjaGVja2JveCBhbW9uZyB0aGVcblx0XHRcdC8vIHBvc3QtcmVmcmVzaCBoZWFkZXJzIGFuZCwgaWYgdGhlIGhlYWRlciBpcyBzdGlsbCB0aGVyZSwgbWFrZSBzdXJlIHRoZSBjb3JyZXNwb25kaW5nXG5cdFx0XHQvLyBjb2x1bW4gd2lsbCBiZSBoaWRkZW4gaWYgdGhlIHByZS1yZWZyZXNoIGNoZWNrYm94IGluZGljYXRlcyB0aGF0IHRoZSBjb2x1bW4gaXNcblx0XHRcdC8vIGhpZGRlbiBieSByZWNvcmRpbmcgaXRzIGluZGV4IGluIHRoZSBhcnJheSBvZiBoaWRkZW4gY29sdW1ucy5cblx0XHRcdHRoaXMuX21lbnUuZmluZCggXCJpbnB1dFwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbnB1dCA9ICQoIHRoaXMgKSxcblx0XHRcdFx0XHRoZWFkZXIgPSBpbnB1dC5qcW1EYXRhKCBcImhlYWRlclwiICksXG5cdFx0XHRcdFx0aW5kZXggPSBoZWFkZXJzLmluZGV4KCBoZWFkZXJbIDAgXSApO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPiAtMSAmJiAhaW5wdXQucHJvcCggXCJjaGVja2VkXCIgKSApIHtcblxuXHRcdFx0XHRcdC8vIFRoZSBjb2x1bW4gaGVhZGVyIGFzc29jaWF0ZWQgd2l0aCAvdGhpcy8gY2hlY2tib3ggaXMgc3RpbGwgcHJlc2VudCBpbiB0aGVcblx0XHRcdFx0XHQvLyBwb3N0LXJlZnJlc2ggdGFibGUgYW5kIHRoZSBjaGVja2JveCBpcyBub3QgY2hlY2tlZCwgc28gdGhlIGNvbHVtbiBhc3NvY2lhdGVkXG5cdFx0XHRcdFx0Ly8gd2l0aCB0aGlzIGNvbHVtbiBoZWFkZXIgaXMgY3VycmVudGx5IGhpZGRlbi4gTGV0J3MgcmVjb3JkIHRoYXQuXG5cdFx0XHRcdFx0aGlkZGVuQ29sdW1ucy5wdXNoKCBpbmRleCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gY29sdW1ucyBub3QgYmVpbmcgcmVwbGFjZWQgbXVzdCBiZSBjbGVhcmVkIGZyb20gaW5wdXQgdG9nZ2xlLWxvY2tzXG5cdFx0XHR0aGlzLl91bmxvY2tDZWxscyggdGhpcy5lbGVtZW50LmZpbmQoIFwiLnVpLXRhYmxlLWNlbGwtaGlkZGVuLCBcIiArXG5cdFx0XHRcdFwiLnVpLXRhYmxlLWNlbGwtdmlzaWJsZVwiICkgKTtcblxuXHRcdFx0Ly8gdXBkYXRlIGNvbHVtbnRvZ2dsZXMgYW5kIGNlbGxzXG5cdFx0XHR0aGlzLl9hZGRUb2dnbGVzKCB0aGlzLl9tZW51LCBjcmVhdGUgKTtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCBhbGwgY29sdW1ucyBhcmUgdmlzaWJsZSwgc28gdW5jaGVjayB0aGUgY2hlY2tib3hlcyB0aGF0IGNvcnJlc3BvbmQgdG9cblx0XHRcdC8vIHRob3NlIGNvbHVtbnMgd2UndmUgZm91bmQgdG8gYmUgaGlkZGVuXG5cdFx0XHRmb3IgKCBpbmRleCA9IGhpZGRlbkNvbHVtbnMubGVuZ3RoIC0gMSA7IGluZGV4ID4gLTEgOyBpbmRleC0tICkge1xuXHRcdFx0XHRoZWFkZXJzLmVxKCBoaWRkZW5Db2x1bW5zWyBpbmRleCBdICkuanFtRGF0YSggXCJpbnB1dFwiIClcblx0XHRcdFx0XHQucHJvcCggXCJjaGVja2VkXCIsIGZhbHNlIClcblx0XHRcdFx0XHQuY2hlY2tib3hyYWRpbyggXCJyZWZyZXNoXCIgKVxuXHRcdFx0XHRcdC50cmlnZ2VyKCBcImNoYW5nZVwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRUb2dnbGVTdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fbWVudS5maW5kKCBcImlucHV0XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjaGVja2JveCA9ICQoIHRoaXMgKTtcblxuXHRcdFx0dGhpcy5jaGVja2VkID0gY2hlY2tib3guanFtRGF0YSggXCJjZWxsc1wiICkuZXEoIDAgKS5jc3MoIFwiZGlzcGxheVwiICkgPT09IFwidGFibGUtY2VsbFwiO1xuXHRcdFx0Y2hlY2tib3guY2hlY2tib3hyYWRpbyggXCJyZWZyZXNoXCIgKTtcblx0XHR9KTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc3VwZXIoKTtcblx0fVxufSk7XG5cbn0pKCBqUXVlcnkgKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQud2lkZ2V0KCBcIm1vYmlsZS50YWJsZVwiLCAkLm1vYmlsZS50YWJsZSwge1xuXHRvcHRpb25zOiB7XG5cdFx0bW9kZTogXCJyZWZsb3dcIixcblx0XHRjbGFzc2VzOiAkLmV4dGVuZCggJC5tb2JpbGUudGFibGUucHJvdG90eXBlLm9wdGlvbnMuY2xhc3Nlcywge1xuXHRcdFx0cmVmbG93VGFibGU6IFwidWktdGFibGUtcmVmbG93XCIsXG5cdFx0XHRjZWxsTGFiZWxzOiBcInVpLXRhYmxlLWNlbGwtbGFiZWxcIlxuXHRcdH0pXG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc3VwZXIoKTtcblxuXHRcdC8vIElmIGl0J3Mgbm90IHJlZmxvdyBtb2RlLCByZXR1cm4gaGVyZS5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5tb2RlICE9PSBcInJlZmxvd1wiICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5lbmhhbmNlZCApIHtcblx0XHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyggdGhpcy5vcHRpb25zLmNsYXNzZXMucmVmbG93VGFibGUgKTtcblxuXHRcdFx0dGhpcy5fdXBkYXRlUmVmbG93KCk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlYnVpbGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3N1cGVyKCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5tb2RlID09PSBcInJlZmxvd1wiICkge1xuXHRcdFx0dGhpcy5fcmVmcmVzaCggZmFsc2UgKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlZnJlc2g6IGZ1bmN0aW9uKCBjcmVhdGUgKSB7XG5cdFx0dGhpcy5fc3VwZXIoIGNyZWF0ZSApO1xuXHRcdGlmICggIWNyZWF0ZSAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gXCJyZWZsb3dcIiApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVJlZmxvdyggKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVJlZmxvdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRhYmxlID0gdGhpcyxcblx0XHRcdG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHQvLyBnZXQgaGVhZGVycyBpbiByZXZlcnNlIG9yZGVyIHNvIHRoYXQgdG9wLWxldmVsIGhlYWRlcnMgYXJlIGFwcGVuZGVkIGxhc3Rcblx0XHQkKCB0YWJsZS5hbGxIZWFkZXJzLmdldCgpLnJldmVyc2UoKSApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbGxzID0gJCggdGhpcyApLmpxbURhdGEoIFwiY2VsbHNcIiApLFxuXHRcdFx0XHRjb2xzdGFydCA9ICQubW9iaWxlLmdldEF0dHJpYnV0ZSggdGhpcywgXCJjb2xzdGFydFwiICksXG5cdFx0XHRcdGhpZXJhcmNoeUNsYXNzID0gY2VsbHMubm90KCB0aGlzICkuZmlsdGVyKCBcInRoZWFkIHRoXCIgKS5sZW5ndGggJiYgXCIgdWktdGFibGUtY2VsbC1sYWJlbC10b3BcIixcblx0XHRcdFx0Y29udGVudHMgPSAkKCB0aGlzICkuY2xvbmUoKS5jb250ZW50cygpLFxuXHRcdFx0XHRpdGVyYXRpb24sIGZpbHRlcjtcblxuXHRcdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCA+IDAgICkge1xuXG5cdFx0XHRcdFx0aWYgKCBoaWVyYXJjaHlDbGFzcyApIHtcblx0XHRcdFx0XHRcdGl0ZXJhdGlvbiA9IHBhcnNlSW50KCB0aGlzLmdldEF0dHJpYnV0ZSggXCJjb2xzcGFuXCIgKSwgMTAgKTtcblx0XHRcdFx0XHRcdGZpbHRlciA9IFwiXCI7XG5cblx0XHRcdFx0XHRcdGlmICggaXRlcmF0aW9uICkge1xuXHRcdFx0XHRcdFx0XHRmaWx0ZXIgPSBcInRkOm50aC1jaGlsZChcIisgaXRlcmF0aW9uICtcIm4gKyBcIiArICggY29sc3RhcnQgKSArXCIpXCI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRhYmxlLl9hZGRMYWJlbHMoIGNlbGxzLmZpbHRlciggZmlsdGVyICksXG5cdFx0XHRcdFx0XHRcdG9wdHMuY2xhc3Nlcy5jZWxsTGFiZWxzICsgaGllcmFyY2h5Q2xhc3MsIGNvbnRlbnRzICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRhYmxlLl9hZGRMYWJlbHMoIGNlbGxzLCBvcHRzLmNsYXNzZXMuY2VsbExhYmVscywgY29udGVudHMgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9hZGRMYWJlbHM6IGZ1bmN0aW9uKCBjZWxscywgbGFiZWwsIGNvbnRlbnRzICkge1xuXHRcdC8vIC5ub3QgZml4ZXMgIzYwMDZcblx0XHRjZWxsc1xuXHRcdFx0Lm5vdCggXCI6aGFzKGIuXCIgKyBsYWJlbCArIFwiKVwiIClcblx0XHRcdFx0LnByZXBlbmQoICQoIFwiPGIgY2xhc3M9J1wiICsgbGFiZWwgKyBcIic+PC9iPlwiICkuYXBwZW5kKCBjb250ZW50cyApICk7XG5cdH1cbn0pO1xuXG59KSggalF1ZXJ5ICk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4vLyBUT0RPIHJlbmFtZSBmaWx0ZXJDYWxsYmFjay9kZXByZWNhdGUgYW5kIGRlZmF1bHQgdG8gdGhlIGl0ZW0gaXRzZWxmIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxudmFyIGRlZmF1bHRGaWx0ZXJDYWxsYmFjayA9IGZ1bmN0aW9uKCBpbmRleCwgc2VhcmNoVmFsdWUgKSB7XG5cdHJldHVybiAoICggXCJcIiArICggJC5tb2JpbGUuZ2V0QXR0cmlidXRlKCB0aGlzLCBcImZpbHRlcnRleHRcIiApIHx8ICQoIHRoaXMgKS50ZXh0KCkgKSApXG5cdFx0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZiggc2VhcmNoVmFsdWUgKSA9PT0gLTEgKTtcbn07XG5cbiQud2lkZ2V0KCBcIm1vYmlsZS5maWx0ZXJhYmxlXCIsIHtcblxuXHRpbml0U2VsZWN0b3I6IFwiOmpxbURhdGEoZmlsdGVyPSd0cnVlJylcIixcblxuXHRvcHRpb25zOiB7XG5cdFx0ZmlsdGVyUmV2ZWFsOiBmYWxzZSxcblx0XHRmaWx0ZXJDYWxsYmFjazogZGVmYXVsdEZpbHRlckNhbGxiYWNrLFxuXHRcdGVuaGFuY2VkOiBmYWxzZSxcblx0XHRpbnB1dDogbnVsbCxcblx0XHRjaGlsZHJlbjogXCI+IGxpLCA+IG9wdGlvbiwgPiBvcHRncm91cCBvcHRpb24sID4gdGJvZHkgdHIsID4gLnVpLWNvbnRyb2xncm91cC1jb250cm9scyA+IC51aS1idG4sID4gLnVpLWNvbnRyb2xncm91cC1jb250cm9scyA+IC51aS1jaGVja2JveCwgPiAudWktY29udHJvbGdyb3VwLWNvbnRyb2xzID4gLnVpLXJhZGlvXCJcblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuXHRcdCQuZXh0ZW5kKCB0aGlzLCB7XG5cdFx0XHRfc2VhcmNoOiBudWxsLFxuXHRcdFx0X3RpbWVyOiAwXG5cdFx0fSk7XG5cblx0XHR0aGlzLl9zZXRJbnB1dCggb3B0cy5pbnB1dCApO1xuXHRcdGlmICggIW9wdHMuZW5oYW5jZWQgKSB7XG5cdFx0XHR0aGlzLl9maWx0ZXJJdGVtcyggKCAoIHRoaXMuX3NlYXJjaCAmJiB0aGlzLl9zZWFyY2gudmFsKCkgKSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSApO1xuXHRcdH1cblx0fSxcblxuXHRfb25LZXlVcDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZhbCwgbGFzdHZhbCxcblx0XHRcdHNlYXJjaCA9IHRoaXMuX3NlYXJjaDtcblxuXHRcdGlmICggc2VhcmNoICkge1xuXHRcdFx0dmFsID0gc2VhcmNoLnZhbCgpLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRsYXN0dmFsID0gJC5tb2JpbGUuZ2V0QXR0cmlidXRlKCBzZWFyY2hbIDAgXSwgXCJsYXN0dmFsXCIgKSArIFwiXCI7XG5cblx0XHRcdGlmICggbGFzdHZhbCAmJiBsYXN0dmFsID09PSB2YWwgKSB7XG5cdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGhhbmRsZXIgb25seSBvbmNlIHBlciB2YWx1ZSBjaGFuZ2Vcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuX3RpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aGlzLl90aW1lciApO1xuXHRcdFx0XHR0aGlzLl90aW1lciA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3RpbWVyID0gdGhpcy5fZGVsYXkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMuX3RyaWdnZXIoIFwiYmVmb3JlZmlsdGVyXCIsIG51bGwsIHsgaW5wdXQ6IHNlYXJjaCB9ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENoYW5nZSB2YWwgYXMgbGFzdHZhbCBmb3IgbmV4dCBleGVjdXRpb25cblx0XHRcdFx0c2VhcmNoWyAwIF0uc2V0QXR0cmlidXRlKCBcImRhdGEtXCIgKyAkLm1vYmlsZS5ucyArIFwibGFzdHZhbFwiLCB2YWwgKTtcblxuXHRcdFx0XHR0aGlzLl9maWx0ZXJJdGVtcyggdmFsICk7XG5cdFx0XHRcdHRoaXMuX3RpbWVyID0gMDtcblx0XHRcdH0sIDI1MCApO1xuXHRcdH1cblx0fSxcblxuXHRfZ2V0RmlsdGVyYWJsZUl0ZW1zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSA9IHRoaXMuZWxlbWVudCxcblx0XHRcdGNoaWxkcmVuID0gdGhpcy5vcHRpb25zLmNoaWxkcmVuLFxuXHRcdFx0aXRlbXMgPSAhY2hpbGRyZW4gPyB7IGxlbmd0aDogMCB9OlxuXHRcdFx0XHQkLmlzRnVuY3Rpb24oIGNoaWxkcmVuICkgPyBjaGlsZHJlbigpOlxuXHRcdFx0XHRjaGlsZHJlbi5ub2RlTmFtZSA/ICQoIGNoaWxkcmVuICk6XG5cdFx0XHRcdGNoaWxkcmVuLmpxdWVyeSA/IGNoaWxkcmVuOlxuXHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZCggY2hpbGRyZW4gKTtcblxuXHRcdGlmICggaXRlbXMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0aXRlbXMgPSBlbGVtLmNoaWxkcmVuKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9LFxuXG5cdF9maWx0ZXJJdGVtczogZnVuY3Rpb24oIHZhbCApIHtcblx0XHR2YXIgaWR4LCBjYWxsYmFjaywgbGVuZ3RoLCBkc3QsXG5cdFx0XHRzaG93ID0gW10sXG5cdFx0XHRoaWRlID0gW10sXG5cdFx0XHRvcHRzID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0ZmlsdGVySXRlbXMgPSB0aGlzLl9nZXRGaWx0ZXJhYmxlSXRlbXMoKTtcblxuXHRcdGlmICggdmFsICE9IG51bGwgKSB7XG5cdFx0XHRjYWxsYmFjayA9IG9wdHMuZmlsdGVyQ2FsbGJhY2sgfHwgZGVmYXVsdEZpbHRlckNhbGxiYWNrO1xuXHRcdFx0bGVuZ3RoID0gZmlsdGVySXRlbXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBQYXJ0aXRpb24gdGhlIGl0ZW1zIGludG8gdGhvc2UgdG8gYmUgaGlkZGVuIGFuZCB0aG9zZSB0byBiZSBzaG93blxuXHRcdFx0Zm9yICggaWR4ID0gMCA7IGlkeCA8IGxlbmd0aCA7IGlkeCsrICkge1xuXHRcdFx0XHRkc3QgPSAoIGNhbGxiYWNrLmNhbGwoIGZpbHRlckl0ZW1zWyBpZHggXSwgaWR4LCB2YWwgKSApID8gaGlkZSA6IHNob3c7XG5cdFx0XHRcdGRzdC5wdXNoKCBmaWx0ZXJJdGVtc1sgaWR4IF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiBub3RoaW5nIGlzIGhpZGRlbiwgdGhlbiB0aGUgZGVjaXNpb24gd2hldGhlciB0byBoaWRlIG9yIHNob3cgdGhlIGl0ZW1zXG5cdFx0Ly8gaXMgYmFzZWQgb24gdGhlIFwiZmlsdGVyUmV2ZWFsXCIgb3B0aW9uLlxuXHRcdGlmICggaGlkZS5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRmaWx0ZXJJdGVtc1sgKCBvcHRzLmZpbHRlclJldmVhbCAmJiB2YWwubGVuZ3RoID09PSAwICkgP1xuXHRcdFx0XHRcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCIgXSggXCJ1aS1zY3JlZW4taGlkZGVuXCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JCggaGlkZSApLmFkZENsYXNzKCBcInVpLXNjcmVlbi1oaWRkZW5cIiApO1xuXHRcdFx0JCggc2hvdyApLnJlbW92ZUNsYXNzKCBcInVpLXNjcmVlbi1oaWRkZW5cIiApO1xuXHRcdH1cblxuXHRcdHRoaXMuX3JlZnJlc2hDaGlsZFdpZGdldCgpO1xuXG5cdFx0dGhpcy5fdHJpZ2dlciggXCJmaWx0ZXJcIiwgbnVsbCwge1xuXHRcdFx0aXRlbXM6IGZpbHRlckl0ZW1zXG5cdFx0fSk7XG5cdH0sXG5cblx0Ly8gVGhlIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgX3JlZnJlc2hDaGlsZFdpZGdldCBhdHRlbXB0cyB0byBjYWxsXG5cdC8vIHJlZnJlc2ggb24gY29sbGFwc2libGVzZXQsIGNvbnRyb2xncm91cCwgc2VsZWN0bWVudSwgb3IgbGlzdHZpZXdcblx0X3JlZnJlc2hDaGlsZFdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHdpZGdldCwgaWR4LFxuXHRcdFx0cmVjb2duaXplZFdpZGdldHMgPSBbIFwiY29sbGFwc2libGVzZXRcIiwgXCJzZWxlY3RtZW51XCIsIFwiY29udHJvbGdyb3VwXCIsIFwibGlzdHZpZXdcIiBdO1xuXG5cdFx0Zm9yICggaWR4ID0gcmVjb2duaXplZFdpZGdldHMubGVuZ3RoIC0gMSA7IGlkeCA+IC0xIDsgaWR4LS0gKSB7XG5cdFx0XHR3aWRnZXQgPSByZWNvZ25pemVkV2lkZ2V0c1sgaWR4IF07XG5cdFx0XHRpZiAoICQubW9iaWxlWyB3aWRnZXQgXSApIHtcblx0XHRcdFx0d2lkZ2V0ID0gdGhpcy5lbGVtZW50LmRhdGEoIFwibW9iaWxlLVwiICsgd2lkZ2V0ICk7XG5cdFx0XHRcdGlmICggd2lkZ2V0ICYmICQuaXNGdW5jdGlvbiggd2lkZ2V0LnJlZnJlc2ggKSApIHtcblx0XHRcdFx0XHR3aWRnZXQucmVmcmVzaCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFRPRE86IFdoZW4gdGhlIGlucHV0IGlzIG5vdCBpbnRlcm5hbCwgZG8gbm90IGV2ZW4gc3RvcmUgaXQgaW4gdGhpcy5fc2VhcmNoXG5cdF9zZXRJbnB1dDogZnVuY3Rpb24gKCBzZWxlY3RvciApIHtcblx0XHR2YXIgc2VhcmNoID0gdGhpcy5fc2VhcmNoO1xuXG5cdFx0Ly8gU3RvcCBhIHBlbmRpbmcgZmlsdGVyIG9wZXJhdGlvblxuXHRcdGlmICggdGhpcy5fdGltZXIgKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aGlzLl90aW1lciApO1xuXHRcdFx0dGhpcy5fdGltZXIgPSAwO1xuXHRcdH1cblxuXHRcdGlmICggc2VhcmNoICkge1xuXHRcdFx0dGhpcy5fb2ZmKCBzZWFyY2gsIFwia2V5dXAgY2hhbmdlIGlucHV0XCIgKTtcblx0XHRcdHNlYXJjaCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdHNlYXJjaCA9IHNlbGVjdG9yLmpxdWVyeSA/IHNlbGVjdG9yOlxuXHRcdFx0XHRzZWxlY3Rvci5ub2RlTmFtZSA/ICQoIHNlbGVjdG9yICk6XG5cdFx0XHRcdHRoaXMuZG9jdW1lbnQuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0dGhpcy5fb24oIHNlYXJjaCwge1xuXHRcdFx0XHRrZXlkb3duOiBcIl9vbktleURvd25cIixcblx0XHRcdFx0a2V5cHJlc3M6IFwiX29uS2V5UHJlc3NcIixcblx0XHRcdFx0a2V5dXA6IFwiX29uS2V5VXBcIixcblx0XHRcdFx0Y2hhbmdlOiBcIl9vbktleVVwXCIsXG5cdFx0XHRcdGlucHV0OiBcIl9vbktleVVwXCJcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NlYXJjaCA9IHNlYXJjaDtcblx0fSxcblxuXHQvLyBQcmV2ZW50IGZvcm0gc3VibWlzc2lvblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuRU5URVIgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dGhpcy5fcHJldmVudEtleVByZXNzID0gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0X29uS2V5UHJlc3M6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIHRoaXMuX3ByZXZlbnRLZXlQcmVzcyApIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR0aGlzLl9wcmV2ZW50S2V5UHJlc3MgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbnM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciByZWZpbHRlciA9ICEoICggb3B0aW9ucy5maWx0ZXJSZXZlYWwgPT09IHVuZGVmaW5lZCApICYmXG5cdFx0XHRcdCggb3B0aW9ucy5maWx0ZXJDYWxsYmFjayA9PT0gdW5kZWZpbmVkICkgJiZcblx0XHRcdFx0KCBvcHRpb25zLmNoaWxkcmVuID09PSB1bmRlZmluZWQgKSApO1xuXG5cdFx0dGhpcy5fc3VwZXIoIG9wdGlvbnMgKTtcblxuXHRcdGlmICggb3B0aW9ucy5pbnB1dCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5fc2V0SW5wdXQoIG9wdGlvbnMuaW5wdXQgKTtcblx0XHRcdHJlZmlsdGVyID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIHJlZmlsdGVyICkge1xuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0cyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGl0ZW1zID0gdGhpcy5fZ2V0RmlsdGVyYWJsZUl0ZW1zKCk7XG5cblx0XHRpZiAoIG9wdHMuZW5oYW5jZWQgKSB7XG5cdFx0XHRpdGVtcy50b2dnbGVDbGFzcyggXCJ1aS1zY3JlZW4taGlkZGVuXCIsIG9wdHMuZmlsdGVyUmV2ZWFsICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGl0ZW1zLnJlbW92ZUNsYXNzKCBcInVpLXNjcmVlbi1oaWRkZW5cIiApO1xuXHRcdH1cblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMuX3RpbWVyICkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGhpcy5fdGltZXIgKTtcblx0XHRcdHRoaXMuX3RpbWVyID0gMDtcblx0XHR9XG5cdFx0dGhpcy5fZmlsdGVySXRlbXMoICggKCB0aGlzLl9zZWFyY2ggJiYgdGhpcy5fc2VhcmNoLnZhbCgpICkgfHwgXCJcIiApLnRvTG93ZXJDYXNlKCkgKTtcblx0fVxufSk7XG5cbn0pKCBqUXVlcnkgKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbi8vIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXBsYWNlIHRoZSBfc2V0T3B0aW9ucyBmdW5jdGlvbiBvZiBhIHdpZGdldCxcbi8vIGFuZCB3aWxsIHBhc3MgdGhlIG9wdGlvbnMgb24gdG8gdGhlIGlucHV0IG9mIHRoZSBmaWx0ZXJhYmxlLlxudmFyIHJlcGxhY2VTZXRPcHRpb25zID0gZnVuY3Rpb24oIHNlbGYsIG9yaWcgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0b3JpZy5jYWxsKCB0aGlzLCBvcHRpb25zICk7XG5cdFx0XHRzZWxmLl9zeW5jVGV4dElucHV0T3B0aW9ucyggb3B0aW9ucyApO1xuXHRcdH07XG5cdH0sXG5cdHJEaXZpZGVyTGlzdEl0ZW0gPSAvKF58XFxzKXVpLWxpLWRpdmlkZXIoXFxzfCQpLyxcblx0b3JpZ0RlZmF1bHRGaWx0ZXJDYWxsYmFjayA9ICQubW9iaWxlLmZpbHRlcmFibGUucHJvdG90eXBlLm9wdGlvbnMuZmlsdGVyQ2FsbGJhY2s7XG5cbi8vIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGZpbHRlciBjYWxsYmFjayB3aXRoIG9uZSB0aGF0IGRvZXMgbm90IGhpZGUgbGlzdCBkaXZpZGVyc1xuJC5tb2JpbGUuZmlsdGVyYWJsZS5wcm90b3R5cGUub3B0aW9ucy5maWx0ZXJDYWxsYmFjayA9IGZ1bmN0aW9uKCBpbmRleCwgc2VhcmNoVmFsdWUgKSB7XG5cdHJldHVybiAhdGhpcy5jbGFzc05hbWUubWF0Y2goIHJEaXZpZGVyTGlzdEl0ZW0gKSAmJlxuXHRcdG9yaWdEZWZhdWx0RmlsdGVyQ2FsbGJhY2suY2FsbCggdGhpcywgaW5kZXgsIHNlYXJjaFZhbHVlICk7XG59O1xuXG4kLndpZGdldCggXCJtb2JpbGUuZmlsdGVyYWJsZVwiLCAkLm1vYmlsZS5maWx0ZXJhYmxlLCB7XG5cdG9wdGlvbnM6IHtcblx0XHRmaWx0ZXJQbGFjZWhvbGRlcjogXCJGaWx0ZXIgaXRlbXMuLi5cIixcblx0XHRmaWx0ZXJUaGVtZTogbnVsbFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZHgsIHdpZGdldE5hbWUsXG5cdFx0XHRlbGVtID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0cmVjb2duaXplZFdpZGdldHMgPSBbIFwiY29sbGFwc2libGVzZXRcIiwgXCJzZWxlY3RtZW51XCIsIFwiY29udHJvbGdyb3VwXCIsIFwibGlzdHZpZXdcIiBdLFxuXHRcdFx0Y3JlYXRlSGFuZGxlcnMgPSB7fTtcblxuXHRcdHRoaXMuX3N1cGVyKCk7XG5cblx0XHQkLmV4dGVuZCggdGhpcywge1xuXHRcdFx0X3dpZGdldDogbnVsbFxuXHRcdH0pO1xuXG5cdFx0Zm9yICggaWR4ID0gcmVjb2duaXplZFdpZGdldHMubGVuZ3RoIC0gMSA7IGlkeCA+IC0xIDsgaWR4LS0gKSB7XG5cdFx0XHR3aWRnZXROYW1lID0gcmVjb2duaXplZFdpZGdldHNbIGlkeCBdO1xuXHRcdFx0aWYgKCAkLm1vYmlsZVsgd2lkZ2V0TmFtZSBdICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuX3NldFdpZGdldCggZWxlbS5kYXRhKCBcIm1vYmlsZS1cIiArIHdpZGdldE5hbWUgKSApICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNyZWF0ZUhhbmRsZXJzWyB3aWRnZXROYW1lICsgXCJjcmVhdGVcIiBdID0gXCJfaGFuZGxlQ3JlYXRlXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLl93aWRnZXQgKSB7XG5cdFx0XHR0aGlzLl9vbiggZWxlbSwgY3JlYXRlSGFuZGxlcnMgKTtcblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZUNyZWF0ZTogZnVuY3Rpb24oIGV2dCApIHtcblx0XHR0aGlzLl9zZXRXaWRnZXQoIHRoaXMuZWxlbWVudC5kYXRhKCBcIm1vYmlsZS1cIiArIGV2dC50eXBlLnN1YnN0cmluZyggMCwgZXZ0LnR5cGUubGVuZ3RoIC0gNiApICkgKTtcblx0fSxcblxuXHRfdHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCBkYXRhICkge1xuXHRcdGlmICggdGhpcy5fd2lkZ2V0ICYmIHRoaXMuX3dpZGdldC53aWRnZXRGdWxsTmFtZSA9PT0gXCJtb2JpbGUtbGlzdHZpZXdcIiAmJlxuXHRcdFx0dHlwZSA9PT0gXCJiZWZvcmVmaWx0ZXJcIiApIHtcblxuXHRcdFx0Ly8gQWxzbyB0cmlnZ2VyIGxpc3R2aWV3YmVmb3JlZmlsdGVyIGlmIHRoaXMgd2lkZ2V0IGlzIGFsc28gYSBsaXN0dmlld1xuXHRcdFx0dGhpcy5fd2lkZ2V0Ll90cmlnZ2VyKCBcImJlZm9yZWZpbHRlclwiLCBldmVudCwgZGF0YSApO1xuXHRcdH1cblxuXHRcdC8vIFBhc3NpbmcgYmFjayB0aGUgcmVzcG9uc2UgZW5hYmxlcyBjYWxsaW5nIHByZXZlbnREZWZhdWx0KClcblx0XHRyZXR1cm4gdGhpcy5fc3VwZXIoIHR5cGUsIGV2ZW50LCBkYXRhICk7XG5cdH0sXG5cblx0X3NldFdpZGdldDogZnVuY3Rpb24oIHdpZGdldCApIHtcblx0XHRpZiAoICF0aGlzLl93aWRnZXQgJiYgd2lkZ2V0ICkge1xuXHRcdFx0dGhpcy5fd2lkZ2V0ID0gd2lkZ2V0O1xuXHRcdFx0dGhpcy5fd2lkZ2V0Ll9zZXRPcHRpb25zID0gcmVwbGFjZVNldE9wdGlvbnMoIHRoaXMsIHRoaXMuX3dpZGdldC5fc2V0T3B0aW9ucyApO1xuXHRcdH1cblxuXHRcdGlmICggISF0aGlzLl93aWRnZXQgKSB7XG5cdFx0XHR0aGlzLl9zeW5jVGV4dElucHV0T3B0aW9ucyggdGhpcy5fd2lkZ2V0Lm9wdGlvbnMgKTtcblx0XHRcdGlmICggdGhpcy5fd2lkZ2V0LndpZGdldE5hbWUgPT09IFwibGlzdHZpZXdcIiApIHtcblx0XHRcdFx0dGhpcy5fd2lkZ2V0Lm9wdGlvbnMuaGlkZURpdmlkZXJzID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fd2lkZ2V0LmVsZW1lbnQubGlzdHZpZXcoIFwicmVmcmVzaFwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuICEhdGhpcy5fd2lkZ2V0O1xuXHR9LFxuXG5cdF9pc1NlYXJjaEludGVybmFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKCB0aGlzLl9zZWFyY2ggJiYgdGhpcy5fc2VhcmNoLmpxbURhdGEoIFwidWktZmlsdGVyYWJsZS1cIiArIHRoaXMudXVpZCArIFwiLWludGVybmFsXCIgKSApO1xuXHR9LFxuXG5cdF9zZXRJbnB1dDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBvcHRzID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0dXBkYXRlUGxhY2Vob2xkZXIgPSB0cnVlLFxuXHRcdFx0dGV4dGlucHV0T3B0cyA9IHt9O1xuXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRpZiAoIHRoaXMuX2lzU2VhcmNoSW50ZXJuYWwoKSApIHtcblxuXHRcdFx0XHQvLyBJZ25vcmUgdGhlIGNhbGwgdG8gc2V0IGEgbmV3IGlucHV0IGlmIHRoZSBzZWxlY3RvciBnb2VzIHRvIGZhbHN5IGFuZFxuXHRcdFx0XHQvLyB0aGUgY3VycmVudCB0ZXh0aW5wdXQgaXMgYWxyZWFkeSBvZiB0aGUgaW50ZXJuYWxseSBnZW5lcmF0ZWQgdmFyaWV0eS5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZW5lcmF0aW5nIGEgbmV3IHRleHRpbnB1dCB3aWRnZXQuIE5vIG5lZWQgdG8gc2V0IHRoZSBwbGFjZWhvbGRlclxuXHRcdFx0XHQvLyBmdXJ0aGVyIGRvd24gdGhlIGZ1bmN0aW9uLlxuXHRcdFx0XHR1cGRhdGVQbGFjZWhvbGRlciA9IGZhbHNlO1xuXHRcdFx0XHRzZWxlY3RvciA9ICQoIFwiPGlucHV0IFwiICtcblx0XHRcdFx0XHRcImRhdGEtXCIgKyAkLm1vYmlsZS5ucyArIFwidHlwZT0nc2VhcmNoJyBcIiArXG5cdFx0XHRcdFx0XCJwbGFjZWhvbGRlcj0nXCIgKyBvcHRzLmZpbHRlclBsYWNlaG9sZGVyICsgXCInPjwvaW5wdXQ+XCIgKVxuXHRcdFx0XHRcdC5qcW1EYXRhKCBcInVpLWZpbHRlcmFibGUtXCIgKyB0aGlzLnV1aWQgKyBcIi1pbnRlcm5hbFwiLCB0cnVlICk7XG5cdFx0XHRcdCQoIFwiPGZvcm0gY2xhc3M9J3VpLWZpbHRlcmFibGUnPjwvZm9ybT5cIiApXG5cdFx0XHRcdFx0LmFwcGVuZCggc2VsZWN0b3IgKVxuXHRcdFx0XHRcdC5zdWJtaXQoIGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRldnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdHNlbGVjdG9yLmJsdXIoKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5pbnNlcnRCZWZvcmUoIHRoaXMuZWxlbWVudCApO1xuXHRcdFx0XHRpZiAoICQubW9iaWxlLnRleHRpbnB1dCApIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5maWx0ZXJUaGVtZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdFx0dGV4dGlucHV0T3B0c1sgXCJ0aGVtZVwiIF0gPSBvcHRzLmZpbHRlclRoZW1lO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNlbGVjdG9yLnRleHRpbnB1dCggdGV4dGlucHV0T3B0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3VwZXIoIHNlbGVjdG9yICk7XG5cblx0XHRpZiAoIHRoaXMuX2lzU2VhcmNoSW50ZXJuYWwoKSAmJiB1cGRhdGVQbGFjZWhvbGRlciApIHtcblx0XHRcdHRoaXMuX3NlYXJjaC5hdHRyKCBcInBsYWNlaG9sZGVyXCIsIHRoaXMub3B0aW9ucy5maWx0ZXJQbGFjZWhvbGRlciApO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIHJldCA9IHRoaXMuX3N1cGVyKCBvcHRpb25zICk7XG5cblx0XHQvLyBOZWVkIHRvIHNldCB0aGUgZmlsdGVyUGxhY2Vob2xkZXIgYWZ0ZXIgaGF2aW5nIGVzdGFibGlzaGVkIHRoZSBzZWFyY2ggaW5wdXRcblx0XHRpZiAoIG9wdGlvbnMuZmlsdGVyUGxhY2Vob2xkZXIgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5faXNTZWFyY2hJbnRlcm5hbCgpICkge1xuXHRcdFx0XHR0aGlzLl9zZWFyY2guYXR0ciggXCJwbGFjZWhvbGRlclwiLCBvcHRpb25zLmZpbHRlclBsYWNlaG9sZGVyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLmZpbHRlclRoZW1lICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fc2VhcmNoICYmICQubW9iaWxlLnRleHRpbnB1dCApIHtcblx0XHRcdHRoaXMuX3NlYXJjaC50ZXh0aW5wdXQoIFwib3B0aW9uXCIsIFwidGhlbWVcIiwgb3B0aW9ucy5maWx0ZXJUaGVtZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggdGhpcy5faXNTZWFyY2hJbnRlcm5hbCgpICkge1xuXHRcdFx0dGhpcy5fc2VhcmNoLnJlbW92ZSgpO1xuXHRcdH1cblx0XHR0aGlzLl9zdXBlcigpO1xuXHR9LFxuXG5cdF9zeW5jVGV4dElucHV0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGlkeCxcblx0XHRcdHRleHRpbnB1dE9wdGlvbnMgPSB7fTtcblxuXHRcdC8vIFdlIG9ubHkgc3luYyBvcHRpb25zIGlmIHRoZSBmaWx0ZXJhYmxlJ3MgdGV4dGlucHV0IGlzIG9mIHRoZSBpbnRlcm5hbGx5XG5cdFx0Ly8gZ2VuZXJhdGVkIHZhcmlldHksIHJhdGhlciB0aGFuIG9uZSBzcGVjaWZpZWQgYnkgdGhlIHVzZXIuXG5cdFx0aWYgKCB0aGlzLl9pc1NlYXJjaEludGVybmFsKCkgJiYgJC5tb2JpbGUudGV4dGlucHV0ICkge1xuXG5cdFx0XHQvLyBBcHBseSBvbmx5IHRoZSBvcHRpb25zIHVuZGVyc3Rvb2QgYnkgdGV4dGlucHV0XG5cdFx0XHRmb3IgKCBpZHggaW4gJC5tb2JpbGUudGV4dGlucHV0LnByb3RvdHlwZS5vcHRpb25zICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnNbIGlkeCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aWYgKCBpZHggPT09IFwidGhlbWVcIiAmJiB0aGlzLm9wdGlvbnMuZmlsdGVyVGhlbWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHRleHRpbnB1dE9wdGlvbnNbIGlkeCBdID0gdGhpcy5vcHRpb25zLmZpbHRlclRoZW1lO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0ZXh0aW5wdXRPcHRpb25zWyBpZHggXSA9IG9wdGlvbnNbIGlkeCBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2VhcmNoLnRleHRpbnB1dCggXCJvcHRpb25cIiwgdGV4dGlucHV0T3B0aW9ucyApO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEluc3RhbnRpYXRlIGEgZmlsdGVyYWJsZSBvbiBhIGxpc3R2aWV3IHRoYXQgaGFzIHRoZSBkYXRhLWZpbHRlcj1cInRydWVcIiBhdHRyaWJ1dGVcbi8vIFRoaXMgaXMgbm90IG5lY2Vzc2FyeSBmb3Igc3RhdGljIGNvbnRlbnQsIGJlY2F1c2UgdGhlIGF1dG8tZW5oYW5jZSB0YWtlcyBjYXJlIG9mIGluc3RhbnRpYXRpbmdcbi8vIHRoZSBmaWx0ZXJhYmxlIHVwb24gZW5jb3VudGVyaW5nIGRhdGEtZmlsdGVyPVwidHJ1ZVwiLiBIb3dldmVyLCBiZWNhdXNlIG9mIDEuMy54IGl0IGlzIGV4cGVjdGVkXG4vLyB0aGF0IGEgbGlzdHZpZXcgd2l0aCBkYXRhLWZpbHRlcj1cInRydWVcIiB3aWxsIGJlIGZpbHRlcmFibGUgZXZlbiBpZiB5b3UganVzdCBpbnN0YW50aWF0ZSBhXG4vLyBsaXN0dmlldyBvbiBpdC4gVGhlIGV4dGVuc2lvbiBiZWxvdyBlbnN1cmVzIHRoYXQgdGhpcyBjb250aW51ZXMgdG8gaGFwcGVuIGluIDEuNC54LlxuJC53aWRnZXQoIFwibW9iaWxlLmxpc3R2aWV3XCIsICQubW9iaWxlLmxpc3R2aWV3LCB7XG5cdG9wdGlvbnM6IHtcblx0XHRmaWx0ZXI6IGZhbHNlXG5cdH0sXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmZpbHRlciA9PT0gdHJ1ZSAmJlxuXHRcdFx0XHQhdGhpcy5lbGVtZW50LmRhdGEoIFwibW9iaWxlLWZpbHRlcmFibGVcIiApICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LmZpbHRlcmFibGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3N1cGVyKCk7XG5cdH0sXG5cblx0X2FmdGVyTGlzdHZpZXdSZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZmlsdGVyYWJsZSA9IHRoaXMuZWxlbWVudC5kYXRhKCBcIm1vYmlsZS1maWx0ZXJhYmxlXCIgKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmZpbHRlciA9PT0gdHJ1ZSAmJiBmaWx0ZXJhYmxlICkge1xuXHRcdFx0dGhpcy5fcHJldmVudFJlZnJlc2hMb29wID0gdHJ1ZTtcblx0XHRcdGZpbHRlcmFibGUucmVmcmVzaCgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBFbGltaW5hdGUgaW5maW5pdGUgcmVjdXJzaW9uIGNhdXNlZCBieSB0aGUgZmFjdCB0aGF0IHdlIGNhbGwgZmlsdGVyYWJsZS5yZWZyZXNoKCkgZnJvbVxuXHQvLyBfYWZ0ZXJMaXN0dmlld1JlZnJlc2goKSBhYm92ZSwgd2hpY2gsIGluIHR1cm4sIGNhbGxzIF9yZWZyZXNoQ2hpbGRXaWRnZXQoKSwgd2hpY2gsIGluXG5cdC8vIHR1cm4sIGNhbGxzIGxpc3R2aWV3IHJlZnJlc2goKSwgd2hpY2ggd291bGQsIGluIHR1cm4sIGNhbGxzIF9hZnRlckxpc3R2aWV3UmVmcmVzaCgpXG5cdC8vIGFib3ZlLCBpZiB3ZSB3b3VsZG4ndCBwcmV2ZW50IHRoYXQgcmlnaHQgaGVyZS5cblx0cmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJldHVyblZhbHVlO1xuXG5cdFx0aWYgKCAhdGhpcy5fcHJldmVudFJlZnJlc2hMb29wICkge1xuXHRcdFx0cmV0dXJuVmFsdWUgPSB0aGlzLl9zdXBlckFwcGx5KCBhcmd1bWVudHMgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9wcmV2ZW50UmVmcmVzaExvb3AgPSBmYWxzZTtcblxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fVxufSk7XG5cbn0pKCBqUXVlcnkgKTtcblxuLyohXG4gKiBqUXVlcnkgVUkgVGFicyBmYWRmMmIzMTJhMDUwNDA0MzY0NTFjNjRiYmZhZjQ4MTRiYzYyYzU2XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTMgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3RhYnMvXG4gKlxuICogRGVwZW5kczpcbiAqXHRqcXVlcnkudWkuY29yZS5qc1xuICpcdGpxdWVyeS51aS53aWRnZXQuanNcbiAqL1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbnZhciB0YWJJZCA9IDAsXG5cdHJoYXNoID0gLyMuKiQvO1xuXG5mdW5jdGlvbiBnZXROZXh0VGFiSWQoKSB7XG5cdHJldHVybiArK3RhYklkO1xufVxuXG5mdW5jdGlvbiBpc0xvY2FsKCBhbmNob3IgKSB7XG5cdHJldHVybiBhbmNob3IuaGFzaC5sZW5ndGggPiAxICYmXG5cdFx0ZGVjb2RlVVJJQ29tcG9uZW50KCBhbmNob3IuaHJlZi5yZXBsYWNlKCByaGFzaCwgXCJcIiApICkgPT09XG5cdFx0XHRkZWNvZGVVUklDb21wb25lbnQoIGxvY2F0aW9uLmhyZWYucmVwbGFjZSggcmhhc2gsIFwiXCIgKSApO1xufVxuXG4kLndpZGdldCggXCJ1aS50YWJzXCIsIHtcblx0dmVyc2lvbjogXCJmYWRmMmIzMTJhMDUwNDA0MzY0NTFjNjRiYmZhZjQ4MTRiYzYyYzU2XCIsXG5cdGRlbGF5OiAzMDAsXG5cdG9wdGlvbnM6IHtcblx0XHRhY3RpdmU6IG51bGwsXG5cdFx0Y29sbGFwc2libGU6IGZhbHNlLFxuXHRcdGV2ZW50OiBcImNsaWNrXCIsXG5cdFx0aGVpZ2h0U3R5bGU6IFwiY29udGVudFwiLFxuXHRcdGhpZGU6IG51bGwsXG5cdFx0c2hvdzogbnVsbCxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGFjdGl2YXRlOiBudWxsLFxuXHRcdGJlZm9yZUFjdGl2YXRlOiBudWxsLFxuXHRcdGJlZm9yZUxvYWQ6IG51bGwsXG5cdFx0bG9hZDogbnVsbFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LmFkZENsYXNzKCBcInVpLXRhYnMgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGxcIiApXG5cdFx0XHQudG9nZ2xlQ2xhc3MoIFwidWktdGFicy1jb2xsYXBzaWJsZVwiLCBvcHRpb25zLmNvbGxhcHNpYmxlIClcblx0XHRcdC8vIFByZXZlbnQgdXNlcnMgZnJvbSBmb2N1c2luZyBkaXNhYmxlZCB0YWJzIHZpYSBjbGlja1xuXHRcdFx0LmRlbGVnYXRlKCBcIi51aS10YWJzLW5hdiA+IGxpXCIsIFwibW91c2Vkb3duXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggJCggdGhpcyApLmlzKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC8vIHN1cHBvcnQ6IElFIDw5XG5cdFx0XHQvLyBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGFjdGlvbiBpbiBtb3VzZWRvd24gZG9lc24ndCBwcmV2ZW50IElFXG5cdFx0XHQvLyBmcm9tIGZvY3VzaW5nIHRoZSBlbGVtZW50LCBzbyBpZiB0aGUgYW5jaG9yIGdldHMgZm9jdXNlZCwgYmx1ci5cblx0XHRcdC8vIFdlIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgZm9jdXNpbmcgdGhlIHByZXZpb3VzbHkgZm9jdXNlZFxuXHRcdFx0Ly8gZWxlbWVudCBzaW5jZSBjbGlja2luZyBvbiBhIG5vbi1mb2N1c2FibGUgZWxlbWVudCBzaG91bGQgZm9jdXNcblx0XHRcdC8vIHRoZSBib2R5IGFueXdheS5cblx0XHRcdC5kZWxlZ2F0ZSggXCIudWktdGFicy1hbmNob3JcIiwgXCJmb2N1c1wiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggJCggdGhpcyApLmNsb3Nlc3QoIFwibGlcIiApLmlzKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0dGhpcy5fcHJvY2Vzc1RhYnMoKTtcblx0XHRvcHRpb25zLmFjdGl2ZSA9IHRoaXMuX2luaXRpYWxBY3RpdmUoKTtcblxuXHRcdC8vIFRha2UgZGlzYWJsaW5nIHRhYnMgdmlhIGNsYXNzIGF0dHJpYnV0ZSBmcm9tIEhUTUxcblx0XHQvLyBpbnRvIGFjY291bnQgYW5kIHVwZGF0ZSBvcHRpb24gcHJvcGVybHkuXG5cdFx0aWYgKCAkLmlzQXJyYXkoIG9wdGlvbnMuZGlzYWJsZWQgKSApIHtcblx0XHRcdG9wdGlvbnMuZGlzYWJsZWQgPSAkLnVuaXF1ZSggb3B0aW9ucy5kaXNhYmxlZC5jb25jYXQoXG5cdFx0XHRcdCQubWFwKCB0aGlzLnRhYnMuZmlsdGVyKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICksIGZ1bmN0aW9uKCBsaSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhhdC50YWJzLmluZGV4KCBsaSApO1xuXHRcdFx0XHR9KVxuXHRcdFx0KSApLnNvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBjaGVjayBmb3IgbGVuZ3RoIGF2b2lkcyBlcnJvciB3aGVuIGluaXRpYWxpemluZyBlbXB0eSBsaXN0XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuYWN0aXZlICE9PSBmYWxzZSAmJiB0aGlzLmFuY2hvcnMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5hY3RpdmUgPSB0aGlzLl9maW5kQWN0aXZlKCBvcHRpb25zLmFjdGl2ZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFjdGl2ZSA9ICQoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cblx0XHRpZiAoIHRoaXMuYWN0aXZlLmxlbmd0aCApIHtcblx0XHRcdHRoaXMubG9hZCggb3B0aW9ucy5hY3RpdmUgKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRpYWxBY3RpdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhY3RpdmUgPSB0aGlzLm9wdGlvbnMuYWN0aXZlLFxuXHRcdFx0Y29sbGFwc2libGUgPSB0aGlzLm9wdGlvbnMuY29sbGFwc2libGUsXG5cdFx0XHRsb2NhdGlvbkhhc2ggPSBsb2NhdGlvbi5oYXNoLnN1YnN0cmluZyggMSApO1xuXG5cdFx0aWYgKCBhY3RpdmUgPT09IG51bGwgKSB7XG5cdFx0XHQvLyBjaGVjayB0aGUgZnJhZ21lbnQgaWRlbnRpZmllciBpbiB0aGUgVVJMXG5cdFx0XHRpZiAoIGxvY2F0aW9uSGFzaCApIHtcblx0XHRcdFx0dGhpcy50YWJzLmVhY2goZnVuY3Rpb24oIGksIHRhYiApIHtcblx0XHRcdFx0XHRpZiAoICQoIHRhYiApLmF0dHIoIFwiYXJpYS1jb250cm9sc1wiICkgPT09IGxvY2F0aW9uSGFzaCApIHtcblx0XHRcdFx0XHRcdGFjdGl2ZSA9IGk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2hlY2sgZm9yIGEgdGFiIG1hcmtlZCBhY3RpdmUgdmlhIGEgY2xhc3Ncblx0XHRcdGlmICggYWN0aXZlID09PSBudWxsICkge1xuXHRcdFx0XHRhY3RpdmUgPSB0aGlzLnRhYnMuaW5kZXgoIHRoaXMudGFicy5maWx0ZXIoIFwiLnVpLXRhYnMtYWN0aXZlXCIgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBubyBhY3RpdmUgdGFiLCBzZXQgdG8gZmFsc2Vcblx0XHRcdGlmICggYWN0aXZlID09PSBudWxsIHx8IGFjdGl2ZSA9PT0gLTEgKSB7XG5cdFx0XHRcdGFjdGl2ZSA9IHRoaXMudGFicy5sZW5ndGggPyAwIDogZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gaGFuZGxlIG51bWJlcnM6IG5lZ2F0aXZlLCBvdXQgb2YgcmFuZ2Vcblx0XHRpZiAoIGFjdGl2ZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRhY3RpdmUgPSB0aGlzLnRhYnMuaW5kZXgoIHRoaXMudGFicy5lcSggYWN0aXZlICkgKTtcblx0XHRcdGlmICggYWN0aXZlID09PSAtMSApIHtcblx0XHRcdFx0YWN0aXZlID0gY29sbGFwc2libGUgPyBmYWxzZSA6IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gZG9uJ3QgYWxsb3cgY29sbGFwc2libGU6IGZhbHNlIGFuZCBhY3RpdmU6IGZhbHNlXG5cdFx0aWYgKCAhY29sbGFwc2libGUgJiYgYWN0aXZlID09PSBmYWxzZSAmJiB0aGlzLmFuY2hvcnMubGVuZ3RoICkge1xuXHRcdFx0YWN0aXZlID0gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWN0aXZlO1xuXHR9LFxuXG5cdF9nZXRDcmVhdGVFdmVudERhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0YWI6IHRoaXMuYWN0aXZlLFxuXHRcdFx0cGFuZWw6ICF0aGlzLmFjdGl2ZS5sZW5ndGggPyAkKCkgOiB0aGlzLl9nZXRQYW5lbEZvclRhYiggdGhpcy5hY3RpdmUgKVxuXHRcdH07XG5cdH0sXG5cblx0X3RhYktleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgZm9jdXNlZFRhYiA9ICQoIHRoaXMuZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCApLmNsb3Nlc3QoIFwibGlcIiApLFxuXHRcdFx0c2VsZWN0ZWRJbmRleCA9IHRoaXMudGFicy5pbmRleCggZm9jdXNlZFRhYiApLFxuXHRcdFx0Z29pbmdGb3J3YXJkID0gdHJ1ZTtcblxuXHRcdGlmICggdGhpcy5faGFuZGxlUGFnZU5hdiggZXZlbnQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUklHSFQ6XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5ET1dOOlxuXHRcdFx0XHRzZWxlY3RlZEluZGV4Kys7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuVVA6XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5MRUZUOlxuXHRcdFx0XHRnb2luZ0ZvcndhcmQgPSBmYWxzZTtcblx0XHRcdFx0c2VsZWN0ZWRJbmRleC0tO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkVORDpcblx0XHRcdFx0c2VsZWN0ZWRJbmRleCA9IHRoaXMuYW5jaG9ycy5sZW5ndGggLSAxO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkhPTUU6XG5cdFx0XHRcdHNlbGVjdGVkSW5kZXggPSAwO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlNQQUNFOlxuXHRcdFx0XHQvLyBBY3RpdmF0ZSBvbmx5LCBubyBjb2xsYXBzaW5nXG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5hY3RpdmF0aW5nICk7XG5cdFx0XHRcdHRoaXMuX2FjdGl2YXRlKCBzZWxlY3RlZEluZGV4ICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkVOVEVSOlxuXHRcdFx0XHQvLyBUb2dnbGUgKGNhbmNlbCBkZWxheWVkIGFjdGl2YXRpb24sIGFsbG93IGNvbGxhcHNpbmcpXG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5hY3RpdmF0aW5nICk7XG5cdFx0XHRcdC8vIERldGVybWluZSBpZiB3ZSBzaG91bGQgY29sbGFwc2Ugb3IgYWN0aXZhdGVcblx0XHRcdFx0dGhpcy5fYWN0aXZhdGUoIHNlbGVjdGVkSW5kZXggPT09IHRoaXMub3B0aW9ucy5hY3RpdmUgPyBmYWxzZSA6IHNlbGVjdGVkSW5kZXggKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZvY3VzIHRoZSBhcHByb3ByaWF0ZSB0YWIsIGJhc2VkIG9uIHdoaWNoIGtleSB3YXMgcHJlc3NlZFxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLmFjdGl2YXRpbmcgKTtcblx0XHRzZWxlY3RlZEluZGV4ID0gdGhpcy5fZm9jdXNOZXh0VGFiKCBzZWxlY3RlZEluZGV4LCBnb2luZ0ZvcndhcmQgKTtcblxuXHRcdC8vIE5hdmlnYXRpbmcgd2l0aCBjb250cm9sIGtleSB3aWxsIHByZXZlbnQgYXV0b21hdGljIGFjdGl2YXRpb25cblx0XHRpZiAoICFldmVudC5jdHJsS2V5ICkge1xuXHRcdFx0Ly8gVXBkYXRlIGFyaWEtc2VsZWN0ZWQgaW1tZWRpYXRlbHkgc28gdGhhdCBBVCB0aGluayB0aGUgdGFiIGlzIGFscmVhZHkgc2VsZWN0ZWQuXG5cdFx0XHQvLyBPdGhlcndpc2UgQVQgbWF5IGNvbmZ1c2UgdGhlIHVzZXIgYnkgc3RhdGluZyB0aGF0IHRoZXkgbmVlZCB0byBhY3RpdmF0ZSB0aGUgdGFiLFxuXHRcdFx0Ly8gYnV0IHRoZSB0YWIgd2lsbCBhbHJlYWR5IGJlIGFjdGl2YXRlZCBieSB0aGUgdGltZSB0aGUgYW5ub3VuY2VtZW50IGZpbmlzaGVzLlxuXHRcdFx0Zm9jdXNlZFRhYi5hdHRyKCBcImFyaWEtc2VsZWN0ZWRcIiwgXCJmYWxzZVwiICk7XG5cdFx0XHR0aGlzLnRhYnMuZXEoIHNlbGVjdGVkSW5kZXggKS5hdHRyKCBcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIgKTtcblxuXHRcdFx0dGhpcy5hY3RpdmF0aW5nID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9uKCBcImFjdGl2ZVwiLCBzZWxlY3RlZEluZGV4ICk7XG5cdFx0XHR9LCB0aGlzLmRlbGF5ICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9wYW5lbEtleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIHRoaXMuX2hhbmRsZVBhZ2VOYXYoIGV2ZW50ICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ3RybCt1cCBtb3ZlcyBmb2N1cyB0byB0aGUgY3VycmVudCB0YWJcblx0XHRpZiAoIGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQua2V5Q29kZSA9PT0gJC51aS5rZXlDb2RlLlVQICkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuYWN0aXZlLmZvY3VzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEFsdCtwYWdlIHVwL2Rvd24gbW92ZXMgZm9jdXMgdG8gdGhlIHByZXZpb3VzL25leHQgdGFiIChhbmQgYWN0aXZhdGVzKVxuXHRfaGFuZGxlUGFnZU5hdjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggZXZlbnQuYWx0S2V5ICYmIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5QQUdFX1VQICkge1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIHRoaXMuX2ZvY3VzTmV4dFRhYiggdGhpcy5vcHRpb25zLmFjdGl2ZSAtIDEsIGZhbHNlICkgKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRpZiAoIGV2ZW50LmFsdEtleSAmJiBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuUEFHRV9ET1dOICkge1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIHRoaXMuX2ZvY3VzTmV4dFRhYiggdGhpcy5vcHRpb25zLmFjdGl2ZSArIDEsIHRydWUgKSApO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdF9maW5kTmV4dFRhYjogZnVuY3Rpb24oIGluZGV4LCBnb2luZ0ZvcndhcmQgKSB7XG5cdFx0dmFyIGxhc3RUYWJJbmRleCA9IHRoaXMudGFicy5sZW5ndGggLSAxO1xuXG5cdFx0ZnVuY3Rpb24gY29uc3RyYWluKCkge1xuXHRcdFx0aWYgKCBpbmRleCA+IGxhc3RUYWJJbmRleCApIHtcblx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdGluZGV4ID0gbGFzdFRhYkluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGluZGV4O1xuXHRcdH1cblxuXHRcdHdoaWxlICggJC5pbkFycmF5KCBjb25zdHJhaW4oKSwgdGhpcy5vcHRpb25zLmRpc2FibGVkICkgIT09IC0xICkge1xuXHRcdFx0aW5kZXggPSBnb2luZ0ZvcndhcmQgPyBpbmRleCArIDEgOiBpbmRleCAtIDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9LFxuXG5cdF9mb2N1c05leHRUYWI6IGZ1bmN0aW9uKCBpbmRleCwgZ29pbmdGb3J3YXJkICkge1xuXHRcdGluZGV4ID0gdGhpcy5fZmluZE5leHRUYWIoIGluZGV4LCBnb2luZ0ZvcndhcmQgKTtcblx0XHR0aGlzLnRhYnMuZXEoIGluZGV4ICkuZm9jdXMoKTtcblx0XHRyZXR1cm4gaW5kZXg7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0aWYgKCBrZXkgPT09IFwiYWN0aXZlXCIgKSB7XG5cdFx0XHQvLyBfYWN0aXZhdGUoKSB3aWxsIGhhbmRsZSBpbnZhbGlkIHZhbHVlcyBhbmQgdXBkYXRlIHRoaXMub3B0aW9uc1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIHZhbHVlICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdC8vIGRvbid0IHVzZSB0aGUgd2lkZ2V0IGZhY3RvcnkncyBkaXNhYmxlZCBoYW5kbGluZ1xuXHRcdFx0dGhpcy5fc2V0dXBEaXNhYmxlZCggdmFsdWUgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSk7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJjb2xsYXBzaWJsZVwiICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LnRvZ2dsZUNsYXNzKCBcInVpLXRhYnMtY29sbGFwc2libGVcIiwgdmFsdWUgKTtcblx0XHRcdC8vIFNldHRpbmcgY29sbGFwc2libGU6IGZhbHNlIHdoaWxlIGNvbGxhcHNlZDsgb3BlbiBmaXJzdCBwYW5lbFxuXHRcdFx0aWYgKCAhdmFsdWUgJiYgdGhpcy5vcHRpb25zLmFjdGl2ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2YXRlKCAwICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwiZXZlbnRcIiApIHtcblx0XHRcdHRoaXMuX3NldHVwRXZlbnRzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ID09PSBcImhlaWdodFN0eWxlXCIgKSB7XG5cdFx0XHR0aGlzLl9zZXR1cEhlaWdodFN0eWxlKCB2YWx1ZSApO1xuXHRcdH1cblx0fSxcblxuXHRfdGFiSWQ6IGZ1bmN0aW9uKCB0YWIgKSB7XG5cdFx0cmV0dXJuIHRhYi5hdHRyKCBcImFyaWEtY29udHJvbHNcIiApIHx8IFwidWktdGFicy1cIiArIGdldE5leHRUYWJJZCgpO1xuXHR9LFxuXG5cdF9zYW5pdGl6ZVNlbGVjdG9yOiBmdW5jdGlvbiggaGFzaCApIHtcblx0XHRyZXR1cm4gaGFzaCA/IGhhc2gucmVwbGFjZSggL1shXCIkJSYnKCkqKywuXFwvOjs8PT4/QFxcW1xcXVxcXmB7fH1+XS9nLCBcIlxcXFwkJlwiICkgOiBcIlwiO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0bGlzID0gdGhpcy50YWJsaXN0LmNoaWxkcmVuKCBcIjpoYXMoYVtocmVmXSlcIiApO1xuXG5cdFx0Ly8gZ2V0IGRpc2FibGVkIHRhYnMgZnJvbSBjbGFzcyBhdHRyaWJ1dGUgZnJvbSBIVE1MXG5cdFx0Ly8gdGhpcyB3aWxsIGdldCBjb252ZXJ0ZWQgdG8gYSBib29sZWFuIGlmIG5lZWRlZCBpbiBfcmVmcmVzaCgpXG5cdFx0b3B0aW9ucy5kaXNhYmxlZCA9ICQubWFwKCBsaXMuZmlsdGVyKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICksIGZ1bmN0aW9uKCB0YWIgKSB7XG5cdFx0XHRyZXR1cm4gbGlzLmluZGV4KCB0YWIgKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX3Byb2Nlc3NUYWJzKCk7XG5cblx0XHQvLyB3YXMgY29sbGFwc2VkIG9yIG5vIHRhYnNcblx0XHRpZiAoIG9wdGlvbnMuYWN0aXZlID09PSBmYWxzZSB8fCAhdGhpcy5hbmNob3JzLmxlbmd0aCApIHtcblx0XHRcdG9wdGlvbnMuYWN0aXZlID0gZmFsc2U7XG5cdFx0XHR0aGlzLmFjdGl2ZSA9ICQoKTtcblx0XHQvLyB3YXMgYWN0aXZlLCBidXQgYWN0aXZlIHRhYiBpcyBnb25lXG5cdFx0fSBlbHNlIGlmICggdGhpcy5hY3RpdmUubGVuZ3RoICYmICEkLmNvbnRhaW5zKCB0aGlzLnRhYmxpc3RbIDAgXSwgdGhpcy5hY3RpdmVbIDAgXSApICkge1xuXHRcdFx0Ly8gYWxsIHJlbWFpbmluZyB0YWJzIGFyZSBkaXNhYmxlZFxuXHRcdFx0aWYgKCB0aGlzLnRhYnMubGVuZ3RoID09PSBvcHRpb25zLmRpc2FibGVkLmxlbmd0aCApIHtcblx0XHRcdFx0b3B0aW9ucy5hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5hY3RpdmUgPSAkKCk7XG5cdFx0XHQvLyBhY3RpdmF0ZSBwcmV2aW91cyB0YWJcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2YXRlKCB0aGlzLl9maW5kTmV4dFRhYiggTWF0aC5tYXgoIDAsIG9wdGlvbnMuYWN0aXZlIC0gMSApLCBmYWxzZSApICk7XG5cdFx0XHR9XG5cdFx0Ly8gd2FzIGFjdGl2ZSwgYWN0aXZlIHRhYiBzdGlsbCBleGlzdHNcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gbWFrZSBzdXJlIGFjdGl2ZSBpbmRleCBpcyBjb3JyZWN0XG5cdFx0XHRvcHRpb25zLmFjdGl2ZSA9IHRoaXMudGFicy5pbmRleCggdGhpcy5hY3RpdmUgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdH0sXG5cblx0X3JlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NldHVwRGlzYWJsZWQoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApO1xuXHRcdHRoaXMuX3NldHVwRXZlbnRzKCB0aGlzLm9wdGlvbnMuZXZlbnQgKTtcblx0XHR0aGlzLl9zZXR1cEhlaWdodFN0eWxlKCB0aGlzLm9wdGlvbnMuaGVpZ2h0U3R5bGUgKTtcblxuXHRcdHRoaXMudGFicy5ub3QoIHRoaXMuYWN0aXZlICkuYXR0cih7XG5cdFx0XHRcImFyaWEtc2VsZWN0ZWRcIjogXCJmYWxzZVwiLFxuXHRcdFx0dGFiSW5kZXg6IC0xXG5cdFx0fSk7XG5cdFx0dGhpcy5wYW5lbHMubm90KCB0aGlzLl9nZXRQYW5lbEZvclRhYiggdGhpcy5hY3RpdmUgKSApXG5cdFx0XHQuaGlkZSgpXG5cdFx0XHQuYXR0cih7XG5cdFx0XHRcdFwiYXJpYS1leHBhbmRlZFwiOiBcImZhbHNlXCIsXG5cdFx0XHRcdFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCJcblx0XHRcdH0pO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIG9uZSB0YWIgaXMgaW4gdGhlIHRhYiBvcmRlclxuXHRcdGlmICggIXRoaXMuYWN0aXZlLmxlbmd0aCApIHtcblx0XHRcdHRoaXMudGFicy5lcSggMCApLmF0dHIoIFwidGFiSW5kZXhcIiwgMCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFjdGl2ZVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktdGFicy1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXCIgKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XCJhcmlhLXNlbGVjdGVkXCI6IFwidHJ1ZVwiLFxuXHRcdFx0XHRcdHRhYkluZGV4OiAwXG5cdFx0XHRcdH0pO1xuXHRcdFx0dGhpcy5fZ2V0UGFuZWxGb3JUYWIoIHRoaXMuYWN0aXZlIClcblx0XHRcdFx0LnNob3coKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwidHJ1ZVwiLFxuXHRcdFx0XHRcdFwiYXJpYS1oaWRkZW5cIjogXCJmYWxzZVwiXG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRfcHJvY2Vzc1RhYnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdHRoaXMudGFibGlzdCA9IHRoaXMuX2dldExpc3QoKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLXRhYnMtbmF2IHVpLWhlbHBlci1yZXNldCB1aS1oZWxwZXItY2xlYXJmaXggdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItYWxsXCIgKVxuXHRcdFx0LmF0dHIoIFwicm9sZVwiLCBcInRhYmxpc3RcIiApO1xuXG5cdFx0dGhpcy50YWJzID0gdGhpcy50YWJsaXN0LmZpbmQoIFwiPiBsaTpoYXMoYVtocmVmXSlcIiApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItdG9wXCIgKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRyb2xlOiBcInRhYlwiLFxuXHRcdFx0XHR0YWJJbmRleDogLTFcblx0XHRcdH0pO1xuXG5cdFx0dGhpcy5hbmNob3JzID0gdGhpcy50YWJzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICQoIFwiYVwiLCB0aGlzIClbIDAgXTtcblx0XHRcdH0pXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktdGFicy1hbmNob3JcIiApXG5cdFx0XHQuYXR0cih7XG5cdFx0XHRcdHJvbGU6IFwicHJlc2VudGF0aW9uXCIsXG5cdFx0XHRcdHRhYkluZGV4OiAtMVxuXHRcdFx0fSk7XG5cblx0XHR0aGlzLnBhbmVscyA9ICQoKTtcblxuXHRcdHRoaXMuYW5jaG9ycy5lYWNoKGZ1bmN0aW9uKCBpLCBhbmNob3IgKSB7XG5cdFx0XHR2YXIgc2VsZWN0b3IsIHBhbmVsLCBwYW5lbElkLFxuXHRcdFx0XHRhbmNob3JJZCA9ICQoIGFuY2hvciApLnVuaXF1ZUlkKCkuYXR0ciggXCJpZFwiICksXG5cdFx0XHRcdHRhYiA9ICQoIGFuY2hvciApLmNsb3Nlc3QoIFwibGlcIiApLFxuXHRcdFx0XHRvcmlnaW5hbEFyaWFDb250cm9scyA9IHRhYi5hdHRyKCBcImFyaWEtY29udHJvbHNcIiApO1xuXG5cdFx0XHQvLyBpbmxpbmUgdGFiXG5cdFx0XHRpZiAoIGlzTG9jYWwoIGFuY2hvciApICkge1xuXHRcdFx0XHRzZWxlY3RvciA9IGFuY2hvci5oYXNoO1xuXHRcdFx0XHRwYW5lbCA9IHRoYXQuZWxlbWVudC5maW5kKCB0aGF0Ll9zYW5pdGl6ZVNlbGVjdG9yKCBzZWxlY3RvciApICk7XG5cdFx0XHQvLyByZW1vdGUgdGFiXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYW5lbElkID0gdGhhdC5fdGFiSWQoIHRhYiApO1xuXHRcdFx0XHRzZWxlY3RvciA9IFwiI1wiICsgcGFuZWxJZDtcblx0XHRcdFx0cGFuZWwgPSB0aGF0LmVsZW1lbnQuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdFx0aWYgKCAhcGFuZWwubGVuZ3RoICkge1xuXHRcdFx0XHRcdHBhbmVsID0gdGhhdC5fY3JlYXRlUGFuZWwoIHBhbmVsSWQgKTtcblx0XHRcdFx0XHRwYW5lbC5pbnNlcnRBZnRlciggdGhhdC5wYW5lbHNbIGkgLSAxIF0gfHwgdGhhdC50YWJsaXN0ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFuZWwuYXR0ciggXCJhcmlhLWxpdmVcIiwgXCJwb2xpdGVcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBhbmVsLmxlbmd0aCkge1xuXHRcdFx0XHR0aGF0LnBhbmVscyA9IHRoYXQucGFuZWxzLmFkZCggcGFuZWwgKTtcblx0XHRcdH1cblx0XHRcdGlmICggb3JpZ2luYWxBcmlhQ29udHJvbHMgKSB7XG5cdFx0XHRcdHRhYi5kYXRhKCBcInVpLXRhYnMtYXJpYS1jb250cm9sc1wiLCBvcmlnaW5hbEFyaWFDb250cm9scyApO1xuXHRcdFx0fVxuXHRcdFx0dGFiLmF0dHIoe1xuXHRcdFx0XHRcImFyaWEtY29udHJvbHNcIjogc2VsZWN0b3Iuc3Vic3RyaW5nKCAxICksXG5cdFx0XHRcdFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFuY2hvcklkXG5cdFx0XHR9KTtcblx0XHRcdHBhbmVsLmF0dHIoIFwiYXJpYS1sYWJlbGxlZGJ5XCIsIGFuY2hvcklkICk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnBhbmVsc1xuXHRcdFx0LmFkZENsYXNzKCBcInVpLXRhYnMtcGFuZWwgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWJvdHRvbVwiIClcblx0XHRcdC5hdHRyKCBcInJvbGVcIiwgXCJ0YWJwYW5lbFwiICk7XG5cdH0sXG5cblx0Ly8gYWxsb3cgb3ZlcnJpZGluZyBob3cgdG8gZmluZCB0aGUgbGlzdCBmb3IgcmFyZSB1c2FnZSBzY2VuYXJpb3MgKCM3NzE1KVxuXHRfZ2V0TGlzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5maW5kKCBcIm9sLHVsXCIgKS5lcSggMCApO1xuXHR9LFxuXG5cdF9jcmVhdGVQYW5lbDogZnVuY3Rpb24oIGlkICkge1xuXHRcdHJldHVybiAkKCBcIjxkaXY+XCIgKVxuXHRcdFx0LmF0dHIoIFwiaWRcIiwgaWQgKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLXRhYnMtcGFuZWwgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWJvdHRvbVwiIClcblx0XHRcdC5kYXRhKCBcInVpLXRhYnMtZGVzdHJveVwiLCB0cnVlICk7XG5cdH0sXG5cblx0X3NldHVwRGlzYWJsZWQ6IGZ1bmN0aW9uKCBkaXNhYmxlZCApIHtcblx0XHRpZiAoICQuaXNBcnJheSggZGlzYWJsZWQgKSApIHtcblx0XHRcdGlmICggIWRpc2FibGVkLmxlbmd0aCApIHtcblx0XHRcdFx0ZGlzYWJsZWQgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIGRpc2FibGVkLmxlbmd0aCA9PT0gdGhpcy5hbmNob3JzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGRpc2FibGUgdGFic1xuXHRcdGZvciAoIHZhciBpID0gMCwgbGk7ICggbGkgPSB0aGlzLnRhYnNbIGkgXSApOyBpKysgKSB7XG5cdFx0XHRpZiAoIGRpc2FibGVkID09PSB0cnVlIHx8ICQuaW5BcnJheSggaSwgZGlzYWJsZWQgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdCQoIGxpIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApXG5cdFx0XHRcdFx0LmF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiLCBcInRydWVcIiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JCggbGkgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiIClcblx0XHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcblx0fSxcblxuXHRfc2V0dXBFdmVudHM6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0Y2xpY2s6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGlmICggZXZlbnQgKSB7XG5cdFx0XHQkLmVhY2goIGV2ZW50LnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oIGluZGV4LCBldmVudE5hbWUgKSB7XG5cdFx0XHRcdGV2ZW50c1sgZXZlbnROYW1lIF0gPSBcIl9ldmVudEhhbmRsZXJcIjtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuX29mZiggdGhpcy5hbmNob3JzLmFkZCggdGhpcy50YWJzICkuYWRkKCB0aGlzLnBhbmVscyApICk7XG5cdFx0dGhpcy5fb24oIHRoaXMuYW5jaG9ycywgZXZlbnRzICk7XG5cdFx0dGhpcy5fb24oIHRoaXMudGFicywgeyBrZXlkb3duOiBcIl90YWJLZXlkb3duXCIgfSApO1xuXHRcdHRoaXMuX29uKCB0aGlzLnBhbmVscywgeyBrZXlkb3duOiBcIl9wYW5lbEtleWRvd25cIiB9ICk7XG5cblx0XHR0aGlzLl9mb2N1c2FibGUoIHRoaXMudGFicyApO1xuXHRcdHRoaXMuX2hvdmVyYWJsZSggdGhpcy50YWJzICk7XG5cdH0sXG5cblx0X3NldHVwSGVpZ2h0U3R5bGU6IGZ1bmN0aW9uKCBoZWlnaHRTdHlsZSApIHtcblx0XHR2YXIgbWF4SGVpZ2h0LFxuXHRcdFx0cGFyZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudCgpO1xuXG5cdFx0aWYgKCBoZWlnaHRTdHlsZSA9PT0gXCJmaWxsXCIgKSB7XG5cdFx0XHRtYXhIZWlnaHQgPSBwYXJlbnQuaGVpZ2h0KCk7XG5cdFx0XHRtYXhIZWlnaHQgLT0gdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCkgLSB0aGlzLmVsZW1lbnQuaGVpZ2h0KCk7XG5cblx0XHRcdHRoaXMuZWxlbWVudC5zaWJsaW5ncyggXCI6dmlzaWJsZVwiICkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSAkKCB0aGlzICksXG5cdFx0XHRcdFx0cG9zaXRpb24gPSBlbGVtLmNzcyggXCJwb3NpdGlvblwiICk7XG5cblx0XHRcdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1heEhlaWdodCAtPSBlbGVtLm91dGVySGVpZ2h0KCB0cnVlICk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5lbGVtZW50LmNoaWxkcmVuKCkubm90KCB0aGlzLnBhbmVscyApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdG1heEhlaWdodCAtPSAkKCB0aGlzICkub3V0ZXJIZWlnaHQoIHRydWUgKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLnBhbmVscy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkKCB0aGlzICkuaGVpZ2h0KCBNYXRoLm1heCggMCwgbWF4SGVpZ2h0IC1cblx0XHRcdFx0XHQkKCB0aGlzICkuaW5uZXJIZWlnaHQoKSArICQoIHRoaXMgKS5oZWlnaHQoKSApICk7XG5cdFx0XHR9KVxuXHRcdFx0LmNzcyggXCJvdmVyZmxvd1wiLCBcImF1dG9cIiApO1xuXHRcdH0gZWxzZSBpZiAoIGhlaWdodFN0eWxlID09PSBcImF1dG9cIiApIHtcblx0XHRcdG1heEhlaWdodCA9IDA7XG5cdFx0XHR0aGlzLnBhbmVscy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRtYXhIZWlnaHQgPSBNYXRoLm1heCggbWF4SGVpZ2h0LCAkKCB0aGlzICkuaGVpZ2h0KCBcIlwiICkuaGVpZ2h0KCkgKTtcblx0XHRcdH0pLmhlaWdodCggbWF4SGVpZ2h0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9ldmVudEhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGFjdGl2ZSA9IHRoaXMuYWN0aXZlLFxuXHRcdFx0YW5jaG9yID0gJCggZXZlbnQuY3VycmVudFRhcmdldCApLFxuXHRcdFx0dGFiID0gYW5jaG9yLmNsb3Nlc3QoIFwibGlcIiApLFxuXHRcdFx0Y2xpY2tlZElzQWN0aXZlID0gdGFiWyAwIF0gPT09IGFjdGl2ZVsgMCBdLFxuXHRcdFx0Y29sbGFwc2luZyA9IGNsaWNrZWRJc0FjdGl2ZSAmJiBvcHRpb25zLmNvbGxhcHNpYmxlLFxuXHRcdFx0dG9TaG93ID0gY29sbGFwc2luZyA/ICQoKSA6IHRoaXMuX2dldFBhbmVsRm9yVGFiKCB0YWIgKSxcblx0XHRcdHRvSGlkZSA9ICFhY3RpdmUubGVuZ3RoID8gJCgpIDogdGhpcy5fZ2V0UGFuZWxGb3JUYWIoIGFjdGl2ZSApLFxuXHRcdFx0ZXZlbnREYXRhID0ge1xuXHRcdFx0XHRvbGRUYWI6IGFjdGl2ZSxcblx0XHRcdFx0b2xkUGFuZWw6IHRvSGlkZSxcblx0XHRcdFx0bmV3VGFiOiBjb2xsYXBzaW5nID8gJCgpIDogdGFiLFxuXHRcdFx0XHRuZXdQYW5lbDogdG9TaG93XG5cdFx0XHR9O1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdGlmICggdGFiLmhhc0NsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIgKSB8fFxuXHRcdFx0XHQvLyB0YWIgaXMgYWxyZWFkeSBsb2FkaW5nXG5cdFx0XHRcdHRhYi5oYXNDbGFzcyggXCJ1aS10YWJzLWxvYWRpbmdcIiApIHx8XG5cdFx0XHRcdC8vIGNhbid0IHN3aXRjaCBkdXJuaW5nIGFuIGFuaW1hdGlvblxuXHRcdFx0XHR0aGlzLnJ1bm5pbmcgfHxcblx0XHRcdFx0Ly8gY2xpY2sgb24gYWN0aXZlIGhlYWRlciwgYnV0IG5vdCBjb2xsYXBzaWJsZVxuXHRcdFx0XHQoIGNsaWNrZWRJc0FjdGl2ZSAmJiAhb3B0aW9ucy5jb2xsYXBzaWJsZSApIHx8XG5cdFx0XHRcdC8vIGFsbG93IGNhbmNlbGluZyBhY3RpdmF0aW9uXG5cdFx0XHRcdCggdGhpcy5fdHJpZ2dlciggXCJiZWZvcmVBY3RpdmF0ZVwiLCBldmVudCwgZXZlbnREYXRhICkgPT09IGZhbHNlICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0b3B0aW9ucy5hY3RpdmUgPSBjb2xsYXBzaW5nID8gZmFsc2UgOiB0aGlzLnRhYnMuaW5kZXgoIHRhYiApO1xuXG5cdFx0dGhpcy5hY3RpdmUgPSBjbGlja2VkSXNBY3RpdmUgPyAkKCkgOiB0YWI7XG5cdFx0aWYgKCB0aGlzLnhociApIHtcblx0XHRcdHRoaXMueGhyLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdG9IaWRlLmxlbmd0aCAmJiAhdG9TaG93Lmxlbmd0aCApIHtcblx0XHRcdCQuZXJyb3IoIFwialF1ZXJ5IFVJIFRhYnM6IE1pc21hdGNoaW5nIGZyYWdtZW50IGlkZW50aWZpZXIuXCIgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRvU2hvdy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLmxvYWQoIHRoaXMudGFicy5pbmRleCggdGFiICksIGV2ZW50ICk7XG5cdFx0fVxuXHRcdHRoaXMuX3RvZ2dsZSggZXZlbnQsIGV2ZW50RGF0YSApO1xuXHR9LFxuXG5cdC8vIGhhbmRsZXMgc2hvdy9oaWRlIGZvciBzZWxlY3RpbmcgdGFic1xuXHRfdG9nZ2xlOiBmdW5jdGlvbiggZXZlbnQsIGV2ZW50RGF0YSApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHR0b1Nob3cgPSBldmVudERhdGEubmV3UGFuZWwsXG5cdFx0XHR0b0hpZGUgPSBldmVudERhdGEub2xkUGFuZWw7XG5cblx0XHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXG5cdFx0ZnVuY3Rpb24gY29tcGxldGUoKSB7XG5cdFx0XHR0aGF0LnJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdHRoYXQuX3RyaWdnZXIoIFwiYWN0aXZhdGVcIiwgZXZlbnQsIGV2ZW50RGF0YSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNob3coKSB7XG5cdFx0XHRldmVudERhdGEubmV3VGFiLmNsb3Nlc3QoIFwibGlcIiApLmFkZENsYXNzKCBcInVpLXRhYnMtYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cblx0XHRcdGlmICggdG9TaG93Lmxlbmd0aCAmJiB0aGF0Lm9wdGlvbnMuc2hvdyApIHtcblx0XHRcdFx0dGhhdC5fc2hvdyggdG9TaG93LCB0aGF0Lm9wdGlvbnMuc2hvdywgY29tcGxldGUgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRvU2hvdy5zaG93KCk7XG5cdFx0XHRcdGNvbXBsZXRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc3RhcnQgb3V0IGJ5IGhpZGluZywgdGhlbiBzaG93aW5nLCB0aGVuIGNvbXBsZXRpbmdcblx0XHRpZiAoIHRvSGlkZS5sZW5ndGggJiYgdGhpcy5vcHRpb25zLmhpZGUgKSB7XG5cdFx0XHR0aGlzLl9oaWRlKCB0b0hpZGUsIHRoaXMub3B0aW9ucy5oaWRlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZXZlbnREYXRhLm9sZFRhYi5jbG9zZXN0KCBcImxpXCIgKS5yZW1vdmVDbGFzcyggXCJ1aS10YWJzLWFjdGl2ZSB1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHRzaG93KCk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXZlbnREYXRhLm9sZFRhYi5jbG9zZXN0KCBcImxpXCIgKS5yZW1vdmVDbGFzcyggXCJ1aS10YWJzLWFjdGl2ZSB1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0dG9IaWRlLmhpZGUoKTtcblx0XHRcdHNob3coKTtcblx0XHR9XG5cblx0XHR0b0hpZGUuYXR0cih7XG5cdFx0XHRcImFyaWEtZXhwYW5kZWRcIjogXCJmYWxzZVwiLFxuXHRcdFx0XCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuXHRcdH0pO1xuXHRcdGV2ZW50RGF0YS5vbGRUYWIuYXR0ciggXCJhcmlhLXNlbGVjdGVkXCIsIFwiZmFsc2VcIiApO1xuXHRcdC8vIElmIHdlJ3JlIHN3aXRjaGluZyB0YWJzLCByZW1vdmUgdGhlIG9sZCB0YWIgZnJvbSB0aGUgdGFiIG9yZGVyLlxuXHRcdC8vIElmIHdlJ3JlIG9wZW5pbmcgZnJvbSBjb2xsYXBzZWQgc3RhdGUsIHJlbW92ZSB0aGUgcHJldmlvdXMgdGFiIGZyb20gdGhlIHRhYiBvcmRlci5cblx0XHQvLyBJZiB3ZSdyZSBjb2xsYXBzaW5nLCB0aGVuIGtlZXAgdGhlIGNvbGxhcHNpbmcgdGFiIGluIHRoZSB0YWIgb3JkZXIuXG5cdFx0aWYgKCB0b1Nob3cubGVuZ3RoICYmIHRvSGlkZS5sZW5ndGggKSB7XG5cdFx0XHRldmVudERhdGEub2xkVGFiLmF0dHIoIFwidGFiSW5kZXhcIiwgLTEgKTtcblx0XHR9IGVsc2UgaWYgKCB0b1Nob3cubGVuZ3RoICkge1xuXHRcdFx0dGhpcy50YWJzLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICQoIHRoaXMgKS5hdHRyKCBcInRhYkluZGV4XCIgKSA9PT0gMDtcblx0XHRcdH0pXG5cdFx0XHQuYXR0ciggXCJ0YWJJbmRleFwiLCAtMSApO1xuXHRcdH1cblxuXHRcdHRvU2hvdy5hdHRyKHtcblx0XHRcdFwiYXJpYS1leHBhbmRlZFwiOiBcInRydWVcIixcblx0XHRcdFwiYXJpYS1oaWRkZW5cIjogXCJmYWxzZVwiXG5cdFx0fSk7XG5cdFx0ZXZlbnREYXRhLm5ld1RhYi5hdHRyKHtcblx0XHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBcInRydWVcIixcblx0XHRcdHRhYkluZGV4OiAwXG5cdFx0fSk7XG5cdH0sXG5cblx0X2FjdGl2YXRlOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0dmFyIGFuY2hvcixcblx0XHRcdGFjdGl2ZSA9IHRoaXMuX2ZpbmRBY3RpdmUoIGluZGV4ICk7XG5cblx0XHQvLyB0cnlpbmcgdG8gYWN0aXZhdGUgdGhlIGFscmVhZHkgYWN0aXZlIHBhbmVsXG5cdFx0aWYgKCBhY3RpdmVbIDAgXSA9PT0gdGhpcy5hY3RpdmVbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyB0cnlpbmcgdG8gY29sbGFwc2UsIHNpbXVsYXRlIGEgY2xpY2sgb24gdGhlIGN1cnJlbnQgYWN0aXZlIGhlYWRlclxuXHRcdGlmICggIWFjdGl2ZS5sZW5ndGggKSB7XG5cdFx0XHRhY3RpdmUgPSB0aGlzLmFjdGl2ZTtcblx0XHR9XG5cblx0XHRhbmNob3IgPSBhY3RpdmUuZmluZCggXCIudWktdGFicy1hbmNob3JcIiApWyAwIF07XG5cdFx0dGhpcy5fZXZlbnRIYW5kbGVyKHtcblx0XHRcdHRhcmdldDogYW5jaG9yLFxuXHRcdFx0Y3VycmVudFRhcmdldDogYW5jaG9yLFxuXHRcdFx0cHJldmVudERlZmF1bHQ6ICQubm9vcFxuXHRcdH0pO1xuXHR9LFxuXG5cdF9maW5kQWN0aXZlOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0cmV0dXJuIGluZGV4ID09PSBmYWxzZSA/ICQoKSA6IHRoaXMudGFicy5lcSggaW5kZXggKTtcblx0fSxcblxuXHRfZ2V0SW5kZXg6IGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHQvLyBtZXRhLWZ1bmN0aW9uIHRvIGdpdmUgdXNlcnMgb3B0aW9uIHRvIHByb3ZpZGUgYSBocmVmIHN0cmluZyBpbnN0ZWFkIG9mIGEgbnVtZXJpY2FsIGluZGV4LlxuXHRcdGlmICggdHlwZW9mIGluZGV4ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aW5kZXggPSB0aGlzLmFuY2hvcnMuaW5kZXgoIHRoaXMuYW5jaG9ycy5maWx0ZXIoIFwiW2hyZWYkPSdcIiArIGluZGV4ICsgXCInXVwiICkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaW5kZXg7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggdGhpcy54aHIgKSB7XG5cdFx0XHR0aGlzLnhoci5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyggXCJ1aS10YWJzIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsIHVpLXRhYnMtY29sbGFwc2libGVcIiApO1xuXG5cdFx0dGhpcy50YWJsaXN0XG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktdGFicy1uYXYgdWktaGVscGVyLXJlc2V0IHVpLWhlbHBlci1jbGVhcmZpeCB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1hbGxcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJyb2xlXCIgKTtcblxuXHRcdHRoaXMuYW5jaG9yc1xuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXRhYnMtYW5jaG9yXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcInRhYkluZGV4XCIgKVxuXHRcdFx0LnJlbW92ZVVuaXF1ZUlkKCk7XG5cblx0XHR0aGlzLnRhYnMuYWRkKCB0aGlzLnBhbmVscyApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICQuZGF0YSggdGhpcywgXCJ1aS10YWJzLWRlc3Ryb3lcIiApICkge1xuXHRcdFx0XHQkKCB0aGlzICkucmVtb3ZlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkKCB0aGlzIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZGVmYXVsdCB1aS1zdGF0ZS1hY3RpdmUgdWktc3RhdGUtZGlzYWJsZWQgXCIgK1xuXHRcdFx0XHRcdFx0XCJ1aS1jb3JuZXItdG9wIHVpLWNvcm5lci1ib3R0b20gdWktd2lkZ2V0LWNvbnRlbnQgdWktdGFicy1hY3RpdmUgdWktdGFicy1wYW5lbFwiIClcblx0XHRcdFx0XHQucmVtb3ZlQXR0ciggXCJ0YWJJbmRleFwiIClcblx0XHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWxpdmVcIiApXG5cdFx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1idXN5XCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtc2VsZWN0ZWRcIiApXG5cdFx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1sYWJlbGxlZGJ5XCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtaGlkZGVuXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtZXhwYW5kZWRcIiApXG5cdFx0XHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLnRhYnMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBsaSA9ICQoIHRoaXMgKSxcblx0XHRcdFx0cHJldiA9IGxpLmRhdGEoIFwidWktdGFicy1hcmlhLWNvbnRyb2xzXCIgKTtcblx0XHRcdGlmICggcHJldiApIHtcblx0XHRcdFx0bGlcblx0XHRcdFx0XHQuYXR0ciggXCJhcmlhLWNvbnRyb2xzXCIsIHByZXYgKVxuXHRcdFx0XHRcdC5yZW1vdmVEYXRhKCBcInVpLXRhYnMtYXJpYS1jb250cm9sc1wiICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsaS5yZW1vdmVBdHRyKCBcImFyaWEtY29udHJvbHNcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5wYW5lbHMuc2hvdygpO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuaGVpZ2h0U3R5bGUgIT09IFwiY29udGVudFwiICkge1xuXHRcdFx0dGhpcy5wYW5lbHMuY3NzKCBcImhlaWdodFwiLCBcIlwiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGVuYWJsZTogZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdHZhciBkaXNhYmxlZCA9IHRoaXMub3B0aW9ucy5kaXNhYmxlZDtcblx0XHRpZiAoIGRpc2FibGVkID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRkaXNhYmxlZCA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbmRleCA9IHRoaXMuX2dldEluZGV4KCBpbmRleCApO1xuXHRcdFx0aWYgKCAkLmlzQXJyYXkoIGRpc2FibGVkICkgKSB7XG5cdFx0XHRcdGRpc2FibGVkID0gJC5tYXAoIGRpc2FibGVkLCBmdW5jdGlvbiggbnVtICkge1xuXHRcdFx0XHRcdHJldHVybiBudW0gIT09IGluZGV4ID8gbnVtIDogbnVsbDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkaXNhYmxlZCA9ICQubWFwKCB0aGlzLnRhYnMsIGZ1bmN0aW9uKCBsaSwgbnVtICkge1xuXHRcdFx0XHRcdHJldHVybiBudW0gIT09IGluZGV4ID8gbnVtIDogbnVsbDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX3NldHVwRGlzYWJsZWQoIGRpc2FibGVkICk7XG5cdH0sXG5cblx0ZGlzYWJsZTogZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdHZhciBkaXNhYmxlZCA9IHRoaXMub3B0aW9ucy5kaXNhYmxlZDtcblx0XHRpZiAoIGRpc2FibGVkID09PSB0cnVlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGRpc2FibGVkID0gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5kZXggPSB0aGlzLl9nZXRJbmRleCggaW5kZXggKTtcblx0XHRcdGlmICggJC5pbkFycmF5KCBpbmRleCwgZGlzYWJsZWQgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggJC5pc0FycmF5KCBkaXNhYmxlZCApICkge1xuXHRcdFx0XHRkaXNhYmxlZCA9ICQubWVyZ2UoIFsgaW5kZXggXSwgZGlzYWJsZWQgKS5zb3J0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkaXNhYmxlZCA9IFsgaW5kZXggXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fc2V0dXBEaXNhYmxlZCggZGlzYWJsZWQgKTtcblx0fSxcblxuXHRsb2FkOiBmdW5jdGlvbiggaW5kZXgsIGV2ZW50ICkge1xuXHRcdGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgoIGluZGV4ICk7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0dGFiID0gdGhpcy50YWJzLmVxKCBpbmRleCApLFxuXHRcdFx0YW5jaG9yID0gdGFiLmZpbmQoIFwiLnVpLXRhYnMtYW5jaG9yXCIgKSxcblx0XHRcdHBhbmVsID0gdGhpcy5fZ2V0UGFuZWxGb3JUYWIoIHRhYiApLFxuXHRcdFx0ZXZlbnREYXRhID0ge1xuXHRcdFx0XHR0YWI6IHRhYixcblx0XHRcdFx0cGFuZWw6IHBhbmVsXG5cdFx0XHR9O1xuXG5cdFx0Ly8gbm90IHJlbW90ZVxuXHRcdGlmICggaXNMb2NhbCggYW5jaG9yWyAwIF0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnhociA9ICQuYWpheCggdGhpcy5fYWpheFNldHRpbmdzKCBhbmNob3IsIGV2ZW50LCBldmVudERhdGEgKSApO1xuXG5cdFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcblx0XHQvLyBqUXVlcnkgPDEuOCByZXR1cm5zIGZhbHNlIGlmIHRoZSByZXF1ZXN0IGlzIGNhbmNlbGVkIGluIGJlZm9yZVNlbmQsXG5cdFx0Ly8gYnV0IGFzIG9mIDEuOCwgJC5hamF4KCkgYWx3YXlzIHJldHVybnMgYSBqcVhIUiBvYmplY3QuXG5cdFx0aWYgKCB0aGlzLnhociAmJiB0aGlzLnhoci5zdGF0dXNUZXh0ICE9PSBcImNhbmNlbGVkXCIgKSB7XG5cdFx0XHR0YWIuYWRkQ2xhc3MoIFwidWktdGFicy1sb2FkaW5nXCIgKTtcblx0XHRcdHBhbmVsLmF0dHIoIFwiYXJpYS1idXN5XCIsIFwidHJ1ZVwiICk7XG5cblx0XHRcdHRoaXMueGhyXG5cdFx0XHRcdC5zdWNjZXNzKGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdFx0XHQvLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxuXHRcdFx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzExNzc4XG5cdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHBhbmVsLmh0bWwoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcImxvYWRcIiwgZXZlbnQsIGV2ZW50RGF0YSApO1xuXHRcdFx0XHRcdH0sIDEgKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmNvbXBsZXRlKGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0XHRcdC8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XG5cdFx0XHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTE3Nzhcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0dGhhdC5wYW5lbHMuc3RvcCggZmFsc2UsIHRydWUgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dGFiLnJlbW92ZUNsYXNzKCBcInVpLXRhYnMtbG9hZGluZ1wiICk7XG5cdFx0XHRcdFx0XHRwYW5lbC5yZW1vdmVBdHRyKCBcImFyaWEtYnVzeVwiICk7XG5cblx0XHRcdFx0XHRcdGlmICgganFYSFIgPT09IHRoYXQueGhyICkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgdGhhdC54aHI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgMSApO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0X2FqYXhTZXR0aW5nczogZnVuY3Rpb24oIGFuY2hvciwgZXZlbnQsIGV2ZW50RGF0YSApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHVybDogYW5jaG9yLmF0dHIoIFwiaHJlZlwiICksXG5cdFx0XHRiZWZvcmVTZW5kOiBmdW5jdGlvbigganFYSFIsIHNldHRpbmdzICkge1xuXHRcdFx0XHRyZXR1cm4gdGhhdC5fdHJpZ2dlciggXCJiZWZvcmVMb2FkXCIsIGV2ZW50LFxuXHRcdFx0XHRcdCQuZXh0ZW5kKCB7IGpxWEhSIDoganFYSFIsIGFqYXhTZXR0aW5nczogc2V0dGluZ3MgfSwgZXZlbnREYXRhICkgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LFxuXG5cdF9nZXRQYW5lbEZvclRhYjogZnVuY3Rpb24oIHRhYiApIHtcblx0XHR2YXIgaWQgPSAkKCB0YWIgKS5hdHRyKCBcImFyaWEtY29udHJvbHNcIiApO1xuXHRcdHJldHVybiB0aGlzLmVsZW1lbnQuZmluZCggdGhpcy5fc2FuaXRpemVTZWxlY3RvciggXCIjXCIgKyBpZCApICk7XG5cdH1cbn0pO1xuXG59KSggalF1ZXJ5ICk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG59KSggalF1ZXJ5ICk7XG5cbihmdW5jdGlvbiggJCwgd2luZG93ICkge1xuXG5cdCQubW9iaWxlLmlvc29yaWVudGF0aW9uZml4RW5hYmxlZCA9IHRydWU7XG5cblx0Ly8gVGhpcyBmaXggYWRkcmVzc2VzIGFuIGlPUyBidWcsIHNvIHJldHVybiBlYXJseSBpZiB0aGUgVUEgY2xhaW1zIGl0J3Mgc29tZXRoaW5nIGVsc2UuXG5cdHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG5cdFx0em9vbSxcblx0XHRldnQsIHgsIHksIHosIGFpZztcblx0aWYgKCAhKCAvaVBob25lfGlQYWR8aVBvZC8udGVzdCggbmF2aWdhdG9yLnBsYXRmb3JtICkgJiYgL09TIFsxLTVdX1swLTlfXSogbGlrZSBNYWMgT1MgWC9pLnRlc3QoIHVhICkgJiYgdWEuaW5kZXhPZiggXCJBcHBsZVdlYktpdFwiICkgPiAtMSApICkge1xuXHRcdCQubW9iaWxlLmlvc29yaWVudGF0aW9uZml4RW5hYmxlZCA9IGZhbHNlO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHpvb20gPSAkLm1vYmlsZS56b29tO1xuXG5cdGZ1bmN0aW9uIGNoZWNrVGlsdCggZSApIHtcblx0XHRldnQgPSBlLm9yaWdpbmFsRXZlbnQ7XG5cdFx0YWlnID0gZXZ0LmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHk7XG5cblx0XHR4ID0gTWF0aC5hYnMoIGFpZy54ICk7XG5cdFx0eSA9IE1hdGguYWJzKCBhaWcueSApO1xuXHRcdHogPSBNYXRoLmFicyggYWlnLnogKTtcblxuXHRcdC8vIElmIHBvcnRyYWl0IG9yaWVudGF0aW9uIGFuZCBpbiBvbmUgb2YgdGhlIGRhbmdlciB6b25lc1xuXHRcdGlmICggIXdpbmRvdy5vcmllbnRhdGlvbiAmJiAoIHggPiA3IHx8ICggKCB6ID4gNiAmJiB5IDwgOCB8fCB6IDwgOCAmJiB5ID4gNiApICYmIHggPiA1ICkgKSApIHtcblx0XHRcdFx0aWYgKCB6b29tLmVuYWJsZWQgKSB7XG5cdFx0XHRcdFx0em9vbS5kaXNhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHR9XHRlbHNlIGlmICggIXpvb20uZW5hYmxlZCApIHtcblx0XHRcdFx0em9vbS5lbmFibGUoKTtcblx0XHR9XG5cdH1cblxuXHQkLm1vYmlsZS5kb2N1bWVudC5vbiggXCJtb2JpbGVpbml0XCIsIGZ1bmN0aW9uKCkge1xuXHRcdGlmICggJC5tb2JpbGUuaW9zb3JpZW50YXRpb25maXhFbmFibGVkICkge1xuXHRcdFx0JC5tb2JpbGUud2luZG93XG5cdFx0XHRcdC5iaW5kKCBcIm9yaWVudGF0aW9uY2hhbmdlLmlvc29yaWVudGF0aW9uZml4XCIsIHpvb20uZW5hYmxlIClcblx0XHRcdFx0LmJpbmQoIFwiZGV2aWNlbW90aW9uLmlvc29yaWVudGF0aW9uZml4XCIsIGNoZWNrVGlsdCApO1xuXHRcdH1cblx0fSk7XG5cbn0oIGpRdWVyeSwgdGhpcyApKTtcblxuKGZ1bmN0aW9uKCAkLCB3aW5kb3csIHVuZGVmaW5lZCApIHtcblx0dmFyXHQkaHRtbCA9ICQoIFwiaHRtbFwiICksXG5cdFx0JHdpbmRvdyA9ICQubW9iaWxlLndpbmRvdztcblxuXHQvL3JlbW92ZSBpbml0aWFsIGJ1aWxkIGNsYXNzIChvbmx5IHByZXNlbnQgb24gZmlyc3QgcGFnZXNob3cpXG5cdGZ1bmN0aW9uIGhpZGVSZW5kZXJpbmdDbGFzcygpIHtcblx0XHQkaHRtbC5yZW1vdmVDbGFzcyggXCJ1aS1tb2JpbGUtcmVuZGVyaW5nXCIgKTtcblx0fVxuXG5cdC8vIHRyaWdnZXIgbW9iaWxlaW5pdCBldmVudCAtIHVzZWZ1bCBob29rIGZvciBjb25maWd1cmluZyAkLm1vYmlsZSBzZXR0aW5ncyBiZWZvcmUgdGhleSdyZSB1c2VkXG5cdCQoIHdpbmRvdy5kb2N1bWVudCApLnRyaWdnZXIoIFwibW9iaWxlaW5pdFwiICk7XG5cblx0Ly8gc3VwcG9ydCBjb25kaXRpb25zXG5cdC8vIGlmIGRldmljZSBzdXBwb3J0IGNvbmRpdGlvbihzKSBhcmVuJ3QgbWV0LCBsZWF2ZSB0aGluZ3MgYXMgdGhleSBhcmUgLT4gYSBiYXNpYywgdXNhYmxlIGV4cGVyaWVuY2UsXG5cdC8vIG90aGVyd2lzZSwgcHJvY2VlZCB3aXRoIHRoZSBlbmhhbmNlbWVudHNcblx0aWYgKCAhJC5tb2JpbGUuZ3JhZGVBKCkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gb3ZlcnJpZGUgYWpheEVuYWJsZWQgb24gcGxhdGZvcm1zIHRoYXQgaGF2ZSBrbm93biBjb25mbGljdHMgd2l0aCBoYXNoIGhpc3RvcnkgdXBkYXRlc1xuXHQvLyBvciBnZW5lcmFsbHkgd29yayBiZXR0ZXIgYnJvd3NpbmcgaW4gcmVndWxhciBodHRwIGZvciBmdWxsIHBhZ2UgcmVmcmVzaGVzIChCQjUsIE9wZXJhIE1pbmkpXG5cdGlmICggJC5tb2JpbGUuYWpheEJsYWNrbGlzdCApIHtcblx0XHQkLm1vYmlsZS5hamF4RW5hYmxlZCA9IGZhbHNlO1xuXHR9XG5cblx0Ly8gQWRkIG1vYmlsZSwgaW5pdGlhbCBsb2FkIFwicmVuZGVyaW5nXCIgY2xhc3NlcyB0byBkb2NFbFxuXHQkaHRtbC5hZGRDbGFzcyggXCJ1aS1tb2JpbGUgdWktbW9iaWxlLXJlbmRlcmluZ1wiICk7XG5cblx0Ly8gVGhpcyBpcyBhIGZhbGxiYWNrLiBJZiBhbnl0aGluZyBnb2VzIHdyb25nIChKUyBlcnJvcnMsIGV0YyksIG9yIGV2ZW50cyBkb24ndCBmaXJlLFxuXHQvLyB0aGlzIGVuc3VyZXMgdGhlIHJlbmRlcmluZyBjbGFzcyBpcyByZW1vdmVkIGFmdGVyIDUgc2Vjb25kcywgc28gY29udGVudCBpcyB2aXNpYmxlIGFuZCBhY2Nlc3NpYmxlXG5cdHNldFRpbWVvdXQoIGhpZGVSZW5kZXJpbmdDbGFzcywgNTAwMCApO1xuXG5cdCQuZXh0ZW5kKCAkLm1vYmlsZSwge1xuXHRcdC8vIGZpbmQgYW5kIGVuaGFuY2UgdGhlIHBhZ2VzIGluIHRoZSBkb20gYW5kIHRyYW5zaXRpb24gdG8gdGhlIGZpcnN0IHBhZ2UuXG5cdFx0aW5pdGlhbGl6ZVBhZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gZmluZCBwcmVzZW50IHBhZ2VzXG5cdFx0XHR2YXIgcGF0aCA9ICQubW9iaWxlLnBhdGgsXG5cdFx0XHRcdCRwYWdlcyA9ICQoIFwiOmpxbURhdGEocm9sZT0ncGFnZScpLCA6anFtRGF0YShyb2xlPSdkaWFsb2cnKVwiICksXG5cdFx0XHRcdGhhc2ggPSBwYXRoLnN0cmlwSGFzaCggcGF0aC5zdHJpcFF1ZXJ5UGFyYW1zKHBhdGgucGFyc2VMb2NhdGlvbigpLmhhc2gpICksXG5cdFx0XHRcdHRoZUxvY2F0aW9uID0gJC5tb2JpbGUucGF0aC5wYXJzZUxvY2F0aW9uKCksXG5cdFx0XHRcdGhhc2hQYWdlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIGhhc2ggKTtcblxuXHRcdFx0Ly8gaWYgbm8gcGFnZXMgYXJlIGZvdW5kLCBjcmVhdGUgb25lIHdpdGggYm9keSdzIGlubmVyIGh0bWxcblx0XHRcdGlmICggISRwYWdlcy5sZW5ndGggKSB7XG5cdFx0XHRcdCRwYWdlcyA9ICQoIFwiYm9keVwiICkud3JhcElubmVyKCBcIjxkaXYgZGF0YS1cIiArICQubW9iaWxlLm5zICsgXCJyb2xlPSdwYWdlJz48L2Rpdj5cIiApLmNoaWxkcmVuKCAwICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGFkZCBkaWFsb2dzLCBzZXQgZGF0YS11cmwgYXR0cnNcblx0XHRcdCRwYWdlcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgJHRoaXMgPSAkKCB0aGlzICk7XG5cblx0XHRcdFx0Ly8gdW5sZXNzIHRoZSBkYXRhIHVybCBpcyBhbHJlYWR5IHNldCBzZXQgaXQgdG8gdGhlIHBhdGhuYW1lXG5cdFx0XHRcdGlmICggISR0aGlzWyAwIF0uZ2V0QXR0cmlidXRlKCBcImRhdGEtXCIgKyAkLm1vYmlsZS5ucyArIFwidXJsXCIgKSApIHtcblx0XHRcdFx0XHQkdGhpcy5hdHRyKCBcImRhdGEtXCIgKyAkLm1vYmlsZS5ucyArIFwidXJsXCIsICR0aGlzLmF0dHIoIFwiaWRcIiApIHx8XG5cdFx0XHRcdFx0XHR0aGVMb2NhdGlvbi5wYXRobmFtZSArIHRoZUxvY2F0aW9uLnNlYXJjaCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gZGVmaW5lIGZpcnN0IHBhZ2UgaW4gZG9tIGNhc2Ugb25lIGJhY2tzIG91dCB0byB0aGUgZGlyZWN0b3J5IHJvb3QgKG5vdCBhbHdheXMgdGhlIGZpcnN0IHBhZ2UgdmlzaXRlZCwgYnV0IGRlZmluZWQgYXMgZmFsbGJhY2spXG5cdFx0XHQkLm1vYmlsZS5maXJzdFBhZ2UgPSAkcGFnZXMuZmlyc3QoKTtcblxuXHRcdFx0Ly8gZGVmaW5lIHBhZ2UgY29udGFpbmVyXG5cdFx0XHQkLm1vYmlsZS5wYWdlQ29udGFpbmVyID0gJC5tb2JpbGUuZmlyc3RQYWdlXG5cdFx0XHRcdC5wYXJlbnQoKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktbW9iaWxlLXZpZXdwb3J0XCIgKVxuXHRcdFx0XHQucGFnZWNvbnRhaW5lcigpO1xuXG5cdFx0XHQvLyBpbml0aWFsaXplIG5hdmlnYXRpb24gZXZlbnRzIG5vdywgYWZ0ZXIgbW9iaWxlaW5pdCBoYXMgb2NjdXJyZWQgYW5kIHRoZSBwYWdlIGNvbnRhaW5lclxuXHRcdFx0Ly8gaGFzIGJlZW4gY3JlYXRlZCBidXQgYmVmb3JlIHRoZSByZXN0IG9mIHRoZSBsaWJyYXJ5IGlzIGFsZXJ0ZWQgdG8gdGhhdCBmYWN0XG5cdFx0XHQkLm1vYmlsZS5uYXZyZWFkeURlZmVycmVkLnJlc29sdmUoKTtcblxuXHRcdFx0Ly8gYWxlcnQgbGlzdGVuZXJzIHRoYXQgdGhlIHBhZ2Vjb250YWluZXIgaGFzIGJlZW4gZGV0ZXJtaW5lZCBmb3IgYmluZGluZ1xuXHRcdFx0Ly8gdG8gZXZlbnRzIHRyaWdnZXJlZCBvbiBpdFxuXHRcdFx0JHdpbmRvdy50cmlnZ2VyKCBcInBhZ2Vjb250YWluZXJjcmVhdGVcIiApO1xuXG5cdFx0XHQvLyBjdWUgcGFnZSBsb2FkaW5nIG1lc3NhZ2Vcblx0XHRcdCQubW9iaWxlLmxvYWRpbmcoIFwic2hvd1wiICk7XG5cblx0XHRcdC8vcmVtb3ZlIGluaXRpYWwgYnVpbGQgY2xhc3MgKG9ubHkgcHJlc2VudCBvbiBmaXJzdCBwYWdlc2hvdylcblx0XHRcdGhpZGVSZW5kZXJpbmdDbGFzcygpO1xuXG5cdFx0XHQvLyBpZiBoYXNoY2hhbmdlIGxpc3RlbmluZyBpcyBkaXNhYmxlZCwgdGhlcmUncyBubyBoYXNoIGRlZXBsaW5rLFxuXHRcdFx0Ly8gdGhlIGhhc2ggaXMgbm90IHZhbGlkIChjb250YWlucyBtb3JlIHRoYW4gb25lICMgb3IgZG9lcyBub3Qgc3RhcnQgd2l0aCAjKVxuXHRcdFx0Ly8gb3IgdGhlcmUgaXMgbm8gcGFnZSB3aXRoIHRoYXQgaGFzaCwgY2hhbmdlIHRvIHRoZSBmaXJzdCBwYWdlIGluIHRoZSBET01cblx0XHRcdC8vIFJlbWVtYmVyLCBob3dldmVyLCB0aGF0IHRoZSBoYXNoIGNhbiBhbHNvIGJlIGEgcGF0aCFcblx0XHRcdGlmICggISAoICQubW9iaWxlLmhhc2hMaXN0ZW5pbmdFbmFibGVkICYmXG5cdFx0XHRcdCQubW9iaWxlLnBhdGguaXNIYXNoVmFsaWQoIGxvY2F0aW9uLmhhc2ggKSAmJlxuXHRcdFx0XHQoICQoIGhhc2hQYWdlICkuaXMoIFwiOmpxbURhdGEocm9sZT0ncGFnZScpXCIgKSB8fFxuXHRcdFx0XHRcdCQubW9iaWxlLnBhdGguaXNQYXRoKCBoYXNoICkgfHxcblx0XHRcdFx0XHRoYXNoID09PSAkLm1vYmlsZS5kaWFsb2dIYXNoS2V5ICkgKSApIHtcblxuXHRcdFx0XHQvLyBTdG9yZSB0aGUgaW5pdGlhbCBkZXN0aW5hdGlvblxuXHRcdFx0XHRpZiAoICQubW9iaWxlLnBhdGguaXNIYXNoVmFsaWQoIGxvY2F0aW9uLmhhc2ggKSApIHtcblx0XHRcdFx0XHQkLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5LmluaXRpYWxEc3QgPSBoYXNoLnJlcGxhY2UoIFwiI1wiLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBtYWtlIHN1cmUgdG8gc2V0IGluaXRpYWwgcG9wc3RhdGUgc3RhdGUgaWYgaXQgZXhpc3RzXG5cdFx0XHRcdC8vIHNvIHRoYXQgbmF2aWdhdGlvbiBiYWNrIHRvIHRoZSBpbml0aWFsIHBhZ2Ugd29ya3MgcHJvcGVybHlcblx0XHRcdFx0aWYgKCAkLmV2ZW50LnNwZWNpYWwubmF2aWdhdGUuaXNQdXNoU3RhdGVFbmFibGVkKCkgKSB7XG5cdFx0XHRcdFx0JC5tb2JpbGUubmF2aWdhdGUubmF2aWdhdG9yLnNxdWFzaCggcGF0aC5wYXJzZUxvY2F0aW9uKCkuaHJlZiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0JC5tb2JpbGUuY2hhbmdlUGFnZSggJC5tb2JpbGUuZmlyc3RQYWdlLCB7XG5cdFx0XHRcdFx0dHJhbnNpdGlvbjogXCJub25lXCIsXG5cdFx0XHRcdFx0cmV2ZXJzZTogdHJ1ZSxcblx0XHRcdFx0XHRjaGFuZ2VIYXNoOiBmYWxzZSxcblx0XHRcdFx0XHRmcm9tSGFzaENoYW5nZTogdHJ1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHRyaWdnZXIgaGFzaGNoYW5nZSBvciBuYXZpZ2F0ZSB0byBzcXVhc2ggYW5kIHJlY29yZCB0aGUgY29ycmVjdFxuXHRcdFx0XHQvLyBoaXN0b3J5IGVudHJ5IGZvciBhbiBpbml0aWFsIGhhc2ggcGF0aFxuXHRcdFx0XHRpZiAoICEkLmV2ZW50LnNwZWNpYWwubmF2aWdhdGUuaXNQdXNoU3RhdGVFbmFibGVkKCkgKSB7XG5cdFx0XHRcdFx0JHdpbmRvdy50cmlnZ2VyKCBcImhhc2hjaGFuZ2VcIiwgW3RydWVdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gVE9ETyBmaWd1cmUgb3V0IGhvdyB0byBzaW1wbGlmeSB0aGlzIGludGVyYWN0aW9uIHdpdGggdGhlIGluaXRpYWwgaGlzdG9yeSBlbnRyeVxuXHRcdFx0XHRcdC8vIGF0IHRoZSBib3R0b20ganMvbmF2aWdhdGUvbmF2aWdhdGUuanNcblx0XHRcdFx0XHQkLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5LnN0YWNrID0gW107XG5cdFx0XHRcdFx0JC5tb2JpbGUubmF2aWdhdGUoICQubW9iaWxlLnBhdGguaXNQYXRoKCBsb2NhdGlvbi5oYXNoICkgPyBsb2NhdGlvbi5oYXNoIDogbG9jYXRpb24uaHJlZiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQkKGZ1bmN0aW9uKCkge1xuXHRcdC8vUnVuIGlubGluZVNWRyBzdXBwb3J0IHRlc3Rcblx0XHQkLnN1cHBvcnQuaW5saW5lU1ZHKCk7XG5cblx0XHQvLyBjaGVjayB3aGljaCBzY3JvbGxUb3AgdmFsdWUgc2hvdWxkIGJlIHVzZWQgYnkgc2Nyb2xsaW5nIHRvIDEgaW1tZWRpYXRlbHkgYXQgZG9tcmVhZHlcblx0XHQvLyB0aGVuIGNoZWNrIHdoYXQgdGhlIHNjcm9sbCB0b3AgaXMuIEFuZHJvaWQgd2lsbCByZXBvcnQgMC4uLiBvdGhlcnMgMVxuXHRcdC8vIG5vdGUgdGhhdCB0aGlzIGluaXRpYWwgc2Nyb2xsIHdvbid0IGhpZGUgdGhlIGFkZHJlc3MgYmFyLiBJdCdzIGp1c3QgZm9yIHRoZSBjaGVjay5cblxuXHRcdC8vIGhpZGUgaU9TIGJyb3dzZXIgY2hyb21lIG9uIGxvYWQgaWYgaGlkZVVybEJhciBpcyB0cnVlIHRoaXMgaXMgdG8gdHJ5IGFuZCBkbyBpdCBhcyBzb29uIGFzIHBvc3NpYmxlXG5cdFx0aWYgKCAkLm1vYmlsZS5oaWRlVXJsQmFyICkge1xuXHRcdFx0d2luZG93LnNjcm9sbFRvKCAwLCAxICk7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgZGVmYXVsdEhvbWVTY3JvbGwgaGFzbid0IGJlZW4gc2V0IHlldCwgc2VlIGlmIHNjcm9sbFRvcCBpcyAxXG5cdFx0Ly8gaXQgc2hvdWxkIGJlIDEgaW4gbW9zdCBicm93c2VycywgYnV0IGFuZHJvaWQgdHJlYXRzIDEgYXMgMCAoZm9yIGhpZGluZyBhZGRyIGJhcilcblx0XHQvLyBzbyBpZiBpdCdzIDEsIHVzZSAwIGZyb20gbm93IG9uXG5cdFx0JC5tb2JpbGUuZGVmYXVsdEhvbWVTY3JvbGwgPSAoICEkLnN1cHBvcnQuc2Nyb2xsVG9wIHx8ICQubW9iaWxlLndpbmRvdy5zY3JvbGxUb3AoKSA9PT0gMSApID8gMCA6IDE7XG5cblx0XHQvL2RvbS1yZWFkeSBpbml0c1xuXHRcdGlmICggJC5tb2JpbGUuYXV0b0luaXRpYWxpemVQYWdlICkge1xuXHRcdFx0JC5tb2JpbGUuaW5pdGlhbGl6ZVBhZ2UoKTtcblx0XHR9XG5cblx0XHQvLyB3aW5kb3cgbG9hZCBldmVudFxuXHRcdC8vIGhpZGUgaU9TIGJyb3dzZXIgY2hyb21lIG9uIGxvYWQgaWYgaGlkZVVybEJhciBpcyB0cnVlIHRoaXMgaXMgYXMgZmFsbCBiYWNrIGluY2FzZSB3ZSB3ZXJlIHRvbyBlYXJseSBiZWZvcmVcblx0XHRpZiAoICQubW9iaWxlLmhpZGVVcmxCYXIgKSB7XG5cdFx0XHQkd2luZG93LmxvYWQoICQubW9iaWxlLnNpbGVudFNjcm9sbCApO1xuXHRcdH1cblxuXHRcdGlmICggISQuc3VwcG9ydC5jc3NQb2ludGVyRXZlbnRzICkge1xuXHRcdFx0Ly8gSUUgYW5kIE9wZXJhIGRvbid0IHN1cHBvcnQgQ1NTIHBvaW50ZXItZXZlbnRzOiBub25lIHRoYXQgd2UgdXNlIHRvIGRpc2FibGUgbGluay1iYXNlZCBidXR0b25zXG5cdFx0XHQvLyBieSBhZGRpbmcgdGhlICd1aS1kaXNhYmxlZCcgY2xhc3MgdG8gdGhlbS4gVXNpbmcgYSBKYXZhU2NyaXB0IHdvcmthcm91bmQgZm9yIHRob3NlIGJyb3dzZXIuXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS1tb2JpbGUvaXNzdWVzLzM1NThcblxuXHRcdFx0Ly8gREVQUkVDQVRFRCBhcyBvZiAxLjQuMCAtIHJlbW92ZSB1aS1kaXNhYmxlZCBhZnRlciAxLjQuMCByZWxlYXNlXG5cdFx0XHQvLyBvbmx5IHVpLXN0YXRlLWRpc2FibGVkIHNob3VsZCBiZSBwcmVzZW50IHRoZXJlYWZ0ZXJcblx0XHRcdCQubW9iaWxlLmRvY3VtZW50LmRlbGVnYXRlKCBcIi51aS1zdGF0ZS1kaXNhYmxlZCwudWktZGlzYWJsZWRcIiwgXCJ2Y2xpY2tcIixcblx0XHRcdFx0ZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9KTtcbn0oIGpRdWVyeSwgdGhpcyApKTtcblxuXG59KSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0U3BvdGlmeVNlbGVjdE9wdGlvbnM6IGZ1bmN0aW9uICh0aXRsZSwgYXJ0aXN0LCBwcmVsb2FkX2lkLCBjYikge1xuICAgIHZhciBzZWFyY2hVUkwgPSAnaHR0cDovL3dzLnNwb3RpZnkuY29tL3NlYXJjaC8xL3RyYWNrLmpzb24/cT0nICsgdGl0bGUgKyAnKycrIGFydGlzdDtcbiAgICBqUXVlcnkuZ2V0KHNlYXJjaFVSTCwgZnVuY3Rpb24gKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9ICcnO1xuICAgICAgdmFyIHNvbmdJZFRhYmxlID0ge307XG4gICAgICBmb3IgKHZhciBpPTA7IGkgPCBNYXRoLm1pbig1LCBkYXRhLnRyYWNrcy5sZW5ndGgpOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGEudHJhY2tzW2ldWydleHRlcm5hbC1pZHMnXSAmJiBkYXRhLnRyYWNrc1tpXVsnZXh0ZXJuYWwtaWRzJ11bMF0pIHtcbiAgICAgICAgICB2YXIgaWQgPSBkYXRhLnRyYWNrc1tpXVsnZXh0ZXJuYWwtaWRzJ11bMF0uaWQ7XG4gICAgICAgICAgaWYgKCEgc29uZ0lkVGFibGVbaWRdKSB7XG4gICAgICAgICAgICBzb25nSWRUYWJsZVtpZF0gPSB0cnVlO1xuICAgICAgICAgICAgb3B0aW9ucyArPSAnPG9wdGlvbiB2YWx1ZT1cIicrZGF0YS50cmFja3NbaV0uaHJlZisnXCI+JytkYXRhLnRyYWNrc1tpXS5uYW1lICsnICgnICtkYXRhLnRyYWNrc1tpXS5hcnRpc3RzWzBdLm5hbWUgKyAnKSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcHRpb25zICs9ICc8b3B0aW9uIHZhbHVlPVwiXCI+KE5vbmUgb2YgdGhlIGFib3ZlKSc7XG4gICAgICBjYihvcHRpb25zKVxuICAgIH0sICdqc29uJyApXG4gIH1cbn0iLCIkID0gcmVxdWlyZSgnanF1ZXJ5JylcbiQubW9iaWxlID0gcmVxdWlyZSgnanF1ZXJ5LW1vYmlsZScpXG5cbiQoZG9jdW1lbnQpLmRlbGVnYXRlIFwiI2FkbWluLWdyb3Vwc1wiLCBcInBhZ2Vpbml0XCIsIC0+XG4gICQoJy5hZG1pbi1ncm91cHMtZGVsZXRlLWxpbmsnKS5vbiAnY2xpY2snLCAoZSkgLT5cbiAgICAkKCcjYWRtaW4tZ3JvdXBzLWRlbGV0ZS1mb3JtJykuYXR0cignYWN0aW9uJywgJy9hZG1pbi9ncm91cHMvJyArICQodGhpcykuYXR0cignZGF0YS1pZCcpKVxuICAgIHBvcHVwID0gJChlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoJ1tkYXRhLXJvbGU9cG9wdXBdJylcbiAgICBwb3B1cC5vbiAncG9wdXBhZnRlcmNsb3NlJywgLT5cbiAgICAgIHNldFRpbWVvdXQgLT5cbiAgICAgICAgJCgkKGUuY3VycmVudFRhcmdldCkuYXR0cignaHJlZicpKS5wb3B1cCgnb3BlbicpXG4gICAgICAgIHBvcHVwLm9mZiAncG9wdXBhZnRlcmNsb3NlJ1xuICAgICAgLCAxMDBcbiAgICBwb3B1cC5wb3B1cCgnY2xvc2UnKSIsIiQgPSByZXF1aXJlKCdqcXVlcnknKVxuJC5tb2JpbGUgPSByZXF1aXJlKCdqcXVlcnktbW9iaWxlJylcblxuJChkb2N1bWVudCkuZGVsZWdhdGUgXCIjYWRtaW4tdXNlcnNcIiwgXCJwYWdlaW5pdFwiLCAtPlxuICAkKCcuYWRtaW4tdXNlcnMtZGVsZXRlLWxpbmsnKS5vbiAnY2xpY2snLCAoZSkgLT5cbiAgICAkKCcjYWRtaW4tdXNlcnMtZGVsZXRlLWZvcm0nKS5hdHRyKCdhY3Rpb24nLCAnL2FkbWluL3VzZXJzLycgKyAkKHRoaXMpLmF0dHIoJ2RhdGEtaWQnKSlcbiAgICBwb3B1cCA9ICQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KCdbZGF0YS1yb2xlPXBvcHVwXScpXG4gICAgcG9wdXAub24gJ3BvcHVwYWZ0ZXJjbG9zZScsIC0+XG4gICAgICBzZXRUaW1lb3V0IC0+XG4gICAgICAgICQoJChlLmN1cnJlbnRUYXJnZXQpLmF0dHIoJ2hyZWYnKSkucG9wdXAoJ29wZW4nKVxuICAgICAgICBwb3B1cC5vZmYgJ3BvcHVwYWZ0ZXJjbG9zZSdcbiAgICAgICwgMTAwXG4gICAgcG9wdXAucG9wdXAoJ2Nsb3NlJykiLCIkID0gcmVxdWlyZSgnanF1ZXJ5JylcbiQubW9iaWxlID0gcmVxdWlyZSgnanF1ZXJ5LW1vYmlsZScpXG5cbiQoZG9jdW1lbnQpLmRlbGVnYXRlIFwiI2dyb3Vwcy1lZGl0XCIsIFwicGFnZWluaXRcIiwgLT5cbiAgJChcIiNncm91cHMtbmV3LW1lbWJlci1jaG9pY2VzXCIpLm9uIFwiZmlsdGVyYWJsZWJlZm9yZWZpbHRlclwiLCAoZSwgZGF0YSktPlxuICAgICR1bCA9ICQodGhpcylcbiAgICAkaW5wdXQgPSAkKGRhdGEuaW5wdXQpXG4gICAgdmFsdWUgPSAkaW5wdXQudmFsKClcbiAgICBodG1sID0gJydcbiAgICAkdWwuaHRtbCAnJ1xuICAgIGlmIHZhbHVlPy5sZW5ndGggPiAxICMgYXQgbGVhc3QgdHdvIGNoYXJhY3RlclxuICAgICAgJHVsLmh0bWwgJzxsaT48ZGl2IGNsYXNzPVwidWktbG9hZGVyXCI+PHNwYW4gY2xhc3M9XCJ1aS1pY29uIHVpLWljb24tbG9hZGluZ1wiPjwvc3Bhbj48L2Rpdj4nXG4gICAgICAkdWwubGlzdHZpZXcgJ3JlZnJlc2gnXG4gICAgICAkLmFqYXhcbiAgICAgICAgdXJsOiBcIi9zZWFyY2gvdXNlcnMvI3t2YWx1ZX1cIlxuICAgICAgICBkYXRhVHlwZTogXCJqc29uXCJcbiAgICAgIC50aGVuIChyZXNwb25zZSktPlxuICAgICAgICAkLmVhY2ggcmVzcG9uc2UsIChpLCB2YWwpLT5cbiAgICAgICAgICBpZiAkKFwiI2dyb3Vwcy1uZXctbWVtYmVycyBsaVtkYXRhLWlkPSN7dmFsLmlkfV1cIikubGVuZ3RoIGlzIDBcbiAgICAgICAgICAgIGh0bWwgKz0gXCI8bGk+PGEgaHJlZj1cXFwiI1xcXCIgZGF0YS1pZD1cXFwiI3t2YWwuaWR9XFxcIj4je3ZhbC5maXJzdF9uYW1lfSAje3ZhbC5sYXN0X25hbWV9PC9hPlwiXG4gICAgICAgICR1bC5odG1sIGh0bWxcbiAgICAgICAgJHVsLmxpc3R2aWV3IFwicmVmcmVzaFwiXG4gICAgICAgICR1bC50cmlnZ2VyIFwidXBkYXRlbGF5b3V0XCJcblxuICAkKGRvY3VtZW50KS5vbiAnY2xpY2snLCAnI2dyb3Vwcy1uZXctbWVtYmVyLWNob2ljZXMgYVtkYXRhLWlkXScsIChlKS0+XG4gICAgJHRoaXMgPSAkKHRoaXMpXG4gICAgaWYgJCgnI2dyb3Vwcy1uZXctbWVtYmVycyBsaVtkYXRhLWlkPScgKyAkdGhpcy5hdHRyKCdkYXRhLWlkJykgKyAnXScpLmxlbmd0aCBpcyAwXG4gICAgICAkKCcjZ3JvdXBzLW5ldy1tZW1iZXJzJykuYXBwZW5kKFwiPGxpIGRhdGEtaWQ9XFxcIiN7JHRoaXMuYXR0cignZGF0YS1pZCcpfVxcXCI+PGEgaHJlZj1cXFwiI1xcXCI+I3skdGhpcy50ZXh0KCl9PC9hPjxhIGRhdGEtdGhlbWU9XFxcImJcXFwiIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJyZW1vdmUtbWVtYmVyXFxcIj5SZW1vdmUgTWVtYmVyPC9hPjxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIG5hbWU9XFxcIm1lbWJlcnNbXVxcXCIgdmFsdWU9XFxcIiN7JHRoaXMuYXR0cignZGF0YS1pZCcpfVxcXCI+XCIpXG4gICAgICAubGlzdHZpZXcoJ3JlZnJlc2gnKVxuICAgICAgJCgnI2dyb3Vwcy1uZXctbWVtYmVyLWNob2ljZXMtYm94IC51aS1pbnB1dC1jbGVhcicpLmNsaWNrKClcbiAgICAgICQoJyNncm91cHMtbmV3LW1lbWJlci1jaG9pY2VzJykuaHRtbCAnJ1xuXG4gICQoZG9jdW1lbnQpLm9uICdjbGljaycsICcucmVtb3ZlLW1lbWJlcicsIChlKS0+XG4gICAgJCh0aGlzKS5jbG9zZXN0KCdsaScpLnJlbW92ZSgpXG4iLCIkID0gcmVxdWlyZSgnanF1ZXJ5JylcbiQubW9iaWxlID0gcmVxdWlyZSgnanF1ZXJ5LW1vYmlsZScpXG5cbiQoZG9jdW1lbnQpLmRlbGVnYXRlIFwiI2dyb3Vwcy12aWV3XCIsIFwicGFnZWluaXRcIiwgLT5cbiAgJCgnLmdyb3Vwcy1kZWxldGUtbGluaycpLm9uICdjbGljaycsIChlKSAtPlxuICAgICQoJyNncm91cC1kZWxldGUtZm9ybScpLmF0dHIoJ2FjdGlvbicsICcvZ3JvdXBzLycgKyAkKHRoaXMpLmF0dHIoJ2RhdGEtdXJsJykpIiwiJCA9IHJlcXVpcmUoJ2pxdWVyeScpXG4kLm1vYmlsZSA9IHJlcXVpcmUoJ2pxdWVyeS1tb2JpbGUnKVxuXG4jJChkb2N1bWVudCkuZGVsZWdhdGUgXCIjaW5kZXhcIiwgXCJwYWdlaW5pdFwiLCAtPlxuICAjYWxlcnQgJ1BhZ2UgSU5ERVggT1BFTkVEISdcblxuJChkb2N1bWVudCkuZGVsZWdhdGUgXCIjaW5kZXhcIiwgXCJwYWdlaGlkZVwiLCAtPlxuXHQjIFJlbW92ZSBsb2dpbiBwYWdlIHRvIHByb3RlY3QgcGFzc3dvcmRcblx0JCh0aGlzKS5yZW1vdmUoKSIsIiQgPSByZXF1aXJlKCdqcXVlcnknKVxuJC5tb2JpbGUgPSByZXF1aXJlKCdqcXVlcnktbW9iaWxlJylcblxuJChkb2N1bWVudCkuZGVsZWdhdGUgXCIjcmVnaXN0ZXIsICN1c2Vycy1wYXNzd29yZFwiLCBcInBhZ2Vpbml0XCIsIC0+XG4gICRwYWdlID0gJCh0aGlzKVxuICAkcGFnZS5vbiAnY2hhbmdlJywgJyNwYXNzd29yZCwgI3Bhc3N3b3JkLWNvbmZpcm0nLCAoZSkgLT5cbiAgICBwYXNzd29yZCA9ICRwYWdlLmZpbmQoJyNwYXNzd29yZCcpLnZhbCgpXG4gICAgcGFzc3dvcmRfY29uZmlybSA9ICRwYWdlLmZpbmQoJyNwYXNzd29yZC1jb25maXJtJykudmFsKClcbiAgICAkYnRuID0gJHBhZ2UuZmluZCgnI3N1Ym1pdC1mb3JtJylcbiAgICBpZiBwYXNzd29yZCBpc250IFwiXCIgYW5kIHBhc3N3b3JkX2NvbmZpcm0gaXNudCBcIlwiXG4gICAgICBpZiBwYXNzd29yZCBpcyBwYXNzd29yZF9jb25maXJtXG4gICAgICAgICRidG4udmFsKCRidG4uYXR0cignZGF0YS12YWxpZC1sYWJlbCcpKVxuICAgICAgICAgIC5idXR0b24oJ3JlZnJlc2gnKVxuICAgICAgICAgIC5idXR0b24oJ2VuYWJsZScsJ3JlZnJlc2gnKVxuICAgICAgZWxzZVxuICAgICAgICAkYnRuLnZhbChcIldoeSB1IHNvIGxpa2UgZGF0IG9uZT8gUGFzc3dvcmRzIGRvbid0IG1hdGNoIGxhaFwiKVxuICAgICAgICAgIC5idXR0b24oJ3JlZnJlc2gnKVxuICAgICAgICAgIC5idXR0b24oJ2Rpc2FibGUnLCdyZWZyZXNoJylcblxuJChkb2N1bWVudCkuZGVsZWdhdGUgXCIjcmVnaXN0ZXIsICN1c2Vycy1wYXNzd29yZFwiLCBcInBhZ2VoaWRlXCIsIC0+XG4gICQodGhpcykucmVtb3ZlKCkiLCIkID0gcmVxdWlyZSgnanF1ZXJ5JylcbiQubW9iaWxlID0gcmVxdWlyZSgnanF1ZXJ5LW1vYmlsZScpXG5cbiQoZG9jdW1lbnQpLmRlbGVnYXRlIFwiI3NldGxpc3RzLWVkaXRcIiwgXCJwYWdlaW5pdFwiLCAtPlxuICBrZXlUZXh0cyA9IFtcIkNcIiwgXCJE4pmtXCIsIFwiRFwiLCBcIkXima1cIiwgXCJFXCIsIFwiRlwiLCBcIkbima9cIiwgXCJHXCIsIFwiQeKZrVwiLCBcIkFcIiwgXCJC4pmtXCIsIFwiQlwiXVxuXG4gIG5leHRJbmRleCA9ICQoJyNzZXRsaXN0cy1uZXctc29uZ3MgbGlbZGF0YS1pZF0nKS5sZW5ndGhcblxuICBjaGVja1NldGxpc3RMZW5ndGggPSAoKSAtPlxuICAgIHNvbmdzID0gW11cbiAgICAkKFwiI3NldGxpc3RzLW5ldy1zb25ncyBbZGF0YS1pZF1cIikuZWFjaCAoaSxzb25nKSAtPlxuICAgICAgc29uZ3MucHVzaCAkKHNvbmcpLmF0dHIoXCJkYXRhLWlkXCIpXG4gICAgJC5nZXRKU09OIFwiL3NldGxpc3RzL2xlbmd0aFwiLCB7IHNvbmdzOiBzb25ncyB9LCAoZGF0YSkgLT5cbiAgICAgIGlmIGRhdGEuZXJyb3IgaXMgXCJcIlxuICAgICAgICAkKFwiI3NldGxpc3RzLXdhcm5pbmctcGFnZXMtY291bnRcIikudGV4dCBkYXRhLnBhZ2VzXG4gICAgICAgICQoXCIjc2V0bGlzdHMtd2FybmluZy1wYWdlc1wiKS50b2dnbGVDbGFzcyBcImhpZGRlblwiLCBkYXRhLnBhZ2VzIDwgMlxuXG4gIGNoZWNrU2V0bGlzdExlbmd0aCgpXG4gIFxuICAkKFwiI3NldGxpc3RzLW5ldy1zb25nLWNob2ljZXNcIikub24gXCJmaWx0ZXJhYmxlYmVmb3JlZmlsdGVyXCIsIChlLCBkYXRhKSAtPlxuICAgICR1bCA9ICQoIHRoaXMgKVxuICAgICRpbnB1dCA9ICQoIGRhdGEuaW5wdXQgKVxuICAgIHZhbHVlID0gJGlucHV0LnZhbCgpXG4gICAgaHRtbCA9IFwiXCJcbiAgICAkdWwuaHRtbCggXCJcIiApXG4gICAgaWYgdmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gMlxuICAgICAgJHVsLmh0bWwoIFwiPGxpPjxkaXYgY2xhc3M9J3VpLWxvYWRlcic+PHNwYW4gY2xhc3M9J3VpLWljb24gdWktaWNvbi1sb2FkaW5nJz48L3NwYW4+PC9kaXY+PC9saT5cIiApXG4gICAgICAkdWwubGlzdHZpZXcoIFwicmVmcmVzaFwiIClcbiAgICAgICQuYWpheFxuICAgICAgICB1cmw6IFwiL3NlYXJjaC9zb25nX3RpdGxlcy9cIiArICRpbnB1dC52YWwoKVxuICAgICAgICBkYXRhVHlwZTogXCJqc29uXCJcbiAgICAgIC50aGVuIChyZXNwb25zZSkgLT5cbiAgICAgICAgJC5lYWNoIHJlc3BvbnNlLCAoaSwgdmFsKSAtPlxuICAgICAgICAgIGlmICQoXCIjc2V0bGlzdHMtbmV3LXNvbmdzIGxpW2RhdGEtaWQ9I3t2YWwuaWR9XVwiKS5sZW5ndGggaXMgMFxuICAgICAgICAgICAgaHRtbCArPSBcIlwiXCI8bGkgZGF0YS1pY29uPVwiZmFsc2VcIj5cbiAgICAgICAgICAgICAgPGEgaHJlZj1cIiNcIiBjbGFzcz1cInNvbmctbGFiZWwgI3tpZiB2YWwuYXJ0aXN0IGlzIFwiXCIgdGhlbiBcInNvbmctbm8tYXJ0aXN0XCIgZWxzZSBcIlwifSBcIiBkYXRhLWFydGlzdD1cIiN7dmFsLmFydGlzdH1cIiBkYXRhLWlkPVwiI3t2YWwuaWR9XCIgZGF0YS1rZXk9XCIje3ZhbC5rZXl9XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNvbmctbGFiZWwta2V5XCIgZGF0YS1jaG9yZD1cIiN7dmFsLmtleX1cIj4je2tleVRleHRzWyt2YWwua2V5XX08L2Rpdj5cbiAgICAgICAgICAgICAgICA8aDIgY2xhc3M9XCJsaXN0dmlldy1oZWFkaW5nXCI+I3t2YWwudGl0bGV9PC9oMj5cbiAgICAgICAgICAgICAgICAje2lmIHZhbC5hcnRpc3QgaXNudCBcIlwiIHRoZW4gXCI8c3BhbiBjbGFzcz1cXFwibGlzdHZpZXctZm9vdGVyXFxcIj4je3ZhbC5hcnRpc3R9PC9zcGFuPlwiIGVsc2UgXCJcIn1cbiAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPC9saT5cIlwiXCJcbiAgICAgICAgJHVsLmh0bWwoaHRtbClcbiAgICAgICAgJHVsLmxpc3R2aWV3KFwicmVmcmVzaFwiKVxuICAgICAgICAkdWwudHJpZ2dlcihcInVwZGF0ZWxheW91dFwiKVxuXG4gICQoZG9jdW1lbnQpLm9uICdjbGljaycsICcjc2V0bGlzdHMtbmV3LXNvbmctY2hvaWNlcyBhW2RhdGEtaWRdJywgKGUpIC0+XG4gICAgJHRoaXMgPSAkIEBcbiAgICBzb25nSWQgPSAkdGhpcy5hdHRyKCdkYXRhLWlkJylcbiAgICBzb25nVGl0bGUgPSAkdGhpcy5maW5kKCdoMicpLnRleHQoKVxuICAgIHNvbmdBcnRpc3QgPSAkdGhpcy5hdHRyKCdkYXRhLWFydGlzdCcpXG4gICAgc29uZ0tleSA9ICR0aGlzLmF0dHIoJ2RhdGEta2V5Jykgb3IgMFxuICAgICQoJyNzZXRsaXN0cy1zb25nLWNob3Nlbi1ieS1wb3B1cCcpLnBvcHVwKCdvcGVuJylcbiAgICAkKCcjc2V0bGlzdHMtc29uZy1jaG9zZW4tYnktcG9wdXAnKS5hdHRyKCdkYXRhLWlkJywgc29uZ0lkKVxuICAgICQoJyNzZXRsaXN0cy1zb25nLWNob3Nlbi1ieS1wb3B1cCcpLmF0dHIoJ2RhdGEtdGl0bGUnLCBzb25nVGl0bGUpXG4gICAgJCgnI3NldGxpc3RzLXNvbmctY2hvc2VuLWJ5LXBvcHVwJykuYXR0cignZGF0YS1hcnRpc3QnLCBzb25nQXJ0aXN0KVxuICAgICQoJyNzZXRsaXN0cy1zb25nLWNob3Nlbi1ieS1wb3B1cCBoMicpLnRleHQoc29uZ1RpdGxlKVxuICAgICQoJyNzZXRsaXN0cy1zb25ncy1rZXknKS52YWwoc29uZ0tleSlcbiAgICAkKCcjc2V0bGlzdHMtc29uZ3Mta2V5Jykuc2VsZWN0bWVudSgncmVmcmVzaCcpXG5cbiAgJChkb2N1bWVudCkub24gJ2NsaWNrJywgJyNzZXRsaXN0LWNob3Nlbi1ieS1zdWJtaXQnLCAoZSkgLT5cbiAgICAkY2hvc2VuU29uZyA9ICQoJyNzZXRsaXN0cy1zb25nLWNob3Nlbi1ieS1wb3B1cCcpXG5cbiAgICBpZiAkKCcjc2V0bGlzdHMtbmV3LXNvbmdzIGxpW2RhdGEtaWQ9JyArIHNvbmdJRCArICddJykubGVuZ3RoIGlzIDBcbiAgICAgICQoJyNzZXRsaXN0cy1uZXctc29uZ3MtZW1wdHknKS5hZGRDbGFzcygnaGlkZGVuJylcbiAgICAgIFxuICAgICAgc29uZ0lEID0gJGNob3NlblNvbmcuYXR0cignZGF0YS1pZCcpXG4gICAgICB0aXRsZSA9ICRjaG9zZW5Tb25nLmF0dHIoJ2RhdGEtdGl0bGUnKVxuICAgICAgYXJ0aXN0ID0gJGNob3NlblNvbmcuYXR0cignZGF0YS1hcnRpc3QnKVxuICAgICAgY2hvc2VuQnkgPSAkKCcjc2V0bGlzdHMtc29uZy1jaG9zZW4tYnktc2VsZWN0JykudmFsKClcbiAgICAgIHNldGxpc3RLZXkgPSArJCgnI3NldGxpc3RzLXNvbmdzLWtleScpLnZhbCgpXG4gICAgICBzZXRsaXN0S2V5VGV4dCA9IGtleVRleHRzW3NldGxpc3RLZXldXG4gICAgICBcbiAgICAgICQoJyNzZXRsaXN0cy1uZXctc29uZ3MnKS5hcHBlbmQgXCJcIlwiXG4gICAgICAgIDxsaSBkYXRhLWlkPVwiI3tzb25nSUR9XCIgY2xhc3M9XCJzZXRsaXN0LXZpZXctc29uZ1wiPlxuICAgICAgICAgIDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJzb25nLWxhYmVsICN7aWYgYXJ0aXN0IGlzIFwiXCIgdGhlbiBcInNvbmctbm8tYXJ0aXN0XCIgZWxzZSBcIlwifSBcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzb25nLWxhYmVsLWtleVwiIGRhdGEtY2hvcmQ9XCIje3NldGxpc3RLZXl9XCI+I3tzZXRsaXN0S2V5VGV4dH08L2Rpdj5cbiAgICAgICAgICAgIDxoMiBjbGFzcz1cImxpc3R2aWV3LWhlYWRpbmdcIj4je3RpdGxlfTwvaDI+XG4gICAgICAgICAgICAje2lmIGFydGlzdCBpc250IFwiXCIgdGhlbiBcIjxzcGFuIGNsYXNzPVxcXCJsaXN0dmlldy1mb290ZXJcXFwiPiN7YXJ0aXN0fTwvc3Bhbj5cIiBlbHNlIFwiXCJ9XG4gICAgICAgICAgPC9hPlxuICAgICAgICAgIDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJyZW1vdmUtc29uZ1wiPlJlbW92ZSBTb25nPC9hPlxuICAgICAgICAgIDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cInNvbmdzWyN7bmV4dEluZGV4fV1baWRdXCIgdmFsdWU9XCIje3NvbmdJRH1cIj5cbiAgICAgICAgICA8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9XCJzb25nc1sje25leHRJbmRleH1dW2Nob3Nlbl9ieV1cIiB2YWx1ZT1cIiN7Y2hvc2VuQnl9XCI+XG4gICAgICAgICAgPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPVwic29uZ3NbI3tuZXh0SW5kZXh9XVtrZXldXCIgdmFsdWU9XCIje3NldGxpc3RLZXl9XCI+XG4gICAgICAgIDwvbGk+XCJcIlwiXG5cbiAgICAgICQoJyNzZXRsaXN0cy1uZXctc29uZ3MnKS5saXN0dmlldygncmVmcmVzaCcpXG4gICAgICAkKCcjc2V0bGlzdHMtbmV3LXNvbmctY2hvaWNlcy1ib3ggLnVpLWlucHV0LWNsZWFyJykuY2xpY2soKVxuICAgICAgJCgnI3NldGxpc3RzLW5ldy1zb25nLWNob2ljZXMnKS5odG1sKCcnKVxuICAgICAgJGNob3NlblNvbmcucG9wdXAoJ2Nsb3NlJylcbiAgICAgIG5leHRJbmRleCsrXG5cbiAgICBjaGVja1NldGxpc3RMZW5ndGgoKVxuXG4gICQoZG9jdW1lbnQpLm9uICdjbGljaycsICcucmVtb3ZlLXNvbmcnLCAoZSkgLT5cbiAgICAkKHRoaXMpLmNsb3Nlc3QoJ2xpJykucmVtb3ZlKClcbiAgICBpZiAkKCcjc2V0bGlzdHMtbmV3LXNvbmdzIGxpW2RhdGEtaWRdJykubGVuZ3RoIGlzIDBcbiAgICAgICQoJyNzZXRsaXN0cy1uZXctc29uZ3MtZW1wdHknKS5yZW1vdmVDbGFzcygnaGlkZGVuJylcbiAgICAkKCcjc2V0bGlzdHMtbmV3LXNvbmdzJykubGlzdHZpZXcoJ3JlZnJlc2gnKVxuICAgIGNoZWNrU2V0bGlzdExlbmd0aCgpXG5cbiAgc3VibWl0VGV4dCA9ICQoJyNzZXRsaXN0LXN1Ym1pdCcpLmF0dHIoJ3ZhbHVlJykgXG4gICQoZG9jdW1lbnQpLm9uICdpbnB1dCcsICcjc2V0bGlzdC10aXRsZScsIChlKSAtPlxuICAgIGlmICQoJyNzZXRsaXN0LXRpdGxlJykudmFsKCkgaXMgJydcbiAgICAgICQoJyNzZXRsaXN0LXN1Ym1pdCcpLnZhbCgnV2FsYXUtZWghIE5lZWQgYSBTZXRsaXN0IG5hbWUnKS5idXR0b24oJ3JlZnJlc2gnKVxuICAgICAgJCgnI3NldGxpc3Qtc3VibWl0JykuYnV0dG9uKCdkaXNhYmxlJywncmVmcmVzaCcpXG4gICAgZWxzZSBcbiAgICAgICQoJyNzZXRsaXN0LXN1Ym1pdCcpLmJ1dHRvbignZW5hYmxlJywncmVmcmVzaCcpXG4gICAgICAkKCcjc2V0bGlzdC1zdWJtaXQnKS52YWwoc3VibWl0VGV4dCkuYnV0dG9uKCdyZWZyZXNoJykiLCIkID0gcmVxdWlyZSgnanF1ZXJ5JylcbiQubW9iaWxlID0gcmVxdWlyZSgnanF1ZXJ5LW1vYmlsZScpXG5cbiQoZG9jdW1lbnQpLmRlbGVnYXRlIFwiI3NldGxpc3RzLXNldHRpbmdzXCIsIFwicGFnZWluaXRcIiwgLT5cbiAgJHBhZ2UgPSAkKHRoaXMpXG4gICR1c2VHcm91cCA9ICRwYWdlLmZpbmQgJyNzZXRsaXN0LXVzZS1ncm91cCdcbiAgc2V0dGluZ3MgPSBKU09OLnBhcnNlICRwYWdlLmZpbmQoJyNzZXRsaXN0LXNldHRpbmdzLXRhcmdldCAuc2V0dGluZ3MtdGhpcycpLmF0dHIoJ2RhdGEtc2V0dGluZ3MnKVxuICBncm91cFNldHRpbmdzID0gSlNPTi5wYXJzZSAkcGFnZS5maW5kKCcjc2V0bGlzdC1zZXR0aW5ncy10YXJnZXQgLnNldHRpbmdzLWdyb3VwJykuYXR0cignZGF0YS1zZXR0aW5ncycpXG5cbiAgdXBkYXRlU2V0dGluZ3MgPSAoc2V0dGluZ3MpIC0+XG4gICAgZm9yIGtleSx2YWx1ZSBvZiBzZXR0aW5nc1xuICAgICAgJGVsID0gJHBhZ2UuZmluZCgnW25hbWU9XCJzZXR0aW5nc1xcXFxbJytrZXkrJ1xcXFxdXCJdJylcbiAgICAgIHNldHRpbmdzW2tleV0gPSAkZWwudmFsKClcbiAgICByZXR1cm4gc2V0dGluZ3NcblxuICBhcHBseVNldHRpbmdzID0gKHNldHRpbmdzKSAtPlxuICAgIGZvciBrZXksdmFsdWUgb2Ygc2V0dGluZ3NcbiAgICAgICRlbCA9ICRwYWdlLmZpbmQoJ1tuYW1lPVwic2V0dGluZ3NcXFxcWycra2V5KydcXFxcXVwiXScpXG4gICAgICAkZWwudmFsKHZhbHVlKVxuICAgICAgaWYgJGVsLmF0dHIoJ2RhdGEtcm9sZScpIGlzICdzbGlkZXInXG4gICAgICAgICRlbC5zbGlkZXIgXCJyZWZyZXNoXCJcbiAgICAgIGVsc2VcbiAgICAgICAgJGVsLnNlbGVjdG1lbnUgXCJyZWZyZXNoXCJcblxuICAkdXNlR3JvdXAuY2hhbmdlIC0+XG4gICAgJHNlY3Rpb24gPSAkcGFnZS5maW5kKCcjc2V0bGlzdC1zZXR0aW5ncy1zZWN0aW9uJylcbiAgICAkc2VjdGlvbi5mYWRlT3V0IDIwMCwgKCkgLT5cbiAgICAgIGlmICR1c2VHcm91cC52YWwoKSBpcyBcIjFcIlxuICAgICAgICBzZXR0aW5ncyA9IHVwZGF0ZVNldHRpbmdzIHNldHRpbmdzXG4gICAgICAgIGFwcGx5U2V0dGluZ3MgZ3JvdXBTZXR0aW5nc1xuICAgICAgICAkcGFnZS5maW5kKCcjc2V0bGlzdC1zZXR0aW5ncy10YXJnZXQgLnNldHRpbmdzLXRoaXMnKS5hZGRDbGFzcyBcImhpZGRlblwiXG4gICAgICAgICRwYWdlLmZpbmQoJyNzZXRsaXN0LXNldHRpbmdzLXRhcmdldCAuc2V0dGluZ3MtZ3JvdXAnKS5yZW1vdmVDbGFzcyBcImhpZGRlblwiXG4gICAgICBlbHNlXG4gICAgICAgIGdyb3VwU2V0dGluZ3MgPSB1cGRhdGVTZXR0aW5ncyBncm91cFNldHRpbmdzXG4gICAgICAgIGFwcGx5U2V0dGluZ3Mgc2V0dGluZ3NcbiAgICAgICAgJHBhZ2UuZmluZCgnI3NldGxpc3Qtc2V0dGluZ3MtdGFyZ2V0IC5zZXR0aW5ncy1ncm91cCcpLmFkZENsYXNzIFwiaGlkZGVuXCJcbiAgICAgICAgJHBhZ2UuZmluZCgnI3NldGxpc3Qtc2V0dGluZ3MtdGFyZ2V0IC5zZXR0aW5ncy10aGlzJykucmVtb3ZlQ2xhc3MgXCJoaWRkZW5cIlxuICAgICRzZWN0aW9uLmZhZGVJbiAyMDAiLCIkID0gcmVxdWlyZSgnanF1ZXJ5JylcbiQubW9iaWxlID0gcmVxdWlyZSgnanF1ZXJ5LW1vYmlsZScpXG5cbiQoZG9jdW1lbnQpLmRlbGVnYXRlIFwiI3NldGxpc3RzLXNvbmdzXCIsIFwicGFnZWNyZWF0ZVwiLCAtPlxuICAkcGFnZSA9ICQodGhpcylcbiAgJGNob3Jkc2lmeSA9ICQoJy5jaG9yZHNpZnktcmF3JylcbiAgaWYgJGNob3Jkc2lmeS5sZW5ndGggPiAwXG4gICAgJGNob3Jkc2lmeS5jaG9yZHNpZnkoKVxuXG4gICRwYWdlLmZpbmQoJy50cmFuc3Bvc2Ugc2VsZWN0JykuY2hhbmdlIChlKSAtPlxuICAgICRzZWxlY3QgPSAkKGUuY3VycmVudFRhcmdldClcbiAgICBrZXkgPSAkc2VsZWN0LnZhbCgpXG4gICAgJHNvbmcgPSAkc2VsZWN0LnBhcmVudHMoJy5zZXRsaXN0LXNvbmdzLXNvbmcnKVxuICAgICRzb25nLmZpbmQoJy5jaG9yZHNpZnknKS5jaG9yZHNpZnkoJ3RyYW5zcG9zZScsIGtleSkuY2hvcmRzaWZ5KCdwb3NpdGlvbicpXG5cbiAgJHBhZ2UuZmluZCgnLnRyYW5zcG9zZS1hbGwnKS5jbGljayAoZSkgLT5cbiAgICAkc29uZyA9ICQoZS5jdXJyZW50VGFyZ2V0KS5wYXJlbnRzKCcuc2V0bGlzdC1zb25ncy1zb25nJylcbiAgICAkc2VsZWN0ID0gJHNvbmcuZmluZCgnLnRyYW5zcG9zZSBzZWxlY3QnKVxuICAgIGtleSA9ICRzZWxlY3QudmFsKClcbiAgICBpbmRleCA9ICRzZWxlY3RbMF0uc2VsZWN0ZWRJbmRleFxuICAgICRwYWdlLmZpbmQoJy50cmFuc3Bvc2Ugc2VsZWN0JykuZWFjaCAoaSwgc2VsKSAtPlxuICAgICAgc2VsLnNlbGVjdGVkSW5kZXggPSBpbmRleFxuICAgICAgJChzZWwpLnNlbGVjdG1lbnUgJ3JlZnJlc2gnXG4gICAgJHBhZ2UuZmluZCgnLmNob3Jkc2lmeScpLmNob3Jkc2lmeSgndHJhbnNwb3NlJywga2V5KS5jaG9yZHNpZnkoJ3Bvc2l0aW9uJylcblxuICAkKFwiOm1vYmlsZS1wYWdlY29udGFpbmVyXCIpLm9uIFwicGFnZWNvbnRhaW5lcnNob3dcIiwgKGV2ZW50LHVpKSAtPlxuICAgICRjaG9yZHNpZnkgPSAkKCcuY2hvcmRzaWZ5Om5vdCguY2hvcmRzaWZ5LXJhdyknKVxuICAgIGlmICRjaG9yZHNpZnkubGVuZ3RoID4gMFxuICAgICAgJGNob3Jkc2lmeS5jaG9yZHNpZnkoJ3Bvc2l0aW9uJykiLCIkID0gcmVxdWlyZSgnanF1ZXJ5JylcbiQubW9iaWxlID0gcmVxdWlyZSgnanF1ZXJ5LW1vYmlsZScpXG5cbiQoZG9jdW1lbnQpLmRlbGVnYXRlIFwiI3NldGxpc3RzLXZpZXdcIiwgXCJwYWdlY3JlYXRlXCIsIC0+XG4gICMgcmVtb3ZlIG90aGVyIHNldGxpc3RzIGZyb20gRE9NXG4gIHNlbGYgPSB0aGlzXG4gICQoJyNzZXRsaXN0cy12aWV3JykuZWFjaCAoaSxlKSAtPlxuICAgIGUucmVtb3ZlKCkgaWYgZSBpc250IHNlbGZcbiAgJChcIiNidG4tcGRmLXNhdmVcIikub24gJ2NsaWNrJywgKGUpIC0+XG4gICAgJC5nZXQgJChlLmN1cnJlbnRUYXJnZXQpLmF0dHIoJ2RhdGEtdXJsJyksIChkYXRhKSAtPlxuICAgICAgcmV0dXJuIGFsZXJ0KGRhdGEuZXJyb3IpIGlmIGRhdGEuZXJyb3JcbiAgICAgICMgc2hlZXQgPSBuZXcgU29uZ3NoZWV0KClcbiAgICAgICMgc2hlZXQuYWRkU29uZ3MoZGF0YS5zb25ncykucmVuZGVyKCkuc2F2ZSgkKGUuY3VycmVudFRhcmdldCkuYXR0cignZGF0YS1wZGYnKSlcbiAgICAsICdqc29uJ1xuIiwiJCA9IHJlcXVpcmUoJ2pxdWVyeScpXG4kLm1vYmlsZSA9IHJlcXVpcmUoJ2pxdWVyeS1tb2JpbGUnKVxuc29uZ3V0aWxzID0gcmVxdWlyZSgnbGlicy9zb25nX3V0aWxzJylcblxuJChkb2N1bWVudCkuZGVsZWdhdGUgXCIjc29uZ3MtZWRpdFwiLCBcInBhZ2VjcmVhdGVcIiwgLT5cbiAgaWYga2V5ID0gJCgnc2VsZWN0W25hbWU9a2V5XScpLmF0dHIoJ2RhdGEta2V5JylcbiAgICAkKCdzZWxlY3RbbmFtZT1rZXldIG9wdGlvblt2YWx1ZT0nICsga2V5ICsgJ10nKS5hdHRyKCdzZWxlY3RlZCcsICdzZWxlY3RlZCcpXG4gICAgJCgnc2VsZWN0W25hbWU9a2V5XScpLnNlbGVjdG1lbnUoJ3JlZnJlc2gnKVxuXG4gIHVwZGF0ZVNwb3RpZnlQcmV2aWV3ID0gLT5cbiAgICBzb25nVXJsID0gJCgnI3Nwb3RpZnknKS52YWwoKVxuICAgIGlmIChzb25nVXJsKVxuICAgICAgJCgnI3Nwb3RpZnktcHJldmlldycpLmh0bWwoJzxpZnJhbWUgc3JjPVwiaHR0cHM6Ly9lbWJlZC5zcG90aWZ5LmNvbS8/dXJpPScgK3NvbmdVcmwgKyAnXCIgd2lkdGg9MTAwJVwiJyskKCcjcGxheScpLndpZHRoKCkrJ1wiIGhlaWdodD1cIjgwXCIgZnJhbWVib3JkZXI9XCIwXCIgYWxsb3d0cmFuc3BhcmVuY3k9XCJ0cnVlXCI+PC9pZnJhbWU+JylcbiAgICBlbHNlXG4gICAgICAkKCcjc3BvdGlmeS1wcmV2aWV3JykuaHRtbCgnJylcblxuICB1cGRhdGVTcG90aWZ5T3B0aW9ucyA9ICh0aXRsZSwgYXJ0aXN0LCBwcmVsb2FkX2lkKSAtPlxuICAgIHNvbmd1dGlscy5nZXRTcG90aWZ5U2VsZWN0T3B0aW9ucyAkKCcjc29uZy1lZGl0LXRpdGxlLWlucHV0JykudmFsKCksICQoJyNzb25nLWVkaXQtYXJ0aXN0LWlucHV0JykudmFsKCksIHByZWxvYWRfaWQsIChvcHRpb25zKSAtPlxuICAgICAgJCgnI3Nwb3RpZnknKS5odG1sKG9wdGlvbnMpXG4gICAgICBpZiAocHJlbG9hZF9pZClcbiAgICAgICAgJCgnI3Nwb3RpZnknKS52YWwoc3BvdGlmeV9pZClcbiAgICAgICQoJyNzcG90aWZ5Jykuc2VsZWN0bWVudSgncmVmcmVzaCcpXG4gICAgICB1cGRhdGVTcG90aWZ5UHJldmlldygpXG5cbiAgc3BvdGlmeVNlYXJjaFRpbWVvdXQgPSBudWxsXG5cbiAgaWYgc3BvdGlmeV9pZCA9ICQoJyNzcG90aWZ5JykuYXR0cignZGF0YS1zcG90aWZ5LWlkJylcbiAgICB1cGRhdGVTcG90aWZ5T3B0aW9ucygkKCcjc29uZy1lZGl0LXRpdGxlLWlucHV0JykudmFsKCksICQoJyNzb25nLWVkaXQtYXJ0aXN0LWlucHV0JykudmFsKCksIHNwb3RpZnlfaWQpXG5cbiAgJCgnLnNvbmctcHJldmlldycpLmNsaWNrIChlKSAtPlxuICAgICQoJyNzb25nLWNob3JkcycpLmF0dHIoJ2RhdGEtb3JpZ2luYWwta2V5JywgJCgnI29yaWdpbmFsLWtleScpLnZhbCgpKS5jaG9yZHNpZnkoKS5jaG9yZHNpZnkoJ3JlcGxhY2UnLCAkKCcjY2hvcmRzJykudmFsKCkpXG5cbiAgJCgnI3Nwb3RpZnknKS5jaGFuZ2UgKGUpIC0+XG4gICAgdXBkYXRlU3BvdGlmeVByZXZpZXcoKVxuXG4gICQoJyNjaG9yZHMtYXMtbHlyaWNzJykuY2hhbmdlIChlKSAtPlxuICAgIGlmICQoZS5jdXJyZW50VGFyZ2V0KS5wcm9wKCdjaGVja2VkJylcbiAgICAgICQoJyNseXJpY3MtY29udGFpbmVyJykuYWRkQ2xhc3MoJ2hpZGRlbicpXG4gICAgZWxzZVxuICAgICAgJCgnI2x5cmljcy1jb250YWluZXInKS5yZW1vdmVDbGFzcygnaGlkZGVuJylcbiAgICAgICQoJyNseXJpY3MtY29udGFpbmVyIHRleHRhcmVhJykuY2hhbmdlKCkgIyBoYWNrIHRvIHRyaWdnZXIgYXV0by1ncm93IHRvIGNvcnJlY3QgaGVpZ2h0IG9uIGluaXRpYWxpemF0aW9uXG5cbiAgJCgnI3NvbmctZWRpdC10aXRsZS1pbnB1dCwgI3NvbmctZWRpdC1hcnRpc3QtaW5wdXQnKS5rZXl1cCAoZSkgLT5cbiAgICBjbGVhclRpbWVvdXQoc3BvdGlmeVNlYXJjaFRpbWVvdXQpIGlmIHNwb3RpZnlTZWFyY2hUaW1lb3V0XG4gICAgc3BvdGlmeVNlYXJjaFRpbWVvdXQgPSBzZXRUaW1lb3V0IC0+XG4gICAgICB1cGRhdGVTcG90aWZ5T3B0aW9ucyAkKCcjc29uZy1lZGl0LXRpdGxlLWlucHV0JykudmFsKCksICQoJyNzb25nLWVkaXQtYXJ0aXN0LWlucHV0JykudmFsKClcbiAgICAsIDE1MFxuXG4gICQoXCIjbmV3LXRhZy1jaG9pY2VzXCIpLm9uIFwiZmlsdGVyYWJsZWJlZm9yZWZpbHRlclwiLCAoZSwgZGF0YSktPlxuICAgICR1bCA9ICQodGhpcylcbiAgICAkaW5wdXQgPSAkKGRhdGEuaW5wdXQpXG4gICAgdmFsdWUgPSAkaW5wdXQudmFsKClcbiAgICB0YWdfZXhpc3RzID0gZmFsc2VcbiAgICBodG1sID0gJydcbiAgICAkdWwuaHRtbCAnJ1xuICAgIGlmIHZhbHVlPy5sZW5ndGggPiAxICMgYXQgbGVhc3QgdHdvIGNoYXJhY3RlclxuICAgICAgJHVsLmh0bWwgJzxsaT48ZGl2IGNsYXNzPVwidWktbG9hZGVyXCI+PHNwYW4gY2xhc3M9XCJ1aS1pY29uIHVpLWljb24tbG9hZGluZ1wiPjwvc3Bhbj48L2Rpdj4nXG4gICAgICAkdWwubGlzdHZpZXcgJ3JlZnJlc2gnXG4gICAgICAkLmFqYXhcbiAgICAgICAgdXJsOiBcIi9zZWFyY2gvdGFncy8je3ZhbHVlfVwiXG4gICAgICAgIGRhdGFUeXBlOiBcImpzb25cIlxuICAgICAgLnRoZW4gKHJlc3BvbnNlKS0+XG4gICAgICAgICQuZWFjaCByZXNwb25zZSwgKGksIHZhbCktPlxuICAgICAgICAgIGlmICQoXCIjc29uZy10YWdzIGxpW2RhdGEtaWQ9I3t2YWwuaWR9XVwiKS5sZW5ndGggaXMgMFxuICAgICAgICAgICAgaHRtbCArPSBcIjxsaT48YSBocmVmPVxcXCIjXFxcIiBkYXRhLWlkPVxcXCIje3ZhbC5pZH1cXFwiPiN7dmFsLm5hbWV9PC9hPlwiXG4gICAgICAgICAgaWYgdmFsLm5hbWUgPT0gdmFsdWVcbiAgICAgICAgICAgIHRhZ19leGlzdHMgPSB0cnVlXG4gICAgICAgIGlmICF0YWdfZXhpc3RzICNHaXZlIG9wdGlvbiB0byBhZGQgbmV3IHRhZyBpZiBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgaHRtbCArPSBcIjxsaT48YSBocmVmPVxcXCIjXFxcIiBuZXctdGFnPVxcXCIje3ZhbHVlfVxcXCI+QWRkIFxcXCIje3ZhbHVlfVxcXCIgYXMgYSBuZXcgdGFnPC9hPlwiXG4gICAgICAgICR1bC5odG1sIGh0bWxcbiAgICAgICAgJHVsLmxpc3R2aWV3IFwicmVmcmVzaFwiXG4gICAgICAgICR1bC50cmlnZ2VyIFwidXBkYXRlbGF5b3V0XCJcblxuICAkKGRvY3VtZW50KS5vbiAnY2xpY2snLCAnI25ldy10YWctY2hvaWNlcyBhW2RhdGEtaWRdJywgKGUpLT5cbiAgICAkdGhpcyA9ICQodGhpcylcbiAgICBpZiAkKCcjc29uZy10YWdzIGxpW2RhdGEtaWQ9JyArICR0aGlzLmF0dHIoJ2RhdGEtaWQnKSArICddJykubGVuZ3RoIGlzIDBcbiAgICAgICQoJyNzb25nLXRhZ3MnKS5hcHBlbmQoXCI8bGkgZGF0YS1pZD1cXFwiI3skdGhpcy5hdHRyKCdkYXRhLWlkJyl9XFxcIj48YSBocmVmPVxcXCIjXFxcIj4jeyR0aGlzLnRleHQoKX08L2E+PGEgZGF0YS10aGVtZT1cXFwiYlxcXCIgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcInJlbW92ZS10YWdcXFwiPlg8L2E+PGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgbmFtZT1cXFwidGFnc1tdXFxcIiB2YWx1ZT1cXFwiI3skdGhpcy5hdHRyKCdkYXRhLWlkJyl9XFxcIj5cIilcbiAgICAgIC5saXN0dmlldygncmVmcmVzaCcpXG4gICAgICAkKCcjbmV3LXRhZy1jaG9pY2VzLWJveCAudWktaW5wdXQtY2xlYXInKS5jbGljaygpXG4gICAgICAkKCcjbmV3LXRhZy1jaG9pY2VzJykuaHRtbCAnJ1xuXG4gICQoZG9jdW1lbnQpLm9uICdjbGljaycsICcjbmV3LXRhZy1jaG9pY2VzIGFbbmV3LXRhZ10nLCAoZSktPiAjYWRkIG5ldyB0YWdcbiAgICAkdGhpcyA9ICQodGhpcylcbiAgICBpZiAkKCcjc29uZy10YWdzIGxpW3ZhbHVlPVwiJyArICR0aGlzLmF0dHIoJ25ldy10YWcnKSArICdcIl0nKS5sZW5ndGggaXMgMFxuICAgICAgJCgnI3NvbmctdGFncycpLmFwcGVuZChcIjxsaSB2YWx1ZT1cXFwiI3skdGhpcy5hdHRyKCduZXctdGFnJyl9XFxcIj48YSBocmVmPVxcXCIjXFxcIj4jeyR0aGlzLmF0dHIoJ25ldy10YWcnKX08L2E+PGEgZGF0YS10aGVtZT1cXFwiYlxcXCIgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcInJlbW92ZS10YWdcXFwiPlg8L2E+PGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgbmFtZT1cXFwibmV3X3RhZ3NbXVxcXCIgdmFsdWU9XFxcIiN7JHRoaXMuYXR0cignbmV3LXRhZycpfVxcXCI+XCIpXG4gICAgICAubGlzdHZpZXcoJ3JlZnJlc2gnKVxuICAgICAgJCgnI25ldy10YWctY2hvaWNlcy1ib3ggLnVpLWlucHV0LWNsZWFyJykuY2xpY2soKVxuICAgICAgJCgnI25ldy10YWctY2hvaWNlcycpLmh0bWwgJydcblxuICAkKGRvY3VtZW50KS5vbiAnY2xpY2snLCAnLnJlbW92ZS10YWcnLCAoZSktPlxuICAgICQodGhpcykuY2xvc2VzdCgnbGknKS5yZW1vdmUoKSIsIiQgPSByZXF1aXJlKCdqcXVlcnknKVxuJC5tb2JpbGUgPSByZXF1aXJlKCdqcXVlcnktbW9iaWxlJylcblxuJChkb2N1bWVudCkuZGVsZWdhdGUgXCIjc29uZ3MtbGlzdFwiLCBcInBhZ2VjcmVhdGVcIiwgLT5cbiAgJCh0aGlzKS5maW5kKCdbbmFtZT1cInZpZXdcIl0nKS5jaGFuZ2UgKCktPlxuICAgIHZpZXcgPSAkKHRoaXMpLnZhbCgpXG5cbiAgICAkbGlzdCA9ICQoJyNzb25ncy1saXN0LXNvbmdzJylcbiAgICAkY2hpbGRyZW4gPSAkbGlzdC5jaGlsZHJlbignLmxpc3R2aWV3LWNoZWNrYm94JykucmVtb3ZlQ2xhc3MoJ2hpZGRlbiB1aS1sYXN0LWNoaWxkJylcbiAgICBcbiAgICBpZiB2aWV3IGlzICdjZXJ0aWZpZWQnXG4gICAgICAkY2hpbGRyZW4uZmlsdGVyKCdbZGF0YS1jZXJ0aWZpZWQ9XCIwXCJdJykuYWRkQ2xhc3MoJ2hpZGRlbicpXG4gICAgICAkY2hpbGRyZW4uZmlsdGVyKCdbZGF0YS1jZXJ0aWZpZWQ9XCIxXCJdJykubGFzdCgpLmFkZENsYXNzKCd1aS1sYXN0LWNoaWxkJylcbiAgICBlbHNlIGlmIHZpZXcgaXMgJ2Nob3JkcydcbiAgICAgICRjaGlsZHJlbi5maWx0ZXIoJ1tkYXRhLWNob3Jkcz1cIjBcIl0nKS5hZGRDbGFzcygnaGlkZGVuJylcbiAgICAgICRjaGlsZHJlbi5maWx0ZXIoJ1tkYXRhLWNob3Jkcz1cIjFcIl0nKS5sYXN0KCkuYWRkQ2xhc3MoJ3VpLWxhc3QtY2hpbGQnKVxuICAgIGVsc2VcbiAgICAgICRjaGlsZHJlbi5sYXN0KCkuYWRkQ2xhc3MoJ3VpLWxhc3QtY2hpbGQnKVxuXG4gICQodGhpcykuZmluZCgnW25hbWU9XCJzb3J0YnlcIl0nKS5jaGFuZ2UgKCktPlxuICAgIHNvcnRieSA9ICQodGhpcykudmFsKClcbiAgICBvcmRlciA9IGlmIHNvcnRieSBpcyAncG9wJyB0aGVuIC0xIGVsc2UgMVxuICAgICRsaXN0ID0gJCgnI3NvbmdzLWxpc3Qtc29uZ3MnKVxuICAgICRjaGlsZHJlbiA9ICRsaXN0LmNoaWxkcmVuKCcubGlzdHZpZXctY2hlY2tib3gnKVxuICAgICRjaGlsZHJlbi5sYXN0KCkucmVtb3ZlQ2xhc3MoJ3VpLWxhc3QtY2hpbGQnKVxuXG4gICAgIyBodHRwOi8vdHJlbnRyaWNoYXJkc29uLmNvbS8yMDEzLzEyLzE2L3NvcnQtZG9tLWVsZW1lbnRzLWpxdWVyeS9cbiAgICAkY2hpbGRyZW4uc29ydCAoYSwgYiktPlxuICAgICAgYVRleHQgPSAkKGEpLmF0dHIoJ2RhdGEtJytzb3J0YnkpXG4gICAgICBiVGV4dCA9ICQoYikuYXR0cignZGF0YS0nK3NvcnRieSlcbiAgICAgIGlmIHNvcnRieSBpcyAna2V5J1xuICAgICAgICBpZiBhVGV4dCBpcyAnJyB0aGVuIGFUZXh0ID0gMTIgZWxzZSBhVGV4dCA9ICthVGV4dFxuICAgICAgICBpZiBiVGV4dCBpcyAnJyB0aGVuIGJUZXh0ID0gMTIgZWxzZSBiVGV4dCA9ICtiVGV4dFxuICAgICAgaWYgYVRleHQgPiBiVGV4dFxuICAgICAgICByZXR1cm4gb3JkZXJcbiAgICAgIGlmIGJUZXh0ID4gYVRleHRcbiAgICAgICAgcmV0dXJuIC1vcmRlclxuICAgICAgcmV0dXJuIDBcblxuICAgICRjaGlsZHJlbi5kZXRhY2goKS5hcHBlbmRUbyAkbGlzdFxuICAgICRjaGlsZHJlbi5sYXN0KCkuYWRkQ2xhc3MoJ3VpLWxhc3QtY2hpbGQnKVxuXG4gICQoJ2lucHV0W25hbWU9XCJjaGVja2VkX3NvbmdzW11cIl0nKS5vbiAnY2hhbmdlJywgLT5cbiAgICBpZiAoY291bnQgPSAkKCdpbnB1dFtuYW1lPVwiY2hlY2tlZF9zb25nc1tdXCJdOmNoZWNrZWQnKS5sZW5ndGgpID4gMFxuICAgICAgJCgnLnVpLWZvb3Rlci1maXhlZCcpLnJlbW92ZUNsYXNzKCdoaWRkZW4nKVxuICAgICAgJCgnLnNvbmdzLWxpc3Qtc2VsZWN0ZWQtY291bnQnKS50ZXh0KGNvdW50KVxuICAgICAgc29uZ2xpc3QgPSBcIlwiXG4gICAgICAkKCdpbnB1dFtuYW1lPVwiY2hlY2tlZF9zb25nc1tdXCJdOmNoZWNrZWQnKS5lYWNoIC0+XG4gICAgICAgIHNvbmdsaXN0ICs9ICQodGhpcykudmFsKCkgKyBcIixcIlxuICAgICAgc29uZ2xpc3QgPSBzb25nbGlzdC5zdWJzdHIoMCwgc29uZ2xpc3QubGVuZ3RoLTEpXG4gICAgICAkKCcjc29uZy1zZXRsaXN0LXBvcHVwLWZvcm0gaW5wdXRbbmFtZT1zb25nc10nKS52YWwoc29uZ2xpc3QpXG4gICAgICAkKCcjc29uZy1zZXRsaXN0LXBvcHVwLW5ldycpLmF0dHIoJ2hyZWYnLCAnL3NldGxpc3RzL25ldz9zb25ncz0nK3NvbmdsaXN0KVxuICAgIGVsc2VcbiAgICAgICQoJy51aS1mb290ZXItZml4ZWQnKS5hZGRDbGFzcygnaGlkZGVuJykiLCIkID0gcmVxdWlyZSgnanF1ZXJ5JylcbiQubW9iaWxlID0gcmVxdWlyZSgnanF1ZXJ5LW1vYmlsZScpXG5cbiQoZG9jdW1lbnQpLmRlbGVnYXRlIFwiI3NvbmdzLXZpZXdcIiwgXCJwYWdlY3JlYXRlXCIsIC0+XG4gICRwYWdlID0gJCB0aGlzXG4gICR0cmFuc3Bvc2UgPSAkcGFnZS5maW5kKCcjc2VsZWN0LXRyYW5zcG9zZScpXG4gICRjaG9yZHNpZnkgPSAkcGFnZS5maW5kKCcuY2hvcmRzaWZ5LXJhdycpXG4gIGlmICRjaG9yZHNpZnkubGVuZ3RoID4gMFxuICAgICRjaG9yZHNpZnkuY2hvcmRzaWZ5KClcbiAgICAkdHJhbnNwb3NlLm9uICdjaGFuZ2UnLCAoZSkgLT5cbiAgICAgIGtleSA9ICQoZS5jdXJyZW50VGFyZ2V0KS52YWwoKVxuICAgICAgJGNob3Jkc2lmeS5jaG9yZHNpZnkoJ3RyYW5zcG9zZScsIGtleSlcblxuJChkb2N1bWVudCkub24gXCJwYWdlY29udGFpbmVyc2hvd1wiLCBcIjptb2JpbGUtcGFnZWNvbnRhaW5lclwiLCAoZXZlbnQsdWkpIC0+XG4gICRjaG9yZHNpZnkgPSAkKCcuY2hvcmRzaWZ5Om5vdCguY2hvcmRzaWZ5LXJhdyknKVxuICBpZiAkY2hvcmRzaWZ5Lmxlbmd0aCA+IDBcbiAgICAkY2hvcmRzaWZ5LmNob3Jkc2lmeSgncG9zaXRpb24nKSIsIiQgPSByZXF1aXJlKCdqcXVlcnknKVxuJC5tb2JpbGUgPSByZXF1aXJlKCdqcXVlcnktbW9iaWxlJylcblxuJChkb2N1bWVudCkuZGVsZWdhdGUgXCIjaG9tZVwiLCBcInBhZ2Vpbml0XCIsIC0+XG4gICMgYWxlcnQgJ1BhZ2UgSE9NRSBPUEVORUQhJyJdfQ==
